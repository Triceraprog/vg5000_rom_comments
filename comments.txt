$0000/romStart/above
Tout commence par un saut à l'adresse $1000. Le choix de l'adresse $1000
semble arbitraire. D'autres machines à base de Z80 font des sauts à d'autres
adresses.
;
Comme les adresses suivantes sont les adresses de branchement des instructions
RST du Z80, le code de démarrage doit se trouver plus loin. D'où le saut.
;
Juste après le saut se trouve, sous forme de chaîne de caractères, le numéro
de version de la ROM.

$0008/chkchr/above
Vérification que le caractère pointé par HL est égal au caractère qui suit exactement
l'instruction RST 8 appelante. Si ce n'est pas le cas, affiche un message d'erreur de syntaxe.

$0008:Enregistre le caractère pointé par HL
$0009:Échange le contenu sur le haut de la pile (l'adresse de retour de RST) et HL
$000a:Compare le contenu de l'adresse de retour et la valeur sauvée dans A
$000b:Incrémente HL afin que l'adresse de retour saute le caractère suivant l'instruction appelante
$000c:Remet la nouvelle adresse de retour en place sur la pile
$000d:Si les deux caractères comparés étaient différent, saute en stx_err_prt ; sinon, passe dans chget


$0010/chget/above
Incrémente HL et met le contenu (HL) dans A.
Si le caractère est supérieur à $3a (: donc juste après '9'), retourne immédiatement, sinon...
Retour: Flag Z si caractère NUL, Flag C si un chiffre, NC si pas un chiffre

$0018/outdo/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

$001B/setext/code
$001B/above
Fonction : redéfinition d'un caractère
Change un caractère programmable dans la mémoire vidéo.
Entrée :
A contient le carractère à changer (sur 7 bits).
A contient sur le bit 7 la nature de la palette (0 == Texte, 1 == Graphique)
HL pointe sur le buffer de 10 octets avec les valeurs
Registres modifiés :

$0020/de_compare/above
Fonction : comparaison de HL et DE
Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
En sortie, C sera positionné si HL < DE

$0028/above
Renvoie $FF, $00 ou $01 en fonction du contenu du buffer flottant.
Préserve HL

$002c:Saute si fac[0] != 0

$0030/usrrst

$0033/warmgo/above/code
Reset

$0038/irq/above
Fonction : traitement de l'interruption.
Sur la machine, cette interruption est dédiée à l'affichage.
C'est aussi l'EF9345 qui provoque l'interruption.
Mais un vecteur est disponible pour personnaliser les traitements dans l'irq.

$0038:Appel au vecteur d'interruption
$003c:Décrémente le compteur de temporisation d'affichage
$003f:Si le compteur n'est pas tombé à zéro, on sort immédiatement (pas de rafraichissement)
$0045:Remise du compteur à la valeur de référence
$004c:Test puis mise à zéro du bit 0 du flag d'affichage
$0050:Si le flag d'affichage était à zéro, on sort immédiatement (pas de rafraichissement)
$0053:Début du rafraichissement de l'affichage
$0056:Envoi à EF9345 de commandes (à décoder)

$0066/nmi/code
$0066/above
Interruption non masquable.
L'interruption est lancée par l'appui de la séquence Ctrl-Delta (cf. description plus
complète).
Le code saute immédiatement, au hook, qui a pour valeur par défaut un saut en 'test_reset'

$0069/resetlang/code
$0069/above
Met le système en anglais.
La seule entrée semble être la valeur que prend temporairemet nmihk pendant le boot.

$006b:Messages en anglais
$0071:Table de transcription du clavier

$0080/retfun/code
$0083/deint/code
$0086/getbyt/code
$0086/above
Fonction : Prend l'argument pointé par HL et renvoi le résultat dans A (quand numérique)

$0089/frmnum/code
$008C/beep/code
$008f/play/code

$0092/putahl/code
$0095/putici/code
$0098/getahl/code
$009B/getici/code
$009E/cls/code
$00A1/cll/code
$00a4/wait/code
$00a7/fndadr/code
$00aa/kbscan/code
$00ad/regst/code
$00b0/stkv/code
$00b3/stkh/code
$00b6/stka/code
$00b9/break/code

$00bc/disp_refrsh/above
Rafraichissement de l'état de l'affichage sur l'EF9345 en fonction
du contenu de la mémoire vidéo en RAM ($4000)

$00bf:Séquence EF9345 à décoder
$00e0/r_line0_lp
$00ec:Boucle sur les 80 octets de la première ligne
$00fd:24 lignes
$00ff/r_line_loop

$0186/skip_dsplay

$018c/putahl_impl
$018c/above
Fonction : affiche un caractère en s'adressant directement à l'EF9345
Entrées : HL=position, D=char, E=attr

$0192:Place le curseur sur le ligne H
$0198:Place le curseur sur le colonne L

$019a/putici_impl
$019a/above
Fonction : affiche un caractère en s'adressant directement à l'EF9345
Entrées : D=char, E=attr

$01a1/put_wait1
$01b1/put_wait2

$01c4/getahl_impl
$01c4/above
Fonction : Récupère une paire caractère/attribut en s'adressant directement à l'EF9345
Entrées : HL=position
Sortie : D=char, E=attr

$01d2/getici_impl
$01d2/above
Fonction : Récupère une paire caractère/attribut en s'adressant directement à l'EF9345
Entrées : -
Sortie : D=char, E=attr

$01df/get_wait1
$01ef/get_wait2

$0255/cls_impl/above
Fonction: Efface l'écran
Efface tout d'abord la ligne 0
Puis recopie le contenu mémoire de cette ligne sur le reste de l'écran
L'effacement est celui de la mémoire vidéo en RAM BASIC.

$0265/cli_impl/above
Fonction: Efface une ligne
Entrées : A contient un numéro de ligne
L'effacement est celui de la mémoire vidéo en RAM BASIC.

$026b:Écriture de $80 à la première position de la ligne
$026d:Récupération des attributs par défaut
$0271:Écriture dans la position suivante des attributs par défaut

$0276
if bit(C,7) == 1 then A = 0 else A = $20
Le bit 7 de C étant à 1 pour un caractère graphique, 0 pour texte

$027d/cli_default
$027d
Boucle pour écrire dans les positions suivantes de la ligne alternativement A et C.
Donc un espace pour le mode texte et 0 pour le mode graphique, suivi des attributs

$027f/cli_loop

$0291/fndadr_impl/above
Fonction: renvoie l'adresse écran à partir des coordonnées X et Y
Entrées : H contient y, L contient x
Retour : HL contient $4000 + 80y + 2x

$0291:C contient x
$0292:L contient Y
$0297:HL = L * 8 (c'est-à-dire y * 8)
$0299:DE = HL = y * 8
$029c:HL = 32 * y + 8 * y = 40 * y
$029d:HL = 80 * y
$029e:C contient x
$02a1:HL = 80 * y + 2 * x
$02a5:HL = $4000 + 80 * y + 2 * x

$02a7/kbscan_impl/above
Fonction : scanne le clavier
En commençant par le port $87 jusqu'au port $80
La valeur obtenu est dans A. Le carry flag est à 1 si ?

$02aa/kb_row_loop
$02aa:lecture de l'entrée
$02ac:la ligne est à l'état haut lorsque la touche n'est pas pressée.
$02ad:test si un signal a été reçu
$02b1:boucle sur les ports
$02b6:Masque avec b10111011

$02b8/key_pressed
$02b8:Si aucune touche pressée (moyennant le masque), saut

$02bc/col_count
$02bc:Calcul le rang du bit à 1
$02c1/col_exit
$02c1:Place dans A le rang du bit à 1 (et donc la colonne)
$02c2:A=2 * col
$02c3:A=4 * col
$02c4:A=8 * col
$02c5:A=(8 * col) + row_port ($80 à $87)
$02c6:A=(8 * col) + row_port - $80 (0 à 7)
$02ca:Lecture du rang 0 dans B
$02d2:Vérification de la touche SHIFT appuyée
$02d6:Si SHIFT est appuyé, ajoute $40 à l'adresse de la table de traduction
$02d7:Si SHIFT est appyyé, CTRL est ignorée

$02d9/key_noshift
$02d9:Vérification de la touche CTRL appuyée
$02de:Ajoute $80 (2 * $40) à l'adresse de la table de traduction
$02df/key_noctrl
$02df:A qui contient l'index dans la table est passé dans E
$02e2:L'index est ajouté au pointeur de la table
$02e3:La valeur de la table est récupérée dans A


$02e4/key_changed
$02e4:récupération de la valeur précédente du clavier
$02e7:set carry flag
$02e8:si la nouvelle touche est la même que l'ancienne saute à la fin pour retour
$02ea:sinon, on enregistre la nouvelle valeur
$02ed:et le carry flag est enlevé
$02ee/kbscan_exit
$02ee:Le Carry Flag indique si la touche a changé (C reset) ou n'a pas changé (C set)


$02EF/regst_impl/above
Fonction: Envoi d'une séquence à l'EF9345
Entrée: HL pointe sur la séquence de données à envoyer.
Le premier octet de la séquence est sa longueur en octet.

$02f1/regst_loop

$0286/wait_impl/above
Fonction: Attente d'état « prêt » de l'EF9345
'$20' est envoyé sur le port $8F puis on attend que le le bit de
poids fort sur le port $CF soit à 0.

$028a/wait_loop

$035c/retfun_4
$035c:En venant du traitement d'auto via retfun_3, A étant à zero, la rotation à gauche n'a pas généré de Carry
$0360:HL <- EB. ?. B est forcé à 0 par retfun_3 et E contient la partie basse du numéro de ligne quand on arrive de auto via retfun_3
$0361:A = 0

$0362/rot_loop/above
La partie ci-dessous prend C, D, H, L, A, B comme un buffer en rotation vers la gauche
(octet par octet). A est un compteur (sauvé temporairement dans B pendant la rotation) auquel
on soustrait 8 à chaque fois, jusqu'à attendre $e0 (ce qui fait 4 fois avec A = 0 au début)

$0362:B <- A
$0362:A <- C
$0365:Saut si A != 0
$0365:C <- D
$0368:D <- H
$0369:H <- L
$036A:L <- A
$036B:A <- B, une sorte de grande rotation entre les registres C, D, H, L, A, B
$036e:Comparaison avec $e0...


$0372/init_f_buf

$37c:Si D H et L sont à zéro, alors on traite C (pour trouver le premier bit à 1 à partir des poids forts)
$037d/bit_find
$037d:Diminue B jusqu'à trouver le premier bit à 1 dans A (qui vient de C)
$0383:C (avec son bit de poids fort à 1) est remis depuis A.
$0393: EB <- HL
$0395:Vérification du compteur, saute si arrivé à zéro.
$039b:Addition dans fac[0] du compteur actuel.
$039e:Saute si supérieur ou égal à 0 ?

$059d:Compare faclo[2] avec $2f (afin de mettre 1 dans Carry si faclo[2] est inférieur à $2f)
$059e/code:Appelé depuis une routine à cause de $060f
$059f:Rotation à gauche via Carry
$05a0:Soustraction de A avec A avec retenu.
$05a1:Saute si la rotation avait débordée dans la retenue.
$05a2:Sinon, augmente A de 1 (autrement, dit A = 1 puisque la soustraction avait donné 0)

$05a5:Prépare le placement des valeurs $88,$80 dans le buffer de virgule flottante

$05aa/retfun_3
$05aa:Appelé depuis le traitement d'auto ($072e), A = 0, B = $98, DE = numéro de ligne

$05b2:Mets dans le buffer 'fac' les octets B et $80, B est assigné à 0. C est à 0 (depuis A) en venant du traitement d'auto.

$05c2/fac_to_stck/above
Function : Place le contenu de faclo et faclo+2 sur la pile
en préservant la valeur de retour pour RET.
La valeur de HL est préservée

$05d2/bcde_to_fac/above
Place DE dans faclo et BC dans faclo+2. Préserve la valeur de HL

$05dd/fac_to_bcde/above
Extrait le contenu du buffer de virgule flottante dans BC/DE

$05e0/hl_to_bcde
$05e7/inc_hl

$05e9/cpy_faclo_hl/above
Copie le contenu des 4 premiers octets de faclo vers ce que pointe HL

$05ec/cpy_4_to_hl/above
Copie le contenu des 4 premiers octets pointés par DE vers ce que pointe HL

$05ee/cpy_4_loop

$0692/str_to_num/above
Function: transforme le texte pointé par HL en nombre

$0692:Cas hexa (commence par `&`)

$0697:Cas négatif qui commence par '-'
$069c:Cas positif qui commence par '+'
$06a0:Position HL un caractère avant dans les autres cas
$06a1:Initialise le buffer de travail avec 0 en première place. Effet de bord, A = 0
$06a6:Met B et DE à 0
$06a8:Met C à FF
$06a9/prse_flt_lp
$06a9:Lecture du caractère suivant
$06aa:Cas d'un chiffre
$06ae:Cas du caractère `.`
$06b2:Cas du caractère `e`
$06b6:Cas du caractère pas `E`
$06b8/case_exp
$06c6/case_dot
$06e9/case_digit

$06f4:Récupération de la valeur du caractère (qui était dans DE ?)
$06f5:Transformation en valeur numérique

$0715/out_in/above
Affiche à l'écran le texte " en "/" in " suivant la langue, suivi de... ?

$0722/out_in_fr

$0726/out_number/above
Affiche à l'écran un nombre contenu dans HL
$0726:DE contient une adresse de retour
$0729:Sauvegarde de la valeur dans la pile pour un prochain RET
$072a:Et échange de HL et DE (HL contient donc l'adresse du signe '#'. DE contient le numéro de ligne d'AUTO
$072e:À l'appel, A = 0 et B = $98

$0736:Place $20 dans fbuffr (un espace)
$073b:Place $2d dans fbuffr (le signe '-') si le flag M est levé (résultat M dans le test des flottants)
$073e:place $30 dans fbuffr[1] (le chiffre '0')
$0740:Saut si le résultat était 0
$0744:Saut si le résultat était < 0
$074c:Aussi appelé (jp (hl))depuis $07fe

$07ff/data_what:Probablement de la donnée

$0a78:Désactivation de l'affichage

$0a87/play_impl
$0a87/above
Joue une séquence sonore
BC = Pointeur vers la séquence ASCII
E = taille du buffer

$0a8a:lecture du caractère suivant
$0a8d:saute si le buffer est épuisé
$0a92:Cas de ','
$0a96:Cas de codage de fin de ligne (?)
$0a9a:Cas de l'espace
$0a9e:Cas inférieur à 'A'

$0b11/play_exit
$0b12:provoque un rafraichissement 3 IRQ plus tard.

$0ca7/snd_emit
$0ca7/above
Fonction : émet un son
Durée dans DE
SONSAV indique la phase

$0ca8/snd_dur_lp

$0caf/snd_L_wait
$0cb8:Mise à état haut de la sortie son
$0cc1/snd_H_wait
$0cca:Mise à état bas de la sortie son

$0cd3:Fin de la procédure snd_emit

$0ce6/wait_69c
$0ce6:Wait 69 cycles, call included
$0ce8/wait_31c
$0ce9/wait_27c

$0d7c/SendToEF/above
Fonction: Envoi d'une donnée à l'EF9345
Registre en entrée : DE
Registre modifié : C
D est envoyé sur le port $8F
C est envoyé sur le port $CF

$0d85/setext_impl/above
Fonction: Redéfinition d'un caractère
Registres en entrée : HL et A
Registres modifiés : AF, HL, BC, DE

$0d8d/setext_2
$0dce/setext_lp2
$0dd3/setext_lp3

$0d85:if bit(A, 7) == 0 then B = $C0 else B = $40
$0d8d:Le haut de la pile contient BC
$0d8e:Désactivation de l'affichage
$0d98
Envoi à l'EF9345 de $22,A (avec le bit 7 de A mis à 1) (R2=A)
(A est envoyé à travers E)

$0d9b:Récupération de la valeur de BC dans AF
$0d9c:Remise du contenu de BC sur la pile
$0d9d:Inversion du bit 7 de A, qui est la valeur de B du début de la fonction ($C0 ou $40)
$0da2:Envoi à l'EF9345 de $21,A (A est envoyé à travers E) (R1=A)
$0da9:Envoi à l'EF9345 de $20,$03 (R0=3 -> KRG+Inc)
$0dae:Récupération, à travers E, de la valeur de A en entrée de fonction (avec les trois lignes suivantes)
$0db4:A = (A >> 2) & $1F
$0db7:Envoi à l'EF9345 de $24,A (A est envoyé à travers E) (R4=A)
$0dbd:A = (A initial de la fonction) & $03
$0dbf:Récupération du contenu du BC initial ($C0 ou $40)
$0dc0:A = A | B
$0dc2:Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0dc9:Envoi à l'EF9345 de $20,$34 (R0=OCT Write AP NoInc, écrit R1 en mémoire désigné par R4 R5)
$0dcc:Boucle extérieure, 10 itérations
$0dce:Récupère la valeur suivante de la redéfinition de caractère dans A
$0dd0:Boucle intérieure, 8 itérations
$0dd4:Inverse le contenu de A et C, bit à bit
$0dd8:La ligne de redéfinition lue dans (HL) est à présent inversée dans A
$0ddd:Envoi à l'EF9345 de $29,A (A est envoyé à travers E) (R1=A + Execute)
$0dee:Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0df3:Réactivation de l'affichage

$0df7:Fin de la fonction setext

$0de5
Envoi sur $8F de $25 puis récupération sur $CF d'une valeur dans A (Read R5)
Puis A = A + $04

$0ec3/stkh_impl/above
Fonction : vérifie la valeur STICK horizontale
A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier)

$0ed3/stkv_nol_k

$0ece:Lecture flêche vers le gauche du clavier
$0ed2:B passe à $FF
$0ed3:Lecture flêche vers le droite du clavier

$0ed7/stkh_joy0
$0edd:B passe à $FF
$0ede/stkh_nol_0

$0ee2/stkh_joy1
$0ee8:B passe à $FF
$0ee9/stkh_nol_1

$0eeb/stk_end:Fin des functions stkh et stkv
$0eed:Si le dernier test était nul (pas de touche appuyée), alors B est incrémenté. Si deux touches opposée étaient appuyée, cela met le résultat à 0.
$0eee/stk_exit:Placement du résultat dans A

$0ef9/stkv_impl/above
Fonction : vérifie la valeur STICK verticale
A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier)

$0f04:Lecture flêche vers le haut du clavier
$0f08:B passe à $FF

$0f09/stkv_noup_k

$0f0b:Lecture flêche vers le bas du clavier

$0f0f/stkv_joy0
$0f15:B passe à $FF
$0f16/stkv_noup_0

$0f1a/stkv_joy1
$0f20:B passe à $FF
$0f21/stkv_noup_1

$0f2e/stka_impl/above
Fonction : vérifie la valeur ACTION
A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier/barre espace)

$0f3a:Vérification de l'appuie de la touche ESPACE

$0f3e/stka_joy0
$0f3a:Vérification de l'appuie sur la bouton action du joystick 0

$1ff3/stka_joy1
$1ff3:Vérification de l'appuie sur la bouton action du joystick 1

$0f8e:Force l'affichage et met le compteur de rafraichissement à 1
$0f96:Attend la prochaine interruption qui provoquera un rafraichissement

$0f98:Valeur par défaut pour DISPLAY
$0f9f/display_def
$0fa2:Enchaine sur l'instruction SCREEN


/////////////////////////////////////////
////////////////// 1000 /////////////////
/////////////////////////////////////////

$1000/Start/above
C'est ici que commence l'intialisation complète de la machine.
La première étape est de recopier le contenu de la ROM dans
l'espace RAM adressable. Adressable ne signifie pas que de la RAM
est effectivement branchée. Cela ne pose pas de problème au
niveau hardware du VG5000 d'envoyer une demande d'écriture.
;
Le contenu de la mémoire est ensuite lu et comparé à la ROM.
Tant que c'est identique, c'est qu'il y a quelque chose de branché
qui répond correctement. Dès que c'est différent, c'est qu'on est
sorti de la zone de la mémoire inscriptible disponible.
;
La dernière adresse valide est stockée dans $4895 et dans SP, le
registre pointeur de pile (Stack Pointer)
;
On remarquera que si une ROM répond avec un contenu identique à
la ROM à une adresse multiple de 16ko, l'initialisation va
penser que c'est de la RAM accessible.

$1000
Démarrage complet de la machine.
Vérifier pourquoi c'est appelé depuis $2282

$100a
Copie de la ROM sur toute la mémoire adressable
Equivalent C-style de : memcpy($4000, $0000, $C000)

$100c:À la fin de LDIR, HL == $C000, DE == $0000, BC == $0000
$100e:À présent, HL == $4000, DE == $0000, BC == $C000
$1010:Début de la comparaison octet par octet de la mémoire
$1015:Si le contenu de (HL) et (DE) est différent, on saute en $101B
$1017
Si le contenu de (HL) et (DE) est identique
et que BC est > 0, on loop

$101a/above
L'instruction partielle suivante ne sert à rien d'autre qu'à gagner un peu
d'espace lorsque BC == 0 et que la boucle est terminée.
Le contenu de A est écrasé un peu plus loin.

$101b
HL est décrémenté pour retrouver la dernière addresse testée (CPI augmente HL).
HL contient donc la première adresse invalide de l'espace mémoire en écriture.
Cette adresse est mise dans SP et stockée en $4895

$1020/above
La seconde étape de l'initialisation consiste à remplir les vecteurs
utilisateur par des instructions spécifiques. Ces vecteurs, situés
en RAM, permettent d'intervenir lors de certaines opérations avec
du code écrit par l'utilisateur et donc de modifier le comportement
du système.

$1020
Les adresses $47D0 à $47EE vont ensuite est remplies par des RET ($C9).
Equivalent C-style de : memset($47D0, $1E, $C9)

$1048:L'adresse $47EE reçoit un JP $0069.

$104b/above
La troisième phase initialise le processeur graphique EF9345. Pour commencer,
une séquence est envoyée au périphérique, puis quelques variables en RAM sont
mises initialisées.
;
Attention, la valeur de IX doit rester constante. Le système de cette ROM
considère que IX est en tout temps égal à $47FA et référence certaines
variables par index par rapport à IX.
;
La séquence est
 $28,$81 -> Écriture de quelque chose dans le TGS
 $29,$00 -> TGS = 0 (625 lignes, non entrelacé, no-input-resync, output VSync+HSync, Service Row = 0, 40 Char
 $20,$82,$29,$6e -> MAT = $6e (Marge = B+G, Insert Marge, Curseur plein/flash, Curseur affiché, simple hauteur
 $20,$83,$29,$f7 -> PAT = $f7 (Ligne 0 'ON', Bulk haut et bas activé, pas de conceal, Insert mode : Active Area, Flash ON, Format court pour le 40 Char
 $20,$84,$29,$13 -> DOR = $13 (Block G0=3, Block G1=1<<1, Block Q=0<<3)
 $20,$87,$29,$08 -> ROR = $08 (Z=0, Y=8)
 $26,$08,$27,$00,$28,$02 -> R6=$08, R7=$00, KRG sans incrémentation avec MP=$0800 (data R1, R2 = $08, ??)
;
Envoyés par pairs sur les ports $8f, $cf

$104b:IX prend la valeur $47FA qui est la base de la zone de données graphiques.

$104F
-> $1179 est la zone mémoire contenant la séquence à envoyer au EF9345.
HL pointe sur la taille de la séquence à envoyer au EF9345.

$1055:Initialisation de la variable $47FA : compteur d'interruptions à 5
$1059:Initialisation de la variable $47FB : besoin de rafraichissement à faux
$105d:Initialisation de la variable $47FA : utilisation des majuscules
$1063/above:Les interruptions sont réactivées pour la suite de l'initialisation.
$1067:Numéro de la première ligne du BASIC ?
$106a:Couleur du pourtour et aspect du curseur
$107a:Copie les valeurs initiales des différentes variables du système en RAM
$107d:Envoi 0 sur le port $EF, censé être non utilisé
$107d:Envoi 0 sur le port $AF, pour le son-k7
$1084:Modification de l'adresse du hook "nmihk"
$1093/above:Calcul des bornes de pile, memsize et place disponible
$1096:hl <- sp - 2 (sp == (stktop))
$109b:hl < $03e8 ? (comment serait-ce possible ?)
$109e:de <- $ffce (-50)
$10a5:Calcul final du haut de la pile comme étant (memsize) - 50
$10ab:Récupération du haut de la pile
$10b1:hl <- (stktop) - 17
$10ba
hl = hl - de, soit ((stktop) - 17 - end_vars)
Autrement dit, la taille disponible entre la fin des variables internes et la pile -17.

$10bb:Cette taille disponible est poussée dans la pile.
$10bc/above:Affichage du texte de démarrage. VG5000 + numéro de version
$10bc:Texte en double hauteur, double largeur

$1118/test_reset/above
Fonction : appelé par le vecteur nmihook ($47ee) qui par défaut est un jp $1118.
Teste si CTRL est appuyé et si oui, effectue un reset.
Plus exactement, pendant le boot, le vecteur est à JP $0069, puis à la fin du boot JP $1118

$1122/reset/above
Fonction: Effectue le reset à chaud

$1148/vg5000_txt
$1163/version_txt
$1179/InitEfSeq:Séquence d'intialisation de l'EF9345 au démarrage.
$1194/InitValues

$11f9/keybfr_0
$1201/keybfr_1
$1209/keybfr_2
$1211/keybfr_3
$1219/keybfr_4
$1221/keybfr_5
$1229/keybfr_6
$1231/keybfr_7
$1239/keybfr_s0
$1241/keybfr_s1
$1249/keybfr_s2
$1251/keybfr_s3
$1259/keybfr_s4
$1261/keybfr_s5
$1269/keybfr_s6
$1271/keybfr_s7
$1279/keysfr_c0
$1281/keysfr_c1
$1289/keysfr_c2
$1291/keysfr_c3
$1299/keysfr_c4
$12a1/keysfr_c5
$12a9/keysfr_c6
$12b1/keysfr_c7

$12b9/keybeng_0
$12c1/keybeng_1
$12c9/keybeng_2
$12d1/keybeng_3
$12d9/keybeng_4
$12e1/keybeng_5
$12e9/keybeng_6
$12f1/keybeng_7
$12f9/keybeng_s0
$1301/keybeng_s1
$1309/keybeng_s2
$1311/keybeng_s3
$1319/keybeng_s4
$1321/keybeng_s5
$1329/keybeng_s6
$1331/keybeng_s7
$1339/keyseng_c0
$1341/keyseng_c1
$1349/keyseng_c2
$1351/keyseng_c3
$1359/keyseng_c4
$1361/keyseng_c5
$1369/keyseng_c6
$1371/keyseng_c7
$1379/errors_fr
$153f/errors_eng

$1763/txt_arret
$176a/txt_break

$1771/txt_in_fr
$1776/txt_in_en
$177b/txt_next

$1d97/sendchar_k7


////////////////////


/////////////////////////////////////////
////////////////// 2000 /////////////////
/////////////////////////////////////////

$2000/instructions
$209d/prekeywords
$209e/keywords
$21fd/keywstop
$21fe/mysteryatnow

$2214/ok_str
$2219/marker_vrfy
$221c:HL pointe 4 octet plus haut que le haut de la pile (skip l'adresse de retour de cette fonction et de celle appelante, l'instruction)
$221f:Compare au token de FOR
$2221:Si différent, retourne immédiatement
$2238/stx_err_prt

$223b/divbyzero:Affiche une erreur "Division par Zéro".
$223e/missfor:Affiche une erreur "NEXT sans FOR"
$2241/redim:Affiche une erreur "Tableau redimensionné"
$2244/undeffn:Affiche une erreur "Fonction utilisateur non définie"
$2247/overflow:Affiche une erreur "Dépassement de capacité"
$224a/missing_op:Affiche une erreur "Opérande manquante"
$224d/wrong_op:Affiche une erreur "Opérande mal adaptée"
$2250:Affiche une erreur "Non reconnue"



$2293:Affiche Ok!

$2250/SomeVector/code:Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.
$2252/error_out/above
Fonction : affiche un message d'erreur
Entrée : E contient le numéro de l'erreur
L'erreur est ensuite cherché dans la table, donc chaque message est séparé des autres par un $00

$2264/err_msg_fr
$2266:Ajoute 2 à l'erreur et prends le multiple de 2 inférieur
$226b:Saute si E est inférieur à $2b
$226f/err_loop:E est le min entre E et $2a

$2278/disp_break/above
Lorsqu'arrive directement ici, c'est pour afficher un arrêt d'exécution en ligne (curlin) (à vérifier)

$228d/ok_loop/above
Reset l'imprimante, remet le curseur en début de ligne et affiche "Ok".
Puis tombe dans la boucle du moniteur.

$2299/monitorloop
$2299:Ligne courante du BASIC à -1
$22a3:Saute si hors du mode AUTO
$22a5:Ligne courante du mode AUTO dans HL

$22ab/above
Suivant si la ligne a déjà du contenu ou pas, le mode de numérotation automatique
arrivera sur out_space ou out_loop, puis tombera dans la boucle de l'éditeur.

$22ab/out_space:Affiche le caractère espace puis continue dans la boucle BASIC
$22ae/stoploop/above
Boucle de traitement du BASIC

$22ad/out_loop:Affiche le caractère qui est dans A puis continue dans la boucle BASIC

$22b3/above
Lorsqu'on arrive ici, CR a été appuyée.
HL pointe sur l'adresse précédente le buffer en entrée, qui se termine par 0.
(Ce buffer est tout le temps basbuf en entrée normale ?)

$22b1:Lorsque monitor sort avec Carry (touche STOP), on boucle immédiatement.
$22b3:Acquisition d'un nouveau caractère depuis HL dans A
$22b5:On ne test pas avec "or a" à cause du test de Carry plus loin en $22ca (vraiment ?)
$22b6:Si le caractère était zéro, le traitement est terminé

$22bd:Si le flag d'exécution BASIC est différent de 0, branchement en 0 pour un reset de la machine. C'est le cas avec les programmes "protégés", dont l'arrêt provoque le RESET de la machine.
$22c3:DE contient soit un numéro de ligne, soit 0.

$22c7:En fin de tokenisation, A == 0, donc B prend 0 aussi
$22c8:Récupération du numéro de ligne dans DE
$22c9:Récupération du AF de $22b8 (vraiment ? Ça n'a pas trop de sens pour lancer l'exécution immédiate)
$22ca:Quand est-ce que le Carry est set ? Autre chose que $FF ?

$22cd:Push numéro de ligne
$22ce:Push de C qui contient la taille du résultat de tokenisation (B = 0 depuis $22c7)
$22cf:Push de l'adresse de tokenisation (un octet avant)

$22d3:Incrément du mode AUTO. DE contenait la ligne décodée, HL contient la ligne suivante.

$22d7/line_record:Récupération de l'adresse de tokenisation
$22d8:Et du prochain token à décoder
$22da:Préparation et sauvegarde d'un test sur le token récupéré
$22de:Le numéro de ligne qui était dans DE (le numéro de la ligne en cours) a été trouvé.

$22e2:Si le caractère récupéré était NUL, alors on sort vers le moniteur. En effet, si la ligne n'existait pas et qu'il n'y a rien à y encoder, on ne fait rien.
$22e5:Pourquoi refaire un "or a,a" ici ?
$22e6:BC contient l'adresse de la ligne trouvée.
$22e7:Saut si on ne vient pas $22de directement. Autrement dit, si la ligne courante n'a pas été trouvée.

$22e6/prev_found:Sauvegarde dans la pile de l'adresse de ligne précédente trouvée
$22e9:DE=adresse de la ligne suivante à celle trouvée
$22ea:HL=pointeur de la zone des variables
$22ed/erase_line:Copie de la zone depuis la ligne suivante à celle trouvée jusqu'à l'adresse de la ligne trouvée. Autrement dit, on écrase la ligne courante. Ce qui invalide au passage tous les pointeurs de chaînage.
$22f2:Boucle pour la copie
$22f6:Ajustement de la nouvelle valeur de (vartab) (comme étant la dernière adresse recopiée dans le bloc précédent)

$22f9/prev_nfound
$22f9:Récupération de l'adresse initiale de la ligne trouvée (avant déplacement)
$22fa:Récupération du résultat du test du token sauvé en $22e1 (fait en $22d9)
$22fd:HL pointe sur l'adresse des variables
$2300:Récupération dans HL de la taille de la tokenisation
$2301:Récupération dans BC de l'adresse des variables (vartab)
$2302:HL contient la nouvelle valeur voulue pour (vartab)
$2303:Sauvegarde de cette valeur
$2304:Déplacement du bloc text vers le haut de la mémoire pour faire la place nécessaire à la ligne qui arrive (avec vérification que HL n'a pas touché la stack, sinon, erreur)
$2307:Récupération de la valeur voulue pour (vartab)
$2308:Et mise à jour de (vartab)
$230b:Récupération dans HL de l'adresse de la ligne
$230c:Mise en place de la première partie de l'adresse de chaînage (nécessaire pour éviter que le chaînage ne soit NUL plus tard et confondre avec la fin de chaîne)
$230d:DE récupère le numéro de ligne
$2313:Placement du numéro de ligne, HL pointe sur le début du contenu de la ligne (qui n'est pas encore là)
$2314:Sauvegarde du pointeur de contenu
$2315:HL pointe sur le buffer de tokenisation

$2318/cpy_line:Commence la copie du contenu de la ligne
$231b:Cas spécial pour les valeurs numériques sur 16 bits
$2321:La copie des deux octets des valeurs numériques

$2325/cpy_not_num
$2326:Continue la copie tant que la valeur n'est pas zéro. En sortie de boucle, la ligne a été insérée dans la partie texte.

$2328/line_empty:Saut si la ligne est vide

$232b:HL pointe sur (txttab)
$232c:DE pointe sur (txttab)

$232d/make_chain
$232e:HL <- DE
$2332:Si le chaînage est NUL, retour au moniteur (d'où l'intérêt de mettre une valeur temporaire dans le chaînage)
$2335:HL pointe sur le numéro de ligne
$2336/skip_2bytes
$2337:Saut du numéro de ligne
$2338/adv_1byte
$2339:Copie dans A de la valeur et avancée du pointeur
$233c:Si on est sur un marqueur de valeur numérique entière, on saute deux octets (en profitant du saut du numero de ligne)
$233f:Si l'octet n'est pas NUL, on continue
$2341:Fin de ligne. On reprend dans HL le pointeur de la ligne précédente (DE en début de boucle)
$2344:Placement dans le chaînage de la ligne précédente du pointeur de ligne actuel


$236b/tokenize/above
Fonction : effectue la tokenisation du buffer d'entrée
Entrée : HL pointe vers le contenu à traiter
(qui est normalement dans basbuf au moins en mode direct)
Sortie : C contient la taille du résultat de tokenisation en octets (?)

$236c:Le flag est à 0 pour signaler la tokenisation
$2371:DE pointe sur le buffer de tokenisation
$2374/analyze
$2374:Récupération dans A du caractère à traiter
$2377:Est-ce un espace ?
$237a:B contient le caractère aussi
$237d:Sont-ce des guillemets ?
$2381:Est-ce NUL ?
$2387:Préparation du test de flag de tokenisation
$2388:A est à nouveau le caractère à l'étude
$2389:Si on est hors tokenisation, on saute.
$2390:Est-ce que le caractère est '?' ? A est préchargé avec $94 dans ce cas. Raccourci vers l'instruction PRINT.
$2393:A est à nouveau le caractère à l'étude
$2398:Est-ce que le caractère est '…' ? A est préchargé avec $AF dans ce cas. Raccourci vers DISK (est-ce vraiment utilisé, DISK est vectorisée ?)
$239b:A est à nouveau le caractère à l'étude
$239e:Est-ce inférieur à '0' ?
$23a2:Est-ce inférieur à '<' ? (les chiffres et ':' et ';' ne sont pas tokenisés)

$23a5/specialchr
$23a5:Ici, A contient tout caractère hors chiffre et ':; "?…\0'. Et le flag de tokenisation est à 0 (donc, actif). DE, qui contient le buffer de tokenisation, est sauvé sur la pile.

$23a6:DE contient le début du buffer des mots clés du BASIC -1 (car le traitement commence par augmenter le pointeur)
$23a9:Pourquoi sauve-t-on BC ?
$23aa:BC contient $244b
$23ad:BC est sauvé sur la pile, ce qui provoquera la sortie à cette adresse si le token n'est pas trouvé
$23ae:B contient $7F et sera incrémenté avec chaque token étudié. Le premier token a donc pour numéro $80
$23b0:A est à nouveau le caractère à l'étude
$23b3:Est-ce inférieur à 'a' ?
$23b7:Est-ce supérieur à 'z' ?
$23b9:Passage en majuscule
$23bb:Mise dans le buffer de la lettre passée en majuscule
$23bc/notlowerchr
$23bc:C contient le caractère à traiter
$23bd:HL pointe sur le buffer de keywords - 1
$23be/nextkeyword
$23c0:Boucle jusqu'au premier caractère avec un bit de poids fort à 1 (cela indique le début d'un mot)
$23c3:Augmenter l'index de mot-clé
$23c5:A contient le premier caractère de la table des mots clé, sur 7 bits (nécessaire pour enlever le marqueur de début de mot)
$23c7:Si égal à NUL, alors la fin du buffer est atteinte, on sort. Comme tokennotfound est actuellement en haut de pile, c'est vers là que l'on sort.
$23c9:Si le caractère à traiter et celui du mot-clé sont différent, on cherche le mot clé suivant
$23cb:Le pointeur sur le mot clé à traité est mis dans DE. HL contient à nouveau l'adresse du buffer en traitement.
$23cd/strcmpkw
$23d0:Puisqu'on atteint un nouveau marqueur de mot clé, c'est que le match a été fait correctement.
$23d3:C contient le caractère courant dans le buffer des mots clé
$23d4:A contient le caractère du buffer d'entrée à traiter
$23d5:Marqueur pour ?
$23d9:Marqueur pour ?

$23dd/marker_1:Lecture du caractère suivant pour l'oublier (le marqueur $8c ou $88)
$23df/marker_2
$23e0:Lecture d'un nouveau caractère.
$23e7/notlower2

$23e5:Passage en majuscule (voir $23b9), mais on ne vérifie pas le supérieur à 'z' cette fois. En effet, seuls les caractères alphabétiques matcherons un mot clé de toute façon.
$23e8:Pour le moment, ça match, on continue.
$23eb:Ça ne matche pas, on essaie le mot clé suivant après avoir récupéré le pointeur vers la chaîne à traiter depuis son début de mot…

$23ed/foundkeyw
$23ee:Pop de HL l'adresse du début du mot
$23ef:Pop de l'adresse de retour 'tokennotfound'

$23f0:A contient le token
$23f3:Saut si le token est $88 (GOTO)
$23f7:Saut si le token est $8c (GOSUB)
$23fb:Saut si le token est $8b (RESTORE)
$23ff:Saut si le token n'est pas $b6 (???)

$2401/test_number:Vérifie s'il y a un paramètre nombre derrière l'instruction
$2404:Ce qui suit n'est pas un nombre, on considère qu'il n'y a pas de paramètre.

$2406:Sauvegarde du HL courant dans DE
$2407:pop IY ?!!! (on doit en être à la sauvegarde de BC)
$2409:Pop de la valeur de DE en $23a5, qui pointe sur le buffer de tokenisation

$240a/dec_number
$240a:On place le token dans le buffer de tokenisation.
$240b:On récupère et on sauve DE, qui pointe sur la zone à parser.
$240d:Échange des registres secondaires.
$240e:Récupération dans HL de la zone à parser.
$240f:Remise dans la pile de l'adresse de la zone à parser.
$2410:Tentative de récupération d'un numéro de ligne.
$2415:Si le numéro de ligne est 0 (ligne invalide), on sort.
$2417:Récupération dans BC de la zone à parser (pour remettre la pile en état)
$2418:Octet bas du numéro de ligne dans A (exx n'echange pas AF, on garde donc une partie de numéro de ligne, voir plus loin)
$241a:Mise dans la pile dans l'adresse de décodage ajustée
$241b:On repasse au registre primaires
$241c:On récupère dans DE le pointeur à parser.
$241a:On incrémente le pointeur de la zone de tokenisation
$241e:On annote avec $0e pour indiquer qu'un paramètre suit.
$2421:Placement de la première partie du numéro de ligne
$2424:Récupération de la seconde partie du numéro de ligne
$2426:La seconde partie du numéro de ligne est placée dans C
$242b:Hein ???

$242d/miss_line
$242e:DE doit toujours être supérieur à HL, sinon, c'est qu'il n'y avait pas d'opérande lorsqu'une était attendue (vérifier)
$2431:HL contient le buffer à parser, DE le buffer tokenisé en cours.
$2432:Sauvegarde du pointeur de parsing en cours
$2433:Lecture du caractère suivant.
$2434:DE=buffer à parser, HL=buffer tokenisé
$2435:Comparaison du dernier caractère lu avec $2ca (virgule ',')
$2437:Si pas de virgule, c'est terminé
$2439:Sinon, on place la deuxième partie du numéro de ligne dans le buffer tokenisé
$243a:Puis passage à l'emplacement suivant dans le buffer tokenisé
$243b:Mais que pointe iy ?
$243d:C contient maintenance $2c (virgule), préparer pour être copié à la prochaine itération.
$243f:Pop de l'adresse de parsing (pour balance)

$2442/invalid_lin
$2447/token_end
$2447:DE recupère le pointeur de parsing final
$2448:Sauvegarde du pointeur tokenisé
$2449:Sauvegarde de IY... ?

$244b/tokennotfound/above
Arrivée ici que la tokenisation échoue ou réussie.

$244b:HL pointe à nouveau sur le buffer en entrée

$244c/tokencomplete
$244c:Récupération du caractère dans A. Dans le cas où l'on a réussi la tokenisation, C contient le token. Dans le cas où l'on a décodé un numéro de ligne, C contient la deuxième partie (haute) du numéro.

$244d:Nettoyage de la pile
$244e:DE pointe sur la partie tokenizée

$244f/no_token

$2450:Recopie du caractère actuel (ou du token ?) dans la partie tokenisée
$2451:Passage à l'adresse suivante dans le buffer tokenisé
$2452:Pourquoi agumenter C ? (vérifier suivant arrivée par no_token ou autre cas)
$2455:Saut si A est égal à ':'

$2457:Avec la soustraction précédente, cela fait que l'on compare le caractère à $83
$2459:Saut si le caractère n'est pas le marqueur $83 (qui est ?)

$245b/is_colon:A est forcément égal à 0. On passe en tokenisation.

$245e/not_83
$245e:Avec la soustraction précédente, cela fait que l'on compare le caractère à $8E
$2460:Saut si le caractère n'est pas le marqueur $8E (qui est ?) pour une nouvelle analyze de token

$2464/trailing:Recopie le reste de la chaîne à traiter
$2466:Sort si le caractère à parser est NUL
$2469:Saute si le caractère nouveau est identique au précédent (qui a été soustrait !)
$246c:Copie le caractère nouveau dans le buffer de tokenisation
$246d:Augmente C (pourquoi ?)
$246e:Augmenter le pointeur de buffer de tokenisation


$246b/ifquote
$2471/ifnul/above
Arrive ici lorsque la chaîne a été complètement parsée.

$2471:HL est placé juste avant le buffer de traitement
$2474:DE pointe sur la fin du buffer tokenizé. Comme A contient 0, le buffer est terminé par trois 0.
$2479:Fin de la fonction de tokenisation

$24ea/end_of_inst/code
$247A/inst_for/code

$24f1:Comparaison avec ':'
$24f6:HL doit pointer sur le NUL de fin de ligne ou bien ':'. Si ce n'est pas le cas, c'est une erreur de syntaxe (l'instruction n'a pas tout consommé)
$24fd:Saut si on est sur la dernière ligne du programme

$2504:HL contient le numéro de ligne, DE contient le pointeur sur le contenu de la ligne BASIC
$2505:Enregistrement du numéro de la ligne courante
$2508:Récupération dans HL du pointeur sur le contenu de la ligne BASIC

//-----------------
$2509/exec_token
$2509:Récupère le première token du buffer
$250d:Met sur la pile une adresse de retour qui est "end_of_inst"
$250e:Retourne en "end_of_inst" si le caractère du buffer est NUL, c'est-à-dire que le contenu de la ligne était vide, ce qui est le cas pour la dernière ligne.
$250f:Les tokens sont tous supérieurs à $80
$2511:Si la soustraction a provoqué un Carry, alors ce n'était pas un token. Exécute par défaut l'assignation de variable.
$2516:Si le token est supérieur à $32 (les 50 premiers token sont des instructions, suivent les fonctions dont les 16 premieres n'ont pas d'adresse), affiche une Erreur de Syntaxe.
$2519:Le token est multiplié par 2
$251a:puis stocké dans C
$251b:B est à 0, donc BC contient le numéro de token * 2
$251d:Sauvegarde de HL dans DE
$251e:HL est chargé avec la table des adresses d'instructions
$2521:HL contient le pointeur adresse d'execution de l'instruction tokenisée
$2524:BC contient l'adresse d'execution de l'instruction tokenisée
$2525:L'adresse est mise sur la pile
$2526:Récupération de l'adresse en cours du buffer tokenisé (cf. $251d)


$2527/skipch/above
Fonction: recupère le caractère suivant du pointeur HL
Retourne immédiatement si le caractère est superieur à $3a,
sinon, fallthrough dans chget_2
La fonction est à la suite du décodage de token, ce qui permet d'avancer le pointeur directement.


$252c/chget_2/above
Suite du traitement de chget.
A contient le caractère lu dans le buffer, qui est inférieur ou égal à $3a

$252e:Se positionne sur le premier caractère qui n'est pas un espace et est inférieur ou égal à '9'
$2530:Si le caractère est supérieur à ' ', saut plus loin
$2534:Saute si le caractère est entre 0F et 1F (une partie des caractères de contrôle)
$2538:Saute si le caractère est inférieur à 0D (une autre partie des caractères de contrôle, dont 0)
$253a:Reste les cas 0D et 0E ?

$2542/chget_3
$2543:Ce RET branchera sur l'instruction à exécuter si un token a été décodé. Si appel depuis RST, retourne normalement avec le flag Z si A était à NUL. Cela signifie aussi que les exécution d'instruction arrivent avec Z=1 si le caractère lu après le token est NUL (modulo le recalage précédent)

$2544/chget_4
$2544:Compare avec '0'
$2546:Inverse la retenue. Donc le flag C sera mis si le caractère est supérieur ou égal à '0' (donc un chiffre).
$2548:Manipulation de A pour mettre le flags en fonction de la valeur du caractère (comment exactement ?)

$2552/deint_impl

$256c/get_lin_num/above
Fonction : sur la ligne pointée par HL, récupère le paramètre numérique sur 16 bits dans DE
Sortie : le paramètre dans DE. Le dernier caractère pointé dans A.
Le numéro de ligne maximum est limité par le test avec $1998 (6552). Ce nombre est multiplié par 10
avant la dernière addition. Ce qui porte le numéro maximum de ligne à 65529. Au delà, le parsing
sera étrange. Par exemple 65530 sera compris comme : ligne 6553, qui contient '0'.

$256d/get_lin_nu2:Accès sans recalage de HL

$2570:Si le caractère actuel du buffer n'est pas $OE (shift out), branchement
$2575:Sinon, récupération du nombre entier sur 16 bits dans DE
$2576:Puis lecture du caractère dans A

$257d:Si le caractère n'était pas un chiffre, retour immédiat

$2578/not_oe
$2579:Initialise le résultat à 0

$257c/num_decode:La boucle décode une valeur numérique depuis sa forme ASCII. Le nombre maximum est $1998 (6552)
$2583:Comparaison de DE (résultat) avec HL ($1998 = 6552).
$2584:Si DE est supérieur à HL, saut

$2588:HL <- DE * 2
$2589:HL <- DE * 4
$258a:HL <- DE * 5
$258b:HL <- DE * 10. Au final, HL contient le résultat précédent multiplié par 10.
$258d:Transposition du caractère "chiffre" en sa valeur entre 0 et 9
$2592:Ajout au résultat de la valeur de chiffre décodée.
$2593:DE contient à présent le résultat précédent multiplié par 10 plus le nouveau chiffre.

$2597/num_dec_end

$25a9/above
Instrution : GOSUB

$25ae:Récupère l'adresse de retour dans BC
$25b0:Sauve le pointeur d'exécution HL une fois, puis réserve un emplacement en haut de la pile (peu importe le contenu)
$25b1:HL contient la ligne courante
$25b4:Met le numéro de la ligne courante au sommet de la pile
$25b7:Place un marqueur sur la pile ($8c, qui est le token d'exécution de GOSUB)
$25b8:Ajuste la pile pour ne pas enregistrer la partie F de AF.
$25b9:Remet l'adresse de retour sur la pile, puis enchaîne sur GOTO. Instruction partagée avec RUN pour lancer un programme.

$25b9/inst_run_2

$25ba/above
Instrution : GOTO

$25ba:DE contient l'argument (numéro de ligne)
$252c:HL contient la ligne courante exécutée
$25c5:C si DE supérieur à HL
$25c7:Saute si le numéro de ligne du GOTO est au-delà de la ligne courante
$25ca:Saute si le numéro de ligne du GOTO est avant la ligne courante
$25d0:Retour en cas de ligne trouvée (HL pointe sur l'octet avant la ligne courante)
$25d3:"Ligne non définie"

$234d/goto_after
$2347/goto_before/above
Chercher la ligne de BASIC à exécuter, présent dans DE
En sortie, si Carry Flag est levé, alors BC contient le pointeur vers la ligne de BASIC trouvée.
Si Carry Flag est reset, alors la ligne n'a pas été trouvée. BC contient le pointeur vers la ligne de numéro inférieur à celui cherché
HL contient la ligne suivante à celle pointée par BC.

$234a:HL contient la première adresse du listing BASIC
$234d:Met la dernière ligne trouvée dans (prelin)
$2352:HL dans BC
$2356:A contient le OR des deux premier octets de la ligne actuelle (HL n'est pas touché)
$2357:Retour immédiat si A est à 0 (fin des liens)
$2359:Pointe HL deux octets plus loin
$235d:Lecture de la valeur pointée par HL dans HL. C'est le numéro de la ligne.
$235e:Comparaison de HL (numéro de ligne considérée) et DE (numéro de ligne recherchée)
$2360:BC dans HL (le pointeur sur la ligne qui avait été sauvé)
$2364:Lecture dans HL de la valeur pointées par HL. C'est le pointeur vers la ligne suivante.
$2365:Inverse la retenue. Dans le cas Z, C n'est pas mis, et du coup le set, ce qui indique que la recherche a réussi.
$2366:Retour immédiat si la ligne considérée était celle cherchée.
$2367:Inverse la retenue. La remet donc à l'état du test précédent (de_compare)
$2368:Retour immédiat si HL > DE dans le test de ligne (on a dépassé la ligne sans la trouver)
$2369:Retour en début de recherche

$25d6/above
Instruction : RETURN

$25d6:S'il y a des choses après le RETURN, retour immédiat. Return n'a pas de paramètre.
$25dc:Ajuste la pile à la valeur calculée par marker_vrfy. Ce qui remet la pile avant le marqueur (au passage, on n'a plus l'adresse de retour de l'appel à l'instruction en cour)
$25dd:Vérification du marqueur placé par GOSUB
$25e1:S'il n'est pas là, lancement d'une erreur "RETURN sans GOSUB"
$25e5:Récuération de l'adresse de la ligne appelante et sauvegarde dans (curlin)
$25eb:Vérification que la valeur incrémentée de 1 n'est pas 0 sinon... ben rien. C'est louche. Visiblement, un test de la valeur de ligne FFFF qui a tourné court.
$25f0:Remise en place en haut de pile de l'adresse de retour de l'instruction. Le POP HL récupère le pointeur d'exécution de la ligne qui avait le GOSUB. Puis quelques instructions nulles, pour arriver en 25f7.

$25f9/rem_ex_lp
$25fb:Swap le contenu de B et C. Donne $3a00 en venant de RETURN (ce qui signfie que l'on cherche un ':')
$25fc/rem_loop

$25fd:Vérifie la présence d'un argument (numérique sur 16 bits?)
$2603:S'il y a un argument, saute le marqueur et la valeur
$2604:Puis lit dans A la valeur suivante
$2605/no_param
$2606:Si la dernière valeur lue est zéro, retour immédiat.
$2607:Compare avec le caractère spécifique cherché
$2608:Retour immédiat si trouvé
$2609:Sinon, on passe au caractère suivant
$260c:Si c'est $22 ('"'), on loop sur l'échange du caractère recherché
$260e:Sinon, on continue le parsing de la ligne


$2610/above
Instruction : LET
Appelé lorsque le buffer tokenisé ne contenait pas un token.

$284d/frnum_impl/above
Fonction :

$28d9:Type numérique
$282c:Lecture du prochain caractère (non blanc, numérique, essayer avec INIT ABC ?)
$28dd:Cas où le caractère est NUL
$28e0:Cas où le caractère est un chiffre.

$29f0/retfun_2:B contient la valeur de la fonction, A contient 0, quand appelé depuis retfun_impl
$29f6:Place 0 dans la globale valtyp, ce qui signifie que la valeur est numérique

$2a0f/retfun_impl
$2a0f/above
Function : met en place la valeur de retour d'une fonction
Prerequis : valeur dans A (?)

$2aa5/getbyt_impl

$2ae4:Saute en fin de fonction si aucun caractère n'a été entré

$2ad4/acquirekey/above
Fonction: décode une touche du clavier et l'affiche à l'écran à la position du curseur.
Attends un refresh (HALT) puis scrute le clavier.
Si rien n'a été appuyé, sort immédiatement.
Sinon, traitement.

$2adf:Attente d'une interruption

$2ae8:Son lorsqu'un caractère est reçu
$2afb:Bit pour indiquer que la ligne est entrée en BASIC (quelque chose a été entré en tout cas et sera traité par le saut en $2adc)
$2aff:Si le bit de signe était 1 dans le caractère lu
$2b02:Comparaison de la touche avec ENTREE
$2b07/acquirekeyn3/above
Suite (2) du traitement de l'entrée

$2b2d/acquire_nul:Ici, la valeur acquise passe à zéro avant de sortir de la fonction

$2b2e/endacquirek
$2b32/bufferstart/above
Fonction : lorsque le bit 1 de $4871 est à 1, arrive ici pour analyse
À l'air de se positionner sur le premier caractère interessant à décoder


$2b32:Coordoonées de la ligne BASIC à décoder
$2b35:A contient la ligne
$2b36:Comparaison avec 24 (le nombre de lignes)
$2b3e:Lecture du caractère en colonne 0 de la ligne suivante
$2b44/ifabove24
$2b45:Comparaison de la colonne avec 40 (colonne max)
$2b4d:Comparaison de la colonne avec 40 (colonne max)
$2b52/ifbelow40
$2b53:Stockage des nouvelles coordonnées (ajustées comment?)
$2b5a:B contient le caractère aux coordonnées
$2b5b:DE contient les coordoonées
$2b5d:A contient le caractère aux coordonnées
$2b5e:Not carry de quoi ?
$2b62:Si ce n'est pas un espace
$2b75/ifabove40
$2bac/specialchars

$2be0/ifcr:Récupération des coordonnées du curseur

$2be9:Comparaison à $80, la caractère de début de ligne

$2be3/find_start_l
$2be3:Décrémentation de X
$2be4:Sauvegarde des coordonnées modifiées du curseur
$2be8:Récupération des coordonnées


$2b23/acquirekeyn7/above
Suite (6) du traitement de l'entrée

$2b24/acquire_sync:Attend le prochain affichage puis passe dans l'annulation de la valeur acquise et la sortie.


$2b24:Force un affichage
$2b2d:A est effacée en traitement normal de touche (et déjà 0 si pas de touche entrée)
$2b2e:Nettoyage de fin de fonction

$2ba7/acquired_cr

$2bf1:Recheche du caractère de continuation ? ($B4)
$2bf3:Boucle sur la recherche
$2bf5/linestart
$2bf7:Si on n'était pas sur la colonne 0, c'était une fausse alerte et non un vrai début de ligne, on continue à chercher.
$2bfe:Si on n'est pas en mode auto, on continue le traitement de la ligne.
$2c01:Sinon, le mode AUTO est annulé
$2c04:L'adresse du curseur mis à jour
$2c09:Le marqueur $84 (re)mis? en place
$2c0a:Et la touche acquise sera validée comme étant $0D (sans traitement)


$2c0d/find_cont:Traitement lors d'une continuation trouvée au début de la ligne
$2c0f/find_start:Remonte de ligne en ligne jusqu'au premier marqueur de non continuité (et donc à la première ligne).
$2c14:Peek du caractère en colonne 0
$2c1b:Saute si on est arrivé en haut de l'écran (H est passé à $FF)
$2c18:Test sur $84, qui est le marquage de continuité des lignes. Saut lorsqu'on ne le trouve plus. On est en tout début du ligne.
$2c1e:Boucle sur la remontée des Y

$2c20/found_start:Coordonnées placées en début de la première ligne
$2c23:Test de INPUT activé
$2c25:Traitement spécifique si le monitor était en train de traiter un INPUT
$2c2c:Recupération des coordonnées de début d'entrée
$2c33:DE contient les coordonnées de début d'entrée. HL l'adresse mémoire
$2c35:Comparaison de X avec la colonne 40
$2c4b/ifinput
$2c4e:Enregistrement du premier caractère de la ligne ($80 en mode direct)
$2c56:Set du flag pour "ligne entrée en BASIC"
$2c5d:Placement des coordonnées sur le caractère en colonne précédente (donc 0?)
$2c60/screenstart:La fonction sortira avec pour valeur acquise NUL.
$2c63/iftab
$2c89/iflinef
$2caf/ifformf


$2d76/func_keys
$2d78:Saute si la valeur est inferieure à $ba
$2d7d:Saute si la valeur est supérieure ou égale à $fb

$2d83/loop_accel:Recherche la valeur de la touche d'accélération dans le tableau
des chaînes affichées par les touches accélératrices.
$2d87/out_accel:Provoque l'affichage de la chaîne accélérée (raccourci BASIC)
$2d8a:Lorsque le bit de poids fort est 1, alors la chaîne est terminée, on sort.
$2d8d:Affichage du caractère de la chaîne en train d'être affichée.

$2d91/ctrl_keys/above
Traitement des touches de contrôle (des touches de contrôle ?)

$2d9a:A est remplacé par la valeur trouvée dans la table d'indirection à 10 entrée en $487a (comment est-elle remplie ?)

$2d9e/accel_keys



$2ead/mem_move_ckk/above
Fonction : vérify la mémoire
Entrée : BC et HL deux pointeurs de mémoire (BC < HL), DE un pointeur de référence (DE < BC)
Copie de DE à BC vers HL en descendant.

$2eb0/mem_move

$2eb0:Mise sur la pile de la taille
$2eb2:Échange des valeurs de HL et BC
$2eb3/cpy_loop
$2eb3:Préparation de la comparaison entre HL et DE
$2eb5:Copie de (HL) vers (BC)
$2eb6:Retour si HL a atteind DE
$2eb8:Décrément de HL et BC
$2eb9:Boucle de la copie

$2ed9/reset_mem/above
Reset memoire ?
Met 0 dans les deux premiers octets de txttab (donc efface l'accès au listing)

$2edc/reset_mem_2
$2edc:appelé depuis l'instruction NEW

$3d91/reset_mem_3
$3d91:0 dans (autoflg)
$3d94:0 dans les deux premiers octets de (txttab). Cela coupe le premier lien du listing BASIC.
$2ee0/reset_mem_4
$2ee1:txttab+2 dans (vartab)
$2ee4/reset_vars:Remet à zéro les pointeurs du modèle mémoire
$2ee7:HL pointe sur l'octet avant txttab
$2ee8:HL est mis de côté
$2eeb:HL prend la valeur de memsiz
$2eee:fretop est donc mis à memsiz, cela signifie que toute la mémoire est disponible.
$2ef5:(vartab) est placé dans (arytab) et (strend). Autrement dit, élimine toutes les variables, les tableaux et les chaînes.

$2ebb/stk_verify/above
Entrée : C, le nombre d'octet que l'on voudrait mettre sur la pile
S'il n'y a pas la place demandée sur la pile, provoque un message d'erreur.
La place vérifiée semble être deux fois la place demandée avec une marge de $60 octets.
Préserve HL.

$2ec4/mem_verify/above
Identique à stk_verify mais fourni HL pour comparer avec la pile.

$2ec2:Ajoute deux fois l'entrée C à strend
$2ecc:HL <- $FFA0 - HL (HL étant (strend) + 2 * C)
$2ecd:S'il n'y a pas au moins $60 octets entre la valeur désirée et $FFFF, alors il n'y a plus de mémoire (oui, c'est en dur quelque soit la mémoire présente, c'est louche)

$2ed1:Si HL + SP provoque une retenue, alors on revient, il y a assez de mémoire. Sinon, c'est qu'il y a moins de $60 octets entre la pile et (strend), il n'y a pas assez de mémoire.
$2ed2/out_of_mem
$2ed5:"Sortie de mémoire"

$2efe/resetstack/above
Fonction : remise à zéro de la pile et effacement de l'interprétation en cours. Réinitialisation de l'imprimante.
Retour : HL contient le code de l'instruction en cours ?
;
Un meilleur nom: interpreter_reset ?

$2efe:Récupération de l'adresse de retour
$2eff:Réinitialisation de la pile (SP) à la dernière addresse RAM valide
$2f06:Le pointeur sur la zone temporaire de descripteur est initialisé
$2f0f:Mise à zéro de `oldtxt`
$2f12:Mise à zéro du buffer `subflg` (utilisé pour FOR)
$2f15:Mise à zéro de 
$2f18:Met 0 sur la pile
$2f19:Remet l'adresse de retour sur la pile avant le RET
$2f1a:HL contient la valeur de `temp` (code d'une instruction)

$2f42/end_of_prog/above
Traite la fin d'un programme

$2f49:Si la dernière ligne était FFFF, alors le A est égal à 0, saut.
$2f4b:Sauve la dernière ligne exécutée si elle avait un numéro
$2f51:Sauve le dernier pointeur de token (?) concernant une ligne avec numéro.

$2f54/no_line
$2f5a:Récupére AF... sans intérêt, on le push juste après sans rien en faite.
$2f68/break_fr
$2f69:Comment est-ce que cela peut être NZ ?

/////////////////////////////////////////
////////////////// 3000 /////////////////
/////////////////////////////////////////

$302c/str_hex_dec

////////////////// 3200 /////////////////
$3278/initscreen/above
Réinitialisation du curseur, d'attributs
Redéfinition de deux caractères: $20 et $7F
Efface l'écran, remise en colonne 1

$3292/initscreen2
$3278:Deux accès à $47FD pour set les bits 4 et 6
$327c:Test du bit zéro sur $47FE (majuscules\minuscules)
$3286:Changement de l'aspect du curseur si minuscules
$3297:Initialisation des attributs utilisés pour l'effacement de l'écran

$329d/cur_home
$32a0:Curseur mis en haut à droite de l'écran
$32a3:Force l'affichage à l'interruption suivante
$32ab:Et attend l'affichage

$32b7/deckeyb/above
Fonction : décode le clavier

$331f:La pile contient, en haut, $33c5, puis AF (qui contient le caractère)

$3349/above
Partial instruction trick en cascade.
Les 6 labels suivants chargent A avec une certaine valeur.
Puis exécutent une série de LD HL avec des valeurs inutiles
Pour finalement arriver sur 'sdchar_pass'
;
Cela agit comme un remapping des caractères qui étaient normalement non affichables.

$3349/sd_a_ff
$334c/sd_a_0d
$334f/sd_a_08
$3352/sd_a_04
$3355/sd_a_1f
$3358/sd_a_03

$335b:$33cd est mis sur la pile pour servir de branchement lors du prochain RET, à la fin de l'émission du caractère.

$331a/sendchar_t2
$3328:A est compris entre 128 et 160. La mise à 0 du bit 7 revient à soustraire 128
$332c:A est inférieur ou égal à 128.
$332e:On vérifie s'il est supérieur à 32
$3334:Saut si on est en train d'utiliser les caractères utilisateurs
$333a:Saut si c'est un caractère graphique
$333c:Arrivé ici si le caractère était dans [128,160[ (ajusté en [0, 32[ ou un caractère redéfini de numéro inférieur strictement à 32.
$332c/sdchar_bl80
$335a/sdchar_pass
$3342:E = A * 3 (A contient le caractère)
$3348:Branchement sur la table de redirection qui commence en $3362

$3362/sdchar_ind/code
Code: $3365
Code: $3368
Code: $336B
Code: $336E
Code: $3371
Code: $3374
Code: $3377
Code: $337A
Code: $337D

Code: $3380
Code: $3383
Code: $3386
Code: $3389
Code: $338C
Code: $338F
Code: $3392
Code: $3395
Code: $3398
Code: $339B

Code: $339E
Code: $33A1
Code: $33A4
Code: $33A7
Code: $33AA
Code: $33AD
Code: $33B0
Code: $33B3
Code: $33B6
Code: $33B9

$33BC/code:Fin de la table d'indirection. Caractère 31.

$33cd/code/above
Cette adresse est forcée dans la pile pour que le RET de l'affichage de caractère passe par là.
Le rafraichissement de l'écran est demandé et la pile et les registres remis en ordre.

$33d4/carreturn/above
Fonction: traitement Carriage Return
Traitement de l'affichage du caractère 13 (et 3)

$33da:Saut si 'x' est différent de 1
$33e1:Saut si 'continuation permitted' est à 0
$33e3
Si le curseur est sur la colonne 1 et 'continuation permitted' est à 1, alors la colonne 0 est mise à $80 (attributs par défaut pour l'EF9345)
Et c'est fini.

$33ed:Le curseur est mis sur la colonne 1 et on enchaîne sur `line_down`
$33fd:Si le scrolling est désactivé, on saute
$341a:Si le scrolling est désactivé, on saute


$3442/col_right/above
Fonction : La position du curseur est avancée de 1 vers la droite
Traitement de l'affichage du caractere 7

$3448:Si le curseur est en position 39, on saute
$344f/line_below
$344b/col_r_end

$3452:On ne fait rien si le curseur est en bas à droite de l'écran.

$33f0/line_down/above
Fonction: amène le curseur une ligne plus bas
Traitement de l'affichage du caractere 10


////////////////// 3400 /////////////////

$340e/line_up/above
Fonction: amène le curseur une ligne plus haut
Traitement de l'affichage du caractere 9

$342b/col_left/above
Fonction : La position du curseur est avancée de 1 vers la gauche
Traitement de l'affichage du caractere 8

$342b:xcursor est suivi de ycursor. Ce qui fait que H contient 'y' et L contient 'x'
$3431:Saut si la colonne du curseur est inférieur strictement à 2

$3438/line_above
$343a:On ne fait rien si la ligne du curseur est à zéro

$3434/col_l_end
$343e:Curseur à la dernière colonne

////////////////// 3300 /////////////////

$3578/peekchar/above
Fonction : récupère le caractère à l'écran aux coordonnées HL dans A
HL est modifié. A contient le caractère. A est comparé à $84.

$359f/clr_scr_btm
Fonction : Efface toutes les lignes à partir de la ligne courante jusqu'en bas de l'écran
Traitement de l'affichage du caractère 31

$35ad/scroll_up/above
Fonction: monte le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

$35b9/scroll_down/above
Fonction: descend le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

$35c5/reset_term/above
La fonction réinitialise les bits 2 et 7 de $4871.
Remet le scrolling (et ligne non entrée sous BASIC (?))
;
Réinitialise quelques valeurs d'affichage

$35cd:$4804 à 0 : pas de redéfinition de caractères
$35d1:$4002 à 0 : couleur d'encre et fond graphique à zero, texte
$35d5:$47FB à 1 : force un affichage
$35d9:$47FC à 0 : équivalent de DISPLAY 10
$35e6/honk
$35f3/jump_ret:Cette adresse est utilisée pour sauter à un RET depuis une table d'indirection.

$35fe/char7f
$35f4/char20


////////////////// 3600 /////////////////

$36a9/sharp_char/code

$36aa/out_str/above
Fonction: Affichage d'une chaîne à l'écran
Entrée: HL pointe sur la chaîne de caractère terminée par un 0

$366c/out_str_prc/above
Fonction: traite la chaîne de caractères à afficher avec extention des variables.

$366c:Positionne hl un caractère avant le début de la chaine (à cause du inc hl de la boucle qui suit)
$3674:Récupération du caractère dans a
$3675:Incrémentation du compteur de caractères affichés
$3677:Si le caractère est 0 (fin de chaîne)
$367a:Si le caractère est $22 (=34, guillemets)

$367f/out_str_2

$367d:Tant que l'on traite des caractères normaux
$3681:Traitement spécifique pour les guillemets
$3670:Sauve la valeur courante de hl (pointe sur ... )

$3aa9/k7write

$3a81/k7sync

$3af3/k7test

$1e00/k7end/code

$3b48/k7read

$38b1/above
Instruction : FRE()
Entrée : (valtyp)

$38b4:DE contient l'adresse de (strend)
$38b8:HL contient l'adresse de la pile
$38bd:Saute si (valtyp) est à 0 (nombre)

$29ea/inst_fre_2
$38ca:HL contient (fretop) et DE contient (stktop)

$3bd0/outdo_impl/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

//------------
$3be1/sendchar_pt
$3c14/resetprt/above:Fonction: Mise à zéro de l'état de l'imprimante
$3c16:Sélectionne l'imprimante pour l'affichage
$3c20:Récupération et mise à zéro du Bit 7 du status de l'imprimante
$3c25:Si le bit était à 0, récupération du numéro de ligne de l'imprimante dans a
$3c28:Permet de mettre à jour les flags de F
$3c29:Appel si le bit 7 du status était 1, ou bien si la ligne de l'imprimante n'est pas 0
$3c31:Clear du picflg sauf le bit 6 (signal de curseur en fin de page)
$3c35:Sélection du terminal comme sortie des caractères
$3c38:Mise à zéro de l'état de l'imprimante.
$3c3c/sendchar_te:Récupération de AF qui contient prtflg
$3c40/cursor_x0/above
Remet le terminal en état. Puis, si le curseur n'était pas en
première colonne, fait un saut à la ligne sur le terminal. Sinon, ressort.

$3c4a/putnulatend/above
Fonction: met un caractère NUL à la fin de la chaîne précédent le pointeur HL actuel, en ignorant les espaces.
À la fin de la fonction, HL contient $4897

$3c4e:Recale le pointeur HL sur le derniere caractère non espace ($20) avant le CR ($0D)
$3c50:HL pointe donc à présent juste après le dernier caractère de la ligne à traiter
$3c52:Place un $0 à la fin de la chaîne
$3c56:Ayant été appelé par jp, ce RET va sortir de la boucle de traitement de basicloop (et se retrouver en $22b1)

$3c57/crdo/above
Fonction : Envoi d'un retour chariot sur la sortie de caractère actuel

$3c5e:Saut si la sortie de caractère se faire sur le terminal
$3c61:Saut si la sortie de caractère n'est pas l'imprimante (donc la k7)

$3c72/crdo_term
$3c7d/break_delay/above
Function : vérifie la séquence BREAK, avec un délai préalable

$3c77/chk_break/above
Vérifie la séquence de BREAK puis continue sur l'instruction STOP.
L'instruction STOP commence par 'ret nz', qui fera donc un RET s'il
n'y a pas eu de BREAK, et qui fera un STOP dans le cas contraire.

$3c7f/break_impl:Est-ce que la touche RUN-STOP est appuyée ?
$3c83:Si non, retour immédiat
$3c84:Est-ce que la touche SHIFT est appuyée ?
$3c88:Si non, retour immédiat
$3c89:Vérification de l'exécution BASIC (flag = 0).
$3c8d:Sinon, retour immédiat.
$3c8e:Met $f2 dans la dernière touche scannée
$3c92:Réinitialisation du drapeau de répétition des touches
$3c96:Réinitialisation du compteur de répétition des touches
$3c9a:Set Carry, pour provoquer la boucle immédiate du BASIC
$3c6e/crdo_k7

$3c63/crdo_prt/above
Fonction : Retour chariot à la ligne suivante sur l'imprimante

$3c6a:Mise à zéro de la colonne de l'imprimante (aucun test de la véracité...)

$3ca2/monitor/above
Fonction: Le Monitor
Entre à chaque nouvelle invite. Sort lorsque la touche CR est appuyée.

$3ca8/monitor_cnt

$3cae:Traitement si inputsel ne désigne pas un clavier (!= 0)

$3cb5/keyloop/above
Fonction : Traitement du moniteur pour une entrée par le clavier

$3cbe:Retour à la boucle de traitement si la touche STOP n'a pas été appuyée
$3cc0:La touche STOP a été appuyée. Carry est à 1.

$3cc1/decodebasic/above
Fonction : décode la ligne en BASIC ?

$3cc7:Remise du caractère dans le buffer sur 7 bits
$3ccb:Comparaison de HL avec $4918
$3ccf:HL est à présent sur?

$3d9a/auto/above
Traitement appelé lorsque le mode AUTO est activé
DE contient l'ancien numéro de ligne (ou le premier en début de AUTO)
HL contient le nouveau numéro de ligne.

$3d9e:Récupération du numéro de ligne
$3d9f:Recherche de la ligne (pointeur dans HL si résultat)
$3da2:Continue par l'affiche d'un espace si la ligne n'a pas été trouvée
$3da7:Sinon, affiche le caractère $a0 pour indiquer qu'il y a déjà du contenu.


$3daa/after_auto
$3daa:Traitement d'un overflow sur AUTO. Si HL est devenu trop grand, on arrête.
$3dad:Préparation de la comparaison avec $fff9 (65529, plus haut numéro de ligne valide)
$3db2:si HL (le numéro de ligne courant) est égal ou supérieur à $fff9, on arrête AUTO
$3db4:Sinon, la nouvelle ligne auto est validée
$3db9/stopauto:Stop le traitement de AUTO

$3dbd/after_auto2

$3dc0/initscreen1
$3de1/decodenext
$3de1:Saute si Carry set. Quand? Le saut incrémente HL puis branche en $3ca8, comme l'instruction suivante.
$3dfb/acquirekeyn4/above
Suite (3) du traitement de l'entrée

$3dff:Si le caractère d'entrée était ACK

$3e02:Test du flag INPUT actif
$3e07/acquirekeyn6

$3e0a/acquirekeyn5

$3e0a:Test de Unit Separator
$3e0c:Si différent, branche

$3e2d/acquirekeyn2/above
Suite (1) du traitement de l'entrée

$3e2d:Saut si la touche appuyée était ENTREE

$3e35:Si on est en basexec == 1


$4000/screen

// Label: $1179, InitEF

// Hooks
$47D0/inthk
$47D3/calhk
$47D6/sonhk
$47D9/plyhk
$47DC/rsthk
$47DF/prthk
$47E2/outhk
$47E5/crdhk
$47E8/inlhk
$47EB/inphk

// Hook vectors
$47EE/nmihk
$47F1/lpnhk
$47F4/dskhk
$47F7/modhk

// Screen communication flags
$47FA/intdiv
$47FB/intact
$47FC/intrat
$47FD/cursor
$47FE/fklock
$47FF/crchar:valeur scannée du clavier la plus récente
$4800/reptim
$4801/repena
$4802/attcar
$4803/attbak
$4804/extenf
$4805/xcursor
$4806/ycursor

// Text Editor
$4807/prelin
$4809/homeln
$480B/retadr:Coordonnées de la prochaine ligne à interpréter
$480D/entstt:programme ($82) ou direct ($80)

// Sound System
$480e/sonsav

// Cassette
$4810/ft:Table de fichier
$4826/low
$4828/high
$482a/handler
$482e/lowlim
$482f/winwid

// BIINIT
$4830/ramlow
// $4833/usrloc
$4836/fdivc
$4845/rndcnt
$4846/rndcnt_1
$4867/rndcnt_22
$486e/lptpos
$486F/prtflg:Selectionne la sortie des caractères (0=Terminal, 1=printer, ff=k7)
$4870/getflg:Entrée des caractères sur clavier (0) ou cassette (255)
$4871/picflg
$4872/cascom
$4873/rawprt
$4874/prtstt:État de l'imprimante
$4875/prtcom
$4876/prtint
$4878/prtxlt

// Text Editor
$487a/contbl
$4884/autoflg:Etat courant de la commande AUTO
$4885/autoline:Ligne courante de la commande AUTO
$4887/autostep:Incrément du mode AUTO
$4889/allflg:Execution de la boucle BASIC (0 to execute BASIC control loop)
$488a/linlen
$488b/clmlst

// Basic
$488c/curlin:Ligne courante du BASIC
$488e/txttab
$4890/frgglg:Messages en anglais (1) ou francais (0)
$4891/kbdtbl:Table de transcription du clavier
$4893/tmpsav
$4894/octsav
$4895/stktop:Addresse de départ (maximale) pour la pile. Initialisée tout en haut de la RAM.

// BINTRP
$4897/bufmin:Zone précédent la zone de tokenisation. Mis dans HL après avoir mis NUL en fin de chaîne à traiter.
$4898/basbuf:Buffer d'entrée pour le BASIC
$4919/basbufend:Fin du buffer
// $4919/endbuf
$491a/dimflg
$491b/valtyp:(0 = numeric, 1=string)
$491c/dores:Drapeau de suppression de la tokenisation
$491d/contxt
$491f/memsiz:Plus haute mémoire disponible (pour le BASIC ?)
$4921/temppt
$4923/tempst
$499b/dsctmp
$49c3/fretop
$47FA:Début de la zone de données graphiques pour la communication avec le EF9345
$49fb/end_vars:Adresse juste après la dernière des variables système.
$49c5/temp3
$49c7/temp8
$49c9/endfor
$49cb/datlin
$49cd/subflg
$49ce/flginp
$49cf/temp
$49d1/ptrfrg
$49d2/temp2
$49d4/oldlin
$49d6/oldtxt
$49d8/vartab
$49da/arytab
$49dc/strend
$49de/datptr
$49ed/prmnam
$49e2/prmval
$49e6/faclo
$49e8/faclo_2
$49e9/fac
$49ea/fac_1
$49eb/fbuffr
$49f8/fmltt1
$49f9/fmltt2


// Generated instructions
$2f3a/inst_end/code
$247a/inst_for/code
$2fe4/inst_next/code
$25f3/inst_data/code
$2760/inst_input/code
$38d5/inst_dim/code
$27a3/inst_read/code
$2610/inst_let/code
$25ba/inst_goto/code
$259a/inst_run/code
$2679/inst_if/code
$2f1e/inst_restore/code
$25a9/inst_gosub/code
$25d6/inst_return/code
$25f5/inst_rem/code
$2f38/inst_stop/code
$265e/inst_on/code
$2694/inst_lprint/code
$2a13/inst_def/code
$2abb/inst_poke/code
$269b/inst_print/code
$2f6f/inst_cont/code
$31a8/inst_list/code
$31a3/inst_llist/code
$2fa0/inst_clear/code
$3058/inst_renum/code
$316e/inst_auto/code
$197e/inst_load/code
$1945/inst_save/code
$1a39/inst_cload/code
$19ed/inst_csave/code
$0fad/inst_call/code
$0e51/inst_init/code
$0c6a/inst_sound/code
$0a75/inst_play/code
$0df8/inst_tx/code
$0e37/inst_gr/code
$0f8e/inst_screen/code
$0f98/inst_display/code
$0fa4/inst_store/code
$0ea8/inst_scroll/code
$0eb1/inst_page/code
$0f52/inst_delim/code
$0ced/inst_sete/code
$0e40/inst_et/code
$0e49/inst_eg/code
$0e83/inst_cursor/code
$47f4/inst_disk/code
$47f7/inst_modem/code
$3dce/inst_new/code
$05a4/inst_sgn/code
$0660/inst_int/code
$05b8/inst_abs/code
$4833/inst_usr/code
$38b1/inst_fre/code
$29fc/inst_lpos/code
$2a01/inst_pos/code
$081d/inst_sqr/code
$090d/inst_rnd/code
$0434/inst_log/code
$0874/inst_exp/code
$097e/inst_cos/code
$0984/inst_sin/code
$0a17/inst_tan/code
$0a2c/inst_atn/code
$2ab4/inst_peek/code
$37fb/inst_len/code
$3636/inst_str/code
$388d/inst_val/code
$380a/inst_asc/code
$0eba/inst_stickx/code
$0ef0/inst_sticky/code
$0f25/inst_action/code
$0f49/inst_key/code
$47f1/inst_lpen/code
$381b/inst_chr/code
$3829/inst_left/code
$3858/inst_right/code
$3861/inst_mid/code
