$0000/romStart/above
Tout commence par un saut à l'adresse $1000. Le choix de l'adresse $1000
semble arbitraire. D'autres machines à base de Z80 font des sauts à d'autres
adresses.
;
Comme les adresses suivantes sont les adresses de branchement des instructions
RST du Z80, le code de démarrage doit se trouver plus loin. D'où le saut.
;
Juste après le saut se trouve, sous forme de chaîne de caractères, le numéro
de version de la ROM.

$0008/chkchr/above
Vérification que le caractère pointé par HL est égal au caractère qui suit exactement
l'instruction RST 8 appelante. Si ce n'est pas le cas, affiche un message d'erreur de syntaxe.

$0008:Enregistre le caractère pointé par HL
$0009:Échange le contenu sur le haut de la pile (l'adresse de retour de RST) et HL
$000a:Compare le contenu de l'adresse de retour et la valeur sauvée dans A
$000b:Incrémente HL afin que l'adresse de retour saute le caractère suivant l'instruction appelante
$000c:Remet la nouvelle adresse de retour en place sur la pile
$000d:Si les deux caractères comparés étaient différent, saute en stx_err_prt ; sinon, passe dans chget


$0010/chget/above
Incrémente HL et met le contenu (HL) dans A.
Si le caractère est supérieur à $3a (: donc juste après '9'), retourne immédiatement, sinon...

$0018/outdo/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

$001B/setext/code
$001B/above
Fonction : redéfinition d'un caractère
Entrée :
Registres modifiés :

$0020/dcompr/above
Fonction : comparaison de HL et DE
Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
En sortie, C sera positionné si HL < DE

$0030/usrrst

$0033/warmgo/above/code
Reset

$0038/irq/above
Fonction : traitement de l'interruption.
Sur la machine, cette interruption est dédiée à l'affichage.
C'est aussi l'EF9345 qui provoque l'interruption.
Mais un vecteur est disponible pour personnaliser les traitements dans l'irq.

$0038:Appel au vecteur d'interruption
$003c:Décrémente le compteur de temporisation d'affichage
$003f:Si le compteur n'est pas tombé à zéro, on sort immédiatement (pas de rafraichissement)
$0045:Remise du compteur à la valeur de référence
$004c:Test puis mise à zéro du bit 0 du flag d'affichage
$0050:Si le flag d'affichage était à zéro, on sort immédiatement (pas de rafraichissement)
$0053:Début du rafraichissement de l'affichage
$0056:Envoi à EF9345 de commandes (à décoder)

$0066/nmi/code
$0066/above
Interruption non masquable.
L'interruption est lancée par l'appui de la séquence Ctrl-Delta (cf. description plus
complète).
Le code saute immédiatement, au hook, qui a pour valeur par défaut un saut en 'test_reset'

$0069/resetlang/code
$0069/above
Met le système en anglais.
La seule entrée semble être la valeur que prend temporairemet nmihk pendant le boot.

$006b:Messages en anglais
$0071:Table de transcription du clavier

$0080/retfun/code
$0083/deint/code
$0086/getbyt/code
$0089/frmnum/code
$008C/beep/code

$008f/play/code
$0a87/playimpl

$0092/putahl/code
$0095/putici/code
$0098/getahl/code
$009B/getici/code
$009E/cls/code
$00A1/cll/code
$00a4/wait/code
$00a7/fndadr/code
$00aa/kbscan/code
$00ad/regst/code
$00b0/stkv/code
$00b3/stkh/code
$00b6/stka/code
$00b9/break/code

$00bc/disp_refrsh/above
Rafraichissement de l'état de l'affichage sur l'EF9345 en fonction
du contenu de la mémoire vidéo en RAM ($4000)

$00bf:Séquence EF9345 à décoder
$00e0/r_line0_lp
$00ec:Boucle sur les 80 octets de la première ligne
$00fd:24 lignes
$00ff/r_line_loop

$0186/skip_dsplay

$0255/ClearScreen/above
Fonction: Efface l'écran
Efface tout d'abord la ligne 0
Puis recopie le contenu mémoire de cette ligne sur le reste de l'écran

$0265/ClearLine/above
Fonction: Efface une ligne
Entrées : A contient un numéro de ligne

$026b:Écriture de $80 à la première position de la ligne
$026d:Récupération des attributs par défaut
$0271:Écriture dans la position suivante des attributs par défaut

$0276
if bit(C,7) == 1 then A = 0 else A = $20
Le bit 7 de C étant à 1 pour un caractère graphique, 0 pour texte

$027d
Boucle pour écrire dans les positions suivantes de la ligne alternativement A et C.
Donc un espace pour le mode texte et 0 pour le mode graphique, suivi des attributs

$0291/xytoscreen/above
Fonction: renvoie l'adresse écran à partir des coordonnées X et Y
Entrées : H contient y, L contient x
Retour : HL contient $4000 + 80y + 2x

$0291:C contient x
$0292:L contient Y
$0297:HL = L * 8 (c'est-à-dire y * 8)
$0299:DE = HL = y * 8
$029c:HL = 32 * y + 8 * y = 40 * y
$029d:HL = 80 * y
$029e:C contient x
$02a1:HL = 80 * y + 2 * x
$02a5:HL = $4000 + 80 * y + 2 * x

$02a7/scankeyb/above
Fonction : scanne le clavier
En commençant par le port $87 jusqu'au port $80
La valeur obtenu est dans A. Le carry flag est à 1 si ?

$02aa:lecture de l'entrée
$02ac:le port envoie $ff lorsqu'il n'y a pas de signal
$02b1:boucle sur les ports

$02e4/predval
$02e4:récupération de la valeur précédente du clavier
$02e7:set carry flag
$02e8:si l'ancienne valeur était zéro, saute à la fin pour retour
$02ea:sinon, on enregistre la nouvelle valeur
$02ed:et le carry flag est enlevé


$02EF/SendSeqEF/above
Fonction: Envoi d'une séquence à l'EF9345
Entrée: HL pointe sur la séquence de données à envoyer.
Le premier octet de la séquence est sa longueur en octet.

$0286/WaitRdyEF/above
Fonction: Attente d'état « prêt » de l'EF9345
'$20' est envoyé sur le port $8F puis on attend que le le bit de
poids fort sur le port $CF soit à 0.

$035c/retfun_4

$05aa/retfun_3

$0a78:Désactivation de l'affichage

$0ca7/snd_emit

$0d7c/SendToEF/above
Fonction: Envoi d'une donnée à l'EF9345
Registre en entrée : DE
Registre modifié : C
D est envoyé sur le port $8F
C est envoyé sur le port $CF

$0d85/setext_impl/above
Fonction: Redéfinition d'un caractère
Registres en entrée : HL et A
Registres modifiés : AF, HL, BC, DE

$0d8d/setext_2
$0dce/setext_lp2
$0dd3/setext_lp3

$0d85:if bit(A, 7) == 0 then B = $C0 else B = $40
$0d8d:Le haut de la pile contient BC
$0d8e:Désactivation de l'affichage
$0d98
Envoi à l'EF9345 de $22,A (avec le bit 7 de A mis à 1) (R2=A)
(A est envoyé à travers E)

$0d9b:Récupération de la valeur de BC dans AF
$0d9c:Remise du contenu de BC sur la pile
$0d9d:Inversion du bit 7 de A, qui est la valeur de B du début de la fonction ($C0 ou $40)
$0da2:Envoi à l'EF9345 de $21,A (A est envoyé à travers E) (R1=A)
$0da9:Envoi à l'EF9345 de $20,$03 (R0=3 -> KRG+Inc)
$0dae:Récupération, à travers E, de la valeur de A en entrée de fonction (avec les trois lignes suivantes)
$0db4:A = (A >> 2) & $1F
$0db7:Envoi à l'EF9345 de $24,A (A est envoyé à travers E) (R4=A)
$0dbd:A = (A initial de la fonction) & $03
$0dbf:Récupération du contenu du BC initial ($C0 ou $40)
$0dc0:A = A | B
$0dc2:Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0dc9:Envoi à l'EF9345 de $20,$34 (R0=OCT Write AP NoInc, écrit R1 en mémoire désigné par R4 R5)
$0dcc:Boucle extérieure, 10 itérations
$0dce:Récupère la valeur suivante de la redéfinition de caractère dans A
$0dd0:Boucle intérieure, 8 itérations
$0dd4:Inverse le contenu de A et C, bit à bit
$0dd8:La ligne de redéfinition lue dans (HL) est à présent inversée dans A
$0ddd:Envoi à l'EF9345 de $29,A (A est envoyé à travers E) (R1=A + Execute)
$0dee:Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0df3:Réactivation de l'affichage

$0df7:Fin de la fonction setext

$0de5
Envoi sur $8F de $25 puis récupération sur $CF d'une valeur dans A (Read R5)
Puis A = A + $04

$0ec3/stkh_impl
$0ef9/stkv_impl

$0eeb/stk_end:Fin des functions stkh et stkv

/////////////////////////////////////////
////////////////// 1000 /////////////////
/////////////////////////////////////////

$1000/Start/above
C'est ici que commence l'intialisation complète de la machine.
La première étape est de recopier le contenu de la ROM dans
l'espace RAM adressable. Adressable ne signifie pas que de la RAM
est effectivement branchée. Cela ne pose pas de problème au
niveau hardware du VG5000 d'envoyer une demande d'écriture.
;
Le contenu de la mémoire est ensuite lu et comparé à la ROM.
Tant que c'est identique, c'est qu'il y a quelque chose de branché
qui répond correctement. Dès que c'est différent, c'est qu'on est
sorti de la zone de la mémoire inscriptible disponible.
;
La dernière adresse valide est stockée dans $4895 et dans SP, le
registre pointeur de pile (Stack Pointer)
;
On remarquera que si une ROM répond avec un contenu identique à
la ROM à une adresse multiple de 16ko, l'initialisation va
penser que c'est de la RAM accessible.

$1000
Démarrage complet de la machine.
Vérifier pourquoi c'est appelé depuis $2282

$100a
Copie de la ROM sur toute la mémoire adressable
Equivalent C-style de : memcpy($4000, $0000, $C000)

$100c:À la fin de LDIR, HL == $C000, DE == $0000, BC == $0000
$100e:À présent, HL == $4000, DE == $0000, BC == $C000
$1010:Début de la comparaison octet par octet de la mémoire
$1015:Si le contenu de (HL) et (DE) est différent, on saute en $101B
$1017
Si le contenu de (HL) et (DE) est identique
et que BC est > 0, on loop

$101a/above
L'instruction partielle suivante ne sert à rien d'autre qu'à gagner un peu
d'espace lorsque BC == 0 et que la boucle est terminée.
Le contenu de A est écrasé un peu plus loin.

$101b
HL est décrémenté pour retrouver la dernière addresse testée (CPI augmente HL).
HL contient donc la première adresse invalide de l'espace mémoire en écriture.
Cette adresse est mise dans SP et stockée en $4895

$1020/above
La seconde étape de l'initialisation consiste à remplir les vecteurs
utilisateur par des instructions spécifiques. Ces vecteurs, situés
en RAM, permettent d'intervenir lors de certaines opérations avec
du code écrit par l'utilisateur et donc de modifier le comportement
du système.

$1020
Les adresses $47D0 à $47EE vont ensuite est remplies par des RET ($C9).
Equivalent C-style de : memset($47D0, $1E, $C9)

$1048:L'adresse $47EE reçoit un JP $0069.

$104b/above
La troisième phase initialise le processeur graphique EF9345. Pour commencer,
une séquence est envoyée au périphérique, puis quelques variables en RAM sont
mises initialisées.
;
Attention, la valeur de IX doit rester constante. Le système de cette ROM
considère que IX est en tout temps égal à $47FA et référence certaines
variables par index par rapport à IX.
;
La séquence est
 $28,$81 -> Écriture de quelque chose dans le TGS
 $29,$00 -> TGS = 0 (625 lignes, non entrelacé, no-input-resync, output VSync+HSync, Service Row = 0, 40 Char
 $20,$82,$29,$6e -> MAT = $6e (Marge = B+G, Insert Marge, Curseur plein/flash, Curseur affiché, simple hauteur
 $20,$83,$29,$f7 -> PAT = $f7 (Ligne 0 'ON', Bulk haut et bas activé, pas de conceal, Insert mode : Active Area, Flash ON, Format court pour le 40 Char
 $20,$84,$29,$13 -> DOR = $13 (Block G0=3, Block G1=1<<1, Block Q=0<<3)
 $20,$87,$29,$08 -> ROR = $08 (Z=0, Y=8)
 $26,$08,$27,$00,$28,$02 -> R6=$08, R7=$00, KRG sans incrémentation avec MP=$0800 (data R1, R2 = $08, ??)
;
Envoyés par pairs sur les ports $8f, $cf

$104b:IX prend la valeur $47FA qui est la base de la zone de données graphiques.

$104F
-> $1179 est la zone mémoire contenant la séquence à envoyer au EF9345.
HL pointe sur la taille de la séquence à envoyer au EF9345.

$1055:Initialisation de la variable $47FA : compteur d'interruptions à 5
$1059:Initialisation de la variable $47FB : besoin de rafraichissement à faux
$105d:Initialisation de la variable $47FA : utilisation des majuscules
$1063/above:Les interruptions sont réactivées pour la suite de l'initialisation.
$1067:Numéro de la première ligne du BASIC ?
$106a:Couleur du pourtour et aspect du curseur
$107a:Copie les valeurs initiales des différentes variables du système en RAM
$107d:Envoi 0 sur le port $EF, censé être non utilisé
$107d:Envoi 0 sur le port $AF, pour le son-k7
$1084:Modification de l'adresse du hook "nmihk"
$1093/above:Calcul des bornes de pile, memsize et place disponible
$1096:hl <- sp - 2 (sp == (stktop))
$109b:hl < $03e8 ? (comment serait-ce possible ?)
$109e:de <- $ffce (-50)
$10a5:Calcul final du haut de la pile comme étant (memsize) - 50
$10ab:Récupération du haut de la pile
$10b1:hl <- (stktop) - 17
$10ba
hl = hl - de, soit ((stktop) - 17 - end_vars)
Autrement dit, la taille disponible entre la fin des variables internes et la pile -17.

$10bb:Cette taille disponible est poussée dans la pile.
$10bc/above:Affichage du texte de démarrage. VG5000 + numéro de version
$10bc:Texte en double hauteur, double largeur

$1118/test_reset/above
Fonction : appelé par le vecteur nmihook ($47ee) qui par défaut est un jp $1118.
Teste si CTRL est appuyé et si oui, effectue un reset.
Plus exactement, pendant le boot, le vecteur est à JP $0069, puis à la fin du boot JP $1118

$1122/reset/above
Fonction: Effectue le reset à chaud

$1148/vg5000_txt
$1163/version_txt
$1179/InitEfSeq:Séquence d'intialisation de l'EF9345 au démarrage.
$1194/InitValues
$1202/AfterInit:Le mapping français ?
$12b9/keybeng

$1d97/sendchar_k7


////////////////////


/////////////////////////////////////////
////////////////// 2000 /////////////////
/////////////////////////////////////////

$2000/instructions
$209d/prekeywords
$209e/keywords
$21fd/keywstop
$21fe/mysteryatnow

$2214/ok_str
$2219/ok_str_next
$2238/stx_err_prt


$2293:Affiche Ok!

$2250/SomeVector/code:Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.

$228d/init_next/above
Suite de l'initialisation

$2299/monitorloop
$2299:Ligne courante du BASIC à -1
$22a3:Saute si hors du mode AUTO
$22a5:Ligne courante du mode AUTO dans HL
$22ae/stoploop/above
Boucle de traitement du BASIC

$22b3/above
Lorsqu'on arrive ici, CR a été appuyée.
HL pointe sur l'adresse précédente le buffer en entrée, qui se termine par 0.
(Ce buffer est tout le temps basbuf en entrée normale ?)

$22b1:Lorsque basic loop sort avec Carry (touche STOP), on boucle immédiatement.
$22b3:Acquisition d'un nouveau caractère depuis HL dans A
$22b6:Si le caractère était zéro, le traitement est terminé

$22bd:Si le flag d'exécution BASIC est à 1, branchement en 0 pour un reset de la machine.

$22c7:En fin de tokenisation, A == 0, donc B prend 0 aussi
$22c9:Récupération du AF de $22b8
$22ca:Quand est-ce que le Carry est set ?

$22d3:Incrément du mode AUTO. DE contenait la ligne courante, HL contient la ligne suivante.

$236b/tokenisation/above
Fonction : effectue la tokenisation du buffer d'entrée

$236c:Activation ou désactivation de la tokenisation (à vérifier)
$2374/analyze
$2374:Récupération dans A du caractère à traiter
$2377:Est-ce un espace ?
$237a:B contient le caractère aussi
$237d:Sont-ce des guillemets ?
$2381:Est-ce NUL ?
$2387:Préparation du test de flag de tokenisation
$2388:A est à nouveau le caractère à l'étude
$2389:Si le flag de tokenisation est vrai
$2390:Est-ce que le caractère est '?' ? A est préchargé avec $94 dans ce cas.
$2393:A est à nouveau le caractère à l'étude
$2398:Est-ce DLE (Data Link Escape) ? A est préchargé avec $AF dans ce cas.
$239b:A est à nouveau le caractère à l'étude
$239e:Est-ce inférieur à '0' ?
$23a2:Est-ce inférieur à '<' ?

$23a5/specialchr
$23a6:DE contient le début du buffer des mots clés du BASIC -1 (car le traitement commence par augmenter le pointeur)
$23aa:BC contient $244b
$23ad:BC est sauvé sur la pile, ce qui provoquera la sortie à cette adresse si le token n'est pas trouvé
$23ae:B contient $7F et sera incrémenté avec chaque token étudié. Le premier token a donc pour numéro $80
$23b0:A est à nouveau le caractère à l'étude
$23b3:Est-ce inférieur à 'a' ?
$23b7:Est-ce supérieur à 'z' ?
$23b9:Passage en majuscule
$23bb:Mise dans le buffer de la lettre passée en majuscule
$23bc/notlowerchr
$23bc:C contient le caractère à traiter
$23bd:HL pointe sur le buffer de keywords
$23be/nextkeyword
$23c0:Boucle jusqu'au premier caractère avec un bit de poids fort à 1 (cela indique le début d'un mot)
$23c3:Augmenter l'index de mot-clé
$23c5:A contient le premier caractère de la table des mots clé, sur 7 bits
$23c7:Si égal à NUL, alors la fin du buffer est atteinte, on sort
$23c9:Si le caractère à traiter et celui du mot-clé sont différent, on cherche le mot clé suivant
$23cb:Le pointeur sur le mot clé à traité est mis dans DE. HL contient à nouveau l'adresse du buffer en traitement.
$23cd/strcmpkw
$23d0:Puisqu'on atteint un nouveau marqueur de mot clé, c'est que le match a été fait correctement.
$23d3:C contient le caractère courant dans le buffer des mots clé
$23d4:A contient le caractère du buffer d'entrée à traiter

$23e5:Passage en majuscule (voir $23b9) ?

$23ed/foundkeyw

$244b/tokennotfound/above
Arrivée ici lorsque la tokenisation échoue

$244b:HL pointe à nouveau sur le buffer en entrée
$244c:Récupération du caractère dans A
$244d:Nettoyage de la pile
$244e:DE pointe sur la partie tokenizée ?

$244f/ifspc

$2450:Recopie du caractère actuel (ou du token ?) dans la partie tokenisée

$2457:Avec la soustraction précédente, cela fait que l'on compare le caractère à $83
$245e:Avec la soustraction précédente, cela fait que l'on compare le caractère à $8E

$246b/ifquote
$2471/ifnul/above
Arrive ici lorsque la chaîne a été complètement parsée.

$2471:HL est placé juste avant le buffer de traitement
$2474:DE pointe sur la fin du buffer tokenizé. Comme A contient 0, le buffer est terminé par trois 0.
$2479:Fin de la fonction de tokenisation

$24ea/playret/code
$247A/inst_for/code

//-----------------
$2509/exectokens
$2509:Récupère le première token du buffer
$250e:Retourne en $24ea si le caractère du buffer est NUL (quand ?)
$250f:Les tokens sont tous supérieurs à $80
$2511:Si la soustraction a provoqué un Carry, alors ce n'était pas un token
$2516:Si le token est supérieur à $32 (les 50 premiers token sont des instructions, suivent les fonctions dont les 16 premieres n'ont pas d'adresse)
$2519:Le token est multiplié par 2
$251a:puis stocké dans C
$251b:B est à 0, donc BC contient le numéro de token * 2
$251d:Sauvegarde de HL dans DE
$251e:HL est chargé avec la table des adresses d'instructions
$2521:HL contient le pointeur adresse d'execution de l'instruction tokenisée
$2524:BC contient l'adresse d'execution de l'instruction tokenisée
$2525:L'adresse est mise sur la pile
$2526:Récupération de l'adresse en cours du buffer tokenisé (cf. $251d)


$2527/skipch/above
Fonction: recupère le caractère suivant du pointeur HL
Retourne immédiatement si le caractère est superieur à $3a,
sinon, fallthrough dans chget_2
La fonction est à la suite du décodage de token, ce qui permet d'avancer le pointeur directement.


$252c/chget_2/above
Suite du traitement de chget.
A contient le caractère lu dans le buffer, qui est inférieur ou égal à $3a

$252e:Se positionne sur le premier caractère qui n'est pas un espace et est inférieur ou égal à '9'
$2530:Si le caractère est supérieur à ' ', saut plus loin
$2534:Saute si le caractère est entre 0F et 1F (une partie des caractères de contrôle)
$2538:Saute si le caractère est inférieur à 0D (une autre partie des caractères de contrôle, dont 0)
$253a:Reste les cas 0D et 0E ?

$2542/chget_3
$2543:Ce RET branchera sur l'instruction à exécuter si un token a été décodé. Si appel depuis RST, retourne normalement avec le flag Z si A était à NUL.

$2544/chget_4
$2544:Compare avec '0'
$2546:Inverse la retenue. Donc le flag C sera mis si le caractère est supérieur ou égal à '0' (donc un chiffre).
$2548:Manipulation de A pour mettre le flags en fonction de la valeur du caractère (comment exactement ?)

$256c/shiftout
$2570:Si le caractère actuel du buffer n'est pas $OE (shift out), branchement
$257d:Traitement de quel cas?

$2610/nottoken/above
Appelé lorsque le buffer tokenisé ne contenait pas un token.
(mais pas que... appelé par FOR aussi. Traitement général des erreurs ?)

$29f0/retfun_2:B contient la valeur de la fonction, A contient 0, quand appelé depuis retfun_impl
$29f6:Place 0 dans la globale valtyp, ce qui signifie que la valeur est numérique

$2a0f/retfun_impl
$2a0f/above
Function : met en place la valeur de retour d'une fonction
Prerequis : valeur dans A (?)

$2ae4:Saute en fin de fonction si aucun caractère n'a été entré

$2ad4/acquirekey/above
Fonction: décode une touche du clavier et l'affiche à l'écran à la position du curseur.
Attends un refresh (HALT) puis scrute le clavier.
Si rien n'a été appuyé, sort immédiatement.
Sinon, traitement.

$2adf:Attente d'une interruption

$2ae8:Son lorsqu'un caractère est reçu
$2afb:Bit pour indiquer que la ligne est entrée en BASIC
$2aff:Si le bit de signe était 1 dans le caractère lu
$2b02:Comparaison de la touche avec ENTREE
$2b07/acquirekeyn3/above
Suite (2) du traitement de l'entrée

$2b2d/exitacquire
$2b2e/endacquirek
$2b32/bufferstart/above
Fonction : lorsque le bit 1 de $4871 est à 0, arrive ici pour analyse
À l'air de se positionner sur le premier caractère interessant à décoder


$2b32:Coordoonées de la ligne BASIC à décoder
$2b35:A contient la ligne
$2b36:Comparaison avec 24 (le nombre de lignes)
$2b3e:Lecture du caractère en colonne 0 de la ligne suivante
$2b44/ifabove24
$2b45:Comparaison de la colonne avec 40 (colonne max)
$2b4d:Comparaison de la colonne avec 40 (colonne max)
$2b52/ifbelow40
$2b53:Stockage des nouvelles coordonnées (ajustées comment?)
$2b5a:B contient le caractère aux coordonnées
$2b5b:DE contient les coordoonées
$2b5d:A contient le caractère aux coordonnées
$2b5e:Not carry de quoi ?
$2b62:Si ce n'est pas un espace
$2b75/ifabove40
$2bac/specialchars

$2be0/ifcr:Récupération des coordonnées du curseur

$2be9:Comparaison à $80, la caractère de début de ligne

$2be3:Décrémentation de X
$2be4:Sauvegarde des coordonnées modifiées du curseur
$2be8:Récupération des coordonnées


$2b23/acquirekeyn7/above
Suite (6) du traitement de l'entrée


$2b24:Force un affichage
$2b2d:A est effacée en traitement normal de touche (et déjà 0 si pas de touche entrée)
$2b2e:Nettoyage de fin de fonction
$2c14:Peek du caractère en colonne 0
$2c1e:Boucle sur la remontée des Y
$2c18:Test sur $84, qui est le marquage de continuité des lignes
$2c20/notcontinous:Coordonnées placées en début de la première ligne
$2c23:Test de INPUT activé
$2c2c:Recupération des coordonnées de début d'entrée
$2c33:DE contient les cooronnees de début d'entrée. HL l'adresse mémoire
$2c35:Comparaison de X avec la colonne 40
$2c4b/ifinput
$2c4e:Enregistrement du premier caractère de la ligne ($80 en mode direct)
$2c56:Set du flag pour "ligne entrée en BASIC"
$2c5d:Placement des coordonnées sur le caractère en colonne précédente (donc 0?)
$2c60/screenstart
$2c63/iftab
$2c89/iflinef
$2caf/ifformf

$2bf1:Recheche des quels caractères?
$2bf3:Boucle sur la recherche
$2bf5/linestart

$2efe/resetstack/above
Fonction : remise à zéro de la pile et effacement de l'interprétation en cours. Réinitialisation de l'imprimante.
Retour : HL contient le code de l'instruction en cours ?
;
Un meilleur nom: interpreter_reset ?

$2efe:Récupération de l'adresse de retour
$2eff:Réinitialisation de la pile (SP) à la dernière addresse RAM valide
$2f06:Le pointeur sur la zone temporaire de descripteur est initialisé
$2f0f:Mise à zéro de `oldtxt`
$2f12:Mise à zéro du buffer `subflg` (utilisé pour FOR)
$2f15:Mise à zéro du buffer `prmnam` (nom du paramètre actif)
$2f18:Met 0 sur la pile
$2f19:Remet l'adresse de retour sur la pile avant le RET
$2f1a:HL contient la valeur de `temp` (code d'une instruction)

/////////////////////////////////////////
////////////////// 3000 /////////////////
/////////////////////////////////////////

////////////////// 3200 /////////////////
$3278/initscreen/above
Réinitialisation du curseur, d'attributs
Redéfinition de deux caractères: $20 et $7F
Efface l'écran, remise en colonne 1

$3292/initscreen2
$3278:Deux accès à $47FD pour set les bits 4 et 6
$327c:Test du bit zéro sur $47FE (majuscules\minuscules)
$3286:Changement de l'aspect du curseur si minuscules
$3297:Initialisation des attributs utilisés pour l'effacement de l'écran

$329d/cur_home
$32a0:Curseur mis en haut à droite de l'écran
$32a3:Force l'affichage à l'interruption suivante
$32ab:Et attend l'affichage

$32b7/deckeyb/above
Fonction : décode le clavier

$331f:La pile contient, en haut, $33c5, puis AF (qui contient le caractère)

$3349/above
Partial instruction trick en cascade.
Les 6 labels suivants chargent A avec une certaine valeur.
Puis exécutent une série de LD HL avec des valeurs inutiles
Pour finalement arriver sur 'sdchar_pass'
;
Cela agit comme un remapping des caractères qui étaient normalement non affichables.

$3349/sd_a_ff
$334c/sd_a_0d
$334f/sd_a_08
$3352/sd_a_04
$3355/sd_a_1f
$3358/sd_a_03

$335b:$33cd est mis sur la pile pour servir de branchement lors du prochain RET, à la fin de l'émission du caractère.

$331a/sendchar_t2
$3328:A est compris entre 128 et 160. La mise à 0 du bit 7 revient à soustraire 128
$332c:A est inférieur ou égal à 128.
$332e:On vérifie s'il est supérieur à 32
$3334:Saut si on est en train d'utiliser les caractères utilisateurs
$333a:Saut si c'est un caractère graphique
$333c:Arrivé ici si le caractère était dans [128,160[ (ajusté en [0, 32[ ou un caractère redéfini de numéro inférieur strictement à 32.
$332c/sdchar_bl80
$335a/sdchar_pass
$3342:E = A * 3 (A contient le caractère)
$3348:Branchement sur la table de redirection qui commence en $3362

$3362/sdchar_ind/code
Code: $3365
Code: $3368
Code: $336B
Code: $336E
Code: $3371
Code: $3374
Code: $3377
Code: $337A
Code: $337D

Code: $3380
Code: $3383
Code: $3386
Code: $3389
Code: $338C
Code: $338F
Code: $3392
Code: $3395
Code: $3398
Code: $339B

Code: $339E
Code: $33A1
Code: $33A4
Code: $33A7
Code: $33AA
Code: $33AD
Code: $33B0
Code: $33B3
Code: $33B6
Code: $33B9

$33BC/code:Fin de la table d'indirection. Caractère 31.

$33cd/code/above
Cette adresse est forcée dans la pile pour que le RET de l'affichage de caractère passe par là.
Le rafraichissement de l'écran est demandé et la pile et les registres remis en ordre.

$33d4/carreturn/above
Fonction: traitement Carriage Return
Traitement de l'affichage du caractère 13 (et 3)

$33da:Saut si 'x' est différent de 1
$33e1:Saut si 'continuation permitted' est à 0
$33e3
Si le curseur est sur la colonne 1 et 'continuation permitted' est à 1, alors la colonne 0 est mise à $80 (attributs par défaut pour l'EF9345)
Et c'est fini.

$33ed:Le curseur est mis sur la colonne 1 et on enchaîne sur `line_down`
$33fd:Si le scrolling est désactivé, on saute
$341a:Si le scrolling est désactivé, on saute


$3442/col_right/above
Fonction : La position du curseur est avancée de 1 vers la droite
Traitement de l'affichage du caractere 7

$3448:Si le curseur est en position 39, on saute
$344f/line_below
$344b/col_r_end

$3452:On ne fait rien si le curseur est en bas à droite de l'écran.

$33f0/line_down/above
Fonction: amène le curseur une ligne plus bas
Traitement de l'affichage du caractere 10


////////////////// 3400 /////////////////

$340e/line_up/above
Fonction: amène le curseur une ligne plus haut
Traitement de l'affichage du caractere 9

$342b/col_left/above
Fonction : La position du curseur est avancée de 1 vers la gauche
Traitement de l'affichage du caractere 8

$342b:xcursor est suivi de ycursor. Ce qui fait que H contient 'y' et L contient 'x'
$3431:Saut si la colonne du curseur est inférieur strictement à 2

$3438/line_above
$343a:On ne fait rien si la ligne du curseur est à zéro

$3434/col_l_end
$343e:Curseur à la dernière colonne

////////////////// 3300 /////////////////

$3578/peekchar/above
Fonction : récupère le caractère à l'écran aux coordonnées HL dans A
HL est modifié. A contient le caractère. A est comparé à $84.

$359f/clr_scr_btm
Fonction : Efface toutes les lignes à partir de la ligne courante jusqu'en bas de l'écran
Traitement de l'affichage du caractère 31

$35ad/scroll_up/above
Fonction: monte le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

$35b9/scroll_down/above
Fonction: descend le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

$35c5/resetcursor/above
La fonction réinitialise les bits 2 et 7 de $4871.
A priori : coupe le scrolling et ligne non entrée sous BASIC
;
Puis réinitialise quelques valeurs d'affichage

$35cd:$4804 à 0 : pas de redéfinition de caractères
$35d1:$4002 à 0 : couleur d'encre et fond graphique à zero, texte
$35d5:$47FB à 1 : force un affichage
$35d9:$47FC à 0 : équivalent de DISPLAY 10
$35e6/honk
$35f3/jump_ret:Cette adresse est utilisée pour sauter à un RET depuis une table d'indirection.

$35fe/char7f
$35f4/char20


////////////////// 3600 /////////////////

$36aa/out_str/above
Fonction: Affichage d'une chaîne à l'écran
Entrée: HL pointe sur la chaîne de caractère terminée par un 0

$366c/out_str_prc/above
Fonction: traite la chaîne de caractères à afficher avec extention des variables.

$366c:Positionne hl un caractère avant le début de la chaine (à cause du inc hl de la boucle qui suit)
$3674:Récupération du caractère dans a
$3675:Incrémentation du compteur de caractères affichés
$3677:Si le caractère est 0 (fin de chaîne)
$367a:Si le caractère est $22 (=34, guillemets)

$367f/out_str_2

$367d:Tant que l'on traite des caractères normaux
$3681:Traitement spécifique pour les guillemets
$3670:Sauve la valeur courante de hl (pointe sur ... )

$3bd0/outdo_impl/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

//------------
$3be1/sendchar_pt
$3c14/resetprt/above:Fonction: Mise à zéro de l'état de l'imprimante
$3c16:Sélectionne l'imprimante pour l'affichage
$3c20:Récupération et mise à zéro du Bit 7 du status de l'imprimante
$3c25:Si le bit était à 0, récupération du numéro de ligne de l'imprimante dans a
$3c28:Permet de mettre à jour les flags de F
$3c29:Appel si le bit 7 du status était 1, ou bien si la ligne de l'imprimante n'est pas 0
$3c31:Clear du picflg sauf le bit 6 (signal de curseur en fin de page)
$3c35:Sélection du terminal comme sortie des caractères
$3c38:Mise à zéro de l'état de l'imprimante.
$3c3c/sendchar_te:Récupération de AF qui contient prtflg
$3c4a/putnulatend/above
Fonction: met un caractère NUL à la fin de la chaîne précédent le pointeur HL actuel, en ignorant les espaces.
À la fin de la fonction, HL contient $4897

$3c4e:Recale le pointeur HL sur le derniere caractère non espace ($20) avant le CR ($0D)
$3c50:HL pointe donc à présent juste après le dernier caractère de la ligne à traiter
$3c52:Place un $0 à la fin de la chaîne
$3c56:Ayant été appelé par jp, ce RET va sortir de la boucle de traitement de basicloop (et se retrouver en $22b1)

$3c57/crdo/above
Fonction : Envoi d'un retour chariot sur la sortie de caractère actuel

$3c5e:Saut si la sortie de caractère se faire sur le terminal
$3c61:Saut si la sortie de caractère n'est pas l'imprimante (donc la k7)

$3c72/crdo_term
$3c7f/specialkey:Est-ce que la touche RUN-STOP est appuyée ?
$3c84:Est-ce que la touche SHIFT est appuyée ?
$3c89:Est-ce que l'on basexec est à 0 ? (ce qui signifie quoi ?)
$3c8d:Dans ces trois conditions, traitement spécifique.
$3c8e:$f2 dans "Scrutation clavier"
$3c92:Réinitialisation du drapeau de répétition des touches
$3c96:Réinitialisation du compteur de répétition des touches
$3c9a:Set Carry, pour provoquer la boucle immédiate du BASIC
$3c6e/crdo_k7

$3c63/crdo_prt/above
Fonction : Retour chariot à la ligne suivante sur l'imprimante

$3c6a:Mise à zéro de la colonne de l'imprimante (aucun test de la véracité...)

$3ca2/BasicLoop/above
Fonction: Interpréteur Basic
Entre à chaque nouvelle invite. Sort lorsque la touche CR est appuyée.

$3ca8/basloopcnt

$3cae:Traitement si inputsel ne désigne pas un clavier (!= 0)

$3cb5/keyloop/above
Fonction : Traitement du moniteur pour une entrée par le clavier

$3cbe:Retour à la boucle de traitement si la touche STOP n'a pas été appuyée
$3cc0:La touche STOP a été appuyée. Carry est à 1.

$3cc1/decodebasic/above
Fonction : décode la ligne en BASIC ?

$3cc7:Remise du caractère dans le buffer sur 7 bits
$3ccb:Comparaison de HL avec $4918
$3ccf:HL est à présent sur?

$3d9a/auto/above
Traitement appelé lorsque le mode AUTO est activé

$3daa:Traitement d'un overflow sur AUTO ?
$3db9/stopauto:Stop le traitement de AUTO

$3dc0/initscreen1
$3de1/decodenext
$3de1:Saute si Carry set. Quand? Le saut incrémente HL puis branche en $3ca8, comme l'instruction suivante.
$3dfb/acquirekeyn4/above
Suite (3) du traitement de l'entrée

$3dff:Si le caractère d'entrée était ACK

$3e02:Test du flag INPUT actif
$3e07/acquirekeyn6

$3e0a/acquirekeyn5

$3e0a:Test de Unit Separator
$3e0c:Si différent, branche

$3e2d/acquirekeyn2/above
Suite (1) du traitement de l'entrée

$3e35:Si on est en basexec == 1


$4000/screen

// Label: $1179, InitEF

// Hooks
$47D0/inthk
$47D3/calhk
$47D6/sonhk
$47D9/plyhk
$47DC/rsthk
$47DF/prthk
$47E2/outhk
$47E5/crdhk
$47E8/inlhk
$47EB/inphk

// Hook vectors
$47EE/nmihk
$47F1/lpnhk
$47F4/dskhk
$47F7/modhk

// Screen communication flags
$47FA/intdiv
$47FB/intact
$47FC/intrat
$47FD/cursor
$47FE/fklock
$47FF/crchar:valeur scannée du clavier la plus récente
$4800/reptim
$4801/repena
$4802/attcar
$4803/attbak
$4804/extenf
$4805/xcursor
$4806/ycursor

// Text Editor
$4807/prelin
$4809/homeln
$480B/retadr:Coordonnées de la prochaine ligne à interpréter
$480D/entstt:programme ($82) ou direct ($80)

// Sound System
$480e/sonsav

// Cassette
$4810/ft:Table de fichier
$4826/low
$4828/high
$482a/handler
$482e/lowlim
$482f/winwid

// BIINIT
$4830/ramlow
// $4833/usrloc
$4836/fdivc
$4845/rndcnt
$486e/lptpos
$486F/prtflg:Selectionne la sortie des caractères (0=Terminal, 1=printer, ff=k7)
$4870/getflg:Entrée des caractères sur clavier (0) ou cassette (255)
$4871/picflg
$4872/cascom
$4873/rawprt
$4874/prtstt:État de l'imprimante
$4875/prtcom
$4876/prtint
$4878/prtxlt

// Text Editor
$487a/contbl
$4884/autoflg:Etat courant de la commande AUTO
$4885/autoline:Ligne courante de la commande AUTO
$4887/autostep:Incrément du mode AUTO
$4889/allflg:Execution de la boucle BASIC (0 to execute BASIC control loop)
$488a/linlen
$488b/clmlst

// Basic
$488c/curlin:Ligne courante du BASIC
$488e/txttab
$4890/frgglg:Messages en anglais (1) ou francais (0)
$4891/kbdtbl:Table de transcription du clavier
$4893/tmpsav
$4894/octsav
$4895/stktop:Addresse de départ (maximale) pour la pile. Initialisée tout en haut de la RAM.

// BINTRP
$4897/bufmin:Zone précédent la zone de tokenisation. Mis dans HL après avoir mis NUL en fin de chaîne à traiter.
$4898/basbuf:Buffer d'entrée pour le BASIC
$4919/basbufend:Fin du buffer
// $4919/endbuf
$491a/dimflg
$491b/valtyp:(0 = numeric, 1=string)
$491c/dores:Drapeau de suppression de la tokenisation
$491d/contxt
$491f/memsiz:Plus haute mémoire disponible (pour le BASIC ?)
$4921/temppt
$4923/tempst
$499b/dsctmp
$49c3/fretop
$47FA:Début de la zone de données graphiques pour la communication avec le EF9345
$49fb/end_vars:Adresse juste après la dernière des variables système.
$49c5/temp3
$49c7/temp8
$49c9/endfor
$49cb/datlin
$49cd/subflg
$49ce/flginp
$49cf/temp
$49d1/ptrfrg
$49d2/temp2
$49d4/oldlin
$49d6/oldtxt
$49d8/vartab
$49da/arytab
$49dc/strend
$49de/datptr
$49ed/prmnam
$49e2/prmval
$49e6/faclo
$49e9/fac
$49eb/fbuffr
$49f8/fmltt1
$49f9/fmltt2


// Generated instructions
$2f3a/inst_end/code
$247a/inst_for/code
$2fe4/inst_next/code
$25f3/inst_data/code
$2760/inst_input/code
$38d5/inst_dim/code
$27a3/inst_read/code
$2610/inst_let/code
$25ba/inst_goto/code
$259a/inst_run/code
$2679/inst_if/code
$2f1e/inst_restore/code
$25a9/inst_gosub/code
$25d6/inst_return/code
$25f5/inst_rem/code
$2f38/inst_stop/code
$265e/inst_on/code
$2694/inst_lprint/code
$2a13/inst_def/code
$2abb/inst_poke/code
$269b/inst_print/code
$2f6f/inst_cont/code
$31a8/inst_list/code
$31a3/inst_llist/code
$2fa0/inst_clear/code
$3058/inst_renum/code
$316e/inst_auto/code
$197e/inst_load/code
$1945/inst_save/code
$1a39/inst_cload/code
$19ed/inst_csave/code
$0fad/inst_call/code
$0e51/inst_init/code
$0c6a/inst_sound/code
$0a75/inst_play/code
$0df8/inst_tx/code
$0e37/inst_gr/code
$0f8e/inst_screen/code
$0f98/inst_display/code
$0fa4/inst_store/code
$0ea8/inst_scroll/code
$0eb1/inst_page/code
$0f52/inst_delim/code
$0ced/inst_sete/code
$0e40/inst_et/code
$0e49/inst_eg/code
$0e83/inst_cursor/code
$47f4/inst_disk/code
$47f7/inst_modem/code
$3dce/inst_new/code
$05a4/inst_sgn/code
$0660/inst_int/code
$05b8/inst_abs/code
$4833/inst_usr/code
$38b1/inst_fre/code
$29fc/inst_lpos/code
$2a01/inst_pos/code
$081d/inst_sqr/code
$090d/inst_rnd/code
$0434/inst_log/code
$0874/inst_exp/code
$097e/inst_cos/code
$0984/inst_sin/code
$0a17/inst_tan/code
$0a2c/inst_atn/code
$2ab4/inst_peek/code
$37fb/inst_len/code
$3636/inst_str/code
$388d/inst_val/code
$380a/inst_asc/code
$0eba/inst_stickx/code
$0ef0/inst_sticky/code
$0f25/inst_action/code
$0f49/inst_key/code
$47f1/inst_lpen/code
$381b/inst_chr/code
$3829/inst_left/code
$3858/inst_right/code
$3861/inst_mid/code
