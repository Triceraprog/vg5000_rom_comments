Label: $0000, romStart
Comment: $0000/above
Tout commence par un saut à l'adresse $1000. Le choix de l'adresse $1000
semble arbitraire. D'autres machines à base de Z80 font des sauts à d'autres
adresses.
;
Comme les adresses suivantes sont les adresses de branchement des instructions
RST du Z80, le code de démarrage doit se trouver plus loin. D'où le saut.
;
Juste après le saut se trouve, sous forme de chaîne de caractères, le numéro
de version de la ROM.

Label: $02EF, SendSeqEF
Comment: $02EF/above
Envoi d'une séquence à l'EF9345
Entrée: HL pointe sur la séquence de données à envoyer.
Le premier octet de la séquence est sa longueur en octet.

Label: $0286, WaitRdyEF
Comment: $0286/above
Attente d'état « prêt » de l'EF9345
$20 est envoyé sur le port $8F puis on attend que le le bit de
poids fort sur le port $CF soit à 0.

Label: $1000, Start
Comment: $1000/above
C'est ici que commence l'intialisation complète de la machine.
La première étape est de recopier le contenu de la ROM dans
l'espace RAM adressable. Adressable ne signifie pas que de la RAM
est effectivement branchée. Cela ne pose pas de problème au
niveau hardware du VG5000 d'envoyer une demande d'écriture.
;
Le contenu de la mémoire est ensuite lu et comparé à la ROM.
Tant que c'est identique, c'est qu'il y a quelque chose de branché
qui répond correctement. Dès que c'est différent, c'est qu'on est
sorti de la zone de la mémoire inscriptible disponible.
;
La dernière adresse valide est stockée dans $4895 et dans SP, le
registre pointeur de pile (Stack Pointer)
;
On remarquera que si une ROM répond avec un contenu identique à
la ROM à une adresse multiple de 16ko, l'initialisation va
penser que c'est de la RAM accessible.

Comment: $1000
Démarrage complet de la machine.
Vérifier pourquoi c'est appelé depuis $2282

Comment: $100a
Copie de la ROM sur toute la mémoire adressable
Equivalent C-style de : memcpy($4000, $0000, $C000)

Comment: $100c
À la fin de LDIR, HL == $C000, DE == $0000, BC == $0000

Comment: $100e
À présent, HL == $4000, DE == $0000, BC == $C000

Comment: $1010
Début de la comparaison octet par octet de la mémoire

Comment: $1015
Si le contenu de (HL) et (DE) est différent, on saute en $101B

Comment: $1017
Si le contenu de (HL) et (DE) est identique
et que BC est > 0, on loop

Comment: $101a/above
L'instruction partielle suivante ne sert à rien d'autre qu'à gagner un peu
d'espace lorsque BC == 0 et que la boucle est terminée.
Le contenu de A est écrasé un peu plus loin.

Comment: $101b
HL est décrémenté pour retrouver la dernière addresse testée (CPI augmente HL).
HL contient donc la première adresse invalide de l'espace mémoire en écriture.
Cette adresse est mise dans SP et stockée en $4895

Comment: $1020/above
La seconde étape de l'initialisation consiste à remplir les vecteurs
utilisateur par des instructions spécifiques. Ces vecteurs, situés
en RAM...

Comment: $1020
Les adresses $47D0 à $47EE vont ensuite est remplies par des RET ($C9).
Equivalent C-style de : memset($47D0, $1E, $C9)

Comment: $102b
Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.

Comment: $1042
L'adresse $47EE reçoit un JP $0069 (la NMI).

Comment: $104b
IX prend la valeur $47FA qui est la base de la zone de données graphiques

Comment: $104F
$1179 est la zone mémoire contenant la séquence à envoyer au EF9345.
HL pointe sur la taille de la séquence à envoyer au EF9345.

Comment: $1055
Initialisation de la variable EF...

Comment: $1059
Initialisation de la variable EF...

Comment: $105d
Initialisation de la variable EF...



Label: $4895, LastValidRAM
Comment: $4895
Première adresse RAM invalide

// Label: $1179, InitEF
// Label: $47D0, ?
// Label: $47F1, ?
// Label: $47F4, ?
// Label: $47F7, ?
Label: $47FA, GraphValues
Comment: $47FA
Début de la zone de données graphiques pour la communication avec le EF9345
