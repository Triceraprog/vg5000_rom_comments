$0000/romStart/above
Tout commence par un saut à l'adresse $1000. Le choix de l'adresse $1000
semble arbitraire. D'autres machines à base de Z80 font des sauts à d'autres
adresses.
;
Comme les adresses suivantes sont les adresses de branchement des instructions
RST du Z80, le code de démarrage doit se trouver plus loin. D'où le saut.
;
Juste après le saut se trouve, sous forme de chaîne de caractères, le numéro
de version de la ROM.

$0008/chkchr/above
Vérification que le caractère pointé par HL est égal au caractère qui suit exactement
l'instruction RST 8 appelante. Si ce n'est pas le cas, affiche un message d'erreur de syntaxe.

$0008:Enregistre le caractère pointé par HL
$0009:Échange le contenu sur le haut de la pile (l'adresse de retour de RST) et HL
$000a:Compare le contenu de l'adresse de retour et la valeur sauvée dans A
$000b:Incrémente HL afin que l'adresse de retour saute le caractère suivant l'instruction appelante
$000c:Remet la nouvelle adresse de retour en place sur la pile
$000d:Si les deux caractères comparés étaient différent, saute en stx_err_prt ; sinon, passe dans chget


$0010/chget/above
Incrémente HL et met le contenu (HL) dans A.
Si le caractère est supérieur à $3a (: donc juste après '9'), retourne immédiatement, sinon...
Retour: Flag Z si caractère NUL, Flag C si un chiffre, NC si pas un chiffre
;
MS_BASIC=GETCH

$0018/outdo/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

$001B/setext/code
$001B/above
Fonction : redéfinition d'un caractère
Change un caractère programmable dans la mémoire vidéo.
Entrée :
A contient le carractère à changer (sur 7 bits).
A contient sur le bit 7 la nature de la palette (0 == Texte, 1 == Graphique)
HL pointe sur le buffer de 10 octets avec les valeurs
Registres modifiés :

$0020/de_compare/above
Fonction : comparaison de HL et DE
Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
En sortie, C sera positionné si HL < DE

$0028/getsign/above
Renvoie $FF, $00 ou $01 en fonction du contenu du buffer flottant.
Préserve HL

$002c:Saute si fac[0] != 0

$0030/usrrst

$0033/warmgo/above/code
Reset

$0038/irq/above
Fonction : traitement de l'interruption.
Sur la machine, cette interruption est dédiée à l'affichage.
C'est aussi l'EF9345 qui provoque l'interruption.
Mais un vecteur est disponible pour personnaliser les traitements dans l'irq.

$0038:Appel au vecteur d'interruption
$003c:Décrémente le compteur de temporisation d'affichage
$003f:Si le compteur n'est pas tombé à zéro, on sort immédiatement (pas de rafraichissement)
$0045:Remise du compteur à la valeur de référence
$004c:Test puis mise à zéro du bit 0 du flag d'affichage
$0050:Si le flag d'affichage était à zéro, on sort immédiatement (pas de rafraichissement)
$0053:Début du rafraichissement de l'affichage
$0056:Envoi à EF9345 de commandes (à décoder)

$0066/nmi/code
$0066/above
Interruption non masquable.
L'interruption est lancée par l'appui de la séquence Ctrl-Delta (cf. description plus
complète).
Le code saute immédiatement, au hook, qui a pour valeur par défaut un saut en 'test_reset'

$0069/resetlang/code
$0069/above
Met le système en anglais.
La seule entrée semble être la valeur que prend temporairemet nmihk pendant le boot.

$006b:Messages en anglais
$0071:Table de transcription du clavier

$0080/retfun/code
$0083/deint/code
$0086/getbyt/code
$0086/above
Fonction : Prend l'argument pointé par HL et renvoi le résultat dans A (quand numérique)

$0089/frmnum/code
$008C/beep/code
$008f/play/code

$0092/putahl/code
$0095/putici/code
$0098/getahl/code
$009B/getici/code
$009E/cls/code
$00A1/cll/code
$00a4/wait/code
$00a7/fndadr/code
$00aa/kbscan/code
$00ad/regst/code
$00b0/stkv/code
$00b3/stkh/code
$00b6/stka/code
$00b9/break/code

$00bc/disp_refrsh/above
Rafraichissement de l'état de l'affichage sur l'EF9345 en fonction
du contenu de la mémoire vidéo en RAM ($4000)

$00bf:Séquence EF9345 à décoder
$00e0/r_line0_lp
$00ec:Boucle sur les 80 octets de la première ligne
$00fd:24 lignes
$00ff/r_line_loop

$0186/skip_dsplay

$018c/putahl_impl
$018c/above
Fonction : affiche un caractère en s'adressant directement à l'EF9345
Entrées : HL=position, D=char, E=attr

$0192:Place le curseur sur le ligne H
$0198:Place le curseur sur le colonne L

$019a/putici_impl
$019a/above
Fonction : affiche un caractère en s'adressant directement à l'EF9345
Entrées : D=char, E=attr

$01a1/put_wait1
$01b1/put_wait2

$01c4/getahl_impl
$01c4/above
Fonction : Récupère une paire caractère/attribut en s'adressant directement à l'EF9345
Entrées : HL=position
Sortie : D=char, E=attr

$01d2/getici_impl
$01d2/above
Fonction : Récupère une paire caractère/attribut en s'adressant directement à l'EF9345
Entrées : -
Sortie : D=char, E=attr

$01df/get_wait1
$01ef/get_wait2

$0255/cls_impl/above
Fonction: Efface l'écran
Efface tout d'abord la ligne 0
Puis recopie le contenu mémoire de cette ligne sur le reste de l'écran
L'effacement est celui de la mémoire vidéo en RAM BASIC.

$0265/cli_impl/above
Fonction: Efface une ligne
Entrées : A contient un numéro de ligne
L'effacement est celui de la mémoire vidéo en RAM BASIC.

$026b:Écriture de $80 à la première position de la ligne
$026d:Récupération des attributs par défaut
$0271:Écriture dans la position suivante des attributs par défaut

$0276
if bit(C,7) == 1 then A = 0 else A = $20
Le bit 7 de C étant à 1 pour un caractère graphique, 0 pour texte

$027d/cli_default
$027d
Boucle pour écrire dans les positions suivantes de la ligne alternativement A et C.
Donc un espace pour le mode texte et 0 pour le mode graphique, suivi des attributs

$027f/cli_loop

$0291/fndadr_impl/above
Fonction: renvoie l'adresse écran à partir des coordonnées X et Y
Entrées : H contient y, L contient x
Retour : HL contient $4000 + 80y + 2x

$0291:C contient x
$0292:L contient Y
$0297:HL = L * 8 (c'est-à-dire y * 8)
$0299:DE = HL = y * 8
$029c:HL = 32 * y + 8 * y = 40 * y
$029d:HL = 80 * y
$029e:C contient x
$02a1:HL = 80 * y + 2 * x
$02a5:HL = $4000 + 80 * y + 2 * x

$02a7/kbscan_impl/above
Fonction : scanne le clavier
En commençant par le port $87 jusqu'au port $80
La valeur obtenu est dans A. Le carry flag est à 1 si ?

$02aa/kb_row_loop
$02aa:lecture de l'entrée
$02ac:la ligne est à l'état haut lorsque la touche n'est pas pressée.
$02ad:test si un signal a été reçu
$02b1:boucle sur les ports
$02b6:Masque avec b10111011

$02b8/key_pressed
$02b8:Si aucune touche pressée (moyennant le masque), saut

$02bc/col_count
$02bc:Calcul le rang du bit à 1
$02c1/col_exit
$02c1:Place dans A le rang du bit à 1 (et donc la colonne)
$02c2:A=2 * col
$02c3:A=4 * col
$02c4:A=8 * col
$02c5:A=(8 * col) + row_port ($80 à $87)
$02c6:A=(8 * col) + row_port - $80 (0 à 7)
$02ca:Lecture du rang 0 dans B
$02d2:Vérification de la touche SHIFT appuyée
$02d6:Si SHIFT est appuyé, ajoute $40 à l'adresse de la table de traduction
$02d7:Si SHIFT est appyyé, CTRL est ignorée

$02d9/key_noshift
$02d9:Vérification de la touche CTRL appuyée
$02de:Ajoute $80 (2 * $40) à l'adresse de la table de traduction
$02df/key_noctrl
$02df:A qui contient l'index dans la table est passé dans E
$02e2:L'index est ajouté au pointeur de la table
$02e3:La valeur de la table est récupérée dans A


$02e4/key_changed
$02e4:récupération de la valeur précédente du clavier
$02e7:set carry flag
$02e8:si la nouvelle touche est la même que l'ancienne saute à la fin pour retour
$02ea:sinon, on enregistre la nouvelle valeur
$02ed:et le carry flag est enlevé
$02ee/kbscan_exit
$02ee:Le Carry Flag indique si la touche a changé (C reset) ou n'a pas changé (C set)


$02EF/regst_impl/above
Fonction: Envoi d'une séquence à l'EF9345
Entrée: HL pointe sur la séquence de données à envoyer.
Le premier octet de la séquence est sa longueur en octet.

$02f1/regst_loop

$0286/wait_impl/above
Fonction: Attente d'état « prêt » de l'EF9345
'$20' est envoyé sur le port $8F puis on attend que le le bit de
poids fort sur le port $CF soit à 0.

$028a/wait_loop

$0302/fp_add_hl/above
Addition flottante depuis (HL)

$030b/fp_stck_sub/code/above
Appelé via la table des priorités
Soustrait le contenu de BCDE (pris dans la pile) du FP
Par inversion de signe et fallthrough dans l'addition.

$030d/fp_bcde_sub

$0310/fp_bcde_add/above
Appelé via la table des priorités
Ajoute le contenu de BCDE et de FP
;
MS_BASIC=FPADD

$0312:Si l'exposant de BCDE est 0, il n'y a rien à ajouter, on ne touche pas à FAC et on retourne.
$0317:Si l'exposant dans FAC est 0, alors on copie BCDE dans FAC et c'est terminé
$031b:Si l'exposant de BCDE (B) est plus petit que celui de FAC (A), on garde comme ça. Sinon, on les échange.
$031e:Oppose la différence entre les expostants (complément à 2)
$031f:Sauve DE...
$0320:Le temps de mettre FAC sur la pile
$0323:... et restaure DE
$0324:Copie BCDE dans FAC
$0328:Et récupère BCDE (l'ancien FAC) depuis la pile.

$0329/no_swap
$0329:Ici, BCDE contient le plus petit des nombres. A contient la différence (positive) entre les deux expostants.
$032b:Si la différence est de plus de 25. BCDE est négligeable face à FAC, on a terminé.
$032c:Sauve AF
$032d:Extrait les signes de FAC et BCDE, A bit 7 à 1 si les signes sont opposés, 0 si identiques.
$0330:Sauve le résultat du signe dans H
$0331:Et récupère AF

$0332:Déplace la mantisse à droite (division) d'un nombre de position égal à A
$0336:Test le résultat de signe
$0337:Pointe sur la mantisse
$033a:Saute si les signes étaient différents. Dans ce cas, on doit faire une soustraction.
$033d:Ajoute les mantisses de FAC et BCDE
$0340:Pas d'overflow, on passe à l'arrondi du résultat (et sa normalisation)
$0342:Sinon, il faut augmenter...
$0343:.. l'exposant de 1
$0344:Si l'exposant a dépassé sa limite (boucle sur zéro), on lance un Overflow.
$0349:Sinon, il faut corriger la mantisse avec un décalage de 1 (L) vers la droite
$034c:Puis on passe à l'arrondi
$034e/min_bcde/above
FAC - CDEB -> BCDE. Si un overflow (underflow) est provoqué, le nombre est complémenté à 2 à la fin. Puis fallback dans la normalisation.

$0350:B ici contient le résultat du shift à droite le moins signifiant. Le nombre est sous forme CDEB

$035c/pos_norm
$035c:Met le nombre en positif potentiellement avant de normer et compacter. En venant du traitement d'auto via bade_to_fp, A étant à zero, la rotation à gauche n'a pas généré de Carry.

$035f/bcde_norm/above
Lors de la normalisation, BCDE n'a pas le format normal. B n'est pas l'exposant, mais le poids le plus faible de la mantisse.

$0360:L et H sont les plus petits signifiants de la mantisse, qui est sous la forme CDHL (l'exposant est dans FAC)
$0361:A = 0, va servir de compteur

$0362/rot_loop/above
La partie ci-dessous prend C, D, H, L, A comme un buffer en decalage vers la gauche
(octet par octet). A est un compteur (sauvé temporairement dans B pendant la rotation) auquel
on soustrait 8 à chaque fois, jusqu'à attendre $e0 (ce qui fait 4 fois avec A = 0 au début)

$0362:Sauvegarde du compteur dans B
$0363:Récupère le MSB de la mantisse dans A
$0364:Si A est différent de 0, c'est que C (la partie la plus haute de la mantisse) était non nul
$0365:Si A (dont l'octet le plus haut) est 0, on peut faire le décalage d'un octet complet. Sinon, bit par bit
$0367:On décale...
$0368:... CDHL
$0369:... vers
$036A:... DHLA (et A est égal à 0 ici). On embarque L (l'exposant) dans le shift, pour tester au passage s'il était nul.
$036B:Récupération temporaire dans A du compteur
$036e:Soustrait 8 du compteur, puisque l'on vient de décaler de 8
$036e:Comparaison avec -24-8
$0370:Arrêt si le compteur est arrivé à 32. On a shifté de 32 bits au max, le résultat est donc 0. Sinon, on continue le shift

$0372/clear_fac
$0372:On met 0 dans le FAC
$0373/a_to_exp

$0377/normal
$0379:Vérifie s'il y a des bits dans DHL (les LSBs de la mantisse).
$037a:Si oui, il faut les traiter avec les routines complète
$037c:Sinon, on ne traite que C pour trouver le premier bit de poids fort. Routine optimisée
$037d/bit_find
$037d:Diminue B jusqu'à trouver le premier bit à 1 dans A (qui vient de C). B est le résultat du nombre de shift de 8 effectué précédemment, en soustraction de $00.
$0381:Bit à 1 trouvé. On remet B un cran avant.
$0382:On remet aussi le nombre au cran d'avant (remettre le CY dans le nombre)
$0383:C (MSB de la mantisse) est normalisé (avec 1 en msb)

$0386/norm_full
$0386:Compte un bit de shift
$0387:Décale HL à gauche de 1
$038a:Shift D de 1 en récupérant le Carry de HL
$038c:Shift C de 1 en récupérant le Carry de D

$038e/norm_bit:Il reste quelque chose, on continu la normalisation

$0391/norm_nxt
$0391:Le compteur de shift est mis dans A. CDHL est normalisé.
$0393:Reconstruction de CDEB contenant la mantisse
$0395:On n'a rien shifté, on passe à l'arrondi
$039a:Modification de l'exposant avec le compteur de décalage (B est négatif en complément à 2).
$039b:Remise en place de l'exposant ajusté.
$039c:Le décalage est trop grand, on n'a plus de précision, le résultat est 0
$039e:L'exposant est 0, le résultat est donc 0 (dans d'autres versions, un RET Z est fait ici)

$03a0/round

$03a0:Récupère la plus petite partie de la mantisse
$03a1/round0
$03a4:Vérifie si la plus petite partie de la mantisse a son msb à 1
$03a5:Dans ce cas, on arrondi vers le haut.
$03a8:Récupération dans B de l'exposant
$03aa:Récupération dans A du résultat de signe
$03ab:Récupération du bit de signe (seul le msb compte)
$03ad:Place le bit de signe (le msb de C est forcément à 1, donc un XOR fonctionne si 1 signifie + ?)
$03ae:Remet en place le MSB + Signe de la mantisse
$03af:Place le résultat dans FAC

$03b2/round_up
$03b2:Incrément la partie basse de la mantisse
$03b3:Si on n'a pas fait d'overflow (retour à zero), c'est ok, on revient
$03b4:Sinon, on augmente la partie suivante
$03b5:On vérifie encore
$03b6:Si on doit toujours arrondir, on arrondie la partie suivante
$03b7:Dernière chance
$03b8:Tout a été arrondi, on reset C
$03ba:Et on incrémente l'exposant
$03bb:Retour si tout va bien. Mais si l'exposant a bouclé sur 0
$03bc:Alors c'est que le nombre est trop grand, on lance l'erreur.

$03bf/add_bcde/above
HL pointe sur la mantisse. Ajoute avec la mantisse de BCDE (donc CDE). Les exposants doivent être identiques pour que cela ait du sens. Si la mantisse "dépasse", le CY sera à 1 en sortie.

$03cb/compl2/above
Complément à 2 de BCDE (sous forme CDEB)

$03df/div_mant/above
Division de la mantisse par le nombre A en entrée
;
MS_BASIC=SCALE

£03df:B ne sert pas à l'exposant dans cette routine.

$03ea:La mantisse a été divisée par 256 (shift left de 8)

$03e1/div_256_24b
$03e1:Boucle sur A divisé par 8 (entier). Décale un nombre stocké dans CDE d'un vers la droite à chaque fois. B sert de récupération temporaire à droite du nombre.
$03ec:La denière soustractiona fait passer A négatif, on y ajoute 9 (8 + 1 ?)
$03ee:Sauvegarde de l'exposant restant dans A
$03e1:Verifie si le résultat est 0 (pourquoi pas C ?)
$03e2:Saute si différent de 0

$03ec/end_256

$03fd/fp_shift_r/above
Décalage vers la droite L fois
;
MS_BASIC=SHRLP

$03fd:Boucle sur L, qui est le reste de la division par 8 de A en entrée, et qui boucle en $040c
$03fe:Annule le +1 du +9 (revient donc à +8)
$03ff:Si on était tombé pile à zéro, retour immédiat

$0400:Cette partie jusqu'au JR est un shift vers la droite de l'ensemble CDEB
$0401/shft_right/above
Décalage d'un vers la droite de (B)CDE, avec C déjà dans A, puis branchement vers la routine générique de décalage vers la droite.

$0404:Grace au XOR A, le CY est à 0

$0478/fp_stk_mult/code/above
Appelé via la table des priorités

$047a/fp_mul/above
Multiplication flottante

$04d0/fp_div_10/above
Division de FP par 10
;
MS_BASIC=DIV10

$04dc/fp_bcde_div/above
Appelé via la table des priorités

$04c9/pop_hl_ret

$0583/fp_x_10/above
Multiplication de FP par 10
;
MS_BASIC=MLSP10

$0583:Récupère FP dans BCDE
$0588:Si l'exposant est à zéro, retour immédiat
$0589:En ajoutant 2 à l'exposant, on multiplie le nombre par 4
$058b:Sortie si Overflow avec le message d'erreur
$058e:Si ok, on remet l'exposant en place dans BCDE
$058f:Ce nombre x4 est ajouté au FP actuel, pour un résultat de x5
$0595:Incrémente directement l'exposant dans FP
$0596:Retour si on n'a pas fait passer l'exposant à zéro
$0597:Sinon, c'est un Overflow

$059a/getsign2

$059d:Compare faclo[2] avec $2f (afin de mettre 1 dans Carry si faclo[2] est inférieur à $2f)
$059e/code:Appelé depuis une routine à cause de $060f
$059f:Rotation à gauche via Carry
$05a0:Soustraction de A avec A avec retenu.
$05a1:Saute si la rotation avait débordée dans la retenue.
$05a2:Sinon, augmente A de 1 (autrement, dit A = 1 puisque la soustraction avait donné 0)

$05a5/a_to_fp
$05a5:Prépare le placement des valeurs $88,$80 dans le buffer de virgule flottante

$05aa/bade_to_fp
$05aa:Appelé depuis le traitement d'auto ($072e), A = 0, B = $98, DE = numéro de ligne

$05b2:Mets dans le buffer 'fac' les octets B et $80, B est assigné à 0. C est à 0 (depuis A) en venant du traitement d'auto.

$05b8/above
Fonction BASIC : ABS()

$05b9:Retour immédiat si le signe est positif
$05ba/inv_sign:Change le signe de l'accumulateur FAC par son opposé
$05be:Le signe est donc stocké dans le troisième octet de faclo, sur le bit de poids fort.

$05c2/fac_to_stck/above
Function : Place le contenu de faclo et faclo+2 sur la pile
en préservant la valeur de retour pour RET.
La valeur de HL est préservée

$05cf/hl_to_fac/above
La valeur numérique pointée par HL sera d'abord extraite dans BCDE, puis par fallthrough sera transmis au FP


$05d2/bcde_to_fac/above
Place DE (mantisse) dans faclo et B (exposant) C (le signe et la mantisse 15 bits) dans faclo+2. Préserve la valeur de HL

$05dd/fac_to_bcde/above
Extrait le contenu du buffer de virgule flottante dans BC/DE

$05e0/hl_to_bcde/above
Charge BCDE avec le nombre pointé par HL
;
MS_BASIC=LOADFP

$05e7/inc_hl

$05e9/cpy_faclsb_hl/above
Copie le contenu des 4 premiers octets de faclo vers ce que pointe HL

$05ec/cpy_detohl_4/above
Copie le contenu des 4 premiers octets pointés par DE vers ce que pointe HL

$05ee/cpy_4_loop

$05f5/ext_sign/above
Extrait le signe de BCDE et FAC et place 1 à la place.
Condition: BCDE est plus petit que FAC (au moins depuis l'addition)
Sauve le signe de FAC. Retourne dans A si les signes étaient identiques (1) ou non (0)

$05fb:A gauche, set CY, A droite avec Carry revient a mettre le bit de poids fort (le signe) à 1. Le CY contient le bit de signe initial.
$05fc:Replace le MSB de la mantisse de FAC, sans le bit de signe, avec 1 à la place.
$0601:Mets dans (fac+1) le résultat : le bit 7 contient le bit de signe opposé (1 = positif). CY est à 0.
$0602:On prend le MSB du nombre de BCDE
$0605:Mise à 1 du MSB de BCDE
$0606:Et le résultat re-part dans C
$0607:Apres une rotation à droite
$0608:XOR entre les deux bits de signe (BCDE et FAC). BCDE non opposé, FAC opposé. Donc bit 7 à 1 si les signes étaient identiques.

$060a/cmp_num/above
Compare des nombres
;
MS_BASIC=CMPNUM


$0635/fp_to_int/above
Transforme le nombre flottant en décalant la mantisse jusqu'à ne garder que la partie entière.

$063a:Retour lors du cas 0
$063b:Sauvegarde de HL (qui contient fac)
$063c:En sortie, BCDE est chargé avec le nombre flottant sur 32 bits

$0644:Quelque chose dans le cas négatif
$0649:Soustraction de l'exposant actuel de l'exposant maximum
$064a:Après l'appel, la CDE contient sur 24 bits le nombre entier.
$064d:Récupération dans A du calcul sauvé en $0643
$064f:Traitement spéciaux en cas de ??? (négatif ?)

$0660/above
Fonction BASIC : INT()

$0664:Comparaison avec $98, c'est à dire exposant 24, car c'est la capacité maximale de la mantisse. Au dela, il n'y a plus de précision pour les décimale.
$0666:Pourquoi prendre FAC LSB juste avant de retourner le résultat ??? (le résultat est dans le buffer flottant de toute façon)
$0669:La partie entière est donc trouvée immédiatement.
$066b:En sortant de cet appel, E contient la partie basse entiere du nombre (si inférieur à 256)
$066e:Puisque le nombre entier est complètement à droite de la mantisse, l'exposant est à $98. Le nombre se fera normaliser par la suite.
$0671:Mise sur la pile de l'octet le plus bas du nombre entier résultat (??? pourquoi ?)

$0679/dim_compute/above
Calcul la taille mémoire nécessaire pour stocker une dimension de tableau
Entrées :
BC == taille d'une dimension (ou index) du tableau
DE == taille d'une entrée pour cette dimension (4 pour la première dimension, puis la taile d'une dimension pour les suivantes)
Si une taille devient trop grande, lance une erreur Subscript Out of Range
Retour :
HL contient la taille nécessaire (ou le déplacement)
DE == 0
BC n'est pas touché


$067e:Si BC == 0, retour immédiat
$067f:Préparation d'une boucle de 16 itérations
$0681:HL <- HL * 2
$0687:DE <- DE * 2
$068f:Boucle sur A (16 fois)

$0692/str_to_num/above
Function: transforme le texte pointé par HL en nombre dans l'accumulateur FP
;
MS_BASIC=ASCTFP

$0692:Cas hexa (commence par `&`)
$0694:On branche immédiatement dans ce cas, c'est une autre routine qui se charge de ça. (à noter que parse_value fait déjà ce test, qui n'est pas inutile car cherche d'autres préfixes)

$0697:Cas négatif qui commence par '-'
$0699:Sauvegarde des flags de la comparaison avec '-'
$069c:Cas positif qui commence par '+'
$06a0:Positionne HL un caractère avant dans les autres cas (car chget avance d'un avant toute chose)
$06a1/skip_sign
$06a1:Initialise l'exposant de FP à 0. Effet de bord, A = 0
$06a4:Nombre de chiffres après le point (la virgule) (B = 0)
$06a5:Signe de l'exposant (D = 0)
$06a6:Puissance de 10 (E = 0)
$06a8:Met C à FF, flag pour situer le parsing avant ou après le point

$06a9/prse_flt_lp
$06a9:Lecture du caractère suivant
$06aa:Cas d'un chiffre
$06ae:Cas du caractère `.`
$06b2:Cas du caractère `e`
$06b6:Cas du caractère pas `E`

$06b8/case_exp
$06b9:Au retour, le signe de l'exposant est dans D

$06bc/exp_loop
$06bd:C'est un chiffre, on l'ajoute à l'exposant
$06bf:Ce n'est pas un chiffre, on vérifie le signe de l'exposant
$06c0:Saut s'il était positif, on a fini
$06c4:S'il était négatif, on inverse E (l'exposant)
$06c5:Le flag de passage de point est augmenté pour s'assurer qu'on ne bouclera plus dans le parsing

$06c6/case_dot:Le flag du passage du point est incrémenté (pour le premier point, passe de FF à 00)
$06c7:Si le flag est passé à 0, alors on boucle pour parser la suite, le flag est maintenant sur 0.

$06c9/exp_end
$06c9:Que ce soit avec un deuxième point ou la fin de l'exposant, le parsing du nombre est terminé. Il faut le finaliser. On sauve le pointeur d'execution.

$06cc/adj_loop
$06cb:A contient l'exposant moins le nombre de chiffre après le point. L'exposant est donc tel que tous les chiffres significatifs sont à gauche du point
$06cc:Saute si l'exposant ajusté est positif
$06cf:Si A toujours positif, vérifie la fin de boucle

$06d3:L'exposant est négatif, on divise FP par 10 et on augmente A

$06d8/adj_div_10

$06da:Restaure le pointeur d'execution.
$06db:Restaure le signe du nombre
$06dc:S'il était négatif, appel l'inversion de signe
$06df:Récupère le pointeur d'execution dans HL

$06e1/adj_x_10/above
Ajuste en multipliant par 10 et en décrémentant A

$06e1:Si A était 0, retour immédiat
$06e2/fp_x_10_dec_a

$06e9/case_digit/above
Parses a digit loaded in A

$06e9:Sauve l'exposant
$06ea:Sauve le chiffre dans D
$06eb:Récupère le nombre de chiffres après le point
$06ec:On est arrivé dans cette routine avec le Carry Flag Set. Si C == FF, alors on ajoute zéro, si C == 0, alors on ajoute 1
$06ed:Compteur après le point ajusté, remis dans B
$06ee:Sauvegarde des informations sur la position du oint
$06ef:Sauvegarde du pointeur d'execution.
$06f0:Sauvegarde du chiffre (qui est dans D)

$06f4:Récupération de la valeur du caractère
$06f5:Transformation en valeur numérique
$06f7:Ajoute A à FP
$06fc:Restaure le contexte du parsing
$06fd:Va chercher le caractère suivant.

$06ff/add_a_to_fp
$06ff:Met le FP sur la pile
$0702:Met le digit dans A dans FP

$0705/eval_add:Appelé a travers la table des priorités ; MS_BASIC=PADD
$0706:Récupère le nombre depuis la pile

$070a/add_to_exp/above
Prend l'exposant actuel E et le multiplie par 10, ajoute le caractère de (HL) et en soustrait '0'
Puis va chercher un autre chiffre pour l'exposant
;
MS_BASIC=EDIGIT

$0715/out_in/above
Affiche à l'écran le texte " en "/" in " suivant la langue, suivi du numéro de ligne présent dans HL
;
MS_BASIC=LINEIN

$0722/out_in_fr

$0726/out_number/above
Affiche à l'écran un nombre contenu dans HL
$0726:DE contient une adresse de retour
$0729:Sauvegarde de la valeur dans la pile pour un prochain RET
$072a:Et échange de HL et DE (HL contient donc l'adresse du signe '#'. DE contient le numéro de ligne d'AUTO
$072e:À l'appel, A = 0 et B = $98

$0731:Affiche à l'écran le contenu de l'accumulateur flottant
$0731/out_fp

$0736:Place $20 dans fbuffr (un espace)
$073b:Place $2d dans fbuffr (le signe '-') si le flag M est levé (résultat M dans le test des flottants)
$073d/pos_sign
$073e:place $30 dans fbuffr[1] (le chiffre '0')
$0740:Saut si le résultat était 0
$0744:Saut si le résultat était < 0
$074c:Aussi appelé (jp (hl))depuis $07fe
$07ea/out_zero

$07ff/data_what:Probablement de la donnée

$0826/fp_bcde_pow

$090d/inst_rnd/code
$090e:Pointe vers la seed (pourquoi cette instruction n'est pas dans reseed !!!)
$0911:Si l'argument est négatif, reseed
$0914:Point vers le dernier nombre généré
$0917:Déplacement vers l'accumulateur flottant
$091a:Pointe vers la seed à nouveau
$091d:Retour si l'argument est 0, on renvoit le dernier nombre généré (qui est dans le FAC)
$091e:On ajoute la seed avec le contenu de A (qui est à 1 car le sign est positif)
$091f:... uniquement les 3 premiers bits (0 à 7)
$0923:On sauve la seed
$0927:Offset dans la table des coefficients (seed * 4, B étant à zéro)
$0928:On pointe vers la table des coefficients
$0929:Charge le coefficient en tant que FP dans BCDE
$092c:Multiplication du nombre en FAC avec le coefficient
$092f:Prend l'autre seed
$0932:L'incrémente...
$0933:Limite entre 0 et 3
$0937:Compare la seed à 1
$0939:Si A était zéro, alors Carry est à 1 et donc A passe à 1.
$093a:On sauve la seed
$093d:4 octets avant rnd_add
$0942:Index dans la table des additions
$0943:Pointe sur l'entrée de la table
$0944:Addition du contenu de la table avec FAC

$0947/afterreseed
$0947:Récupération de FAC dans BCDE
$094a:A récupère le poids faible de la mantisse
$094b:Met le poids fort de la mantisse dans le poids faible
$094c:Modifie des bits de A
$094e:Met le résultat en haut de la mantisse
$094f:HL pointe sur fac_1 (signe résultant). On y met $80 pour positif.
$0951:HL pointe sur l'exposant
$0952:Que l'on récupère dans B (étrange... on avait déjà récupéré dans BCDE)
$0953:On fixe l'exposant à $80 (donc puissance 0)
$0958:Incrémentation de la troisième seed
$0959:Récupération de sa valeur
$095a:Modulo 171
$095e:Si on boucle, on bouge un peu la mantisse
$0962/rnd_cnt
$0962:Normalisation
$0968:Copie FAC dans (HL), donc dans le dernier numéro généré.


$096b/reseed

$0972/rnd_add
$0976/rnd_add_1
$097A/rnd_add_2

$0a78:Désactivation de l'affichage

$0a87/play_impl
$0a87/above
Joue une séquence sonore
BC = Pointeur vers la séquence ASCII
E = taille du buffer

$0a8a:lecture du caractère suivant
$0a8d:saute si le buffer est épuisé
$0a92:Cas de ','
$0a96:Cas de codage de fin de ligne (?)
$0a9a:Cas de l'espace
$0a9e:Cas inférieur à 'A'

$0b11/play_exit
$0b12:provoque un rafraichissement 3 IRQ plus tard.

$0c6d:Récupère le premier paramètre
$0c73:Si le premier paramètre est 0, l'augmente de 1
$0c74/snd_val_ok
$0c76:Met la valeur du son dans DE'
$0c79:Attente du son = 256 - A (plus la valeur du paramètre est haute, moins on attend)
$0c7a:-val du son dans C'
$0c7c:Vérification de la présence d'une virgule
$0c7e:Récupère le deuxième paramètre
$0c82:HL <- DE << 8 ; DE <- DE * A
$0c87/de_d_16_lp
$0c8c:DE est divisé par 16
$0c8e:Et íncrémenté
$0c93:Valeur par défaut du troisième paramètre
$0c95:Saut si pas de troisième paramètre (pas de virgule)
$0c98:Sinon, récupération dans A du troisième paramètre
$0c9b/no_cycle
$0c9c:Sauvegarde du troisième paramètre
$0c9e:Première valeur du cycle = attente du son + troisième paramètre
$0ca4:Deuxième valeur du cycle = attente du son - troisième paramètre

$0ca7/snd_emit
$0ca7/above
Fonction : émet un son
Durée dans DE
SONSAV_1 et SONSAV_2 indiquent la phase (première et seconde)

$0ca8/snd_dur_lp

$0caf/snd_L_wait
$0cb8:Mise à état haut de la sortie son
$0cc1/snd_H_wait
$0cca:Mise à état bas de la sortie son

$0cd3:Fin de la procédure snd_emit

$0cd4/de_mul_a/above
Entrée : A, DE
Sortie : HL = DE << 8 (autrement dit, H <- E) ; DE = DE * A ; A inchangé

$0ce6/wait_69c
$0ce6:Wait 69 cycles, call included
$0ce8/wait_31c
$0ce9/wait_27c

$0d7c/SendToEF/above
Fonction: Envoi d'une donnée à l'EF9345
Registre en entrée : DE
Registre modifié : C
D est envoyé sur le port $8F
C est envoyé sur le port $CF

$0d85/setext_impl/above
Fonction: Redéfinition d'un caractère
Registres en entrée : HL et A
Registres modifiés : AF, HL, BC, DE

$0d8d/setext_2
$0dce/setext_lp2
$0dd3/setext_lp3

$0d85:if bit(A, 7) == 0 then B = $C0 else B = $40
$0d8d:Le haut de la pile contient BC
$0d8e:Désactivation de l'affichage
$0d98
Envoi à l'EF9345 de $22,A (avec le bit 7 de A mis à 1) (R2=A)
(A est envoyé à travers E)

$0d9b:Récupération de la valeur de BC dans AF
$0d9c:Remise du contenu de BC sur la pile
$0d9d:Inversion du bit 7 de A, qui est la valeur de B du début de la fonction ($C0 ou $40)
$0da2:Envoi à l'EF9345 de $21,A (A est envoyé à travers E) (R1=A)
$0da9:Envoi à l'EF9345 de $20,$03 (R0=3 -> KRG+Inc)
$0dae:Récupération, à travers E, de la valeur de A en entrée de fonction (avec les trois lignes suivantes)
$0db4:A = (A >> 2) & $1F
$0db7:Envoi à l'EF9345 de $24,A (A est envoyé à travers E) (R4=A)
$0dbd:A = (A initial de la fonction) & $03
$0dbf:Récupération du contenu du BC initial ($C0 ou $40)
$0dc0:A = A | B
$0dc2:Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0dc9:Envoi à l'EF9345 de $20,$34 (R0=OCT Write AP NoInc, écrit R1 en mémoire désigné par R4 R5)
$0dcc:Boucle extérieure, 10 itérations
$0dce:Récupère la valeur suivante de la redéfinition de caractère dans A
$0dd0:Boucle intérieure, 8 itérations
$0dd4:Inverse le contenu de A et C, bit à bit
$0dd8:La ligne de redéfinition lue dans (HL) est à présent inversée dans A
$0ddd:Envoi à l'EF9345 de $29,A (A est envoyé à travers E) (R1=A + Execute)
$0dee:Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0df3:Réactivation de l'affichage

$0df7:Fin de la fonction setext

$0de5
Envoi sur $8F de $25 puis récupération sur $CF d'une valeur dans A (Read R5)
Puis A = A + $04

$0ec3/stkh_impl/above
Fonction : vérifie la valeur STICK horizontale
A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier)

$0ed3/stkv_nol_k

$0ece:Lecture flêche vers le gauche du clavier
$0ed2:B passe à $FF
$0ed3:Lecture flêche vers le droite du clavier

$0ed7/stkh_joy0
$0edd:B passe à $FF
$0ede/stkh_nol_0

$0ee2/stkh_joy1
$0ee8:B passe à $FF
$0ee9/stkh_nol_1

$0eeb/stk_end:Fin des functions stkh et stkv
$0eed:Si le dernier test était nul (pas de touche appuyée), alors B est incrémenté. Si deux touches opposée étaient appuyée, cela met le résultat à 0.
$0eee/stk_exit:Placement du résultat dans A

$0ef9/stkv_impl/above
Fonction : vérifie la valeur STICK verticale
A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier)

$0f04:Lecture flêche vers le haut du clavier
$0f08:B passe à $FF

$0f09/stkv_noup_k

$0f0b:Lecture flêche vers le bas du clavier

$0f0f/stkv_joy0
$0f15:B passe à $FF
$0f16/stkv_noup_0

$0f1a/stkv_joy1
$0f20:B passe à $FF
$0f21/stkv_noup_1

$0f2e/stka_impl/above
Fonction : vérifie la valeur ACTION
A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier/barre espace)

$0f3a:Vérification de l'appuie de la touche ESPACE

$0f3e/stka_joy0
$0f3a:Vérification de l'appuie sur la bouton action du joystick 0

$0fad/above
Instruction CALL
Évalue l'argument, le cast en int, puis utilise le vecteur `calhk` comme tremplin.

$0fd2/get_hex/above
Lecture d'un chiffre Hexa depuis HL (HL doit donc être positionné sur le caractère précédent)
Le caractère est valide si le Carry est reset, A contient alors la valeur.
Si le Carry est set, la valeur n'était pas valide

$0fd4:Comparaison avec '0'
$0fd6:Saute si en dessous, c'est invalide

$0fd8:Comparaison avec ':' (juste après '9')
$0fda:Saute si en dessous (on est donc entre '0' et '9', c'est valide)
$0fdc:toupper() du caractère
$0fe0:Saute si en-dessous de 'A'
$0fe4:Saute si au-dessus ou égal à 'G'
$0fe7:Soustrait $37 à A pour obtenir la valeur ('A' - $37 donne $0A)

$0fe9/valid_hex
$0fe9:S'assure que le résultat dans de $00 à $0F, au passage clear du carry

$0fec/invalid_hex:set le carry et revient


$1af8/mem_out_err
$1afc:Affiche l'erreur "Out of Memory"

$1ff3/stka_joy1
$1ff3:Vérification de l'appuie sur la bouton action du joystick 1

$0f8e:Force l'affichage et met le compteur de rafraichissement à 1
$0f96:Attend la prochaine interruption qui provoquera un rafraichissement

$0f98:Valeur par défaut pour DISPLAY
$0f9f/display_def
$0fa2:Enchaine sur l'instruction SCREEN


/////////////////////////////////////////
////////////////// 1000 /////////////////
/////////////////////////////////////////

$1000/Start/above
C'est ici que commence l'intialisation complète de la machine.
La première étape est de recopier le contenu de la ROM dans
l'espace RAM adressable. Adressable ne signifie pas que de la RAM
est effectivement branchée. Cela ne pose pas de problème au
niveau hardware du VG5000 d'envoyer une demande d'écriture.
;
Le contenu de la mémoire est ensuite lu et comparé à la ROM.
Tant que c'est identique, c'est qu'il y a quelque chose de branché
qui répond correctement. Dès que c'est différent, c'est qu'on est
sorti de la zone de la mémoire inscriptible disponible.
;
La dernière adresse valide est stockée dans $4895 et dans SP, le
registre pointeur de pile (Stack Pointer)
;
On remarquera que si une ROM répond avec un contenu identique à
la ROM à une adresse multiple de 16ko, l'initialisation va
penser que c'est de la RAM accessible.

$1000
Démarrage complet de la machine.
Vérifier pourquoi c'est appelé depuis $2282

$100a
Copie de la ROM sur toute la mémoire adressable
Equivalent C-style de : memcpy($4000, $0000, $C000)


$100c:À la fin de LDIR, HL == $C000, DE == $0000, BC == $0000
$100e:À présent, HL == $4000, DE == $0000, BC == $C000
$1010:Début de la comparaison octet par octet de la mémoire
$1015:Si le contenu de (HL) et (DE) est différent, on saute en $101B
$1017
Si le contenu de (HL) et (DE) est identique
et que BC est > 0, on loop

$101a/above
L'instruction partielle suivante ne sert à rien d'autre qu'à gagner un peu
d'espace lorsque BC == 0 et que la boucle est terminée.
Le contenu de A est écrasé un peu plus loin.

$101b
HL est décrémenté pour retrouver la dernière addresse testée (CPI augmente HL).
HL contient donc la première adresse invalide de l'espace mémoire en écriture.
Cette adresse est mise dans SP et stockée en $4895

$1020/above
La seconde étape de l'initialisation consiste à remplir les vecteurs
utilisateur par des instructions spécifiques. Ces vecteurs, situés
en RAM, permettent d'intervenir lors de certaines opérations avec
du code écrit par l'utilisateur et donc de modifier le comportement
du système.

$1020
Les adresses $47D0 à $47EE vont ensuite est remplies par des RET ($C9).
Equivalent C-style de : memset($47D0, $1E, $C9)

$1027/hk_ini_lop

$1048:L'adresse $47EE reçoit un JP $0069.

$104b/above
La troisième phase initialise le processeur graphique EF9345. Pour commencer,
une séquence est envoyée au périphérique, puis quelques variables en RAM sont
mises initialisées.
;
Attention, la valeur de IX doit rester constante. Le système de cette ROM
considère que IX est en tout temps égal à $47FA et référence certaines
variables par index par rapport à IX.
;
La séquence est
 $28,$81 -> Écriture de quelque chose dans le TGS
 $29,$00 -> TGS = 0 (625 lignes, non entrelacé, no-input-resync, output VSync+HSync, Service Row = 0, 40 Char
 $20,$82,$29,$6e -> MAT = $6e (Marge = B+G, Insert Marge, Curseur plein/flash, Curseur affiché, simple hauteur
 $20,$83,$29,$f7 -> PAT = $f7 (Ligne 0 'ON', Bulk haut et bas activé, pas de conceal, Insert mode : Active Area, Flash ON, Format court pour le 40 Char
 $20,$84,$29,$13 -> DOR = $13 (Block G0=3, Block G1=1<<1, Block Q=0<<3)
 $20,$87,$29,$08 -> ROR = $08 (Z=0, Y=8)
 $26,$08,$27,$00,$28,$02 -> R6=$08, R7=$00, KRG sans incrémentation avec MP=$0800 (data R1, R2 = $08, ??)
;
Envoyés par pairs sur les ports $8f, $cf

$104b:IX prend la valeur $47FA qui est la base de la zone de données graphiques.

$104F
-> $1179 est la zone mémoire contenant la séquence à envoyer au EF9345.
HL pointe sur la taille de la séquence à envoyer au EF9345.

$1055:Initialisation de la variable $47FA : compteur d'interruptions à 5
$1059:Initialisation de la variable $47FB : besoin de rafraichissement à faux
$105d:Initialisation de la variable $47FA : utilisation des majuscules
$1063/above:Les interruptions sont réactivées pour la suite de l'initialisation.
$1067:Numéro de la première ligne du BASIC ?
$106a:Couleur du pourtour et aspect du curseur
$107a:Copie les valeurs initiales des différentes variables du système en RAM
$107d:Envoi 0 sur le port $EF, censé être non utilisé
$107d:Envoi 0 sur le port $AF, pour le son-k7
$1084:Modification de l'adresse du hook "nmihk"
$1093/above:Calcul des bornes de pile, memsize et place disponible
$1096:hl <- sp - 2 (sp == (stktop))
$109b:hl < $03e8 ? (comment serait-ce possible ?)
$109e:de <- $ffce (-50)
$10a5:Calcul final du haut de la pile comme étant (memsize) - 50
$10ab:Récupération du haut de la pile
$10b1:hl <- (stktop) - 17
$10ba
hl = hl - de, soit ((stktop) - 17 - end_vars)
Autrement dit, la taille disponible entre la fin des variables internes et la pile -17.

$10bb:Cette taille disponible est poussée dans la pile.
$10bc/above:Affichage du texte de démarrage. VG5000 + numéro de version
$10bc:Texte en double hauteur, double largeur

$1118/test_reset/above
Fonction : appelé par le vecteur nmihook ($47ee) qui par défaut est un jp $1118.
Teste si CTRL est appuyé et si oui, effectue un reset.
Plus exactement, pendant le boot, le vecteur est à JP $0069, puis à la fin du boot JP $1118

$1122/reset/above
Fonction: Effectue le reset à chaud

$1148/vg5000_txt
$1163/version_txt
$1179/InitEfSeq:Séquence d'intialisation de l'EF9345 au démarrage.
$1194/initvalues

$11f9/keybfr_0
$1201/keybfr_1
$1209/keybfr_2
$1211/keybfr_3
$1219/keybfr_4
$1221/keybfr_5
$1229/keybfr_6
$1231/keybfr_7
$1239/keybfr_s0
$1241/keybfr_s1
$1249/keybfr_s2
$1251/keybfr_s3
$1259/keybfr_s4
$1261/keybfr_s5
$1269/keybfr_s6
$1271/keybfr_s7
$1279/keysfr_c0
$1281/keysfr_c1
$1289/keysfr_c2
$1291/keysfr_c3
$1299/keysfr_c4
$12a1/keysfr_c5
$12a9/keysfr_c6
$12b1/keysfr_c7

$12b9/keybeng_0
$12c1/keybeng_1
$12c9/keybeng_2
$12d1/keybeng_3
$12d9/keybeng_4
$12e1/keybeng_5
$12e9/keybeng_6
$12f1/keybeng_7
$12f9/keybeng_s0
$1301/keybeng_s1
$1309/keybeng_s2
$1311/keybeng_s3
$1319/keybeng_s4
$1321/keybeng_s5
$1329/keybeng_s6
$1331/keybeng_s7
$1339/keyseng_c0
$1341/keyseng_c1
$1349/keyseng_c2
$1351/keyseng_c3
$1359/keyseng_c4
$1361/keyseng_c5
$1369/keyseng_c6
$1371/keyseng_c7
$1379/errors_fr
$13ef/out_mem_fr
$153f/errors_eng
$159e/out_mem_eng

$16c6/txt_fre_fr
$16db/txt_fre_en

$170f/txt_igno_fr
$172d/txt_igno_en

$173c/txt_redo_fr
$1752/txt_redo_en

$1763/txt_arret
$176a/txt_break

$1771/txt_in_fr
$1776/txt_in_en
$177b/txt_next

$19e3/pause_msg

$1aef/ok_clear:Affiche le message d'invite "Ok!" et réinitialise le chaînage et les variables.

$1d97/sendchar_k7

$1e89/fetch_next/above
Va chercher une adresse stockée dans le compteur 'high' (normalement utilisé par les cassettes)
L'incrémente et va y chercher la valeur en entrée.
Si cette valeur est $03, alors termine l'action en revenant sur le clavier.
Sinon, la valeur est retournée par A pour être décodée.


$1e97:Replace le périphérique d'entrée sur le clavier


////////////////////


/////////////////////////////////////////
////////////////// 2000 /////////////////
/////////////////////////////////////////

$2000/instructions
$2064/functions
$209d/prekeywords
$209e/keywords
$21fd/keywstop
$21fe/prio_table

$2213/null_str
$2214/ok_str
$2219/marker_vrfy
$221c:HL pointe 4 octet plus haut que le haut de la pile (skip l'adresse de retour de cette fonction et de celle appelante, l'instruction)
$221f:Compare au token de FOR
$2221:Si différent, retourne immédiatement
$2238/stx_err_prt

$223b/divbyzero:Affiche une erreur "Division par Zéro".
$223e/missfor:Affiche une erreur "NEXT sans FOR"
$2241/redim:Affiche une erreur "Tableau redimensionné"
$2244/undeffn:Affiche une erreur "Fonction utilisateur non définie"
$2247/overflow:Affiche une erreur "Dépassement de capacité"
$224a/missing_op:Affiche une erreur "Opérande manquante"
$224d/wrong_op:Affiche une erreur "Opérande mal adaptée"
$2250:Affiche une erreur "Device not supported"



$2293:Affiche Ok!

$2250/no_device/code:Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.
$2252/error_out/above
Fonction : affiche un message d'erreur
Entrée : E contient le numéro de l'erreur
L'erreur est ensuite cherché dans la table, donc chaque message est séparé des autres par un $00

$2264/err_msg_fr
$2266:Ajoute 2 à l'erreur et prends le multiple de 2 inférieur
$226b:Saute si E est inférieur à $2b
$226f/err_loop:E est le min entre E et $2a

$2278/disp_break/above
Lorsqu'arrive directement ici, c'est pour afficher un arrêt d'exécution en ligne (curlin)
;
MS_BASIC=ERRIN

$2281:Si le numéro de ligne est 65534, alors c'est un cold start.
$2288:Il y avait un numéro de ligne, on l'affiche. Sinon fallthrough dans la loop Ok!

$228c/nok_loop:MS_BASIC=POPNOK
$228d/ok_loop/above
Reset l'imprimante, remet le curseur en début de ligne et affiche "Ok".
Puis tombe dans la boucle du moniteur.
;
MS_BASIC=PRNTOK

$2299/monitorloop
$2299:Ligne courante du BASIC à -1 ; MS_BASIC=GETCMD
$22a3:Saute si hors du mode AUTO
$22a5:Ligne courante du mode AUTO dans HL

$22ab/above
Suivant si la ligne a déjà du contenu ou pas, le mode de numérotation automatique
arrivera sur out_space ou out_loop, puis tombera dans la boucle de l'éditeur.

$22ab/out_space:Affiche le caractère espace puis continue dans la boucle BASIC
$22ae/stoploop/above
Boucle de traitement du BASIC

$22ad/out_loop:Affiche le caractère qui est dans A puis continue dans la boucle BASIC

$22b3/above
Lorsqu'on arrive ici, CR a été appuyée.
HL pointe sur l'adresse précédente le buffer en entrée, qui se termine par 0.
(Ce buffer est tout le temps basbuf en entrée normale ?)

$22b1:Lorsque monitor sort avec Carry (touche STOP), on boucle immédiatement.
$22b3:Acquisition d'un nouveau caractère depuis HL dans A
$22b5:On ne test pas avec "or a" à cause du test de Carry plus loin en $22ca. Le inc,dec n'affecte pas le Carry flag.
$22b6:Si rien n'a été entré, on repart pour un tour.
$22b8:Sauve le Carry flag.

$22bd:Si le flag d'exécution BASIC est différent de 0, branchement en 0 pour un reset de la machine. C'est le cas avec les programmes "protégés", dont l'arrêt provoque le RESET de la machine.
$22c3:DE contient soit un numéro de ligne, soit 0.

$22c7:En fin de tokenisation, A == 0, donc B prend 0 aussi (ou plutôt, A contient la longueur de la ligne tokenisée ??? Ou bien est-ce C ???)
$22c8:Récupération du numéro de ligne dans D
$22c9:Récupération du AF de $22b8
$22ca:Carry est set lorsqu'il y avait un numéro de ligne. Dans le cas contraire, exécution immediate.

$22cd:Push numéro de ligne
$22ce:Push de C qui contient la taille du résultat de tokenisation (B = 0 depuis $22c7)
$22cf:Push de l'adresse de tokenisation (un octet avant)

$22d3:Incrément du mode AUTO. DE contenait la ligne décodée, HL contient la ligne suivante.

$22d7/line_record:Récupération de l'adresse de tokenisation
$22d8:Et du prochain token à décoder
$22da:Préparation et sauvegarde d'un test sur le token récupéré
$22de:Le numéro de ligne qui était dans DE (le numéro de la ligne en cours) a été trouvé.

$22e2:Si le caractère récupéré était NUL, alors on sort vers le moniteur. En effet, si la ligne n'existait pas et qu'il n'y a rien à y encoder, on ne fait rien.
$22e5:Pourquoi refaire un "or a,a" ici ? Il faut apparamment clearer le Carry flag
$22e6:BC contient l'adresse de la ligne trouvée.
$22e7:Saut si on ne vient pas $22de directement. Autrement dit, si la ligne courante n'a pas été trouvée.

$22e6/prev_found:Sauvegarde dans la pile de l'adresse de ligne précédente trouvée
$22e9:DE=adresse de la ligne suivante à celle trouvée
$22ea:HL=pointeur de la zone des variables
$22ed/erase_line:Copie de la zone depuis la ligne suivante à celle trouvée jusqu'à l'adresse de la ligne trouvée. Autrement dit, on écrase la ligne courante. Ce qui invalide au passage tous les pointeurs de chaînage.
$22f2:Boucle pour la copie
$22f6:Ajustement de la nouvelle valeur de (vartab) (comme étant la dernière adresse recopiée dans le bloc précédent)

$22f9/prev_nfound
$22f9:Récupération de l'adresse initiale de la ligne trouvée (avant déplacement)
$22fa:Récupération du résultat du test du token sauvé en $22e1 (fait en $22d9)
$22fd:HL pointe sur l'adresse des variables
$2300:Récupération dans HL de la taille de la tokenisation
$2301:Récupération dans BC de l'adresse des variables (vartab)
$2302:HL contient la nouvelle valeur voulue pour (vartab)
$2303:Sauvegarde de cette valeur
$2304:Déplacement du bloc text vers le haut de la mémoire pour faire la place nécessaire à la ligne qui arrive (avec vérification que HL n'a pas touché la stack, sinon, erreur)
$2307:Récupération de la valeur voulue pour (vartab)
$2308:Et mise à jour de (vartab)
$230b:Récupération dans HL de l'adresse de la ligne
$230c:Mise en place de la première partie de l'adresse de chaînage (nécessaire pour éviter que le chaînage ne soit NUL plus tard et confondre avec la fin de chaîne)
$230d:DE récupère le numéro de ligne
$2313:Placement du numéro de ligne, HL pointe sur le début du contenu de la ligne (qui n'est pas encore là)
$2314:Sauvegarde du pointeur de contenu
$2315:HL pointe sur le buffer de tokenisation

$2318/cpy_line:Commence la copie du contenu de la ligne
$231b:Cas spécial pour les valeurs numériques sur 16 bits
$2321:La copie des deux octets des valeurs numériques

$2325/cpy_not_num
$2326:Continue la copie tant que la valeur n'est pas zéro. En sortie de boucle, la ligne a été insérée dans la partie texte.

$2328/line_empty:Saut si la ligne est vide

$232b:HL pointe sur (txttab)
$232c:DE pointe sur (txttab)

$232d/make_chain
$232e:HL <- DE
$2332:Si le chaînage est NUL, retour au moniteur (d'où l'intérêt de mettre une valeur temporaire dans le chaînage)
$2335:HL pointe sur le numéro de ligne
$2336/skip_2bytes
$2337:Saut du numéro de ligne
$2338/adv_1byte
$2339:Copie dans A de la valeur et avancée du pointeur
$233c:Si on est sur un marqueur de valeur numérique entière, on saute deux octets (en profitant du saut du numero de ligne)
$233f:Si l'octet n'est pas NUL, on continue
$2341:Fin de ligne. On reprend dans HL le pointeur de la ligne précédente (DE en début de boucle)
$2344:Placement dans le chaînage de la ligne précédente du pointeur de ligne actuel


$236b/tokenize/above
Fonction : effectue la tokenisation du buffer d'entrée (HL) vers BASBUF
Entrée : HL pointe vers le contenu à traiter
Sortie : C contient la taille du résultat de tokenisation en octets (?)
;
MS_BASIC=CRUNCH

$236c:Le flag est à 0 pour signaler la tokenisation
$2371:DE pointe sur le buffer de tokenisation
$2374/analyze
$2374:Récupération dans A du caractère à traiter
$2377:Est-ce un espace ?
$237a:B contient le caractère aussi
$237d:Sont-ce des guillemets ?
$2381:Est-ce NUL ?
$2387:Préparation du test de flag de tokenisation
$2388:A est à nouveau le caractère à l'étude
$2389:Si on est hors tokenisation, on saute.
$2390:Est-ce que le caractère est '?' ? A est préchargé avec $94 dans ce cas. Raccourci vers l'instruction PRINT.
$2393:A est à nouveau le caractère à l'étude
$2398:Est-ce que le caractère est '…' ? A est préchargé avec $AF dans ce cas. Raccourci vers DISK (est-ce vraiment utilisé, DISK est vectorisée ?)
$239b:A est à nouveau le caractère à l'étude
$239e:Est-ce inférieur à '0' ?
$23a2:Est-ce inférieur à '<' ? (les chiffres et ':' et ';' ne sont pas tokenisés)

$23a5/specialchr
$23a5:Ici, A contient tout caractère hors chiffre et ':; "?…\0'. Et le flag de tokenisation est à 0 (donc, actif). DE, qui contient le buffer de tokenisation, est sauvé sur la pile.

$23a6:DE contient le début du buffer des mots clés du BASIC -1 (car le traitement commence par augmenter le pointeur)
$23a9:Pourquoi sauve-t-on BC ?
$23aa:BC contient $244b
$23ad:BC est sauvé sur la pile, ce qui provoquera la sortie à cette adresse si le token n'est pas trouvé
$23ae:B contient $7F et sera incrémenté avec chaque token étudié. Le premier token a donc pour numéro $80
$23b0:A est à nouveau le caractère à l'étude
$23b3:Est-ce inférieur à 'a' ?
$23b7:Est-ce supérieur à 'z' ?
$23b9:Passage en majuscule
$23bb:Mise dans le buffer de la lettre passée en majuscule
$23bc/notlowerchr
$23bc:C contient le caractère à traiter
$23bd:HL pointe sur le buffer de keywords - 1
$23be/nextkeyword
$23c0:Boucle jusqu'au premier caractère avec un bit de poids fort à 1 (cela indique le début d'un mot)
$23c3:Augmenter l'index de mot-clé
$23c5:A contient le premier caractère de la table des mots clé, sur 7 bits (nécessaire pour enlever le marqueur de début de mot)
$23c7:Si égal à NUL, alors la fin du buffer est atteinte, on sort. Comme tokennotfound est actuellement en haut de pile, c'est vers là que l'on sort.
$23c9:Si le caractère à traiter et celui du mot-clé sont différent, on cherche le mot clé suivant
$23cb:Le pointeur sur le mot clé à traité est mis dans DE. HL contient à nouveau l'adresse du buffer en traitement.
$23cd/strcmpkw
$23d0:Puisqu'on atteint un nouveau marqueur de mot clé, c'est que le match a été fait correctement.
$23d3:C contient le caractère courant dans le buffer des mots clé
$23d4:A contient le caractère du buffer d'entrée à traiter
$23d5:Marqueur pour ?
$23d9:Marqueur pour ?

$23dd/marker_1:Lecture du caractère suivant pour l'oublier (le marqueur $8c ou $88)
$23df/marker_2
$23e0:Lecture d'un nouveau caractère.
$23e7/notlower2

$23e5:Passage en majuscule (voir $23b9), mais on ne vérifie pas le supérieur à 'z' cette fois. En effet, seuls les caractères alphabétiques matcherons un mot clé de toute façon.
$23e8:Pour le moment, ça match, on continue.
$23eb:Ça ne matche pas, on essaie le mot clé suivant après avoir récupéré le pointeur vers la chaîne à traiter depuis son début de mot…

$23ed/foundkeyw
$23ee:Pop de HL l'adresse du début du mot
$23ef:Pop de l'adresse de retour 'tokennotfound'

$23f0:A contient le token
$23f3:Saut si le token est $88 (GOTO)
$23f7:Saut si le token est $8c (GOSUB)
$23fb:Saut si le token est $8b (RESTORE)
$23ff:Saut si le token n'est pas $b6 (???)

$2401/test_number:Vérifie s'il y a un paramètre nombre derrière l'instruction
$2404:Ce qui suit n'est pas un nombre, on considère qu'il n'y a pas de paramètre.

$2406:Sauvegarde du HL courant dans DE
$2407:pop IY ?!!! (on doit en être à la sauvegarde de BC)
$2409:Pop de la valeur de DE en $23a5, qui pointe sur le buffer de tokenisation

$240a/dec_number
$240a:On place le token dans le buffer de tokenisation.
$240b:On récupère et on sauve DE, qui pointe sur la zone à parser.
$240d:Échange des registres secondaires.
$240e:Récupération dans HL de la zone à parser.
$240f:Remise dans la pile de l'adresse de la zone à parser.
$2410:Tentative de récupération d'un numéro de ligne.
$2415:Si le numéro de ligne est 0 (ligne invalide), on sort.
$2417:Récupération dans BC de la zone à parser (pour remettre la pile en état)
$2418:Octet bas du numéro de ligne dans A (exx n'echange pas AF, on garde donc une partie de numéro de ligne, voir plus loin)
$241a:Mise dans la pile dans l'adresse de décodage ajustée
$241b:On repasse au registre primaires
$241c:On récupère dans DE le pointeur à parser.
$241a:On incrémente le pointeur de la zone de tokenisation
$241e:On annote avec $0e pour indiquer qu'un paramètre suit.
$2421:Placement de la première partie du numéro de ligne
$2424:Récupération de la seconde partie du numéro de ligne
$2426:La seconde partie du numéro de ligne est placée dans C
$242b:Hein ???

$242d/miss_line
$242e:DE doit toujours être supérieur à HL, sinon, c'est qu'il n'y avait pas d'opérande lorsqu'une était attendue (vérifier)
$2431:HL contient le buffer à parser, DE le buffer tokenisé en cours.
$2432:Sauvegarde du pointeur de parsing en cours
$2433:Lecture du caractère suivant.
$2434:DE=buffer à parser, HL=buffer tokenisé
$2435:Comparaison du dernier caractère lu avec $2ca (virgule ',')
$2437:Si pas de virgule, c'est terminé
$2439:Sinon, on place la deuxième partie du numéro de ligne dans le buffer tokenisé
$243a:Puis passage à l'emplacement suivant dans le buffer tokenisé
$243b:Mais que pointe iy ?
$243d:C contient maintenance $2c (virgule), préparer pour être copié à la prochaine itération.
$243f:Pop de l'adresse de parsing (pour balance)

$2442/invalid_lin
$2447/token_end
$2447:DE recupère le pointeur de parsing final
$2448:Sauvegarde du pointeur tokenisé
$2449:Sauvegarde de IY... ?

$244b/tokennotfound/above
Arrivée ici que la tokenisation échoue ou réussie.

$244b:HL pointe à nouveau sur le buffer en entrée

$244c/tokencomplete
$244c:Récupération du caractère dans A. Dans le cas où l'on a réussi la tokenisation, C contient le token. Dans le cas où l'on a décodé un numéro de ligne, C contient la deuxième partie (haute) du numéro.

$244d:Nettoyage de la pile
$244e:DE pointe sur la partie tokenizée

$244f/no_token

$2450:Recopie du caractère actuel (ou du token ?) dans la partie tokenisée
$2451:Passage à l'adresse suivante dans le buffer tokenisé
$2452:Pourquoi agumenter C ? (vérifier suivant arrivée par no_token ou autre cas)
$2455:Saut si A est égal à ':'

$2457:Avec la soustraction précédente, cela fait que l'on compare le caractère à $83
$2459:Saut si le caractère n'est pas le marqueur $83 (qui est ?)

$245b/is_colon:A est forcément égal à 0. On passe en tokenisation.

$245e/not_83
$245e:Avec la soustraction précédente, cela fait que l'on compare le caractère à $8E
$2460:Saut si le caractère n'est pas le marqueur $8E (qui est ?) pour une nouvelle analyze de token

$2464/trailing:Recopie le reste de la chaîne à traiter
$2466:Sort si le caractère à parser est NUL
$2469:Saute si le caractère nouveau est identique au précédent (qui a été soustrait !)
$246c:Copie le caractère nouveau dans le buffer de tokenisation
$246d:Augmente C (pourquoi ?)
$246e:Augmenter le pointeur de buffer de tokenisation


$246b/ifquote
$2471/ifnul/above
Arrive ici lorsque la chaîne a été complètement parsée.

$2471:HL est placé juste avant le buffer de traitement
$2474:DE pointe sur la fin du buffer tokenizé. Comme A contient 0, le buffer est terminé par trois 0.
$2479:Fin de la fonction de tokenisation

$24ea/end_of_inst/code/above
Recherche l'instruction suivante
;
MS_BASIC=RUNCNT

$247A/inst_for/code

$24f1:Comparaison avec ':'
$24f3:Il y a une autre instruction à exécuter
$24f6:HL doit pointer sur le NUL de fin de ligne ou bien ':'. Si ce n'est pas le cas, c'est une erreur de syntaxe (l'instruction n'a pas tout consommé)
$24fc:La dernière ligne chaine sur l'adresse de ligne $0000. C'est ce qu'on lit ici.
$24fd:Saut si on est sur la dernière ligne du programme (l'adresse de ligne suivante était $0000)

$2504:HL contient le numéro de ligne, DE contient le pointeur sur le contenu de la ligne BASIC
$2505:Enregistrement du numéro de la ligne courante
$2508:Récupération dans HL du pointeur sur le contenu de la ligne BASIC

//-----------------
$2509/exec_token
$2509:Récupère le première token du buffer ; MS_BASIC=EXECUTE
$250d:Met sur la pile une adresse de retour qui est "end_of_inst"
$250e/retz
$250e:Retourne en "end_of_inst" si le caractère du buffer est NUL, c'est-à-dire que le contenu de la ligne était vide (':' en fin de ligne principalement ? Protection contre une ligne vide ?)
$250f:Les tokens sont tous supérieurs à $80
$2511:Si la soustraction a provoqué un Carry, alors ce n'était pas un token. Exécute par défaut l'assignation de variable.
$2516:Si le token est supérieur à $32 (les 50 premiers token sont des instructions, suivent les fonctions dont les 16 premieres n'ont pas d'adresse), affiche une Erreur de Syntaxe.
$2519:Le token est multiplié par 2
$251a:puis stocké dans C
$251b:B est à 0, donc BC contient le numéro de token * 2
$251d:Sauvegarde de HL dans DE
$251e:HL est chargé avec la table des adresses d'instructions
$2521:HL contient le pointeur adresse d'execution de l'instruction tokenisée
$2524:BC contient l'adresse d'execution de l'instruction tokenisée
$2525:L'adresse est mise sur la pile
$2526:Récupération de l'adresse en cours du buffer tokenisé (cf. $251d)


$2527/skipch/above
Fonction: recupère le caractère suivant du pointeur HL
Retourne immédiatement si le caractère est superieur à $3a avec NC
sinon, fallthrough dans chget_2
Retourne avec Z set si le caractère lu était NUL
Retourne avec C set si 
;
La fonction est à la suite du décodage de token, ce qui permet d'avancer le pointeur directement.
"RET" signifie donc aussi dans ce contexte un saut à l'adresse de l'instruction.


$252c/chget_2/above
Suite du traitement de chget.
A contient le caractère lu dans le buffer, qui est inférieur ou égal à $3a

$252e:Se positionne sur le premier caractère qui n'est pas un espace et est inférieur ou égal à '9'
$2530:Si le caractère est supérieur à ' ', saut plus loin
$2534:Saute si le caractère est entre 0F et 1F (une partie des caractères de contrôle)
$2538:Saute si le caractère est inférieur à 0D (une autre partie des caractères de contrôle, dont 0)
$253a:Reste les cas 0D et 0E. Dans ce cas, le pointeur d'execution + 3 est sauvé dans (contxt) puis HL est restauré.

$2542/chget_3
$2543:Ce RET branchera sur l'instruction à exécuter si un token a été décodé. Si appel depuis RST, retourne normalement avec le flag Z si A était à NUL. Cela signifie aussi que les exécution d'instruction arrivent avec Z=1 si le caractère lu après le token est NUL (modulo le recalage précédent)

$2544/chget_4
$2544:Compare avec '0'
$2546:Inverse la retenue. Donc le flag C sera mis si le caractère est supérieur ou égal à '0' (donc un chiffre).
$2548:Manipulation de A pour setter Z si A était NUL

$254a/num_read/above
Lecture d'un nombre depuis une chaine pointée par HL.
Ce nombre doit être entre 0 et 32767. (avec un parsing tel que str_to_num, on parse un FP)
Sortie dans DE.
Une structure récurante est d'appeler frnum_impl puis deint_impl, pour récupérer un entier de -32768 à 32767
(la vérification du signe est "évitée")
;
MS_BASIC=FPSINT

$254b/pos_int/above
Lecture d'un nombre dans DE
MS_BASIC=POSINT

$254e/dep_int:MS_BASIC=DEPINT
$254f:Erreur si le nombre est négatif

$2552/deint_impl
$2552:Récupère l'exposant
$2555:Et le compare à $80+16 (donc 16).
$2557:Si l'exposant est ok, on convertie en INT.
$255a:Limite haute: -32768
$2566:Si dans le range, retour. Sinon, fallthrough dans l'erreur

$2567/ill_call
$2569:Affichage "Illegal function call"

$256c/get_lin_num/above
Fonction : sur la ligne pointée par HL, récupère le paramètre numérique sur 16 bits dans DE
Sortie : le paramètre dans DE. Le dernier caractère pointé dans A.
Le numéro de ligne maximum est limité par le test avec $1998 (6552). Ce nombre est multiplié par 10
avant la dernière addition. Ce qui porte le numéro maximum de ligne à 65529. Au delà, le parsing
sera étrange. Par exemple 65530 sera compris comme : ligne 6553, qui contient '0'.
Le caractère $OE sert de marqueur pour récupérer une valeur 16 bits entière directement dans le buffer.
;
MS_BASIC=ATOH ; ASCII to HEX?

$256d/get_lin_nu2:Accès sans recalage de HL

$2570:Si le caractère actuel du buffer n'est pas $OE (shift out), branchement
$2575:Sinon, récupération du nombre entier sur 16 bits dans DE
$2576:Puis lecture du caractère dans A

$257d:Si le caractère n'était pas un chiffre, retour immédiat

$2578/not_oe
$2579:Initialise le résultat à 0

$257c/num_decode:La boucle décode une valeur numérique depuis sa forme ASCII. Le nombre maximum est $1998 (6552)
$2583:Comparaison de DE (résultat) avec HL ($1998 = 6552).
$2584:Si DE est supérieur à HL, saut

$2588:HL <- DE * 2
$2589:HL <- DE * 4
$258a:HL <- DE * 5
$258b:HL <- DE * 10. Au final, HL contient le résultat précédent multiplié par 10.
$258d:Transposition du caractère "chiffre" en sa valeur entre 0 et 9
$2592:Ajout au résultat de la valeur de chiffre décodée.
$2593:DE contient à présent le résultat précédent multiplié par 10 plus le nouveau chiffre.

$2597/num_dec_end

$25a9/above
Instrution : GOSUB

$25ae:Récupère l'adresse de retour dans BC
$25b0:Sauve le pointeur d'exécution HL une fois, puis réserve un emplacement en haut de la pile (peu importe le contenu)
$25b1:HL contient la ligne courante
$25b4:Met le numéro de la ligne courante au sommet de la pile
$25b7:Place un marqueur sur la pile ($8c, qui est le token d'exécution de GOSUB)
$25b8:Ajuste la pile pour ne pas enregistrer la partie F de AF.
$25b9:Remet l'adresse de retour sur la pile, puis enchaîne sur GOTO. Instruction partagée avec RUN pour lancer un programme.

$25b9/inst_run_2

$25ba/above
Instrution : GOTO

$25bd:Le reste de la liste ne peut pas être atteint, on ignore donc tout
$25c1:Le pointeur sur l'éxecution de la ligne suivante est mis sur la pile. Pourquoi???

$25ba:DE contient l'argument (numéro de ligne)
$252c:HL contient la ligne courante exécutée
$25c5:C si DE supérieur à HL
$25c7:Saute si le numéro de ligne du GOTO est au-delà de la ligne courante
$25ca:Saute si le numéro de ligne du GOTO est avant la ligne courante
$25d0:Retour en cas de ligne trouvée (HL pointe sur l'octet avant la ligne courante)

$25d1/udef_line
$25d3:Erreur "Undefined line number"

$234d/line_search_lp
$2347/line_search/above
Chercher la ligne de BASIC à exécuter, présent dans DE
En sortie, si Carry Flag est levé, alors HL contient le pointeur vers la ligne de BASIC trouvée.
Si Carry Flag est reset, alors la ligne n'a pas été trouvée. BC contient le pointeur vers la ligne de numéro inférieur à celui cherché. HL contient la ligne suivante à celle pointée par BC.
(prelin) contient toujours le pointeur vers la ligne cherchée précédemment.
;
MS_BASIC=SRCHLN

$234a:HL contient la première adresse du listing BASIC
$234d:Met la dernière ligne trouvée dans (prelin) ; MS_BASIC=SRCHLP
$2352:HL dans BC
$2356:A contient le OR des deux premier octets de la ligne actuelle (HL n'est pas touché)
$2357:Retour immédiat si A est à 0 (fin des liens)
$2359:Pointe HL deux octets plus loin
$235d:Lecture de la valeur pointée par HL dans HL. C'est le numéro de la ligne.
$235e:Comparaison de HL (numéro de ligne considérée) et DE (numéro de ligne recherchée)
$2360:BC dans HL (le pointeur sur la ligne qui avait été sauvé)
$2364:Lecture dans HL de la valeur pointées par HL. C'est le pointeur vers la ligne suivante.
$2365:Inverse la retenue. Dans le cas Z, C n'est pas mis, et du coup le set, ce qui indique que la recherche a réussi.
$2366:Retour immédiat si la ligne considérée était celle cherchée.
$2367:Inverse la retenue. La remet donc à l'état du test précédent (de_compare)
$2368:Retour immédiat si HL > DE dans le test de ligne (on a dépassé la ligne sans la trouver)
$2369:Retour en début de recherche

$25d6/above
Instruction : RETURN

$25d6:S'il y a des choses après le RETURN, retour immédiat. Return n'a pas de paramètre.
$25dc:Ajuste la pile à la valeur calculée par marker_vrfy. Ce qui remet la pile avant le marqueur (au passage, on n'a plus l'adresse de retour de l'appel à l'instruction en cours). Cela a aussi pour effet d'enlever tous les contextes sur la pile, comme les FOR (uniquement les FOR ?)
$25dd:Vérification du marqueur placé par GOSUB
$25e1:S'il n'est pas là, lancement d'une erreur "RETURN without GOSUB"
$25e5:Récuération de l'adresse de la ligne appelante et sauvegarde dans (curlin)
$25eb:Si on était en mode direct, HL est à $FFFF et donc fallthrough. Sinon, on saute plus loin, on était dans un programme... Mais sur cette implémentation, on ne fait rien de spécial. Ce qui permet un `RETURN` en mode direct après un pending `GOSUB`
$25ed/useless_jp
$25f0:Remise en place en haut de pile de l'adresse de retour de l'instruction. La reste de la ligne est ignoré en fallthrough sur DATA.REM

$25f2/next_data:MS_BASIC=NXTDTA, un appel ici suppose que la chaîne à traiter est sur la pile. Fallthrough sur inst_data. On va donc mettre HL sur le statement ou fin de ligne suivante.

$25f3/above
Instruction DATA
En arrivant en DATA, C sera chargé avec $3e (: == end of statement)

$25f5/above
Instruction REM
En arrivant en REM, C sera chargé avec $00 (identique à la fin de ligne, donc pas de traitement particulier de ':')

$25f9/rem_ex_lp
$25fb:Swap le contenu de B et C. Donne $3a00 en venant de RETURN (ce qui signfie que l'on cherche un ':'). Cela permet de chercher temporairement " pour les chaîne de caractères en mettant le ':' de côté.
$25fc/rem_loop

$25fd:Vérifie la présence d'un argument (numérique sur 16 bits?)
$2603:S'il y a un argument, saute le marqueur et la valeur
$2604:Puis lit dans A la valeur suivante
$2605/no_param
$2606:Si la dernière valeur lue est zéro, retour immédiat. C'est la fin de la ligne.
$2607:Compare avec le caractère spécifique cherché (: ou 0 suivant si on traite REM ou DATA)
$2608:Retour immédiat si trouvé
$2609:Sinon, on passe au caractère suivant
$260a:Comparaison avec " pour une chaîne de caractères.
$260c:Si c'est $22 ('"'), on loop sur l'échange du caractère recherché
$260e:Sinon, on continue le parsing de la ligne


$2610/above
Instruction : LET
Appelé lorsque le buffer tokenisé ne contenait pas un token.

$2614:Code $C1 pour la vérification du dessus. $C1 est l'opérateur '=', ici d'assignation. Une erreur de syntaxe est émise s'il n'est pas présent.
$2615:Sauvegarde de la zone de la variable (deux octets après son identifiant)
$2616:Récupération de son type
$2619:Sauvegarde de son type
$261a:Évaluation de l'expression.
$261d:Récupération du type. HL pointe actuellement sur la suite du parsing.
$261e:Récupération dans HL de l'adresse du contenu de la variable
$261f:Cette adresse est sauvegardée dans (temp)
$2622:Mise du type de la variable dans le Carry (1 si chaîne, 0 si numérique). A est à 0.
$2623:Vérification de la compatibilité du type de l'expression et de la variable.
$2626:Saut en cas de variable numérique
$2628/let_string
$2628:Sauvegarde du pointeur vers la variable
$2629:Récupération de la valeur de l'expression
$262c:... et la sauvegarde
$2631:Adresse de la chaine dans `DE`
$2636:Saute si l'adresse de la variable est avant (txttab), autrement dit, dans un buffer temporaire. Il faut donc créer une entrée.
$263b:Vérifie si la chaîne est présente dans le programme
$263c:Récupère le pointeur sur le descripteur de chaine
$263d:Si la chaîne est dans le programme, on saute à la fin
$2643:Saute aussi si la chaîne n'est pas dans le buffer temporaire
$2645:On a déjà fait le POP DE, il est sauté

$2646/crtstrentry
$2647:Récupération de la chaîne en haut du buffer temporaire (qui est popée si elle est égale à `DE`
$264a:BC contient l'adresse du contenu de la chaîne, DE contient le pointeur vers le descripteur
$264e/pop_string
$264e:Récupération de la chaîne temporaire en haut du buffer
$2651:Récupération de l'adresse de la variable
$2652:Copie de descripteur de chaine vers la variable
$2655:Restauration du pointeur d'exécution


$2657/set_num_var

$2746/bad_input/above
Arrive ici si les données sont insuffisantes pour les variables à remplir
;
MS_BASIC=BADINP

$274a:Saute dans le cas d'un READ
$274d:Jette le pointeur de données courant
$275a/redo_fr:Affiche "Redo from scratch" en fonction de la langue

$2760/above
Instruction INPUT
;
MS_BASIC=INPUT

$2763:Appel du hook sur INPUT
$2767:S'il y a un " après INPUT, c'est qu'il y a un texte à afficher.
$2769:Efface A et laisse les flags (reste de MS pour enable output ? Pas besoin de clearer A ici... !!)
$2770:Vérifie que le caractère suivant est un ';'
$2771: ';'
$2772:Sauvegarde du pointeur d'exécution
$2773:Affiche la chaine de caractères
$2777/raw_input

$2780/prompt_2
$278e:Remet en place le contact du curseur et de l'INPUT flag

$2793/inst_input_2
$2793:Récupération du pointeur d'exécution dans BC (HL est utilisé par la ligne juste entrée pour l'INPUT)
$2794:Comme on est passé par get_line, si Carry set, c'est qu'on a appuyé sur Break. On arrête le programme.
$279a:Peek du premier caractère de la chaine pour voir s'il est NUL.
$279b:Sauvegarde du pointeur d'exécution.
$279c:Si c'était la fin de la ligne, alors on saute jusqu'au prochain statement. Les variables ne seront pas touchées.
$279f:Sinon, on place ',' comme premier caractère (avant la ligne)

$27a3/above
Instruction : READ
;
MS_BASIC=READ

$27a3:Sauvegarde du pointeur d'exécution
$27a4:Chargement de l'emplacement du prochain DATA

$27a8/read_data:MS_BASIC=NXTITM
$27a9:Si A == 0, on est dans INPUT, sinon, on est dans READ. (flginp) est donc plutôt un Flag Read?
$27ac:Met sur la pile le pointeur DATA et récupère le pointeur d'exécution.
$27ae/data_loop:Vérifie qu'il y a un ',' (sauf la première fois)
$27af:','
$27b0:Récupération de la variable (retour dans DE)
$27b3:Swap pour récupérer la ligne d'INPUT,DATA
$27b4:Sauvegarde de la variable
$27b8:Saute si le prochaine caractère de la donnée est ',' (c'est pour cela que l'INPUT est amorcé avec un ',')
$27be:Saute si on est dans le cas READ
$27c1:Il manque des données, réaffiche le prompt
$27c7:Récupération de la variable
$27c8:Récupération du pointeur d'exécution
$27c9:Traitement du break
$27cf:INPUT line vide ?
$27d0:Sauvegarde du pointeur d'exécution
$27d1:Si vide, alors statement suivant, la variable ne sera pas touchée.
$27d4:Sauvegarde de la variable

$27d5/get_value:MS_BASIC=ANTVLU
$27d9:Saute si la variable est de type numérique ; Si la donnée et le variable ne correspondent pas, que se passe-t-il ???
$27db:Récupération du prochain caractère
$27dd:Sauvegarde du caractère dans D et B
$27e0:Saute si le premier caractère est "

$27e5:A == 0 si on est dans INPUT
$27e6:Dans ce cas, D contiendra 0, sinon, D sera fixé en $27e9
$27e9:En cas de READ, D est ':'

$27eb/data_sep:B == ',', séparateur des données
$27ed:Remise en place de HL sur le premier caractère dans le cas où il n'était pas "

$27ee/lit_string:Au final, B et D contiennent des séparateurs de données, et HL est sur la première position intéressante. Récupération de la chaine.

$27f1:DE <- adresse de la chaine de caractères.
$27f5:Branchement pour le RET
$27f6:Sauvegarde de la chaine de caractères de données
$27f7:Tout est prêt pour l'assignation de la variable alphanumérique. Le retour se fera à l'adresse juste spécifiée.

$27fa/num_data
$27fb:Transformation de la donnée en nombre
$27fe:Sauve le pointeur de données, récupération de la variable
$27ff:Assignation de la variable (par copie du buffer flottant vers HL, qui est le contenu de la variable)
$2802:Récupération du pointeur de données.

$2803/next_comma
$2805:Saute si le buffer données est vide
$2809:Saute si le caractère suivant n'est pas ","
$280c/empty_data
$280c:HL <- pointeur d'exécution. Pointeur DATA sur la pile
$280d:Recalage
$280f:Saute s'il reste du contenu dans la paramètres d'INPUT ou de READ
$2811:Récupération du pointeur DATA
$2815:Est-ce qu'on est dans INPUT (== 0) ou READ ?
$2816:Échange de DATA et d'exécution
$2817:Mise à jour du pointeur de DATA pour les prochains READ
$281a:Sauvegarde du pointeur d'exécution
$281b:Est-ce qu'il restait des choses dans les données pour INPUT ?

$2829/ignore_fr
$282a:Si oui, on affiche que le reste est ignoré (après restauration des flags)
$282d:Restauration du pointeur d'exécution

$282f/go_nxt_data:MS_BASIC=FDTLP ; Va à la prochaine instruction
$2832:Test de fin de ligne
$2833:Saute si ce n'est pas la fin de la ligne
$2838:On est à la fin de la ligne, est-ce que la ligne suivante est NUL ?
$283b:Si oui, sors avec "Out of DATA"

$2846/test_data
$2847:Compare avec le token DATA
$2849:Saute si ce n'est pas une instruction DATA pour aller chercher plus loin
$284b:On a trouvé la prochaine donnée, on peut aller l'assigner à la variable
$2842:Sinon, charge la ligne de DATA courante. Il y a ici in EX HL,DE dans MS_BASIC, que se passe-t-il ???

$284d/eval_num_ex/above
Fonction : Evalue une expression et vérifie que le résultat est numérique.

$2850/type_eq_num/above
Fonction: vérifie que le type évalué est de type numérique.
Le OR A,$37 va faire un clear Carry et sauter le Set Carry du test de type chaîne

$2851/type_eq_str/above
Fonction: vérifie que le type évalué est une chaine de caractère


$2852/type_eq_chk/above
Fonction: vérifie que deux types sont égaux
Entrée: Carry flag pour l'un des deux types, (valtyp) pour le second
Sortie: Retour en cas de parité paire, c'est-à-dire si Carry et (valtype) sont égaux.
Sinon, branche sur "Opérande mal adapté"

$285f/paren_expr/above
Fonction appelée récursivement par l'évaluation commencée par read_expr.
Commence par vérifier la présence d'une parenthèse ouvrante puis continue l'évaluation.
Il n'y a pas de partial instruction en $2860, c'est uniquement le paramètre de chkchr

$2860:Vérifie la parenthèse ouvrante

$2861/read_expr/above
Lecture et évaluation d'une expression
À chaque parsing, est mis sur la pile l'adresse de l'opérande, suivi du FP (BCDE), suivi du retour en eval_2 (qui sera exécuté par le RET dans l'opérande)
Cela forme une liste de commandes à exécuter lorsqu'un bloc est évalué.
Lorsqu'un opérateur de plus faible priorité est trouvé, le RET NC permet de faire un saut vers l'adresse d'exécution de l'opérateur, qui trouvera son
paramètre sur la pile, suivi de l'adresse de retour en eval_2, qui considère que l'accumulateur FP est rempli (et contient donc l'évaluation).
;
MS_BASIC=EVAL

$2862:La priorité est stockée dans D.

$2864/eval_1
$2864:Sauvegarde de la priorité

$2867:Vérification qu'il est possible d'ajouter 1 niveau (C) sur la pile
$286a:Attention, la lecture de caractère via RST $10 commence par un INC HL, les opérateurs sont donc 'ignorés' naturellement à ce niveau du parsing. D'où aussi la nécessité du DEC HL en début de fonction
$286d:Sauvegarde de l'adresse de parsing courante

$2870/eval_2
$2870:Récupération de l'adresse de parsing courante
$2873:Récupération de la priorité
$2875:Comparaison avec la priorité de AND et OR
$2877:Si ce n'est pas AND et OR (la priorité est au moins à $78), vérification que l'on veut un type numérique. Si on revient, c'est que c'était le cas
$287a:Récupération dans A de l'opérateur suivant (ou de la fonction)
$287b:Sauvegarde de l'adresse de parsing courante
$287e:$b9 est le token pour '+', qui est aussi le premier token qui n'est pas une instruction (les opérateurs)
$2880:Retour si ce qui est parsé est avant le '+', donc ne faisant plus partie de l'expression
$2881:$c3 est le code de SGN, la première fonction prédéfinie. 
$2883:Si c'est une fonction ou ensuite, ce n'est pas un opérateur, on sort de l'évaluation.
$2884: $c0 '>' $c1 '=' $c2 '<'
$2886:Saute si '>' ou au-delà
$2888:Index de l'opérateur (en commençant par '+' comme 0)
$288a:Sauvegarde de l'index dans E
$288b:Saute si l'opérateur n'est pas '+'
$2891:Récupération de l'index de l'opérateur sauvé en $288a
$2892:Si la valeur est une chaîne de caractères, on saute (concatenation de chaînes)

$288d/no_call
$288d:Il n'y a pas d'appel ici, c'est l'appelant qui est un "skip"
$2890:Type de la valeur : -1=num 0=string

$2895/not_plus
$2897:Index de l'opérateur multiplié par 3 dans E
$2898:Charge la table des priorités
$289d:Indexation dans la table
$289e:Sauvegarde de la priorité courante
$289f:Récupération de la priorité du nouvel opérateur
$28a0:Comparaison des priorités
$28a1:Si la nouvelle priorité est plus petite, on sort (== on saute à l'adresse de l'opérateur sur la pile)
$28a2:Sinon, HL pointe sur l'adresse de l'opérateur
$28a3:On vérifie que l'on a affaire à un type numérique (encore ???)
$28a6:Sauvegarde de B (précédente actuelle) et C (???)
$28aa:Sauvegarde de l'adresse de retour lorsque l'expression de cette priorité sortira
$28ab:Sauve l'index dans la table de priorité
$28ad:Monte la valeur FP sur la pile
$28b1:Restaure l'index dans la table de priorité
$28b4:Récupération de l'adresse de l'opérateur dans BC
$28b6:Qui est mis sur la pile
$28b7:Restauration du pointeur de parsing
$28ba:On continue le parsing jusqu'á sortir de la priorité courante

$28bd/above
Lorsque l'on arrive ici, A contient > = <
Il s'agit de chercher un motif d'opérateur de comparaison composé.

$28bf/comp_loop
$28c1:Saut si A est avant >
$28c6:Saut si A est après <
$28c9:Est-ce '=' ?
$28cb:> donne b11, = donne b10, < donne b00
$28cc:À la première boucle, A n'est pas changé (D == 0). En deuxième boucle, tous les doublons (>>, << et ==) donnent b00, <= et => donnent b01, >= et => donnent b10
$28ce:Le premier caractère est mis dans D
$28cf:À la première boucle, A ne peut pas être inférieur à D.
$28d2:Le pointeur de parsing est ajusté (à la deuxième boucle surtout)
$28d5:Lecture du caractère suivant

$28bd/eval_comp

$28d8/parse_value/above
Fonction: parse une valeur depuis HL+1. Cette valeur peut être numérique, alphanum ou bien une fonction
prédéfinie ou utilisateur.
;
MS_BASIC=OPRND

$28d9:On cherche un type numérique par défaut
$28dc:Lecture du prochain caractère (non blanc, numérique, essayer avec INIT ABC ?)
$28dd:Saute dans le cas où le caractère est NUL
$28e0:Saute dans le cas où le caractère est un chiffre.
$28e3:Caractère '&'
$28e5:Saut si sur le point de parser un nombre en hexa
$28eb:Saut si la valeur est entre A et Z (on va chercher une variable)
$28ed:Token pour '+'
$28ef:La valeur commence par un '+', on ignore et on relance le parsing
$28f1:Caractère '.'
$28f3:C'est un nombre (flottant)
$28f6:Token pour '-'
$28f8:Saut pour prendre l'opposé du parsing
$28fa:Caractère '"'
$28fc:C'est une chaîne de caractères délimité par "
$28ff:Token pour 'NOT'
$2901:Saute å l'évaluation d'un NOT
$2904:Token pour 'FN'
$2906:Saute à l'évaluation d'une fonction utilisateur
$2909:Token pour 'SGN', la première des fonctions
$290b:Saute á l'évaluation d'une fonction prédéfinie

$290d/eval_paren
$290d:Cas de la sous-expression entre parenthèses, qui est le dernier choix possible. Pour cela, on lance une évaluation de sous expression qui commencera par vérifier l'existence de cette parenthèse.
$2911:Caractère ')' pour le check du-dessus. Donc erreur de syntaxe si une parenthèse fermante n'est pas trouvée.
$2912:À ce niveau là, la sous-expression est dans l'accumulateur FP.

$2913/str_to_min
$2913:Un '-' comme opérateur unaire doit s'évaluer sur ce qui suit. Charge la précédence de l'opérateur.
$2915:Puis évalue l'expression. Qui sortira lorsque la précédence sera moins forte
$2918:Récupération de l'adresse de parsing du prochain opérateur
$291b:Que l'on sauve
$291c:Le temps d'inverser le signe de ce que contient FP

$291f/ret_num
$291f:Et de vérifier que l'on a bien affaire à un type numérique
$2922:Restauration du pointeur d'exécution

$2924/str_to_var/above
Récupère la valeur d'une variable lors d'une évaluation.

$2927/from_eval

$2924:Récupère l'adresse de la variable dans DE
$2927:Sauve le contexte
$2928:HL prend l'adresse de la variable
$2929:Sauve l'adresse de la variable
$2930:Appel si le type de la variable est numérique (pour mettre sa valeur dans FP)
$2933:Restaure le contexte

$2935/str_to_func/above
Exécute le code d'une fonction interne lors de l'évaluation d'une expression
En entrée, A contient l'index de la fonction (token soustrait du token de la première fonction)
;
MS_BASIC=FNOFST

$2937:Double l'index de la fonction
$2938:Avec B mis à 0, BC contient l'index doublé de la fonction
$2939:Que l'on sauve
$293a:Saute la '(' qui doit suivre
$293b:A <- index doublé de la fonction
$293c:Compare par rapport au token 220 (token CHR$ - token SGN, le tout * 2)
$293e:Saute si c'est une fonction qui renvoie une valeur numérique
$2940:On est dans une des fonctions renvoyant une valeur alphanumériques. Évaluation du premier paramètre.
$2944:Vérification que le caractère suivant est ','
$2945:Et que la valeur évaluée est bien alphanumérique.
$2948:Sauve le pointeur d'exécution
$2949:HL <- adresse de la chaîne évaluée
$294c:Que l'on met en haut de la pile (et récupération de l'index doublé)
$294d:Push de l'index doublé
$294e:HL <- pointeur d'exécution
$294f:Récupération d'un entier sur 8 bits (dans A et DE)
$2952:Pointeur d'exécution dans DE, HL <- l'int récupéré
$2953:HL <- index doublé, en haut de pile, l'entier du second paramètre

$2956/num_func:Évaluation du paramètre de la fonction (qui est donc dans FP)
$2959:HL <- index doublé, en haut de la pile, le pointeur d'exécution
$295d:Prépare l'adresse de retour pour le prochain RET comme retour de fonction numérique

$295e/exec_func
$2961:Pointe dans le tableau d'adresse des fonctions celle correspondant à l'index
$2965:Chargement de l'adresse dans HL
$2966:Saut à l'implémentation de la fonction interne

$2967/exp_sign/above
Retourne D == FF si le caractère dans A est - (token) ou '-', D == 0 si + (token) ou '+' avec Z flag set. Si rien trouvé, NZ (et D = 0), et HL reculé (pour recommencer le parsing)
;
MS_BASIC=SGNEXP

$2978/fp_bcde_and/code:MS_BASIC=PAND

$2977/fp_bcde_or/code/above
Execution de AND et OR. Appelé via la table de priorités.
;
MS_BASIC=PAND

$29ea/inst_fre_2

$29ef/ac_to_fp:Met A dans B, pour fallthrough dans ab_to_fp

$29f0/ab_to_fp:Met B dans D (de BADE)
$29f1:Net E à 0.
$29f6:Place 0 dans la globale valtyp, ce qui signifie que la valeur est numérique
$29f7:Exposant $80+$10


$29d3/str_to_not
$29d3:Charge la priorité pour l'opérateur NOT
$29d5:Lance une évaluation qui sortira en descente de priorité
$29d8:Vérifie le type numérique de la valeur obtenue
$29db:FP to Signed Int
$29e2:Inverse les valeurs de la mantisse (D et E) et met le résultat dans A et C
$29e3:Résultat dans FP
$29e7:Suite de l'évaluation

$2a13/above
Instruction: DEF, définition d'une fonction
;
MS_BASIC=DEF

$2a13:Vérifie que l'on a affaire à une fonction (et définie l'entrée)
$2a16:Cette instruction ne peut pas être appelé en direct
$2a1c:Prépare la valeur de retour pour aller à la prochaine instruction
$2a1d:Sauve l'adresse de la fonction (de son pointeur)
$2a1e:DE <- 0
$2a22:Caractère suivant est '(' ?
$2a24:Saute si non (il n'y a pas de paramètre, légal pour ce BASIC, même si l'appel doit quand même spécifier un argument...)
$2a26:Saute le caractère '('
$2a27:Récupère la variable en paramètre. check_fn a mis $80 dans subflg
$2a2a:Sauvegarde du pointeur d'exécution
$2a2b:HL <- pointeur sur la variable paramètre
$2a2f:DE <- nom de la variable paramètre
$2a30:HL <- pointeur d'exécution
$2a31:Vérification du type numérique (pas de fonction alphanum)
$2a35:Le caractère suivant est bien ')' ?
$2a37:Le caractère suivant est bien '=' ?
$2a39:BC <- HL (pointeur d'exec)
$2a3a:HL <- pointeur de fonction, Stack -> pointeur d'exécution
$2a3d:Le pointeur de fonction reçoit l'adresse du pointeur d'exécution au niveau de la fonction
$2a3e:DE (nom de la variable) sera mis à la suite, avant un RET


$2a36/no_param


$2a41/str_to_fn/above
Pour traiter la valeur du paramètre, c'est dans la récupération de la variable qu'un test
est fait entre le nom de la variable en cours en prmnam. Si c'est égal, alors DE est
placé sur prmval

$2a41:Vérification que l'on a bien une fonction numérique (DE prend le pointeur vers la variable)
$2a44:Sauvegarde du pointeur de fonction
$2a45:Évaluation du paramètre de la fonction
$2a48:Qui doit être numérique
$2a4b:HL <- Pointeur sur la fonction (qui contient en premier un pointeur vers le code de la fonction)
$2a4f:DE <- Pointeur sur la chaîne de code de la fonction
$2a52:Saute si le pointeur était NUL, et donc la fonction non définie
$2a58:HL <- Second paramètre de la variable, qui contient l'emplacement de la variable de fonction
$2a59:Que l'on met sur la pile
$2a5d:Sauvegarde du contenu du nom de paramètre sur la pile et échange avec l'actuel (les fonctions peuvent appeler de fonctions ???)
$2a68:Sauvegarde du contenu actuel de la valeur du paramètre
$2a6c:Sauve DE (code de la fonction)
$2a6d:Copy FP dans ce qui est pointé par HL (valeur paramètre)
$2a70:Pointeur sur le code de la fonction dans HL
$2a71:Évaluation de la fonction (qui est une expression numérique)
$2a74:Recalage du pointeur de parsing
$2a82:Remise en place de la valeur et du nom du paramètre précédent


$2a0f/retfun_impl/above
Function : met en place la valeur de retour d'une fonction
Prerequis : valeur dans A
Sortie : valeur entière dans FP

$2a87/ill_direct/above
Vérifie que la ligne courante n'est pas -1.
Si c'est le cas, lance l'erreur correspondante.
MS_BASIC=IDTEST

$2a92:Sors avec "Illegal direct"

$2a95/check_fn:Vérifie que ce qui suite est une fonction (au sens DEFFN)
$2a96:Token pour FN
$2a97:Signal à la recherche de variable que les tableaux sont interdits dans ce contexte
$2a9c:A contient le caractère suivant avec le bit 7 à 1
$2a9d:Qui est mis dans C
$2aa1:Vérification du type numérique (qui se chargera du RET)

$2aa4/preget_byte
$2aa5/getbyt_impl/above
Fonction : récupère un entier sur un octet depuis le buffer d'entrée
Entrée : HL pointe sur la zone de texte
Sortie : A contient l'entrée (ainsi que DE ?)

$2aa8/to_int

$2ab4/above
Fonction : Peek
Récupère le paramètre entier, déférence l'adresse dans A et en fait la valeur de retour

$2abb/above
Instruction : Poke

$2abe:Sauve la partie entière du paramètre (assuré d'être entier)
$2ac0:Vérifie la présence de ','
$2ac1:Récupère un octet (dans A)
$2ac5:Met A à l'adresse DE

$2ac7/why:Pourquoi ???


$2acb/get_poke_addr


$2ae4:Saute en fin de fonction si aucun caractère n'a été entré

$2ad4/acquirekey/above
Fonction: décode une touche du clavier et l'affiche à l'écran à la position du curseur.
Attends un refresh (HALT) puis scrute le clavier.
Si rien n'a été appuyé, sort immédiatement. A == 0
Si la touche a été traitée, A == 0
Quand est-ce que A != 0 ?
Sinon, traitement.

$2adf:Attente d'une interruption

$2ae8:Son lorsqu'un caractère est reçu
$2afb:Bit pour indiquer que la ligne est entrée en BASIC (quelque chose a été entré en tout cas et sera traité par le saut en $2adc)
$2aff:Si le bit de signe était 1 dans le caractère lu
$2b02:Comparaison de la touche avec ENTREE
$2b07/acquirekeyn3/above
Suite (2) du traitement de l'entrée

$2b2d/acquire_nul:Ici, la valeur acquise passe à zéro avant de sortir de la fonction

$2b2e/endacquirek
$2b32/bufferstart/above
Fonction : lorsque le bit 1 de $4871 est à 1, arrive ici pour analyse
À l'air de se positionner sur le premier caractère interessant à décoder


$2b32:Coordoonées de la ligne BASIC à décoder
$2b35:A contient la ligne
$2b36:Comparaison avec 24 (le nombre de lignes)
$2b3e:Lecture du caractère en colonne 0 de la ligne suivante
$2b44/ifabove24
$2b45:Comparaison de la colonne avec 40 (colonne max)
$2b4d:Comparaison de la colonne avec 40 (colonne max)
$2b52/ifbelow40
$2b53:Stockage des nouvelles coordonnées (ajustées comment?)
$2b5a:B contient le caractère aux coordonnées
$2b5b:DE contient les coordoonées
$2b5d:A contient le caractère aux coordonnées
$2b5e:Not carry de quoi ?
$2b62:Si ce n'est pas un espace
$2b75/ifabove40
$2bac/specialchars

$2be0/ifcr:Récupération des coordonnées du curseur

$2be9:Comparaison à $80, la caractère de début de ligne

$2be3/find_start_l
$2be3:Décrémentation de X
$2be4:Sauvegarde des coordonnées modifiées du curseur
$2be8:Récupération des coordonnées


$2b23/acquirekeyn7/above
Suite (6) du traitement de l'entrée

$2b24/acquire_sync:Attend le prochain affichage puis passe dans l'annulation de la valeur acquise et la sortie.


$2b24:Force un affichage
$2b2d:A est effacée en traitement normal de touche (et déjà 0 si pas de touche entrée)
$2b2e:Nettoyage de fin de fonction

$2ba7/acquired_cr

$2bf1:Recheche du caractère de continuation ? ($B4)
$2bf3:Boucle sur la recherche
$2bf5/linestart
$2bf7:Si on n'était pas sur la colonne 0, c'était une fausse alerte et non un vrai début de ligne, on continue à chercher.
$2bfe:Si on n'est pas en mode auto, on continue le traitement de la ligne.
$2c01:Sinon, le mode AUTO est annulé
$2c04:L'adresse du curseur mis à jour
$2c09:Le marqueur $84 (re)mis? en place
$2c0a:Et la touche acquise sera validée comme étant $0D (sans traitement)


$2c0d/find_cont:Traitement lors d'une continuation trouvée au début de la ligne
$2c0f/find_start:Remonte de ligne en ligne jusqu'au premier marqueur de non continuité (et donc à la première ligne).
$2c14:Peek du caractère en colonne 0
$2c1b:Saute si on est arrivé en haut de l'écran (H est passé à $FF)
$2c18:Test sur $84, qui est le marquage de continuité des lignes. Saut lorsqu'on ne le trouve plus. On est en tout début du ligne.
$2c1e:Boucle sur la remontée des Y

$2c20/found_start:Coordonnées placées en début de la première ligne
$2c23:Test de INPUT activé
$2c25:Traitement spécifique si le monitor était en train de traiter un INPUT
$2c2c:Recupération des coordonnées de début d'entrée
$2c33:DE contient les coordonnées de début d'entrée. HL l'adresse mémoire
$2c35:Comparaison de X avec la colonne 40
$2c4b/ifinput
$2c4e:Enregistrement du premier caractère de la ligne ($80 en mode direct)
$2c56:Set du flag pour "ligne entrée en BASIC"
$2c5d:Placement des coordonnées sur le caractère en colonne précédente (donc 0?)
$2c60/screenstart:La fonction sortira avec pour valeur acquise NUL.
$2c63/iftab
$2c89/iflinef
$2caf/ifformf


$2d76/func_keys
$2d78:Saute si la valeur est inferieure à $ba
$2d7d:Saute si la valeur est supérieure ou égale à $fb

$2d83/loop_accel:Recherche la valeur de la touche d'accélération dans le tableau
des chaînes affichées par les touches accélératrices.
$2d87/out_accel:Provoque l'affichage de la chaîne accélérée (raccourci BASIC)
$2d8a:Lorsque le bit de poids fort est 1, alors la chaîne est terminée, on sort.
$2d8d:Affichage du caractère de la chaîne en train d'être affichée.

$2d91/ctrl_keys/above
Traitement des touches de contrôle (des touches de contrôle ?)

$2d9a:A est remplacé par la valeur trouvée dans la table d'indirection à 10 entrée en $487a (comment est-elle remplie ?)

$2d9e/accel_keys



$2ead/mem_move_chk/above
Fonction : vérify la mémoire
Entrée : DE < BC < HL trois pointeurs de mémoire
Copie la zone [DE, BC] vers [DE+(HL-BC), HL] depuis la fin (permet le recouvrement)

$2eb0/mem_move

$2eb0:Mise sur la pile de la taille
$2eb2:Échange des valeurs de HL et BC
$2eb3/cpy_loop
$2eb3:Préparation de la comparaison entre HL et DE
$2eb5:Copie de (HL) vers (BC)
$2eb6:Retour si HL a atteind DE
$2eb8:Décrément de HL et BC
$2eb9:Boucle de la copie

$2ed9/reset_mem/above
Met 0 dans les deux premiers octets de txttab (donc efface l'accès au listing)
L'effet sur l'utilisateur est d'effacer le programme (mais il est encore là)
;
MS_BASIC=CLRPTR

$2edc/reset_mem_2
$2edc:appelé depuis l'instruction NEW

$3d91/reset_mem_3
$3d91:0 dans (autoflg)
$3d94:0 dans les deux premiers octets de (txttab). Cela coupe le premier lien du listing BASIC.
$2ee0/reset_mem_4
$2ee1:txttab+2 dans (vartab)
$2ee4/reset_vars:Remet à zéro les pointeurs du modèle mémoire
$2ee7:HL pointe sur l'octet avant txttab
$2ee8/init_vars:HL est mis de côté ; MS_BASIC=INTVAR
$2eeb:HL prend la valeur de memsiz
$2eee:fretop est donc mis à memsiz, cela signifie que toute la mémoire est disponible.
$2ef5:(vartab) est placé dans (arytab) et (strend). Autrement dit, élimine toutes les variables, les tableaux et les chaînes.

$2ebb/stk_verify/above
Entrée : BC (B == 0), le nombre de mots de 2 octets (des "niveaux" que l'on voudrait mettre sur la pile
S'il n'y a pas la place demandée sur la pile, provoque un message d'erreur.
La place vérifiée semble être deux fois la place demandée avec une marge de $60 octets (jamais moins
de $60 octets disponibles)
Préserve HL.
;
MS_BASIC=CHKSTK

$2ebb:Sauve le pointeur d'exécution
$2ebc:Prend la mémoire la plus basse disponible (après les chaînes?)

$2ec4/mem_verify/above
Identique à stk_verify mais fourni HL pour comparer avec la pile.
;
MS_BASIC=ENFMEM

$2ec2:Ajoute deux fois l'entrée C à strend
$2ecc:HL <- $FFA0 - HL (HL étant (strend) + 2 * C)
$2ecd:S'il n'y a pas au moins $60 octets entre la valeur désirée et $FFFF, alors il n'y a plus de mémoire (oui, c'est en dur quelque soit la mémoire présente, c'est louche)

$2ed0:Restore dans HL le pointeur d'exécution
$2ed1:Si HL + SP provoque une retenue, alors on revient, il y a assez de mémoire. Sinon, c'est qu'il y a moins de $60 octets entre la pile et (strend), il n'y a pas assez de mémoire.
$2ed2/out_of_mem
$2ed5:"Out of Memory"

$2efe/resetstack/above
Fonction : remise à zéro de la pile et effacement de l'interprétation en cours. Réinitialisation de l'imprimante.
Retour : HL contient le code de l'instruction en cours ?
;
MS_BASIC=CLREG

$2efe:Récupération de l'adresse de retour
$2eff:Réinitialisation de la pile (SP) à la dernière addresse RAM valide
$2f06:Le pointeur sur la zone temporaire de descripteur est initialisé
$2f0f:Mise à zéro de `oldtxt`
$2f12:Mise à zéro du buffer `subflg` (utilisé pour FOR)
$2f15:Mise à zéro du nom du paramètre pour les fonctions utilisateurs
$2f18:Met 0 sur la pile
$2f19:Remet l'adresse de retour sur la pile avant le RET
$2f1a:HL contient la valeur de `temp` (code d'une instruction)
$2f1a/do_again/above
Récupère le pointeur d'exécution de l'instruction en court puis termine l'instruction
en court. A priori pour la relancer (appelée depuis INPUT en cas de Redo from Scratch)
A tracer depuis le reset qui précède et depuis INPUT (??)
;
MS_BASIC=RUNFST <- Non, ça fait autre chose

$2f1e/above
Instruction : RESTORE
;
MS_BASIC=RESTORE

$2f22:Pas de paramètre, on restore depuis le début du programme
$2f2f:Si le numéro de ligne spécifié n'est pas trouvé, erreur

$2f32/restore_all:MS_BASIC=RESTNL
$2f33/set_data:MS_BASIC=UPDATA
$2f33:Sauvegarde de l'octet de la prochaine ligne de DATA

$2f3f/input_brk
$2f41:Enlève l'adresse de retour des instructions. Le programme est terminé


$2f42/end_of_prog/above
Traite la fin d'un programme
;
MS_BASIC=ENDPRG

$2f45:Sauve le status de l'arrêt. STOP a mis A <- $C0, BREAK a mis A <- $FF, et END ?

$2f49:Si la dernière ligne était FFFF, alors le A est égal à 0, saut. Nous étions en mode direct.
$2f4b:Sauve la dernière ligne exécutée si elle avait un numéro
$2f51:Sauve le dernier pointeur d'exécution concernant une ligne avec numéro. Utile pour CONT

$2f54/no_line
$2f54:Nouvelle ligne sur la sortie (et l'imprimante?)
$2f5a:Récupére AF... sans intérêt, on le push juste après sans rien en faire. A est écrasé par la langue et F par le test. (!!)
$2f5b:Chargement du texte pour l'arrêt
$2f5e:Remise dans la pile de AF...
$2f5f:Chargement de la langue du système.
$2f68/break_fr
$2f69:Si A était à zéro, il s'agissait d'un arrêt de programme normal, sinon, au saute à l'affichage de message d'arrêt.
$2f6c:Boucle sur l'affichage "Ok!"

$2f77:Sors avec l'erreur "Cannot continue"

$2f98/a_to_z/above
Vérification que le caractère pointé par HL est entre A et Z inclus.
Dans le cas contraire, lève le drapeau de retenu.

$2f99/a_to_z_2:Appelé ici lorsque A contient déjà la caractère à vérifier

$2fa0/above
Instruction : CLEAR

$2fa0:Si pas d'argument, initialise les variables avec les valeurs courantes
$2fa3:Récupère un premier paramètre entre 0 et 32768
$2fa7:Prend le caractère suivant
$2fa8:Sauve le pointeur d'exécution
$2fa9:HL prend la dernière adresse mémoire disponible.
$2fac:Si pas de deuxième paramètre (le chget a renvoyé 0), alors on continue plus loin
$2faf:Vérifie que le caractère lu est bien une virgule
$2fb0:data -> ','
$2fb1:Sauve le premier paramètre
$2fb2:Décode le second paramètre (de -32768 à 32767)
$2fb9:Lit le caractère suivant.
$2fba:S'il n'est pas nul, c'est une erreur de syntaxe
$2fbd:Le pointeur d'exécution va sur la pile et on récupère le premier paramètre dans HL
$2fbe:Le premier paramètre est dans DE, le second dans HL.

$2fbf/clr_stored/above
Le premier paramètre est dans DE, le second dans HL, qui est (memsiz) si on est venu sans second paramètre spécifié.
;
MS_BASIC=STORED

$2fbf:Appel qui pourrait être inliné... (!!!)
$2fc2:Si HL - DE est négatif, alors erreur de mémoire
$2fc5:Sauvegarde de l'adresse mémoire haute (second paramètre)
$2fc5:HL prend la valeur de (vartab), l'adresse de fin de programme BASIC stocké.
$2fc9:En vrai, LD BC,$28 (== 40) (taille minimale voulue)
$2fcd:Comparaison de (vartab) + $28 et de DE, qui contient la plus haute mémoire réduire de la taille pour les chaînes
$2fce:S'il n'y a pas assez de mémoire, le signaler.
$2fd2:Stockage de HL (venant de DE) comme nouveau (stktop)
$2fd6:Stockage de HL (venant de la pile) comme neaucou (memsiz)
$2fd9:On pop quoi ??? L'adresse de retour car on jump ?
$2fda:Saut à l'initialisation des variables.

$2fdd/top_string/above
Soustraction du second paramètre (la mémoire haute) par la taille
pour les chaînes demandée.
À la fin, HL n'est pas touché, et DE contient HL - (taille demandée)

/////////////////////////////////////////
////////////////// 3000 /////////////////
/////////////////////////////////////////

$302c/str_hex_dec/above
Transforme un nombre de la forme &"xxxx" en FP.
;
MS_BASIC=HEXTFP


$302d:Vérifie que le début du nombre (après le '&'), est un '"'
$302f/dummy/code:Pour forcer la donnée de chkchr. Le décodage ne fonctionne pas bien ici, c'est vraiment LD DE,$0000 qu'il faut lire. C'est l'initialisation de l'accumulateur de la valeur lue.
$3032:Compteur de chiffres maximum (4 chiffres max, la boucle djnz sort lorsque B est décrémenté à 0)
$3034:Positionnement du pointeur d'execution.

$3035/hex_fetch:Va chercher un chiffre Hexa
$3038:Saute si ce n'était pas un chiffre Hexa
$303a:Temporairement sauve HL dans DE, qui contient l'accumulateur des valeurs
$303e:HL (l'accumulateur) est décalé de 4 vers la gauche.
$303f:A est ajouté dans les 4 bits de poids faible
$3040:Remis dans l'accumulateur
$3041:Remise en place de DE=accumulateur et HL=pointeur
$3042:Si le compteur de chiffres n'est pas encore à zero, on repart pour un tour. 
$3049:On lit (puis ignore) le caractère suivant
$304c:Sauvegarde du pointeur d'exécution.
$304d:B (exp) = $98, A == 0 et DE contient l'entier lu. Le tout est monté dans FP
$3051:Restauration du pointeur d'exécution.
$304d:Ici, on ignore le caractère qui vient d'être lu

$3044/not_hexa:Vérification que le caractère est '"' (en cas d'arrivée par caractère non hexa, on peut voir que &"" est valide et égal à 0)
$3046:Si ça n'est pas le cas, c'est une erreur de syntaxe.

$319f/bcode_start

////////////////// 3200 /////////////////
$3278/initscreen/above
Réinitialisation du curseur, d'attributs
Redéfinition de deux caractères: $20 et $7F
Efface l'écran, remise en colonne 1

$3292/initscreen2
$3278:Deux accès à $47FD pour set les bits 4 et 6
$327c:Test du bit zéro sur $47FE (majuscules\minuscules)
$3286:Changement de l'aspect du curseur si minuscules
$3297:Initialisation des attributs utilisés pour l'effacement de l'écran

$329d/cur_home
$32a0:Curseur mis en haut à droite de l'écran
$32a3:Force l'affichage à l'interruption suivante
$32ab:Et attend l'affichage

$32b7/deckeyb/above
Fonction : décode le clavier

$331f:La pile contient, en haut, $33c5, puis AF (qui contient le caractère)

$3349/above
Partial instruction trick en cascade.
Les 6 labels suivants chargent A avec une certaine valeur.
Puis exécutent une série de LD HL avec des valeurs inutiles
Pour finalement arriver sur 'sdchar_pass'
;
Cela agit comme un remapping des caractères qui étaient normalement non affichables.

$3349/sd_a_ff
$334c/sd_a_0d
$334f/sd_a_08
$3352/sd_a_04
$3355/sd_a_1f
$3358/sd_a_03

$335b:$33cd est mis sur la pile pour servir de branchement lors du prochain RET, à la fin de l'émission du caractère.

$331a/sendchar_t2
$3328:A est compris entre 128 et 160. La mise à 0 du bit 7 revient à soustraire 128
$332c:A est inférieur ou égal à 128.
$332e:On vérifie s'il est supérieur à 32
$3334:Saut si on est en train d'utiliser les caractères utilisateurs
$333a:Saut si c'est un caractère graphique
$333c:Arrivé ici si le caractère était dans [128,160[ (ajusté en [0, 32[ ou un caractère redéfini de numéro inférieur strictement à 32.
$332c/sdchar_bl80
$335a/sdchar_pass
$3342:E = A * 3 (A contient le caractère)
$3348:Branchement sur la table de redirection qui commence en $3362

$3362/sdchar_ind/code
Code: $3365
Code: $3368
Code: $336B
Code: $336E
Code: $3371
Code: $3374
Code: $3377
Code: $337A
Code: $337D

Code: $3380
Code: $3383
Code: $3386
Code: $3389
Code: $338C
Code: $338F
Code: $3392
Code: $3395
Code: $3398
Code: $339B

Code: $339E
Code: $33A1
Code: $33A4
Code: $33A7
Code: $33AA
Code: $33AD
Code: $33B0
Code: $33B3
Code: $33B6
Code: $33B9

$33BC/code:Fin de la table d'indirection. Caractère 31.

$33cd/code/above
Cette adresse est forcée dans la pile pour que le RET de l'affichage de caractère passe par là.
Le rafraichissement de l'écran est demandé et la pile et les registres remis en ordre.

$33d4/carreturn/above
Fonction: traitement Carriage Return
Traitement de l'affichage du caractère 13 (et 3)

$33da:Saut si 'x' est différent de 1
$33e1:Saut si 'continuation permitted' est à 0
$33e3
Si le curseur est sur la colonne 1 et 'continuation permitted' est à 1, alors la colonne 0 est mise à $80 (attributs par défaut pour l'EF9345)
Et c'est fini.

$33ed:Le curseur est mis sur la colonne 1 et on enchaîne sur `line_down`
$33fd:Si le scrolling est désactivé, on saute
$341a:Si le scrolling est désactivé, on saute


$3442/col_right/above
Fonction : La position du curseur est avancée de 1 vers la droite
Traitement de l'affichage du caractere 7

$3448:Si le curseur est en position 39, on saute
$344f/line_below
$344b/col_r_end

$3452:On ne fait rien si le curseur est en bas à droite de l'écran.

$33f0/line_down/above
Fonction: amène le curseur une ligne plus bas
Traitement de l'affichage du caractere 10


////////////////// 3400 /////////////////

$340e/line_up/above
Fonction: amène le curseur une ligne plus haut
Traitement de l'affichage du caractere 9

$342b/col_left/above
Fonction : La position du curseur est avancée de 1 vers la gauche
Traitement de l'affichage du caractere 8

$342b:xcursor est suivi de ycursor. Ce qui fait que H contient 'y' et L contient 'x'
$3431:Saut si la colonne du curseur est inférieur strictement à 2

$3438/line_above
$343a:On ne fait rien si la ligne du curseur est à zéro

$3434/col_l_end
$343e:Curseur à la dernière colonne

////////////////// 3300 /////////////////

$3578/peekchar/above
Fonction : récupère le caractère à l'écran aux coordonnées HL dans A
HL est modifié. A contient le caractère. A est comparé à $84.

$359f/clr_scr_btm
Fonction : Efface toutes les lignes à partir de la ligne courante jusqu'en bas de l'écran
Traitement de l'affichage du caractère 31

$35ad/scroll_up/above
Fonction: monte le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

$35b9/scroll_down/above
Fonction: descend le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

$35c5/reset_term/above
La fonction réinitialise les bits 2 et 7 de $4871.
Remet le scrolling (et ligne non entrée sous BASIC (?))
;
Réinitialise quelques valeurs d'affichage

$35cd:$4804 à 0 : pas de redéfinition de caractères
$35d1:$4002 à 0 : couleur d'encre et fond graphique à zero, texte
$35d5:$47FB à 1 : force un affichage
$35d9:$47FC à 0 : équivalent de DISPLAY 10
$35e6/honk
$35f3/jump_ret:Cette adresse est utilisée pour sauter à un RET depuis une table d'indirection.

$35fe/char7f
$35f4/char20


////////////////// 3600 /////////////////

$3646/save_str
$3646:A <- longueur de la chaine
$3649:HL positionné sur l'adresse du contenu poussée dans la pile
$364a:Vérification qu'il y a assez de place dans la mémoire de chaines
$364d:Si oui, on lit l'adresse du contenu dans BC
$3651:Création d'un descripteur temporaire
$3656:Copie L octets de BC (source) vers DE (destination)
$3659:Pointeur de descripteur de chaine dans DE

$365b/str_len_1:Construction après vérification d'une chaine de taille 1.
$365d/ctr_ver_str:Construction d'une chaine après vérification de la mémoire disponible
$3660/crt_str_dsc/above
Fonction: met la longueur de chaîne (A) puis rien (0, pour être sur 16 bits) puis DE (pointeur de chaîne) dans dsctmp
Entrée: A contient un nombre de caractères (longueur de chaîne), DE le pointeur sur la chaine (sans séparateur de début)
Sortie: HL pointe sur le buffer temporaire de chaîne, dsctmp
;
MS_BASIC=CRTMST

$3666/de_in_hl:Puts DE where HL points to

$366c/out_str_prc/above
Création d'une chaine de caractère depuis la source pointée par HL (dans le pool de string ???)
;
MS_BASIC=CRTST (Create String?)

$366c:Positionne hl un caractère avant le début de la chaine (à cause du inc hl de la boucle qui suit)
$366d/str_to_str:MS_BASIC=QTSTR

$366f:'"' est dans B puis D

$3670/direct_str:Sauve la valeur courante de HL, la mémoire à parser entre guillemets. Un appel direct ici devra placer ses propres terminateurs dans B et D ; MS_BASIC=DTSTR
$3671:Compteur C de la taille de la chaine à -1

$3673/loop_str
$3674:Récupération du caractère dans a
$3675:Incrémentation du compteur de caractères parsés (longueur totale de la chaîne)
$3677:Si le caractère est 0 (fin de chaîne)
$367a:Si le caractère est $22 (=34, guillemets) (ou autre terminateur mis dans D)
$367c:Traitement du deuxième terminateur possible
$367d:Tant que l'on traite des caractères normaux

$367f/create_str

$3681:Si la lecture s'est terminée par des guillements, on les consomme ("BLA est une chaine valide si en fin de ligne)
$3684:Récupération du pointeur du début de la chaîne dans HL
$3686:DE contient le début de la chaîne +1 (dont après les guillemets)
$3687:A <- longueur de la chaîne
$3688:Création du pointeur de chaine sur l'espace temporaire

$368b/cpy_to_pool
$368b:DE <- espace temporaire
$368e:HL <- espace actuel de traitement de chaine
$368e:Sauve l'adresse de la chaine dans FP
$3696:La valeur courante est une chaîne de caractères

$3699:Copie les 4 premiers octets de dsctmp vers HL, qui pointe vers (temppt). Autrement dit, copie la description de chaine temporaire dans le pool de chaine.
$369c:Comparaison avec DE, qui est dsctmp et agit donc comme gardien de fin de buffer (après tempst) (où est initialisé temppt à part au reset de stack ???)
$369d:Mise à jour du pointeur vers le buffer tempst
$36a0:Récupération du pointeur de parsing
$36a1:Lecture du prochain caractère
$36a2:Retour s'il reste de la place dans le buffer tempst
$36a6:Lancement de l'erreur "String formula too complex"

$36a9/sharp_char/code/above
Afficher une chaîne sans le premier caractère
;
MS_BASIC=PRNUMS

$36aa/out_str/above
Fonction: Affichage d'une chaîne à l'écran
Entrée: HL pointe sur la chaîne de caractère terminée par un 0
;
MS_BASIC=PRS (Print String)

$36ad/out_str1
$36ad:MS_BASIC=PRS1
$36b4/prsloop
$36b4:MS_BASIC=PRSLP ; Compte les caractères

$36bb/alloc_str_mem/above
Vérifie la place restante pour les chaines, alloue la chaine, lance le GC si nécessaire.
La place demandée est dans A. À la fin de la routine, DE pointe sur un espace allouée de A
caractères dans la mémoire dédiée, et (fretop) est ajusté en conséquence. Ainsi, ce n'est
pas seulement un test mais un test et une allocation.
Dans ces implémentations, Z est d'abord reset, mais plus tard Set avec un bouclage après GC.
Si au deuxième passage il n'y a toujours pas assez de mémoire, alors l'erreur est lancée.
;
MS_BASIC=TESTR

$36bb:Ajuste un flag pour signaler no-GC
$36bc:Annule $f1 qui est pop af
$36bd/code/retry_alloc

$36bf:Charge le pointeur sur le haut de la stack (et donc juste sous la mémoire réservée pour les chaines)
$36c2:... dans DE
$36c3:Charge le pointeur sur la plus haute mémoire libre disponible
$36c6:A contient la longueur cherchée.
$36c8:Met son inverse dans BC
$36ca:L'ajoute à la plus haute mémoire
$36cb:Ajustement pour le complèment à 2 de la soustraction
$36cc:Compare avec l'adresse DE (adresse minimale possible)
$36cd:Pas assez de mémoire, on lance l'erreur (ou le GC en première tentative)
$36cf:Remise en place de la plus haute mémoire après un GC.
$36d2:HL est positionné sur la première adresse après fretop (la première adresse des chaines avec une allocation de A caractères)
$36d3:... dans DE (qui est utilisé par save_str par exemple)
$36d4:Restauration de AF


$36d6/out_str_mem
$36da:Sors avec l'erreur "Out of string space"

$36e3/gc_start

$3784/str_concat

$379b:Sors avec "String too long"

$37c5/copy_str/above
Copie le contenu mémoire d'une taille de L de BC vers DE.

$37c6/move_loop

$37ec/bc_from_tmp/above
Récupère dans BC une adresse contenue dans l'adresse juste avant le pointeur (temppt)
Si en remontant encore de deux adresse ou tombe sur DE, alors on met à jour (temppt) avec cette nouvelle addresse.
Sinon, on retourne.
Quoi qu'il arrive, avec BC

$37d1/GSTRCU/above
MS_BASIC=GSTRCU (Current string to pool)

$37dc:DE <- BC, l'adresse de la chaine de caractères
$37de:C contient la taille de la chaine de caractères

$3aa9/k7write

$3a81/k7sync

$3af3/k7test

$1e00/k7end/code

$3b48/k7read

$37ff/fetch_str
$3802:A cet endroit, C contient la longueur de la chaine de caractères, mais on n'a pas l'air de s'en servir
$3804:C'est une valeur numérique
$3807:HL pointe vers la longueur de chaine, qui est donc mise dans A pour valeur de retour

$3811:Saute si la longueur de la chaine est 0.
$3818:DE <- pointeur sur la chaine
$3819:A <- le premier caractère de la chaine, qui est aussi le résultat en numérique

$3890:Saute si la longueur de la chaine est 0. Le résultat est alors 0.

$38b1/above
Instruction : FRE()
Entrée : (valtyp)

$38b4:DE contient l'adresse de (strend)
$38b8:HL contient l'adresse de la pile
$38bd:Saute si (valtyp) est à 0 (nombre)

$38ca:HL contient (fretop) et DE contient (stktop)

$38d0/code/dim_cont/above
L'appel est induit par le push en $38d8, lors de l'exécution de l'instruction DIM.

$38d1:Si la zone de parsing contient 0, alors retour de l'instruction
$38d3:Sinon, vérification que le caractère suivant est une virgule ($2C) qui induit une deuxième définition de tableau
$38d4:Valeur pour le chkchr précédent

$38d5/above
Instruction : DIM
Le format d'un tableau (stocké à partir de arytab) est le suivant:
+0/+1 : identifiant du tableau
+2/+3 : taille des données allouées pour le tableau (dimensions comprises)
+4    : nombre de dimensions
paires suivantes : taille de chaque dimension
puis la zone d'allocation de données (4 octets par indice)

$38da/getvar:Saut depuis LET pour définir une variable
$38da/above
Fonction qui parse le nom de la variable et initialise l'espace nécessaire après vartab, en poussant
l'existant. Puis inscrit l'identifiant. Si la variable existe, se contente de la retourner.
En entrée: HL pointe sur la zone de parsing.
En sortie: DE pointe sur la zone de mémoire contenant la valeur et cas d'assigntion,
           l'accumulateur flottant la valeur en cas d
           HL sur la zone de parsing.
L'identifant est sur deux caractères. Si le type est alphanum, alors le second caractère a son bit de poids fort à 1.
Une variable a 4 octets de valeur.
Si le type est une fonction, le premier caractère a son bit de poids fort à 1 (vérifier ???)
Pour une chaine : taille, (rien), pointeur sur la chaine (en fin de mémoire)

$38db:0 dans dimflg sauf si l'on vient de DIM, auquel cas cela vaut $AF
$38de:Récupération du premier caractère de la variable dans C

$38df/get_id
$38e2:Si le nom de variable ne commence par par une lettre majuscule entre A et Z, c'est une erreur de syntaxe (rappel : tout ce qui est parsé hors chaîne de caractère est passé en majuscules)
$38e7:valtyp à 0 par défaut (valeur numérique)
$38ea:Lit le caractère suivant
$38eb:Saute si le caractère lu est un chiffre
$38f0:Saute si le caractère lu n'est pas entre A et Z (donc si ni chiffre ni A à Z l'identifiant est terminé)
$38f2/idnum_trail:Sauve le premier caractère de la variable dans B
$38f3/idtrail_skp
$38f4:Avance la lecture de l'identifiant tant que l'on trouve des chiffres
$38f9:Avance la lecture de l'identifiant tant que l'on trouve des lettres
$38fb/id_end:Le nom de l'identifiant a été lu. On vérifie son qualificatif en '$'
$38fd:Si '$' n'est pas présent, on saute. La valeur est bien numérique.
$38ff:Sinon, la variable est de type chaîne de caractères
$3900:Ce qui est indiqué dans valtyp
$3903:A <= $80 et Carry à 1
$3904:Ajoute $80 à B pour marque le type string de la variable
$3905:B <- B + A ($80)
$3906:Lecture du caractère suivant le '$'
$3907/num_vrble:(subflg) == 1 pour une demande de tableau, >= 1 lorsque l'on vient d'un FOR ou d'une fonction ($80 lors d'une évaluation)
$390b:Saut si subflg était égal à 1. L'appelant veut un tableau.
$390e:Saut si subflg était supérieur à 1 (traitement des fonctions et FOR Le subflg est à $80 pour une fonction lors d'une évaluation avec la variable paramètre)
$3914:Saut si le caractère suivant est une parenthèse ouvrante (pour le dimensionnement des tableaux)
$3917/simplevar
$3918:Reset de subflg
$391b:Push de la position actuelle du pointeur de parsing
$391d:DE <- BC
$3921:Compare DE (le nom de variable cherchée) et HL (le nom pointée par le paramètre)

$3925:Si la valeur sont identique, saute (pour un RET) avec DE placé sur la valeur du paramètre.
$392c:HL est à (vartab) et DE est à (arytab). L'espace de stockage des variables est entre les deux (HL < ou égal à DE)
$392f/next_var
$3930:Saut si HL et DE sont égaux, c'est-à-dire (vartab) == (arytab) (donc pas de variable définie)

$3933:À cet endroit, HL < DE et l'espace entre les deux contient des variables. BC contient l'identifiant de la variable en train d'être parsée.
$3934:Comparaison du premier caractère de la variable avec le premier caractère de la variable pointée
$3935:Incrémente HL avant le saut potentiel
$3936:Saut si les caractères étaient différents (dont pas la bonne variable)
$393a:Comparaison des seconds caractères
$393b/var_diff:Incrémente pour la deuxième fois HL, qui pointe après l'identifiant.
$393c:Saute si le second caractère était identique à celui pointé. On a donc retrouvé la variable et on saute à la fin de la fonction
$3942:La variable n'a pas été trouvée, on saute les 4 prochains octets pour aller vers la suivante (ou terminer en atteignant DE=(arytab))

$3946/no_var_yet
$3947:Récupération dans HL dans la valeur de retour du CALL (2613 si appelé par LET)
$3948:Push de DE qui contient arytab
$394c:Comparaison de l'adresse de retour avec $2927 (quelle instruction ???)
$394d:Pop de DE qui contient maintenant arytab
$394e:Saut si l'adresse de retour venait de str_to_var. Attention, l'adresse de retour est toujours dans HL et le pointeur de parsing sur la pile
$3951:Remise en place de l'adresse de retour et HL pointe sur le parsing.
$3952:Sauve le pointeur de parsing. On remet tout en place.
$3953:Sauve BC, qui contient le nom de la variable.
$395c:Récupération de strend dans HL (pointeur de fin de mémoire utilisable)
$395b:Ajout de 6 à strend
$395d:Sauvegarde de strend + 6
$395e:Copie de DE,BC vers HL
$3962:(strend) <- (strend) + 6
$3966:HL <- BC
$3967:(arytab) <- HL
$396a/clear_mem
$396e:Mise à zéro de la partie entre l'ancien (arytab) (DE) et le nouveau (HL). C'est-à-dire l'espace libérée pour la nouvelle variable.
$3970:DE récupère le nom de la variable.
$3974:(HL) <- DE et HL += 2, enregistrement du nom de la variable dans son emplacement.
$3975/var_found:DE pointe sur la mémoire après le nom de la variable
$3976:HL pointe sur la zone de parsing

$3978/ret_null

$3983/subscript/above
HL pointe sur la zone de parsing

$3983:Sauvegarde du pointeur de parsing
$3987:Récupération dans HL du pointeur de parsing et mise sur la pile de (dimflag)
$3988:Initialisation de D à 0 (A == 0 ici)
$3989/loop_dim
$3990:HL <- DE, la taille demandée du tableau
$3991:Mise sur la pile de la dimension.
$3992:Remise en place de la valeur qui était sur la pile (insertion de la dimension avant la valeur de la pile). Il s'agit de (dimflg)
$3993:DE contient le (dimflag), HL le pointeur de parsing
$3995:D contient la dimension actuelle
$3996:Parsing
$3999:Saut si la taille est suivie par une virgule
$399c:Vérification de parenthèse fermante
$399d:Code pour la parenthèses fermante
$399e:À ce moment, la pile contient (dimflg),(dimension tableau)+,...???, D contient le nombre de dimensions du tableau, HL le pointeur de parsing. La valeur du pointeur de parsing est sauvée dans (temp2)
$39a2:Remise en place de la valeur de (dimflg) venant de la pile (a-t-elle pu être modifiée ???)
$39a7:Nettoyage de E puis mise de DE (D contient le nombre de dimensions du tableau) sur la pile
$39a8:En arrivant par ici, les push hl et push af suivant saut ignorés.

$39a9/aryvar
$39a9:On arrive ici par un jump conditionnel si lors d'une recherche de variable, (subflg) == 1
$39aa:La pile contient (# de dimension),(tailles des dimensions)+
$39ae:En arrivant par ici, le add hl,de suivant est ignoré
$39af/dim_search

$39b7:Premier caractère du nom du tableau (BC contient le nom du tableau courant)
$39ba:Si le premier caractère est différent, on saute (c'est ok, pas de redimensionnement)
$39bd:Comparaison du second caractère du nom du tableau (le test aura lieu en $39c3)

$39be/dim_neq

$39c2:Récupération dans DE de la taille mémoire du contenu du tableau (pour chaînage)
$39c3:Si le nom de variable était différent, on boucle
$39c5:Arrivé ici, cela signifie qu'une entrée de tableau a été trouvée avec le même nom
$39c9:Si (dimflg) était différent de zéro, c'est que l'on cherche à redéfinir un tableau. Lancement de l'erreur
$39cc:Arrivé ici, le tableau a été trouvé (et c'est donc un accès).
$39cd:BC <- HL, qui pointe vers les attributs du tableau (debut+4)
$39cf:Saut dans quel cas ???
$39d2:Soustraction du type pour vérifier si c'est le même ???
$39d6/out_range
$39d6:Il n'y avait pas égalité, on lance une erreur.

$39d9:Sortie avec l'erreur "Subscript out of range"

$39dc/ary_at_end/above
Arrive ici lorsque arytab == strend lors d'un dimensionnement de tableau.
HL contient arytab
BC contient le nom de la variable (du tableau)
DE est initalisé à 4, qui est la taille d'un élément pour la première dimension
;
MS_BASIC=CREARY

$39df:Récupération de la dimension (dans A, F == 0 normalement, sauf ???)

$39e0:Quelle est la nature du test précédente récupéré par AF ???
$39e3:Place le nom de la variable dans la zone pointée par HL (zone arytab)
$39e7:Place le nombre de dimensions dans C
$39e8:Vérifie la place restante pour stocker le nombre de dimensions * 2 (ce qui ne semble pas suffisant, cela ne compte pas le nombre de dimension ni la taille)
$39ed:Place le pointeur HL (4 octets après la variable) dans temp3
$39f0:Place le nombre de dimensions du tableau dans la structure du tableau
$39f1:HL pointe sur l'emplacement de la première dimension
$39f5:Pour setter Carry. A priori, si accès sans DIM, le Carry flag est OFF (donc bit de poids fors de A est à 0 ?)
$39f6:A contient le nombre de dimensions
$39f7/multi_dim:Préparation de BC <- $000B pour le saut suivant. C'est la taille par défaut d'un tableau ; MS_BASIC=CRARLP
$39fc:BC contient la taille de la dimension traitée
$39fd:En BASIC, la taille d'un tableau est d'une unité plus grande que celle spécifiée (à cause de l'indice 0). Ce BASIC n'a pas l'option pour démarrer les indices à 1.
$39fe/default_dim:MS_BASIC=DEFSIZ
$39ff:Sauvegarde de la dimension en cours sur la pile
$3a01:BC est placé dans les deux octets de la spécification de la dimension des données du tableau
$3a03:Sauvegarde sur la pile de la position suivante dans la structure du tableau
$3a07:DE <- taille nécessaire pour les données de cette dimension
$3a08:Récupération du pointeur sur les données du tableau
$3a09:Récupération de la dimension en cours
$3a0a:Dimension suivante (décroissante)
$3a0d:Sauvegarde des flags (car A == 0 ici)

$3a0f:BC <- DE (la taille du contenu du tableau à réserver)
$3a10:HL contient la taille à réserver, DE contient le pointeur de contenu du tableau
$3a11:Après l'addition, HL contient le pointeur de fin du contenu du tableau
$3a12:Si HL a débordé, alors il n'y avait plus de mémoire pour sûr (dépassement de la plus haute adresse adressable)
$3a15:Sinon, vérification par rapport à la mémoire installée
$3a18:Si tout est bon, comme un nouveau tableau est toujours en dernier (on ne redimensionne pas les tableaux), mise à jour de (strend)
$3a1b/dim_nullify:MS_BASIC=ZERARY
$3a1c:Mise à zéro du contenu du tableau
$3a1f:Mise à zéro du contenu du tableau en ramenant HL (pointeur sur la fin du contenu du tableau) vers DE (début du contenu du tableau)
$3a21:Incrément du la taille mémoire du tableau
$3a22:A priori, A == 0 donc mise à 0 de D
$3a26:Récupération dans E du nombre de dimensions du tableau
$3a29:HL <- 2 * (# de dimension) + BC(espace de tableau + 1)
$3a2a:DE <- HL == taille nécessaire pour les données, les tailles des dimensions et le nombre de dimension
$3a2c:Positionnement de HL à identifiant + 2, pour stocker la taille de mémoire allouée au tableau (hors identifiant)
$3a30:Placement de la taille calculée à cet endroit
$3a31:Récupération des anciens flags
$3a32:Si le Carry Flag était set, alors on a fini. Sinon, il s'agit d'un accès au tableau (allocation par défaut lors d'un accès à un tableau non défini)

$3a34/dim_access:MS_BASIC=FINDEL
$3a34:En arrivant ici depuis $3a4e, a est égal à 0
$3a35:Donc BC <- $00
$3a36:HL est à identifiant+4. A <- nombre de dimensions du tableau
$3a37:HL pointe sur le début des taille de dimensions du tableau
$3a38:Le partial élimine le pop hl suivant
$3a39/dimension_l
$3a39:Récupération dans HL du pointeur vers la taille de la dimension courante (en première boucle, HL était initialisé par la partie précédente)
$3a3c:Ce qui donne DE <- taille du tableau dans la dimension actuelle
$3a3e:Les index sont sur la pile. Récupération de l'index dans HL (en partant de la droite)
$3a3f:Sauvegarde du nombre de dimensions et flags
$3a41:Saut si l'index demandé est au delà de la taille du tableau
$3a44:Sauvegarde de l'index accédé sur la pile
$3a45:BC contient le numéro d'index accédé par la dimension précédente
$3a48:Récuépration dans DE de l'index accédé
$3a49:HL contient le début de la zone due à l'indice de la dimension précédente. On y ajoute l'index de la dimension courante.
$3a4a:Récupération de la valeur d'AF sauvegardée en $3a3f (contient la dimension en cours et les flags)
$3a4b:Décroit A, la dimension en court
$3a4d:BC <- HL
$3a51:HL <- Index * 4, car chaque entrée du tableau prend 4 octets.
$3a52:Récupération dans BC du pointeur des données du tableau mise sur la pile en $3a3e
$3a53:HL <- addresse de la donnée cherchée
$3a54:DE <- addresse de la donnée cherchée

$3a55/end_dim:MS_BASIC=ENDDIM
$3a55:Récupération dans HL du pointeur de parsing
$3a58:En cas de lecture du tableau, DE contient le pointeur vers l'entrée cherchée.

$3bd0/outdo_impl/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

//------------
$3be1/sendchar_pt
$3c14/resetprt/above:Fonction: Mise à zéro de l'état de l'imprimante
$3c16:Sélectionne l'imprimante pour l'affichage
$3c20:Récupération et mise à zéro du Bit 7 du status de l'imprimante
$3c25:Si le bit était à 0, récupération du numéro de ligne de l'imprimante dans a
$3c28:Permet de mettre à jour les flags de F
$3c29:Appel si le bit 7 du status était 1, ou bien si la ligne de l'imprimante n'est pas 0
$3c31:Clear du picflg sauf le bit 6 (signal de curseur en fin de page)
$3c35:Sélection du terminal comme sortie des caractères
$3c38:Mise à zéro de l'état de l'imprimante.
$3c3c/sendchar_te:Récupération de AF qui contient prtflg
$3c40/cursor_x0/above
Remet le terminal en état. Puis, si le curseur n'était pas en
première colonne, fait un saut à la ligne sur le terminal. Sinon, ressort.
;
MS_BASIC=STTLIN

$3c4a/putnulatend/above
Fonction: met un caractère NUL à la fin de la chaîne précédent le pointeur HL actuel, en ignorant les espaces.
À la fin de la fonction, HL contient $4897, c'est-a-dire juste avant le buffer de crunch de la ligne.

$3c4e:Recale le pointeur HL sur le derniere caractère non espace ($20) avant le CR ($0D)
$3c50:HL pointe donc à présent juste après le dernier caractère de la ligne à traiter
$3c51/hl_oncrunch/above
Met un zéro à l'emplacement pointé par HL puis fait pointer HL en début de buffer de crunch.

$3c52:Place un $0 à la fin de la chaîne
$3c56:Ayant été appelé par jp, ce RET va sortir de la boucle de traitement de basicloop (et se retrouver en $22b1)

$3c57/crdo/above
Fonction : Envoi d'un retour chariot sur la sortie de caractère actuel

$3c5e:Saut si la sortie de caractère se faire sur le terminal
$3c61:Saut si la sortie de caractère n'est pas l'imprimante (donc la k7)

$3c72/crdo_term
$3c7d/break_delay/above
Function : vérifie la séquence BREAK, avec un délai préalable

$3c77/chk_break/above
Vérifie la séquence de BREAK puis continue sur l'instruction STOP.
L'instruction STOP commence par 'ret nz', qui fera donc un RET s'il
n'y a pas eu de BREAK, et qui fera un STOP dans le cas contraire.

$3c7f/break_impl:Est-ce que la touche RUN-STOP est appuyée ?
$3c83:Si non, retour immédiat
$3c84:Est-ce que la touche SHIFT est appuyée ?
$3c88:Si non, retour immédiat
$3c89:Vérification de l'exécution BASIC (flag = 0).
$3c8d:Sinon, retour immédiat.
$3c8e:Met $f2 dans la dernière touche scannée
$3c92:Réinitialisation du drapeau de répétition des touches
$3c96:Réinitialisation du compteur de répétition des touches
$3c9a:Set Carry, pour provoquer la boucle immédiate du BASIC
$3c6e/crdo_k7

$3c9c/print_prt/above
Affiche le prompt "? " de INPUT.
Puis fallthrough sur l'acquisition d'une ligne de texte.
;
MS_BASIC=PROMPT

$3c63/crdo_prt/above
Fonction : Retour chariot à la ligne suivante sur l'imprimante

$3c6a:Mise à zéro de la colonne de l'imprimante (aucun test de la véracité...)

$3ca2/get_line/above
Fonction: Récupération d'une ligne d'instruction entrée au BASIC
Entre à chaque nouvelle invite. Sort lorsque la touche CR est appuyée.
;
MS_BASIC=GETLIN

$3ca2:Appel au HOOK de GetLine

$3ca4:Commence par un appel à l'input hook qui par défaut revient immédiatement.

$3ca8/get_line2
$3cac:Saute si le périphérique d'entrée actuel est le clavier.

$3cae:Traitement si inputsel ne désigne pas un clavier (!= 0). A priori, on arrive ici lorsque l'on décode du BASICODE à travers LOAD. À vérifier.

$3cb5/keyloop/above
Fonction : Traitement du moniteur pour une entrée par le clavier

$3cb9:Saute si une touche a été appuyée et nécessite un traitement. La plupart des touches renvoient 0 dans A. Quelles touchent sortent avec A != 0 ? STOP par exemple.

$3cbe:Retour à la boucle de traitement si la touche STOP n'a pas été appuyée
$3cc0:La touche STOP a été appuyée. Carry est à 1.

$3cc1/decodebasic/above
Fonction : décode la ligne en BASIC ?

$3cc3:Saute si la touche était la touche entrée.

$3cc7:Remise du caractère dans le buffer en s'assurant qu'il soit sur 7 bits
$3ccb:Comparaison de HL avec $4918, qui est juste avant la fin du buffer de crunch. Mais comment est-ce que HL pourrait déborder ? Pas en entrée direct on dirait... Il est possible qu'on n'arrive là que via la lecture k7 ?
$3ccf/hl_incbuf
$3ccf:HL pointe sur la position suivante dans le buffer de crunch

$3d9a/auto/above
Traitement appelé lorsque le mode AUTO est activé
DE contient l'ancien numéro de ligne (ou le premier en début de AUTO)
HL contient le nouveau numéro de ligne.

$3d9e:Récupération du numéro de ligne
$3d9f:Recherche de la ligne (pointeur dans HL si résultat)
$3da2:Continue par l'affiche d'un espace si la ligne n'a pas été trouvée
$3da7:Sinon, affiche le caractère $a0 pour indiquer qu'il y a déjà du contenu.


$3daa/after_auto
$3daa:Traitement d'un overflow sur AUTO. Si HL est devenu trop grand, on arrête.
$3dad:Préparation de la comparaison avec $fff9 (65529, plus haut numéro de ligne valide)
$3db2:si HL (le numéro de ligne courant) est égal ou supérieur à $fff9, on arrête AUTO
$3db4:Sinon, la nouvelle ligne auto est validée
$3db9/stopauto:Stop le traitement de AUTO

$3dbd/after_auto2

$3dc0/initscreen1

$3dce/above
Instruction : NEW
Efface le listing courant.
Il y a une condition sur Z qui semble dire que dans certaines situations, le NEW n'est pas honoré ???
;
MS_BASIC=NEW

$3de1/decodenext
$3de1:Si HL était avant la fin du buffer de crunch, on incrémente HL et on continue.
$3de3:Si HL n'est pas égal non plus, c'est qu'il est supérieur à la fin du buffer de crunch, on loop directement sur le moniteur sans toucher à HL.
$3de3:Sinon, HL est sur la dernière position du buffer, on émet le caractere $0E (signification ?) puis on passe à l'incrémentation de HL. $0E semble donc être un marqueur de fin de buffer.

$3de9/ind_inchl:Saut intermédiaire pour aller incrémenter HL

$3dec/prompt
MS_BASIC=PROMPT (ou pas tout à fait, car chez MS, c'est l'affichage du PROMPT et le branchement sur l'acquisition)
$3df1:Met le flag INPUT à 1
$3df4:Paramètres du curseur

$3dfb/acquirekeyn4/above
Suite (3) du traitement de l'entrée

$3dff:Si le caractère d'entrée était ACK

$3e02:Test du flag INPUT actif
$3e07/acquirekeyn6

$3e0a/acquirekeyn5

$3e0a:Test de Unit Separator
$3e0c:Si différent, branche

$3e2d/acquirekeyn2/above
Suite (1) du traitement de l'entrée

$3e2d:Saut si la touche appuyée était ENTREE

$3e35:Si on est en basexec == 1


$4000/screen

// Label: $1179, InitEF

// Hooks
$47D0/inthk
$47D3/calhk
$47D6/sonhk
$47D9/plyhk
$47DC/rsthk
$47DF/prthk
$47E2/outhk
$47E5/crdhk
$47E8/inlhk
$47EB/inphk

// Hook vectors
$47EE/nmihk
$47F1/lpnhk
$47F4/dskhk
$47F7/modhk

// Screen communication flags
$47FA/intdiv
$47FB/intact
$47FC/intrat
$47FD/cursor
$47FE/fklock
$47FF/crchar:valeur scannée du clavier la plus récente
$4800/reptim
$4801/repena
$4802/attcar
$4803/attbak
$4804/extenf
$4805/xcursor
$4806/ycursor

// Text Editor
$4807/prelin
$4809/homeln
$480B/retadr:Coordonnées de la prochaine ligne à interpréter
$480D/entstt:programme ($82) ou direct ($80)

// Sound System
$480e/sonsav_hi
$480f/sonsav_lo

// Cassette
$4810/ft:Table de fichier
$4826/low
$4828/high
$482a/handler
$482e/lowlim
$482f/winwid

// BIINIT
$4830/ramlow
// $4833/usrloc
$4836/fdivc
$4844/rnd_seed_0
$4845/rnd_seed_1
$4846/rnd_seed_2
$4867/rnd_gen
$486e/lptpos
$486F/prtflg:Selectionne la sortie des caractères (0=Terminal, 1=printer, ff=k7)
$4870/getflg:Entrée des caractères sur clavier (0) ou cassette (255)
$4871/picflg
$4872/cascom
$4873/rawprt
$4874/prtstt:État de l'imprimante
$4875/prtcom
$4876/prtint
$4878/prtxlt

// Text Editor
$487a/contbl
$4884/autoflg:Etat courant de la commande AUTO
$4885/autoline:Ligne courante de la commande AUTO
$4887/autostep:Incrément du mode AUTO
$4889/allflg:Execution de la boucle BASIC (0 to execute BASIC control loop)
$488a/linlen
$488b/clmlst

// Basic
$488c/curlin:Ligne courante du BASIC
$488e/txttab
$4890/frgglg:Messages en anglais (1) ou francais (0)
$4891/kbdtbl:Table de transcription du clavier
$4893/tmpsav
$4894/octsav
$4895/stktop:Addresse de départ (maximale) pour la pile. Initialisée tout en haut de la RAM.

// BINTRP
$4897/bufmin:Zone précédent la zone de tokenisation. Mis dans HL après avoir mis NUL en fin de chaîne à traiter.
$4898/basbuf:Buffer d'entrée pour le BASIC
$4918/basbufpre:Juste avant la fin du buffer
$4919/basbufend:Fin du buffer
// $4919/endbuf
$491a/dimflg
$491b/valtyp:(0 = numeric, 1=string)
$491c/dores:Drapeau de suppression de la tokenisation
$491d/contxt
$491f/memsiz:Plus haute mémoire disponible (pour le BASIC ?)
$4921/temppt
$4923/tempst
$499b/dsctmp
$49c3/fretop
$47FA:Début de la zone de données graphiques pour la communication avec le EF9345
$49fb/end_vars:Adresse juste après la dernière des variables système.
$49c5/temp3
$49c7/temp8
$49c9/endfor
$49cb/datlin
$49cd/subflg
$49ce/flginp
$49cf/temp
$49d1/ptrfrg
$49d2/temp2
$49d4/oldlin
$49d6/oldtxt
$49d8/vartab
$49da/arytab
$49dc/strend
$49de/datptr
$49e0/prmnam
$49e2/prmval
$49e4/prmval_2
$49e6/fac_lsb
$49e8/fac_msb
$49e9/fac_exp
$49ea/fac_sgn
$49eb/fbuffr
$49f8/fmltt1
$49f9/fmltt2


// Generated instructions
$2f3a/inst_end/code
$247a/inst_for/code
$2fe4/inst_next/code
$25f3/inst_data/code
$2760/inst_input/code
$38d5/inst_dim/code
$27a3/inst_read/code
$2610/inst_let/code
$25ba/inst_goto/code
$259a/inst_run/code
$2679/inst_if/code
$2f1e/inst_restore/code
$25a9/inst_gosub/code
$25d6/inst_return/code
$25f5/inst_rem/code
$2f38/inst_stop/code
$265e/inst_on/code
$2694/inst_lprint/code
$2a13/inst_def/code
$2abb/inst_poke/code
$269b/inst_print/code
$2f6f/inst_cont/code
$31a8/inst_list/code
$31a3/inst_llist/code
$2fa0/inst_clear/code
$3058/inst_renum/code
$316e/inst_auto/code
$197e/inst_load/code
$1945/inst_save/code
$1a39/inst_cload/code
$19ed/inst_csave/code
$0fad/inst_call/code
$0e51/inst_init/code
$0c6a/inst_sound/code
$0a75/inst_play/code
$0df8/inst_tx/code
$0e37/inst_gr/code
$0f8e/inst_screen/code
$0f98/inst_display/code
$0fa4/inst_store/code
$0ea8/inst_scroll/code
$0eb1/inst_page/code
$0f52/inst_delim/code
$0ced/inst_sete/code
$0e40/inst_et/code
$0e49/inst_eg/code
$0e83/inst_cursor/code
$47f4/inst_disk/code
$47f7/inst_modem/code
$3dce/inst_new/code
$05a4/inst_sgn/code
$0660/inst_int/code
$05b8/inst_abs/code
$4833/inst_usr/code
$38b1/inst_fre/code
$29fc/inst_lpos/code
$2a01/inst_pos/code
$081d/inst_sqr/code
$0434/inst_log/code
$0874/inst_exp/code
$097e/inst_cos/code
$0984/inst_sin/code
$0a17/inst_tan/code
$0a2c/inst_atn/code
$2ab4/inst_peek/code
$37fb/inst_len/code
$3636/inst_str/code
$388d/inst_val/code
$380a/inst_asc/code
$0eba/inst_stickx/code
$0ef0/inst_sticky/code
$0f25/inst_action/code
$0f49/inst_key/code
$47f1/inst_lpen/code
$381b/inst_chr/code
$3829/inst_left/code
$3858/inst_right/code
$3861/inst_mid/code


