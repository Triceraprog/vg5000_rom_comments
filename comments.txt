Label: $0000, romStart
Comment: $0000/above
Tout commence par un saut à l'adresse $1000. Le choix de l'adresse $1000
semble arbitraire. D'autres machines à base de Z80 font des sauts à d'autres
adresses.
;
Comme les adresses suivantes sont les adresses de branchement des instructions
RST du Z80, le code de démarrage doit se trouver plus loin. D'où le saut.
;
Juste après le saut se trouve, sous forme de chaîne de caractères, le numéro
de version de la ROM.

Label: $0018, SendChar
Comment: $0018/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

Label: $0020, hl_de_cmp
Comment: $0020/above
Fonction : comparaison de HL et DE
Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
En sortie, C sera positionné si HL < DE

Label: $3bd0, SendCharImp
Comment: $3bd0/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

Label: $0255, ClearScreen
Comment: $0255/above
Fonction: Efface l'écran
Efface tout d'abord la ligne 0
Puis recopie le contenu mémoire de cette ligne sur le reste de l'écran

Label: $0265, ClearLine
Comment: $0265/above
Fonction: Efface une ligne
Entrées : A contient un numéro de ligne

Comment: $026b
Écriture de $80 à la première position de la ligne

Comment: $026d
Récupération des attributs par défaut

Comment: $0271
Écriture dans la position suivante des attributs par défaut

Comment: $0276
if bit(C,7) == 1 then A = 0 else A = $20
Le bit 7 de C étant à 1 pour un caractère graphique, 0 pour texte

Comment: $027d
Boucle pour écrire dans les positions suivantes de la ligne alternativement A et C.
Donc un espace pour le mode texte et 0 pour le mode graphique, suivi des attributs


Label: $0291, xytoscreen
Comment: $0291/above
Fonction: renvoie l'adresse écran à partir des coordonnées X et Y
Entrées : H contient y, L contient x
Retour : HL contient $4000 + 80y + 2x

Comment: $0291
C contient x

Comment: $0292
L contient Y

Comment: $0297
HL = L * 8 (c'est-à-dire y * 8)

Comment: $0299
DE = HL = y * 8

Comment: $029c
HL = 32 * y + 8 * y = 40 * y

Comment: $029d
HL = 80 * y

Comment: $029e
C contient x

Comment: $02a1
HL = 80 * y + 2 * x

Comment: $02a5
HL = $4000 + 80 * y + 2 * x


Label: $02EF, SendSeqEF
Comment: $02EF/above
Fonction: Envoi d'une séquence à l'EF9345
Entrée: HL pointe sur la séquence de données à envoyer.
Le premier octet de la séquence est sa longueur en octet.

Label: $0286, WaitRdyEF
Comment: $0286/above
Fonction: Attente d'état « prêt » de l'EF9345
$20 est envoyé sur le port $8F puis on attend que le le bit de
poids fort sur le port $CF soit à 0.

Comment: $0a78
Désactivation de l'affichage

Label: $0d7c, SendToEF
Comment: $0d7c/above
Fonction: Envoi d'une donnée à l'EF9345
Registre en entrée : DE
Registre modifié : C
D est envoyé sur le port $8F
C est envoyé sur le port $CF

Label: $0d85, DefineChar
Comment: $0d85/above
Fonction: Redéfinition d'un caractère
Registres en entrée : HL et A
Registres modifiés : AF, HL, BC, DE

Comment: $0d85
if bit(A, 7) == 0 then B = $C0 else B = $40

Comment: $0d8d
Le haut de la pile contient BC

Comment: $0d8e
Désactivation de l'affichage

Comment: $0d98
Envoi à l'EF9345 de $22,A (avec le bit 7 de A mis à 1) (R2=A)
(A est envoyé à travers E)

Comment: $0d9b
Récupération de la valeur de BC dans AF

Comment: $0d9c
Remise du contenu de BC sur la pile

Comment: $0d9d
Inversion du bit 7 de A, qui est la valeur de B du début de la fonction ($C0 ou $40)

Comment: $0da2
Envoi à l'EF9345 de $21,A (A est envoyé à travers E) (R1=A)

Comment: $0da9
Envoi à l'EF9345 de $20,$03 (R0=3 -> KRG+Inc)

Comment: $0dae
Récupération, à travers E, de la valeur de A en entrée de fonction (avec les trois lignes suivantes)

Comment: $0db4
A = (A >> 2) & $1F

Comment: $0db7
Envoi à l'EF9345 de $24,A (A est envoyé à travers E) (R4=A)

Comment: $0dbd
A = (A initial de la fonction) & $03

Comment: $0dbf
Récupération du contenu du BC initial ($C0 ou $40)

Comment: $0dc0
A = A | B

Comment: $0dc2
Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)

Comment: $0dc9
Envoi à l'EF9345 de $20,$34 (R0=OCT Write AP NoInc, écrit R1 en mémoire désigné par R4 R5)

Comment: $0dcc
Boucle extérieure, 10 itérations

Comment: $0dce
Récupère la valeur suivante de la redéfinition de caractère dans A

Comment: $0dd0
Boucle intérieure, 8 itérations

Comment: $0dd4
Inverse le contenu de A et C, bit à bit

Comment: $0dd8
La ligne de redéfinition lue dans (HL) est à présent inversée dans A

Comment: $0ddd
Envoi à l'EF9345 de $29,A (A est envoyé à travers E) (R1=A + Execute)

Comment: $0dee
Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)

Comment: $0df3
Réactivation de l'affichage

Comment: $0de5
Envoi sur $8F de $25 puis récupération sur $CF d'une valeur dans A (Read R5)
Puis A = A + $04

Label: $1000, Start
Comment: $1000/above
C'est ici que commence l'intialisation complète de la machine.
La première étape est de recopier le contenu de la ROM dans
l'espace RAM adressable. Adressable ne signifie pas que de la RAM
est effectivement branchée. Cela ne pose pas de problème au
niveau hardware du VG5000 d'envoyer une demande d'écriture.
;
Le contenu de la mémoire est ensuite lu et comparé à la ROM.
Tant que c'est identique, c'est qu'il y a quelque chose de branché
qui répond correctement. Dès que c'est différent, c'est qu'on est
sorti de la zone de la mémoire inscriptible disponible.
;
La dernière adresse valide est stockée dans $4895 et dans SP, le
registre pointeur de pile (Stack Pointer)
;
On remarquera que si une ROM répond avec un contenu identique à
la ROM à une adresse multiple de 16ko, l'initialisation va
penser que c'est de la RAM accessible.

Comment: $1000
Démarrage complet de la machine.
Vérifier pourquoi c'est appelé depuis $2282

Comment: $100a
Copie de la ROM sur toute la mémoire adressable
Equivalent C-style de : memcpy($4000, $0000, $C000)

Comment: $100c
À la fin de LDIR, HL == $C000, DE == $0000, BC == $0000

Comment: $100e
À présent, HL == $4000, DE == $0000, BC == $C000

Comment: $1010
Début de la comparaison octet par octet de la mémoire

Comment: $1015
Si le contenu de (HL) et (DE) est différent, on saute en $101B

Comment: $1017
Si le contenu de (HL) et (DE) est identique
et que BC est > 0, on loop

Comment: $101a/above
L'instruction partielle suivante ne sert à rien d'autre qu'à gagner un peu
d'espace lorsque BC == 0 et que la boucle est terminée.
Le contenu de A est écrasé un peu plus loin.

Comment: $101b
HL est décrémenté pour retrouver la dernière addresse testée (CPI augmente HL).
HL contient donc la première adresse invalide de l'espace mémoire en écriture.
Cette adresse est mise dans SP et stockée en $4895

Comment: $1020/above
La seconde étape de l'initialisation consiste à remplir les vecteurs
utilisateur par des instructions spécifiques. Ces vecteurs, situés
en RAM, permettent d'intervenir lors de certaines opérations avec
du code écrit par l'utilisateur et donc de modifier le comportement
du système.

Comment: $1020
Les adresses $47D0 à $47EE vont ensuite est remplies par des RET ($C9).
Equivalent C-style de : memset($47D0, $1E, $C9)

Code: $2250
Label: $2250, SomeVector
Comment: $102b
Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.

Code: $0069
Label: $0069, from47ee
Comment: $1042
L'adresse $47EE reçoit un JP $0069.

Comment: $104b/above
La troisième phase initialise le processeur graphique EF9345. Pour commencer,
une séquence est envoyée au périphérique, puis quelques variables en RAM sont
mises initialisées.
;
Attention, la valeur de IX doit rester constante. Le système de cette ROM
considère que IX est en tout temps égal à $47FA et référence certaines
variables par index par rapport à IX.
;
La séquence est
$28,$81 -> Écriture de quelque chose dans le TGS
$29,$00 -> TGS = 0 (625 lignes, non entrelacé, no-input-resync, output VSync+HSync, Service Row = 0, 40 Char
$20,$82,$29,$6e -> MAT = $6e (Marge = B+G, Insert Marge, Curseur plein/flash, Curseur affiché, simple hauteur
$20,$83,$29,$f7 -> PAT = $f7 (Ligne 0 'ON', Bulk haut et bas activé, pas de conceal, Insert mode : Active Area, Flash ON, Format court pour le 40 Char
$20,$84,$29,$13 -> DOR = $13 (Block G0=3, Block G1=1<<1, Block Q=0<<3)
$20,$87,$29,$08 -> ROR = $08 (Z=0, Y=8)
$26,$08,$27,$00,$28,$02 -> R6=$08, R7=$00, KRG sans incrémentation avec MP=$0800 (data R1, R2 = $08, ??)
;
Envoyés par pairs sur les ports $8f, $cf
;
Regarder ce que cela donne en EF9345

Comment: $104b
IX prend la valeur $47FA qui est la base de la zone de données graphiques.

Label: $1179, InitEfSeq
Label: $1194, InitValues
Label: $1202, AfterInit
Comment: $1179
Séquence d'intialisation de l'EF9345 au démarrage.

Comment: $104F
$1179 est la zone mémoire contenant la séquence à envoyer au EF9345.
HL pointe sur la taille de la séquence à envoyer au EF9345.

Comment: $1055
Initialisation de la variable $47FA : compteur d'interruptions à 5

Comment: $1059
Initialisation de la variable $47FB : besoin de rafraichissement à faux

Comment: $105d
Initialisation de la variable $47FA : utilisation des majuscules

Comment: $1063/above
Les interruptions sont réactivées pour la suite de l'initialisation.

Comment: $1067
Numéro de la première ligne du BASIC ?

Comment: $106a
Couleur du pourtour et aspect du curseur

Comment: $107a
Copie les valeurs initiales des différentes variables du système en RAM


Comment: $107d
Sort 0 sur le port $EF, censé être non utilisé

Comment: $107d
Sort 0 sur le port $AF, pour le son/k7

Comment: $1084
Modification de l'adresse du hook "nmihk"

Label: $3c3c, sendchar_te
Label: $3be1, sendchar_pt
Label: $1d97, sendchar_k7

////////////////////

//-----------------
Label: $2efe,resetstack
Comment: $2efe/above
Fonction : remise à zéro de la pile et effacement de l'interprétation en cours. Réinitialisation de l'imprimante.
Retour : HL contient le code de l'instruction en cours ?
;
Un meilleur nom: interpreter_reset ?

Comment: $2efe
Récupération de l'adresse de retour

Comment: $2eff
Réinitialisation de la pile (SP) à la dernière addresse RAM valide

Comment: $2f06
Le pointeur sur la zone temporaire de descripteur est initialisé

Comment: $2f0f
Mise à zéro de `oldtxt`

Comment: $2f12
Mise à zéro du buffer `subflg` (utilisé pour FOR)

Comment: $2f15
Mise à zéro du buffer `prmnam` (nom du paramètre actif)

Comment: $2f18
Met 0 sur la pile

Comment: $2f19
Remet l'adresse de retour sur la pile avant le RET

Comment: $2f1a
HL contient la valeur de `temp` (code d'une instruction)

//-------------
Label: $3278,initscreen
Comment: $3278/above
Réinitialisation du curseur, d'attributs
Redéfinition de deux caractères: $20 et $7F
Efface l'écran, remise en colonne 1

Label: $3dc0,initscreen1
Label: $3292,initscreen2

Comment: $3278
Deux accès à $47FD pour set les bits 4 et 6

Comment: $327c
Test du bit zéro sur $47FE (majuscules/minuscules)

Comment: $3286
Changement de l'aspect du curseur si minuscules

Comment: $3297
Initialisation des attributs utilisés pour l'effacement de l'écran

Comment: $32a0
Curseur mis en haut à droite de l'écran

Comment: $32a3
Force l'affichage à l'interruption suivante

Comment: $32ab
Et attend l'affichage

Label: $331a, sendchar_t2
Comment:

Comment: $3328
A est compris entre 128 et 160. La mise à 0 du bit 7 revient à soustraire 128

Comment: $332c
A est inférieur ou égal à 128.

Comment: $332e
On vérifie s'il est supérieur à 32

Comment: $3334
Saut si on est en train d'utiliser les caractères utilisateurs

Comment: $333a
Saut si c'est un caractère graphique

Comment: $333c
Arrivé ici si le caractère était dans [128,160[ (ajusté en [0, 32[ ou un caractère redéfini de numéro inférieur strictement à 32.

Label: $332c, sdchar_bl80
Label: $335a, sdchar_pass

Comment: $3342
E = A * 3 (A contient le caractère)

Comment: $3348
Branchement sur la table de redirection qui commence en $3362

Label: $3362, sdchar_ind
Code: $3362
Code: $3365
Code: $3368
Code: $336B
Code: $336E
Code: $3371
Code: $3374
Code: $3377
Code: $337A
Code: $337D

Code: $3380
Code: $3383
Code: $3386
Code: $3389
Code: $338C
Code: $338F
Code: $3392
Code: $3395
Code: $3398
Code: $339B

Code: $339E
Code: $33A1
Code: $33A4
Code: $33A7
Code: $33AA
Code: $33AD
Code: $33B0
Code: $33B3
Code: $33B6
Code: $33B9

Code: $33BC
Comment: $33BC
Fin de la table d'indirection. Caractère 31.

Label: $33d4, carreturn
Comment: $33d4/above
Fonction: traitement Carriage Return
Traitement de l'affichage du caractère 13 (et 3)

Comment: $33da
Saut si 'x' est différent de 1

Comment: $33e1
Saut si 'continuation permitted' est à 0

Comment: $33e3
Si le curseur est sur la colonne 1 et 'continuation permitted' est à 1, alors la colonne 0 est mise à $80 (attributs par défaut pour l'EF9345)
Et c'est fini.

Comment: $33ed
Le curseur est mis sur la colonne 1 et on enchaîne sur `line_down`

Comment: $33fd
Si le scrolling est désactivé, on saute

Comment: $341a
Si le scrolling est désactivé, on saute

Label: $35f3, jump_ret
Comment: $35f3
Cette adresse est utilisée pour sauter à un RET depuis une table d'indirection.

Label: $3442, col_right
Comment: $3442/above
Fonction : La position du curseur est avancée de 1 vers la droite
Traitement de l'affichage du caractere 7

Label: $344f, line_below
Comment: $3452
On ne fait rien si le curseur est en bas à droite de l'écran.

Label: $344b, col_r_end

Label: $33f0, line_down
Comment: $33f0/above
Fonction: amène le curseur une ligne plus bas
Traitement de l'affichage du caractere 10

Label: $342b, col_left
Comment: $342b/above
Fonction : La position du curseur est avancée de 1 vers la gauche
Traitement de l'affichage du caractere 8

Comment: $342b
xcursor est suivi de ycursor. Ce qui fait que H contient 'y' et L contient 'x'

Comment: $3431
Saut si la colonne du curseur est inférieur strictement à 2

Label: $3438,line_above
Comment: $343a
On ne fait rien si la ligne du curseur est à zéro

Label: $3434, col_l_end
Comment: $343e
Curseur à la dernière colonne

Label: $340e, line_up
Comment: $340e/above
Fonction: amène le curseur une ligne plus haut
Traitement de l'affichage du caractere 9

Label: $35ad, scroll_up
Comment: $35ad/above
Fonction: monte le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

Label: $35b9, scroll_down
Comment: $35b9/above
Fonction: descend le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

Label: $329d, cur_home

Comment: $3448
Si le curseur est en position 39, on saute

Comment: $331f
La pile contient, en haut, $33c5, puis AF (qui contient le caractère)

Label: $35e6, honk
Label: $0ca7, snd_emit

Comment: $3349/above
Partial instruction trick en cascade.
Les 6 labels suivants chargent A avec une certaine valeur.
Puis exécutent une série de LD HL avec des valeurs inutiles
Pour finalement arriver sur 'sdchar_pass'
;
Cela agit comme un remapping des caractères qui étaient normalement non affichables.

Label: $3349, sd_a_ff
Label: $334c, sd_a_0d
Label: $334f, sd_a_08
Label: $3352, sd_a_04
Label: $3355, sd_a_1f
Label: $3358, sd_a_03

Code: $33cd
Comment: $33cd/above
Cette adresse est forcée dans la pile pour que le RET de l'affichage de caractère passe par là.
Le rafraichissement de l'écran est demandé et la pile et les registres remis en ordre.

Comment: $335b
$33cd est mis sur la pile pour servir de branchement lors du prochain RET, à la fin de l'émission du caractère.

Label: $359f, clr_scr_btm
Comment: $359f
Fonction : Efface toutes les lignes à partir de la ligne courante jusqu'en bas de l'écran
Traitement de l'affichage du caractère 31


//-----------------
Label: $35c5, resetcursor
Comment: $35c5/above
La fonction réinitialise les bits 2 et 7 de $4871.
A priori : coupe le scrolling et ligne non entrée sous BASIC
;
Puis réinitialise quelques valeurs d'affichage

Comment: $35cd
$4804 à 0 : pas de redéfinition de caractères

Comment: $35d1
$4002 à 0 : couleur d'encre et fond graphique à zero, texte

Comment: $35d5
$47FB à 1 : force un affichage

Comment: $35d9
$47FC à 0 : équivalent de DISPLAY 10

Comment: $35dd
Changement du pourtour et aspect du curseur

Label: $35fe, char7f
Label: $35f4, char20

//------------
Label: $3c14, resetprt
Comment: $3c14/above
Fonction: Mise à zéro de l'état de l'imprimante

Comment: $3c16
Sélectionne l'imprimante pour l'affichage

Comment: $3c20
Récupération et mise à zéro du Bit 7 du status de l'imprimante

Comment: $3c25
Si le bit était à 0, récupération du numéro de ligne de l'imprimante dans a

Comment: $3c28
Permet de mettre à jour les flags de F

Comment: $3c29
Appel si le bit 7 du status était 1, ou bien si la ligne de l'imprimante n'est pas 0

Comment: $3c31
Clear du picflg sauf le bit 6 (signal de curseur en fin de page)

Comment: $3c35
Sélection du terminal comme sortie des caractères

Comment: $3c38
Mise à zéro de l'état de l'imprimante.

Comment: $3c3c
Récupération de AF qui contient prtflg

// Label: $3c57
Label: $3c57,crdo
Comment: $3c57/above
Fonction : Envoi d'un retour chariot sur la sortie de caractère actuel

Comment: $3c5e
Saut si la sortie de caractère se faire sur le terminal

Comment: $3c61
Saut si la sortie de caractère n'est pas l'imprimante (donc la k7)

Label: $3c72, crdo_term
Label: $3c6e, crdo_k7

Label: $3c63, crdo_prt
Comment: $3c63/above
Fonction : Retour chariot à la ligne suivante sur l'imprimante

Comment: $3c6a
Mise à zéro de la colonne de l'imprimante (aucun test de la véracité...)


// Label: $1179, InitEF
Label: $47D0, VectorBase

// Hooks
Label: $47E2, outhk
Label: $47E5, crdhk
Label: $47EE, nmihook
Label: $47F1, lpenhook
Label: $47F4, diskhook
Label: $47F7, modemhook

//
Label: $47FA, GraphValues
Label: $4805, xcursor
Label: $4806, ycursor
Label: $486F, prtflg
Comment: $486f
Selectionne la sortie des caractères (0=Terminal, 1=printer, ff=k7)

Label: $4871, DisplayCtrl
Label: $4874, prtstt
Commnent: $4874
État de l'imprimante

Label: $4895, stktop
Comment: $4895
Addresse de départ (maximale) pour la pile. Initialisée tout en haut de la RAM.

Label: $4919, endbuf

Label: $4921, temppt
Label: $4923, tempst
Comment: $47FA
Début de la zone de données graphiques pour la communication avec le EF9345

Label: $49fb, end_vars
Comment: $49fb
Adresse juste après la dernière des variables système.
