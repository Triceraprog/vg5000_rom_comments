$0000/romStart/above
Tout commence par un saut à l'adresse $1000. Le choix de l'adresse $1000
semble arbitraire. D'autres machines à base de Z80 font des sauts à d'autres
adresses.
;
Comme les adresses suivantes sont les adresses de branchement des instructions
RST du Z80, le code de démarrage doit se trouver plus loin. D'où le saut.
;
Juste après le saut se trouve, sous forme de chaîne de caractères, le numéro
de version de la ROM.

$0018/SendChar/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

$0020/hl_de_cmp/above
Fonction : comparaison de HL et DE
Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
En sortie, C sera positionné si HL < DE

$0069/from47ee/code:L'adresse $47EE reçoit un JP $0069.

$008f/playsnd/code
$0a87/playimpl

$0255/ClearScreen/above
Fonction: Efface l'écran
Efface tout d'abord la ligne 0
Puis recopie le contenu mémoire de cette ligne sur le reste de l'écran

$0265/ClearLine/above
Fonction: Efface une ligne
Entrées : A contient un numéro de ligne

$026b:Écriture de $80 à la première position de la ligne
$026d:Récupération des attributs par défaut
$0271:Écriture dans la position suivante des attributs par défaut

$0276
if bit(C,7) == 1 then A = 0 else A = $20
Le bit 7 de C étant à 1 pour un caractère graphique, 0 pour texte

$027d
Boucle pour écrire dans les positions suivantes de la ligne alternativement A et C.
Donc un espace pour le mode texte et 0 pour le mode graphique, suivi des attributs

$0291/xytoscreen/above
Fonction: renvoie l'adresse écran à partir des coordonnées X et Y
Entrées : H contient y, L contient x
Retour : HL contient $4000 + 80y + 2x

$0291:C contient x
$0292:L contient Y
$0297:HL = L * 8 (c'est-à-dire y * 8)
$0299:DE = HL = y * 8
$029c:HL = 32 * y + 8 * y = 40 * y
$029d:HL = 80 * y
$029e:C contient x
$02a1:HL = 80 * y + 2 * x
$02a5:HL = $4000 + 80 * y + 2 * x

$02EF/SendSeqEF/above
Fonction: Envoi d'une séquence à l'EF9345
Entrée: HL pointe sur la séquence de données à envoyer.
Le premier octet de la séquence est sa longueur en octet.

$0286/WaitRdyEF/above
Fonction: Attente d'état « prêt » de l'EF9345
'$20' est envoyé sur le port $8F puis on attend que le le bit de
poids fort sur le port $CF soit à 0.

$0a78:Désactivation de l'affichage

$0ca7/snd_emit

$0d7c/SendToEF/above
Fonction: Envoi d'une donnée à l'EF9345
Registre en entrée : DE
Registre modifié : C
D est envoyé sur le port $8F
C est envoyé sur le port $CF

$0d85/DefineChar/above
Fonction: Redéfinition d'un caractère
Registres en entrée : HL et A
Registres modifiés : AF, HL, BC, DE

$0d85:if bit(A, 7) == 0 then B = $C0 else B = $40
$0d8d:Le haut de la pile contient BC
$0d8e:Désactivation de l'affichage
$0d98
Envoi à l'EF9345 de $22,A (avec le bit 7 de A mis à 1) (R2=A)
(A est envoyé à travers E)

$0d9b:Récupération de la valeur de BC dans AF
$0d9c:Remise du contenu de BC sur la pile
$0d9d:Inversion du bit 7 de A, qui est la valeur de B du début de la fonction ($C0 ou $40)
$0da2:Envoi à l'EF9345 de $21,A (A est envoyé à travers E) (R1=A)
$0da9:Envoi à l'EF9345 de $20,$03 (R0=3 -> KRG+Inc)
$0dae:Récupération, à travers E, de la valeur de A en entrée de fonction (avec les trois lignes suivantes)
$0db4:A = (A >> 2) & $1F
$0db7:Envoi à l'EF9345 de $24,A (A est envoyé à travers E) (R4=A)
$0dbd:A = (A initial de la fonction) & $03
$0dbf:Récupération du contenu du BC initial ($C0 ou $40)
$0dc0:A = A | B
$0dc2:Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0dc9:Envoi à l'EF9345 de $20,$34 (R0=OCT Write AP NoInc, écrit R1 en mémoire désigné par R4 R5)
$0dcc:Boucle extérieure, 10 itérations
$0dce:Récupère la valeur suivante de la redéfinition de caractère dans A
$0dd0:Boucle intérieure, 8 itérations
$0dd4:Inverse le contenu de A et C, bit à bit
$0dd8:La ligne de redéfinition lue dans (HL) est à présent inversée dans A
$0ddd:Envoi à l'EF9345 de $29,A (A est envoyé à travers E) (R1=A + Execute)
$0dee:Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0df3:Réactivation de l'affichage

$0de5
Envoi sur $8F de $25 puis récupération sur $CF d'une valeur dans A (Read R5)
Puis A = A + $04

/////////////////////////////////////////
////////////////// 1000 /////////////////
/////////////////////////////////////////

$1000/Start/above
C'est ici que commence l'intialisation complète de la machine.
La première étape est de recopier le contenu de la ROM dans
l'espace RAM adressable. Adressable ne signifie pas que de la RAM
est effectivement branchée. Cela ne pose pas de problème au
niveau hardware du VG5000 d'envoyer une demande d'écriture.
;
Le contenu de la mémoire est ensuite lu et comparé à la ROM.
Tant que c'est identique, c'est qu'il y a quelque chose de branché
qui répond correctement. Dès que c'est différent, c'est qu'on est
sorti de la zone de la mémoire inscriptible disponible.
;
La dernière adresse valide est stockée dans $4895 et dans SP, le
registre pointeur de pile (Stack Pointer)
;
On remarquera que si une ROM répond avec un contenu identique à
la ROM à une adresse multiple de 16ko, l'initialisation va
penser que c'est de la RAM accessible.

$1000
Démarrage complet de la machine.
Vérifier pourquoi c'est appelé depuis $2282

$100a
Copie de la ROM sur toute la mémoire adressable
Equivalent C-style de : memcpy($4000, $0000, $C000)

$100c:À la fin de LDIR, HL == $C000, DE == $0000, BC == $0000
$100e:À présent, HL == $4000, DE == $0000, BC == $C000
$1010:Début de la comparaison octet par octet de la mémoire
$1015:Si le contenu de (HL) et (DE) est différent, on saute en $101B
$1017
Si le contenu de (HL) et (DE) est identique
et que BC est > 0, on loop

$101a/above
L'instruction partielle suivante ne sert à rien d'autre qu'à gagner un peu
d'espace lorsque BC == 0 et que la boucle est terminée.
Le contenu de A est écrasé un peu plus loin.

$101b
HL est décrémenté pour retrouver la dernière addresse testée (CPI augmente HL).
HL contient donc la première adresse invalide de l'espace mémoire en écriture.
Cette adresse est mise dans SP et stockée en $4895

$1020/above
La seconde étape de l'initialisation consiste à remplir les vecteurs
utilisateur par des instructions spécifiques. Ces vecteurs, situés
en RAM, permettent d'intervenir lors de certaines opérations avec
du code écrit par l'utilisateur et donc de modifier le comportement
du système.

$1020
Les adresses $47D0 à $47EE vont ensuite est remplies par des RET ($C9).
Equivalent C-style de : memset($47D0, $1E, $C9)

$104b/above
La troisième phase initialise le processeur graphique EF9345. Pour commencer,
une séquence est envoyée au périphérique, puis quelques variables en RAM sont
mises initialisées.
;
Attention, la valeur de IX doit rester constante. Le système de cette ROM
considère que IX est en tout temps égal à $47FA et référence certaines
variables par index par rapport à IX.
;
La séquence est
 $28,$81 -> Écriture de quelque chose dans le TGS
 $29,$00 -> TGS = 0 (625 lignes, non entrelacé, no-input-resync, output VSync+HSync, Service Row = 0, 40 Char
 $20,$82,$29,$6e -> MAT = $6e (Marge = B+G, Insert Marge, Curseur plein/flash, Curseur affiché, simple hauteur
 $20,$83,$29,$f7 -> PAT = $f7 (Ligne 0 'ON', Bulk haut et bas activé, pas de conceal, Insert mode : Active Area, Flash ON, Format court pour le 40 Char
 $20,$84,$29,$13 -> DOR = $13 (Block G0=3, Block G1=1<<1, Block Q=0<<3)
 $20,$87,$29,$08 -> ROR = $08 (Z=0, Y=8)
 $26,$08,$27,$00,$28,$02 -> R6=$08, R7=$00, KRG sans incrémentation avec MP=$0800 (data R1, R2 = $08, ??)
;
Envoyés par pairs sur les ports $8f, $cf

$104b:IX prend la valeur $47FA qui est la base de la zone de données graphiques.

$104F
-> $1179 est la zone mémoire contenant la séquence à envoyer au EF9345.
HL pointe sur la taille de la séquence à envoyer au EF9345.

$1055:Initialisation de la variable $47FA : compteur d'interruptions à 5
$1059:Initialisation de la variable $47FB : besoin de rafraichissement à faux
$105d:Initialisation de la variable $47FA : utilisation des majuscules
$1063/above:Les interruptions sont réactivées pour la suite de l'initialisation.
$1067:Numéro de la première ligne du BASIC ?
$106a:Couleur du pourtour et aspect du curseur
$107a:Copie les valeurs initiales des différentes variables du système en RAM
$107d:Envoi 0 sur le port $EF, censé être non utilisé
$107d:Envoi 0 sur le port $AF, pour le son-k7
$1084:Modification de l'adresse du hook "nmihk"
$1093/above:Calcul des bornes de pile, memsize et place disponible
$1096:hl <- sp - 2 (sp == (stktop))
$109b:hl < $03e8 ? (comment serait-ce possible ?)
$109e:de <- $ffce (-50)
$10a5:Calcul final du haut de la pile comme étant (memsize) - 50
$10ab:Récupération du haut de la pile
$10b1:hl <- (stktop) - 17
$10ba
hl = hl - de, soit ((stktop) - 17 - end_vars)
Autrement dit, la taille disponible entre la fin des variables internes et la pile -17.

$10bb:Cette taille disponible est poussée dans la pile.
$10bc/above:Affichage du texte de démarrage. VG5000 + numéro de version
$10bc:Texte en double hauteur, double largeur

$1148/vg5000_txt
$1163/version_txt
$1179/InitEfSeq:Séquence d'intialisation de l'EF9345 au démarrage.
$1194/InitValues
$1202/AfterInit
$1d97/sendchar_k7


////////////////////


/////////////////////////////////////////
////////////////// 2000 /////////////////
/////////////////////////////////////////

$2250/SomeVector/code:Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.

$24ea/playret/code
$247A/code

//-----------------
$2527/read_quotes/above
Fonction: lecture appelée à l'ouverture du guillemets lors d'un out_str...
... entre autre.

$2efe/resetstack/above
Fonction : remise à zéro de la pile et effacement de l'interprétation en cours. Réinitialisation de l'imprimante.
Retour : HL contient le code de l'instruction en cours ?
;
Un meilleur nom: interpreter_reset ?

$2efe:Récupération de l'adresse de retour
$2eff:Réinitialisation de la pile (SP) à la dernière addresse RAM valide
$2f06:Le pointeur sur la zone temporaire de descripteur est initialisé
$2f0f:Mise à zéro de `oldtxt`
$2f12:Mise à zéro du buffer `subflg` (utilisé pour FOR)
$2f15:Mise à zéro du buffer `prmnam` (nom du paramètre actif)
$2f18:Met 0 sur la pile
$2f19:Remet l'adresse de retour sur la pile avant le RET
$2f1a:HL contient la valeur de `temp` (code d'une instruction)

/////////////////////////////////////////
////////////////// 3000 /////////////////
/////////////////////////////////////////

////////////////// 3200 /////////////////
$3278/initscreen/above
Réinitialisation du curseur, d'attributs
Redéfinition de deux caractères: $20 et $7F
Efface l'écran, remise en colonne 1

$3292/initscreen2
$3278:Deux accès à $47FD pour set les bits 4 et 6
$327c:Test du bit zéro sur $47FE (majuscules\minuscules)
$3286:Changement de l'aspect du curseur si minuscules
$3297:Initialisation des attributs utilisés pour l'effacement de l'écran

$329d/cur_home
$32a0:Curseur mis en haut à droite de l'écran
$32a3:Force l'affichage à l'interruption suivante
$32ab:Et attend l'affichage

$331f:La pile contient, en haut, $33c5, puis AF (qui contient le caractère)

$3349/above
Partial instruction trick en cascade.
Les 6 labels suivants chargent A avec une certaine valeur.
Puis exécutent une série de LD HL avec des valeurs inutiles
Pour finalement arriver sur 'sdchar_pass'
;
Cela agit comme un remapping des caractères qui étaient normalement non affichables.

$3349/sd_a_ff
$334c/sd_a_0d
$334f/sd_a_08
$3352/sd_a_04
$3355/sd_a_1f
$3358/sd_a_03

$335b:$33cd est mis sur la pile pour servir de branchement lors du prochain RET, à la fin de l'émission du caractère.

$331a/sendchar_t2
$3328:A est compris entre 128 et 160. La mise à 0 du bit 7 revient à soustraire 128
$332c:A est inférieur ou égal à 128.
$332e:On vérifie s'il est supérieur à 32
$3334:Saut si on est en train d'utiliser les caractères utilisateurs
$333a:Saut si c'est un caractère graphique
$333c:Arrivé ici si le caractère était dans [128,160[ (ajusté en [0, 32[ ou un caractère redéfini de numéro inférieur strictement à 32.
$332c/sdchar_bl80
$335a/sdchar_pass
$3342:E = A * 3 (A contient le caractère)
$3348:Branchement sur la table de redirection qui commence en $3362

$3362/sdchar_ind/code
Code: $3365
Code: $3368
Code: $336B
Code: $336E
Code: $3371
Code: $3374
Code: $3377
Code: $337A
Code: $337D

Code: $3380
Code: $3383
Code: $3386
Code: $3389
Code: $338C
Code: $338F
Code: $3392
Code: $3395
Code: $3398
Code: $339B

Code: $339E
Code: $33A1
Code: $33A4
Code: $33A7
Code: $33AA
Code: $33AD
Code: $33B0
Code: $33B3
Code: $33B6
Code: $33B9

$33BC/code:Fin de la table d'indirection. Caractère 31.

$33cd/code/above
Cette adresse est forcée dans la pile pour que le RET de l'affichage de caractère passe par là.
Le rafraichissement de l'écran est demandé et la pile et les registres remis en ordre.

$33d4/carreturn/above
Fonction: traitement Carriage Return
Traitement de l'affichage du caractère 13 (et 3)

$33da:Saut si 'x' est différent de 1
$33e1:Saut si 'continuation permitted' est à 0
$33e3
Si le curseur est sur la colonne 1 et 'continuation permitted' est à 1, alors la colonne 0 est mise à $80 (attributs par défaut pour l'EF9345)
Et c'est fini.

$33ed:Le curseur est mis sur la colonne 1 et on enchaîne sur `line_down`
$33fd:Si le scrolling est désactivé, on saute
$341a:Si le scrolling est désactivé, on saute


$3442/col_right/above
Fonction : La position du curseur est avancée de 1 vers la droite
Traitement de l'affichage du caractere 7

$3448:Si le curseur est en position 39, on saute
$344f/line_below
$344b/col_r_end

$3452:On ne fait rien si le curseur est en bas à droite de l'écran.

$33f0/line_down/above
Fonction: amène le curseur une ligne plus bas
Traitement de l'affichage du caractere 10


////////////////// 3400 /////////////////

$340e/line_up/above
Fonction: amène le curseur une ligne plus haut
Traitement de l'affichage du caractere 9

$342b/col_left/above
Fonction : La position du curseur est avancée de 1 vers la gauche
Traitement de l'affichage du caractere 8

$342b:xcursor est suivi de ycursor. Ce qui fait que H contient 'y' et L contient 'x'
$3431:Saut si la colonne du curseur est inférieur strictement à 2

$3438/line_above
$343a:On ne fait rien si la ligne du curseur est à zéro

$3434/col_l_end
$343e:Curseur à la dernière colonne

////////////////// 3300 /////////////////

$359f/clr_scr_btm
Fonction : Efface toutes les lignes à partir de la ligne courante jusqu'en bas de l'écran
Traitement de l'affichage du caractère 31

$35ad/scroll_up/above
Fonction: monte le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

$35b9/scroll_down/above
Fonction: descend le contenu de l'écran d'une ligne par recopie de la mémoire
La nouvelle ligne a toujours l'ancien contenu

$35c5/resetcursor/above
La fonction réinitialise les bits 2 et 7 de $4871.
A priori : coupe le scrolling et ligne non entrée sous BASIC
;
Puis réinitialise quelques valeurs d'affichage

$35cd:$4804 à 0 : pas de redéfinition de caractères
$35d1:$4002 à 0 : couleur d'encre et fond graphique à zero, texte
$35d5:$47FB à 1 : force un affichage
$35d9:$47FC à 0 : équivalent de DISPLAY 10
$35e6/honk
$35f3/jump_ret:Cette adresse est utilisée pour sauter à un RET depuis une table d'indirection.

$35fe/char7f
$35f4/char20


////////////////// 3600 /////////////////

$36aa/out_str/above
Fonction: Affichage d'une chaîne à l'écran
Entrée: HL pointe sur la chaîne de caractère terminée par un 0

$366c/out_str_prc/above
Fonction: traite la chaîne de caractères à afficher avec extention des variables.

$366c:Positionne hl un caractère avant le début de la chaine (à cause du inc hl de la boucle qui suit)
$3674:Récupération du caractère dans a
$3675:Incrémentation du compteur de caractères affichés
$3677:Si le caractère est 0 (fin de chaîne)
$367a:Si le caractère est $22 (=34, guillemets)

$367f/out_str_2

$367d:Tant que l'on traite des caractères normaux
$3681:Traitement spécifique pour les guillemets
$3670:Sauve la valeur courante de hl (pointe sur ... )

$3bd0/SendCharImp/above
Fonction : envoie d'un caractère sur le périphérique sélectionné
Entrée : le caractère est contenu dans A

//------------
$3be1/sendchar_pt
$3c14/resetprt/above:Fonction: Mise à zéro de l'état de l'imprimante
$3c16:Sélectionne l'imprimante pour l'affichage
$3c20:Récupération et mise à zéro du Bit 7 du status de l'imprimante
$3c25:Si le bit était à 0, récupération du numéro de ligne de l'imprimante dans a
$3c28:Permet de mettre à jour les flags de F
$3c29:Appel si le bit 7 du status était 1, ou bien si la ligne de l'imprimante n'est pas 0
$3c31:Clear du picflg sauf le bit 6 (signal de curseur en fin de page)
$3c35:Sélection du terminal comme sortie des caractères
$3c38:Mise à zéro de l'état de l'imprimante.
$3c3c/sendchar_te:Récupération de AF qui contient prtflg

$3c57/crdo/above
Fonction : Envoi d'un retour chariot sur la sortie de caractère actuel

$3c5e:Saut si la sortie de caractère se faire sur le terminal
$3c61:Saut si la sortie de caractère n'est pas l'imprimante (donc la k7)

$3c72/crdo_term
$3c6e/crdo_k7

$3c63/crdo_prt/above
Fonction : Retour chariot à la ligne suivante sur l'imprimante

$3c6a:Mise à zéro de la colonne de l'imprimante (aucun test de la véracité...)

$3dc0/initscreen1



// Label: $1179, InitEF
$47D0/VectorBase

// Hooks
$47E2/outhk
$47E5/crdhk
$47EE/nmihook
$47F1/lpenhook
$47F4/diskhook
$47F7/modemhook

//
$47FA/GraphValues
$4805/xcursor
$4806/ycursor
$486F/prtflg:Selectionne la sortie des caractères (0=Terminal, 1=printer, ff=k7)
$4871/DisplayCtrl
$4874/prtstt:État de l'imprimante
$4895/stktop:Addresse de départ (maximale) pour la pile. Initialisée tout en haut de la RAM.
$4919/endbuf
$491f/memsiz:Plus haute mémoire disponible (pour le BASIC ?)
$4921/temppt
$4923/tempst
$47FA:Début de la zone de données graphiques pour la communication avec le EF9345
$49fb/end_vars:Adresse juste après la dernière des variables système.
