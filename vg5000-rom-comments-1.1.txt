            Commentaire par Triceraprog (https://www.triceraprog.fr/) / Sylvain Glaize

            Licence : Attribution - Partage dans les Mêmes Conditions 4.0 International
                      Attribution-ShareAlike 4.0 International
                      (CC BY-SA 4.0) 

$0000       [reset]
            %CODE,SECTION(in)
            == DEBUT DE SECTION IN (bas niveau et interruptions) ==
            Tout commence par un saut à l'adresse $1000.

            C'est aussi `RST 0`.

            Le Z80 réserve le bas de la mémoire aux branchements de type `RST`.
            Il est donc standard que `RST 0`, le reset, branche vers une
            adresse plus loin pour la phase démarrage du système.

            Cette adresse est variable d'une machine à l'autre. Sur VG5000µ, c'est
            $1000.
$0003       Un octet inutilisé.
$0004       [num_ver]
$0004       %NTS
            Numéro de la version de la ROM

$0008       [chkchr]
            %CODE
            Vérifie que le caractère pointé par HL est égal au caractère qui suit exactement
            l'instruction `RST $8`/`RST 1` appelante.

            Si ce n'est pas le cas, affiche un message d'erreur de syntaxe BASIC.

$0008       Enregistre le caractère pointé par HL
$0009       Échange le contenu sur le haut de la pile (l'adresse de retour de RST) et HL
$000a       Compare le contenu de l'adresse de retour et la valeur sauvée dans A
$000b       Incrémente HL afin que l'adresse de retour saute le caractère suivant l'instruction appelante
$000c       Remet la nouvelle adresse de retour en place sur la pile
$000d       Si les deux caractères comparés étaient différent, saute en stx_err_prt ; sinon, passe dans chget

$0010       [chget]
            %CODE,MS_BASIC(GETCH)
            Incrémente HL et met le caractères pointé par le nouveau HL dans A.

            Appelé par `RST $10`/`RST 2`

            Retour:
            - A = code caractère
            - Carry = 1 si c'est un chiffre, 0 sinon
            - Z = 1 si c'est une fin de ligne (A était égal à 0) ou si le caractère était ':' (fin d'instruction)
$0010-$0011 A prend la valeur pointée par HL incrémenté de 1
$0012       %CHAR
            ':' est le premier caractère après '9'
$0014       Ce n'est pas un chiffre (ni zéro), retour immédiat.

$0018       [outdo]
            %CODE
            Envoi d'un caractère sur le périphérique sélectionné par `prtflg`.

            Appel par `RST $18`/`RST 3`.

            Entrée :
            - le caractère à envoyer est dans A.

$0018       L'implémentation de `outdo` est plus loin.

$001b       [setext]
            %CODE
            Redéfinition d'un caractère programmable de la mémoire vidéo.

            Entrées :
            - A[6:0] contient le caractère à changer (sur 7 bits).
            - A[7] contient la nature de la palette (0 == Texte, 1 == Graphique)
            - HL pointe sur le buffer de 10 octets avec les valeurs de caractère.

            [ArticleSetExtCommandsAndMemoryLayout]

$001b       L'implémentation de `setext` est plus loin.
$001e       Deux octets inutilisés.

$0020       [dcompr]
            %CODE
            Comparaison de HL et DE.

            Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
            Aucun des deux registres n'est modifié.

            Appel par `RST $20`/`RST 4`.

            Entrée :
            - HL et DE, les deux registres à comparer.

            Sortie :
            - A est modifié
            - Carry est à 1 si DE est supérieur à HL.
            - Z est à 1 si les deux registres sont égaux.
            - HL et DE sont conservés.


$0020-$0024 Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
$0026       Deux octets inutilisés.

$0028       [getsign]
            %CODE
            Détermine le signe du nombre dans l'accumulateur flottant.

            Appel par `RST $28`/`RST 5`.

            Retour:
            - A retourne $FF (négatif), $00 (nul) ou $01 (positif).
            - Préserve HL
$0028-$002b Si l'exposant est à 0, alors le nombre est nul.
$002c       Saute si l'exposant est 0.
$002f       Sinon sort avec 0 dans A.

$0030       [usrrst]
            %CODE
            Cette entrée de `RST` est réservée pour l'utilisateur.

            Appel par `RST $30`/`RST 6`.

            [ArticleRST6]

$0030       Saut vers le trampoline, initialement contenant `RET`.

$0033       [warmgo]
            %CODE
            Indirection pour le redémarrage à chaud.

$0033       Saute vers l'implémentation du démarrage à chaud.
$0036       Semble ne servir à rien.

$0038       [irq]
            %CODE
            Traitement de l'interruption (IRQ) du Z80.

            Le Z80 fonctionne en mode 1. Dans ce mode, un signal IRQ provoque, après
            traitement de l'instruction en cours, un branchement à cette adresse.

            Sur le VG5000µ, cette interruption est levée par le signal Vertical Sync
            de l'affichage (sortie PC/VS sur l'EF9345).

            Un vecteur est disponible pour installer une routine d'utilisateur qui
            sera appelée lors du traitement de l'IRQ.

            Appel par `RST $38`/`RST 7`.

            [ArticleUserIRQ]

$0038       Appel au vecteur utilisateur.
$003b       Sauve AF.
$003c       Décrémente le compteur de temporisation d'affichage
$003f       Si le compteur n'est pas nul, on évite le rafraîchissement.
$0042-$0045 Chargement de la valeur de référence du compteur de rafraîchissement.
$0048-$004c Test puis mise à zéro du bit 0 du drapeau d'affichage.
$0050       Si le drapeau d'affichage était à zéro, on évite le rafraîchissement.
$0053-$0055 Début du rafraîchissement de l'affichage, avec sauvegarde
            de registres.
$0056-$005c VDP - $28/$82, MAT = R1
$005e-$0062 Prépare la commande $29
$0065       Un octet inutilisé.

$0066       [nmi]
            %CODE
            Interruption non masquable.

            L'interruption est provoquée par l'appui sur la touche Delta, qui est branchée
            sur l'interruption du processeur (broche \NMI)

            L'interruption branche immédiatement vers un vecteur qui, par défaut, branche à
            son tour vers `test_reset`. Cette routine par défaut vérifie l'appui sur la
            touche `CTRL`. Si c'est le cas, un redémarrage à chaud aura lieu. Sinon, il ne
            se passe rien de plus.

            [ArticleUserNMI]

$0069       [lang_to_eng]
            %CODE
            Met le système en anglais.

            Le seul accès semble être via la valeur que prend temporairement `nmihk` pendant le démarrage.
$0069-$006b Messages en anglais.
$006e-$0071 Table de transcription du clavier en anglais.
$0074       Retour d'interruption NMI.

$0076       Dix octets inutilisés.

$0080       [retfun]
            %CODE
            Fin de fonction d'utilisateur.

            Doit être appelé à la fin d'une fonction utilisateur afin de placer le contenu de A comme
            résultat de la fonction.

            Entrées :
            - A contient la valeur de retour de la fonction
            - HL pointe sur le texte BASIC
$0080       Saut vers l'implémentation.

$0083       [deint]
            %CODE
            Place l'accumulateur flottant en tant qu'entier dans DE.

            Peut être appelé par une fonction utilisateur afin de récupérer le contenu de
            l'accumulateur flottant en tant qu'entier, dans DE. Si ce n'est pas possible,
            une erreur BASIC est provoquée.

            Entrées :
            - HL pointe généralement sur le texte BASIC (mais ne sert pas et est préservé).

            Sortie :
            - DE contient la valeur de l'accumulateur flottant, sous forme entière.
$0083       Saut vers l'implémentation.

$0086       [getbyt]
            %CODE
            Évalue l'expression BASIC pointée par HL et renvoie son résultat dans A.

            Le résultat de l'expression doit être numérique et tenir sur 8 bits.
            Dans le cas contraire, une erreur BASIC sera levée.

            Entrées :
            - HL pointe sur le texte BASIC.

            Sortie :
            - DE contient l'évaluation de l'expression, sous forme entière.
            - HL est avancé après l'expression.
$0086       Saut vers l'implémentation.

$0089       [frmnum]
            %CODE
            Évalue l'expression BASIC pointée par HL et renvoie son résultat dans FAC.

            Si l'expression n'est pas numérique, une erreur BASIC sera levée.

            Cette opération peut être enchaînée avec un appel à `deint` pour récupérer le
            résultat sous forme d'entier 16 bits dans DE.

            Entrées :
            - HL pointe sur le texte BASIC.

            Sortie :
            - FAC contient l'évaluation de l'expression.
            - HL est avancé après l'expression.
$0089       Saut vers l'implémentation.
$008c       [beep]
            %CODE
            Produit un son.

            Entrées :
            - DE contient la durée du son.
            - (sonsav_hi) contient le temps de la période haute du son.
            - (sonsav_lo) contient le temps de la période basse du son.

            [ArticleBeep]
$008c       Saut vers l'implémentation.

$008f       [play]
            %CODE
            Joue une séquence sonore codée par une chaîne de caractères selon le format de la commande
            BASIC `PLAY`.

            Entrées :
            - BC pointe vers la chaîne de commande.
            - E contient la taille de la chaîne de commande en octets.

            [ArticleVDP]
$008f       Saut vers l'implémentation.

$0092       [putahl]
            %CODE
            Place une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            La position est spécifiée.

            Le BASIC n'utilise pas cette commande et passe par une mémoire intermédiaire.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC et AF

            [ArticleVDP]
$0092       Saut vers l'implémentation.

$0095       [putici]
            %CODE
            Place une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            Le caractère est placé à la position courante du curseur.

            Le BASIC n'utilise pas cette commande et passe par une mémoire intermédiaire.

            Entrées :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC et AF

            [ArticleVDP]
$0095       Saut vers l'implémentation.

$0098       [getahl]
            %CODE
            Lit une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            La position est spécifiée.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            Sorties :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC DE, et AF

            [ArticleVDP]
$0098       Saut vers l'implémentation.

$009b       [getici]
            %CODE
            Lit une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            Le caractère est lu depuis la position courante du curseur.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            Sorties :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC DE, et AF

            [ArticleVDP]
$009b       Saut vers l'implémentation.

$009e       [cls]
            %CODE
            Efface la mémoire tampon de l'écran.

            L'effacement se fait en effaçant la première selon la procédure `cll` qui suit, puis
            en recopiant son contenu dans le reste de la mémoire tampon.

            Entrées :
            - (attbak) contient la couleur de fond.
            - (attcar) contient les attributs de caractères.

            [ArticleScreenBuffer]
$009e       Saut vers l'implémentation.

$00a1       [cll]
            %CODE
            Efface une ligne donnée de la mémoire tampon de l'écran.

            L'effacement se fait en plaçant en début de ligne un caractère de délimitation dont les paramètres
            se trouvent en (attbak). Puis en remplissant la ligne avec $20 (espace ASCII) en mode
            texte, ou $00 en mode graphique, avec un attribut, selon la directive (attcar).

            Entrées :
            - A contient le numéro de la ligne.
            - (attbak) contient la couleur de fond.
            - (attcar) contient les attributs de caractères.

            [ArticleScreenBuffer]
$00a1       Saut vers l'implémentation.

$00a4       [wait]
            %CODE
            Attente que le VDP soit prêt.

            Modifie :
            - AF

            [ArticleVDP]
$00a4       Saut vers l'implémentation.

$00a7       [fndadr]
            %CODE
            Calcule de l'adresse dans le tampon vidéo de coordonnées.

            Entrées :
            - H contient le numéro de la ligne (Y)
            - L contient le numéro de la colonne (X)
            Sortie :
            - HL contient l'adresse correspondante dans le tampon vidéo

            [ArticleScreenBuffer]
$00a7       Saut vers l'implémentation.

$00aa       [kbscan]
            %CODE
            Renvoi le numéro de la touche clavier appuyée, ou 0.

            Effectue un scan du clavier sur le moment.

            Sortie :
            - A contient le caractère ASCII produit par la touche appuyée, ou bien 0.
            - Le Carry indique si la lue touche a changé depuis le dernier appel (0) ou est restée identique (1).

            [ArticleKeyboard]
$00aa       Saut vers l'implémentation.

$00ad       [regst]
            %CODE
            Envoie au VDP une liste de paires (registres, valeur).

            Le premier élément de la liste est le nombre de paires de la table.
            Suivent les paires sous forme de deux octets, le premier contenant l'adresse de sélection de registre et le deuxième la valeur à transmettre.

            Entrées :
            - HL pointe vers la table des valeurs.

            Modifie :
            - HL, BC, AF
            [ArticleVDP]
$00ad       Saut vers l'implémentation.

$00b0       [stkv]
            %CODE
            Vérification de l'axe vertical pour les déplacements.

            L'axe vertical est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de sélection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.

            Sortie :
            - A = 0, aucune action selon l'axe vertical.
            - A = 1, action vers le bas.
            - A = 255, action vers le haut.

            Modifie :
            - AF, B

            [ArticleActions]
$00b0       Saut vers l'implémentation.

$00b3       [stkh]
            %CODE
            Vérification de l'axe horizontal pour les déplacements.

            L'axe horizontal est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de sélection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.

            Sortie :
            - A = 0, aucune action selon l'axe horizontal.
            - A = 1, action vers la droite.
            - A = 255, action vers la gauche.

            Modifie :
            - AF, B

            [ArticleActions]
$00b3       Saut vers l'implémentation.

$00b6       [stka]
            %CODE
            Vérification du bouton d'action.

            Le bouton d'action est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de sélection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour la barre espace du clavier.

            Sortie :
            - A = 0, aucune action.
            - A = 1, bouton actif.

            Modifie :
            - AF, B

            [ArticleActions]
$00b6       Saut vers l'implémentation.

$00b9       [break]
            %CODE
            Vérification de la séquence `break` (shift + stop appuyés au clavier).

            Sortie :
            - A = 1 si `stop` n'était pas pressé
            - A = 4 si `stop` était pressé, mais pas `shift`.
            - A = 0 si `stop` et `shift` étaient pressés, le Carry est à mis à 1.
$00b9       Saut vers l'implémentation.

$00bc       [disp_refrsh]
            Rafraîchissement de l'état de l'affichage sur l'EF9345 en fonction
            du contenu de la mémoire vidéo en RAM ($4000)

            La séquence commence avant le branchement à la fin de `irq:`.

            La séquence envoyée au VDP change entre la ROM 1.0 et ROM 1.1
            La version ROM 1.1 est plus optimisée.

$00bc-$00c1 VDP - $29/MAT, R1 = `(cursor)` (+ Exec)
            Le bit 6 de MAT est forcé à 0, ce invalide l'affichage du curseur.
$00c3-$00ca VDP - $26/$00, R6 = 0
$00cc-$00d1 VDP - $27/$00, R7 = 0
$00d3       HL pointe vers le début du buffer d'écran BASIC.
$00d6       Prépare l'argument de la prochaine commande.
$00d8       Compteur pour les 80 prochaines paires caractère/attribut à transférer au VDP.
            Cela représente les deux premières lignes de l'écran.
$00da-$00de VDP - $20/$03, KRG avec incrément, MP = $0000.

$00e0       [r_line0_lp]
$00e0-$00e4 VDP - $22/(HL), R2 = (HL) et HL++
$00e6-$00ea VDP - $29/(HL), R1 = (HL) et HL++ (+ Exec)
$00ec       Boucle sur les 160 octets des deux première lignes.

$00ee-$00f4 VDP - $26/$08, R6 = 0
$00f6-$00fb VDP - $27/$00, R7 = 8
            R6, R7 forment le nouveau pointeur pour KRG.
$00fd       24 transferts.

$00ff       [r_line_loop]
$00ff       Compteur pour les 120 prochains octets à transférer.

$0101-$0103 VDP - $20
$0105       [w_vdp_1]
$0105-$0108 Attente du VDP
$010b-$010f VDP - $20/$03, KRG avec incrément (E = $03)

$0111       [col_loop]
$0111-$0113 VDP - $20
$0115       [w_vdp_2]
$0115-$0118 Attente du VDP

$011b-$011f VDP - $22/(HL), R2 = (HL) et HL++
$0121-$0125 VDP - $29/(HL), R1 = (HL) et HL++ (+ Exec)
$0127       Boucle 60 fois.

$0129-$012b VDP - $20
$012d       [w_vdp_3]
$012d-$0130 Attente du VDP

$0133-$0139 VDP - $28/$b0, Increment Y
$013b-$013c Boucle 24 fois.
$013e-$0142 Branche si le curseur n'est pas actif.
$0144       Coordonnées du curseur dans HL
$0147-$0149 Branche si la ligne du curseur est 0
$014b-$014d Sinon, ajoute 7 au numéro de ligne logique pour obtenir le numéro de ligne VDP.
$014e       [set_cursor]
$014e-$0154 VDP - $26/H - R6 = H, la ligne du curseur.
$0156-$015a VDP - $27/L - R7 = L, la colonne du curseur.
$015c-$0162 VDP - $28/$0a - RAM VDP à l'adresse R6/R7 vers R1/R2

$0164-$0166 VDP - $20
$0168       [w_vdp_4]
$0168-$016b Attente du VDP

$016e-$0174 VDP - $28/$82, MAT = R1
$0176-$0181 VDP - $29/`(cursor)`, R1 = `(cursor)` après avoir forcé l'activation de la marge.

$0183       [end_refresh]
$0183-$0185 Restaure les registres.

$0186       [skip_dsplay]
$0186       Incrémente le compteur de répétition des touches.
$0189       Restaure AF.
$018a       Active les interruptions.

$018c       [putahl_impl]
            Implémentation de `putahl:`.
$018c-$0192 VDP - $26/H - Place le curseur sur le ligne H
$0194-$0198 VDP - $27/L - Place le curseur sur la colonne L

$019a       [putici_impl]
            Implémentation de `putici:`.
$019a       B = $03, C = $cf (port I/O pour les données VDP)
$019d-$019f VDP - $20

$01a1       [put_wait_1]
$01a1-$01a4 Attente du VDP.
$01a7-$01ab VDP - $22/D - Code caractère.
$01ad-$01af VDP - $20

$01b1       [put_wait_2]
$01b1-$01b4 Attente du VDP.
$01b7-$01bb VDP - $21/E - Code attribut
$01bd-$01c1 VDP - $28/$03

$01c4       [getahl_impl]
            Implémentation de `getahl:`.
$01c4       Préparation du port I/O pour les données VDP
$01c6-$01ca VDP - $26/H - Place le curseur sur le ligne H
$01cc-$01d0 VDP - $27/L - Place le curseur sur la colonne L

$01d2       [getici_impl]
            Implémentation de `getici:`.
$01d2       B = $0b, C = $cf (port I/O pour les données VDP)
$01d5-$01d9 VDP - $28/$0b
$01db-$01dd VDP - $20

$01df       [get_wait_1]
$01df-$01e2 Attente du VDP.
$01e5-$01e9 VDP - $22, lecture dans D
$01eb-$01ed VDP - $20

$01ef       [get_wait_2]
$01ef-$01f2 Attente du VDP.
$01f5-$01f9 VDP - $21, lecture dans E

$01fc       [delim_wrt]
            Inscrit un caractère à l'écran avec les attributs courants et avance le curseur.
            Sert aussi pour afficher un délimiteur, qui n'est autre qu'un caractère $80 (espacement) ou $84 (espacement + souligné).

            Peut provoquer un défilement de l'écran.

            Entrée :
            - A contient le caractère à afficher

$01fc       Récupère la valeur de `extenf`, qui indique l'utilisation des caractères ROM ou RAM.
$01ff       Récupère les coordonnées actuelles du curseur.
$0202       Sauve les coordonnées du curseur.
$0203       Sauve le caractère à afficher.
$0204       Calcul de l'adresse écran en RAM pour la position du curseur dans HL.
$0207       Restaure la valeur de `extenf`.
$0208       Met cette valeur dans le premier octet de la paire caractère/attribut dans la zone de l'écran.
$0209       Récupère la valeur de `attcar`, qui contient les attributs de caractère courant.
$020c       Avance le pointeur de l'écran.
$020d       Met dans le second octet de la paire caractère/attribut les attributs de couleurs.
$020e       Avance le pointeur de l'écran.
$020f       Sauve le pointeur de l'écran dans DE.
$0210-$0213 Désactive la continuité de ligne.
            L'écriture du délimiteur ne provoquera pas de création de ligne logique.
$0215       Récupère les coordonnées du curseur.
$0216-$0219 Branche si la colonne est inférieure à 39
$021b       Sinon ramène le curseur à la colonne 0.
$021d       Incrémente la ligne du curseur.
$021e-$0221 Branche si la ligne est inférieur à 25.
$0223       Sinon réduit la ligne de 1.
$0224-$0229 Indique dans le registre `picflg` que le curseur à atteint le bas de l'écran.
$022c-$022e Branche si le défilement n'est pas permis.
$0230       Sauve les coordonnées.
$0231       Provoque un défilement de l'écran de 1 ligne vers le haut.
$0234-$0236 Efface la ligne 24.
$0239       Restaure les coordonnées.
$023a       Demande un rafraîchissement de l'écran à la prochaine interruption.
$023e       Charge DE avec l'adresse du premier octet de la dernière ligne de l'écran.
$0241       [line_ok]
$0241-$0246 Branche si le caractère de continuité n'est pas requis par le registre.
$0248-$024a Réactive la continuité.
$024d-$024f Inscrit le caractère de continuité ($84) au début de la dernière ligne.
$0250       [delim_end]
$0250       Incrémente le numéro de colonne.
$0251       Replace les nouvelles coordonnées dans le registre.

$0255       [cls_impl]
            Efface l'écran avec la couleur de fond passée dans A.

            Entrée :
            - A contient la valeur pour le registre `attbak`.

            Normalement appelé par `cls`

$0255       A = 0
$0256       Efface la première ligne du buffer d'écran avec la valeur `0`.
$0259-$0262 Copie le contenue de la première ligne dans le reste du buffer écran.

$0265       [cli_impl]
            Implémentation de `cli:`.
$0265-$0268 HL pointe vers le buffer d'écran BASIC aux coordonnées X=0, Y=A.
$026b       Écriture de `$80` à la première position de la ligne.
            Ce caractère indique le début d'une ligne logique (par opposition au caractère de continuité).
$026d       A récupère les attributs par défaut de fond `(attbak)`.
$0270-$0271 Écrit dans la position suivante les attributs par défaut de fond `(attbak)`.
            La colonne 0 est donc un caractère marqueur représenté par un caractère vide aux attributs par défaut.
            Dans le mode du VDP utilisé par la ROM, la couleur de fond influe la ligne jusqu`au prochain délimiteur.
$0272       C récupère les attributs par défaut de caractère `(attcar)`.
$0275       HL pointe sur le caractère de la seconde colonne.
$0276-$027c Si `(attcar)` indique le mode texte (= 0), alors A prépare le caractère d'espacement ($20).
            Si `(attcar)` indique le mode graphique (= 1), alors A prépare le caractère nul.

$027d       [cli_default]
            Boucle pour écrire dans les positions suivantes de la ligne alternativement A et C.
            Donc un espace pour le mode texte et 0 pour le mode graphique, suivi des attributs
$027d       B = 39 colonnes
$027f       [cli_loop]
$027f-$0280 Place le caractère préparé dans les positions paires.
$0281-$0282 Place `(attcar)` dans les positions impaires.
$0283       Boucle sur les 39 colonnes.

$0286       [wait_impl]
            Implémentation de `wait:`.
$0286-$0288 VDP - $20
$028a       [wait_loop]
$028a-$028d Attente du VDP.

$0291       [fndadr_impl]
            Implémentation de `fndadr`.

            Effectue le calcul $4000 + (80 * y) + (2 * x).

            Normalement appelé par `fndadr`.

$0291       C contient x
$0292       L contient y
$0293-$0297 HL = L * 8 (c'est-à-dire y * 8)
$0298-$0299 DE = HL = y * 8
$029a-$029c HL = 32 * y + 8 * y = 40 * y
$029d       HL = 80 * y
$029e       C contient x
$02a0-$02a1 HL = 80 * y + 2 * x
$02a2-$02a5 HL = $4000 + 80 * y + 2 * x

$02a7       [kbscan_impl]
            Implémentation de `kbscan:`.

            Les touches sont branchées sur une matrice de 8 lignes de 8 colonnes.

            La première étape est de trouver la premier ligne contenant une touche appuyée,
            puis dans cette ligne, trouver laquelle des 8 touches est appuyée.

            À partir de la ligne et de la colonne, un index est calculé et cet index sert
            à lire la valeur de la touche dans une table.

            Il y a trois tables consécutives.
            - Table standard
            - Table avec `shift` appuyée.
            - Table avec `control` appuyée.

            Ces tables sont en RAM et remplies à l'initialisation en fonction de la langue
            du sytème.

            Sortie :
            - A contient le caractère ASCII produit par la touche appuyée, ou bien 0.
            - Le Carry indique si la lue touche a changé depuis le dernier appel (0) ou est restée identique (1).

$02a7       Prépare C avec le premier port à scanner ($87) et B avec le nombre de ports (7).
$02aa       [kb_row_loop]
$02aa       Lecture de l'entrée depuis un des ports de $87 à $81
$02ac-$02ad La ligne est à l'état haut lorsque la touche n'est pas pressée.
            En prenant son complément, un résultat à 0 signifie qu'aucune touche de la rangée n'est pressée.
$02ae       Branche si une touche est pressée sur cette ligne.
$02b0       Vise le port précédent.
$02b1       Boucle sur le nombre de ports.
$02b3       Lecture de l'entrée depuis le port $80
$02b5       Complément de l'entrée, comme pour la boucle précédente.
$02b6       Masque le rang $80 avec b10111011. Cela filtre la touches `CTRL` ainsi qu'une entrée de la matrice non utilisée.
$02b8       [key_pressed]
$02b8       Branche si aucune touche n'est pressée.
$02ba       Initialise le compteur de nombre de rang du clavier.

$02bc       [col_count]
$02bc-$02bf Cherche la 'colonne' de la touche appuyée et décalant
            vers la gauche A jusqu'à ce que Carry passe à 1, tout
            en comptant depuis 7 à rebours.
$02c1       [col_exit]
$02c1       Place dans A la colonne de la touche pressée.
$02c2       A=2 * colonne
$02c3       A=4 * colonne
$02c4       A=8 * colonne
$02c5       A=(8 * colonne) + (port de la ligne) ($80 à $87)
$02c6       A=(8 * colonne) + (port de la ligne - $80) (0 à 7)
            Cela donne l'index dans la table de décodage.
$02c8-$02ca Lecture du rang 0 dans B (port $80) pour vérifier l'appui sur `shift` et `control`.
$02cc-$02cf Préparation de la table de décodage dans HL et du potentiel décalage.
$02d2       Vérification de la touche `shift` appuyée.
$02d4       Branchement si `shift` n'est pas appuyée.
$02d6       Déplacement du pointeur vers la table de décodage avec `shift` appuyée.
$02d7       Si `shift` est appuyée, `control` est ignorée.
$02d9       [key_noshift]
$02d9       Vérification de la touche `control` appuyée.
$02db       Branchement si la touche `control` n'est pas appuyée.
$02dd-$02de Ajoute $80 (2 * $40) à l'adresse de la table de décodage.
$02df       [key_noctrl]
$02df-$02e0 L'index de la table, dans A, est copié dans DE.
$02e2       L'index est ajouté au pointeur de la table.
$02e3       La valeur de la table est lue dans A.
$02e4       [key_changed]
$02e4       Comparaison avec la valeur précédente lue au clavier.
$02e7       Set Carry
$02e8       Branche si la nouvelle touche pressée est identique à la précédente.
$02ea       Sinon, on enregistre la nouvelle valeur
$02ed       Et le Carry est enlevé
$02ee       [kbscan_exit]

$02ef       [regst_impl]
            Implémentation de `regst:`.
$02ef       Lecture dans B de la longueur (nombre de paires) de la table.
$02f0       Place HL sur l'octet suivant de la séquence.
$02f1       [regst_loop]
$02f4-$02fc Utilisation de `outi` pour envoyer les paires vers le VDP.
            À chaque tour de boucle, le premier octet est envoyé vers le port `$8f` et le second vers le port `$cf`. Chaque envoie est précédé d'une attente d'état `prêt` du VDP.

$02ff       [add_half]
            %SECTION(f4i),MS_BASIC(ROUND)
            == DEBUT DE SECTION F4I (mathématiques flottantes) ==
            Ajoute `0.5` à FAC (l'accumulateur flottant).

            Est utilisé pour faire un arrondi à l'entier le plus proche.

$0302       [fp_add_hl]
            %MS_BASIC(ADDPHL)
            Addition flottante : (HL) + FAC

            Entrées :
            - FAC
            - Le nombre flottant pointé par HL.

            Sortie :
            - FAC contient le résultat.
$0302       Charge les quatre octets pointés par HL dans BCDE.
$0305       Branche vers l'addition entre BCDE et FAC.
$0307       [fp_sub_hl]
            %MS_BASIC(SUBPHL),CODE
            Soustraction flottante : (HL) - FAC

            Entrées :
            - FAC
            - Le nombre flottant pointé par HL.

            Sortie :
            - FAC contient le résultat.

$030a       Saute par dessus les deux `pop` qui suivent.

$030b       [fp_stck_sub]
            %CODE,MS_BASIC(PSUB)
            Appelé via la table des priorités lors de l'évaluation d'une expression.
            Soustrait FAC du contenu de la pile, placé dans BCDE.
$030b-$030c Récupère le nombre flottante depuis la pile puis continue
            sur l'inversion de signe et l'ajout de BCDE à FAC.

$030d       [fp_bcde_sub]
            %MS_BASIC(SUBBCDE)
            Inverse le contenu de FAC puis y ajoute BCDE.
            Ce qui revient à faire BCDE - FAC.

$0310       [fp_bcde_add]
            %MS_BASIC(FPADD)
            Appelé via la table des priorités lors de l'évaluation d'une expression.
            Ajoute le contenu de BCDE et de FAC.
$0310-$0312 Si l'exposant de BCDE est 0, il n'y a rien à ajouter, on ne touche pas à FAC et on sort.
$0313-$0317 Si l'exposant dans FAC est 0, alors on copie BCDE dans FAC et c'est terminé
$031a-$031b Si l'exposant de BCDE (B) est plus petit que celui de FAC (A), on garde comme ça. Sinon, on les échange.
$031d-$031e Oppose la différence entre les exposants (complément à 2)
$031f       Sauve DE...
$0320       Le temps de mettre FAC sur la pile
$0323       ... et restaure DE
$0324       Copie BCDE dans FAC
$0327-$0328 Et récupère BCDE (l'ancien FAC) depuis la pile.
$0329       [no_swap]
            Ici, BCDE contient le plus petit des nombres. A contient la différence (positive) entre les deux exposants.
$0329-$032b Si la différence est de plus de 25. BCDE est négligeable face à FAC, on a terminé.
$032c       Sauve AF
$032d       Extrait les signes de FAC et BCDE, A bit 7 à 1 si les signes sont opposés, 0 si identiques.
$0330       Sauve le résultat du signe dans H
$0331       Et récupère AF
$0332       Déplace la mantisse à droite (division) d'un nombre de position égal à A
$0335-$0336 Test le résultat de signe
$0337       Pointe sur la mantisse
$033a       Branche si les signes étaient différents. Dans ce cas, on doit faire une soustraction.
$033d       Ajoute les mantisses de FAC et BCDE
$0340       Pas d'overflow, on passe à l'arrondi du résultat (et sa normalisation)
$0342       Sinon, il faut augmenter...
$0343       .. l'exposant de 1
$0344       Si l'exposant a dépassé sa limite (boucle sur zéro), branche sur une erreur de dépassement de capacité.
$0347-$0349 Sinon, il faut corriger la mantisse avec un décalage de 1 (L) vers la droite
$034c       Puis on passe à l'arrondi

$034e       [min_bcde]
            FAC - CDEB -> BCDE. Si un overflow (underflow) est provoqué, le nombre est complémenté à 2 à la fin. Puis fallback dans la normalisation.
$0350       B ici contient le résultat du shift à droite le moins signifiant. Le nombre est sous forme CDEB
$035c       [pos_norm]
            Met le nombre en positif potentiellement avant de normer et compacter.
$035c       Si Carry est à 1, fait le complément à 2 de CDEB.

$035f       [bcde_norm]
            Lors de la normalisation, BCDE n'a pas le format normal. B n'est pas l'exposant, mais le poids le plus faible de la mantisse.

            C'est donc une mantisse sous forme CDEB qui est traitée. L'exposant est celui de FAC.
$035f-$0360 L et H sont les plus petits signifiants de la mantisse, qui est sous la forme CDHL (l'exposant est dans FAC)
$0361       A = 0, va servir de compteur

$0362       [rot_loop]
            La partie ci-dessous prend C, D, H, L, A comme un buffer en décalage vers la gauche
            (octet par octet). A est un compteur (sauvé temporairement dans B pendant la rotation) auquel
            on soustrait 8 à chaque fois, jusqu'à attendre $e0 (ce qui fait 4 fois avec A = 0 au début)
$0362       Sauvegarde du compteur dans B
$0363       Récupère le MSB de la mantisse dans A
$0364       Si A est différent de 0, c'est que C (la partie la plus haute de la mantisse) était non nul
$0365       Si A (dont l'octet le plus haut) est 0, on peut faire le décalage d'un octet complet. Sinon, bit par bit
$0367       On décale...
$0368       ... CDHL
$0369       ... vers
$036a       ... DHLA (et A est égal à 0 ici). On embarque L (l'exposant) dans le shift, pour tester au passage s'il était nul.
$036b       Récupération temporaire dans A du compteur
$036c-$036e Soustrait 8 du compteur, puisque l'on vient de décaler de 8, et comparaison avec -24-8.
$0370       Arrêt si le compteur est arrivé à 32. On a décalé de 32 bits au max, le résultat est donc 0. Sinon, on continue le shift
$0372       [clear_fac]
$0372       On met 0 dans le FAC
$0373       [a_to_exp]
$0376       Charge A dans l'exposant de FAC.
$0377       [normal]
$0378-$0379 Vérifie s'il y a des bits dans DHL (les LSBs de la mantisse).
$037a       Si oui, il faut les traiter avec les routines complète
$037c       Sinon, on ne traite que C pour trouver le premier bit de poids fort. Routine optimisée
$037d       [bit_find]
$037d-$037f Diminue B jusqu'à trouver le premier bit à 1 dans A (qui vient de C). B est le résultat du nombre de shift de 8 effectué précédemment, en soustraction de $00.
$0381       Bit à 1 trouvé. On remet B un cran avant.
$0382       On remet aussi le nombre au cran d'avant (remettre le CY dans le nombre)
$0383       C (MSB de la mantisse) est normalisé (avec 1 en msb)
$0386       [norm_full]
$0386       Compte un bit de shift
$0387       Décale HL à gauche de 1
$0388-$038a Shift D de 1 en récupérant le Carry de HL
$038b-$038d Shift C de 1 en récupérant le Carry de D
$038e       [norm_bit]
$038e       Il reste quelque chose, on continu la normalisation
$0391       [norm_nxt]
$0391       Le compteur de shift est mis dans A. CDHL est normalisé.
$0392-$0393 Reconstruction de CDEB contenant la mantisse
$0394-$0395 On n'a rien shifté, on passe à l'arrondi
$0397-$039a Modification de l'exposant avec le compteur de décalage (B est négatif en complément à 2).
$039b       Remise en place de l'exposant ajusté.
$039c       Le décalage est trop grand, on n'a plus de précision, le résultat est 0
$039e       L'exposant est 0, le résultat est donc 0 (dans d'autres versions, un RET Z est fait ici)
$03a0       [round]
$03a0       Récupère la plus petite partie de la mantisse
$03a1       [round0]
$03a4       Vérifie si la plus petite partie de la mantisse a son msb à 1
$03a5       Dans ce cas, on arrondi vers le haut.
$03a8       Récupération dans B de l'exposant
$03a9-$03aa Récupération dans A du résultat de signe
$03ab       Récupération du bit de signe (seul le msb compte)
$03ad       Place le bit de signe (le msb de C est forcément à 1, donc un XOR fonctionne si 1 signifie + ?)
$03ae       Remet en place le MSB + Signe de la mantisse
$03af       Place le résultat dans FAC
$03b2       [round_up]
$03b2       Incrément la partie basse de la mantisse
$03b3       Si on n'a pas fait d'overflow (retour à zero), c'est ok, on revient
$03b4       Sinon, on augmente la partie suivante
$03b5       On vérifie encore
$03b6       Si on doit toujours arrondir, on arrondie la partie suivante
$03b7       Dernière chance
$03b8       Tout a été arrondi, on reset C
$03ba       Et on incrémente l'exposant
$03bb       Retour si tout va bien. Mais si l'exposant a bouclé sur 0
$03bc       Alors c'est que le nombre est trop grand, on lance l'erreur.

$03bf       [add_bcde]
            Ajoute les mantisses de FAC (plus exactement, de ce qui est pointé par HL) et CDE.

            Le résultat est dans CDE, et Carry à 1 si dépassement de capacité.
            FAC n'est pas modifié.

$03bf-$03ca HL pointe sur la mantisse de FAC. Y ajoute la mantisse CDE.

            Les exposants des deux nombres doivent être identiques pour que cela ait du sens.
            Si la mantisse provoque un dépassement de capacité, le Carry sera à 1 en sortie.

$03cb       [cpl_2]
            Complément à 2 de la mantisse sous forme CDEB.
$03cb-$03d0 Inverse le bit de signe temporaire.

$03df       [scale]
            %MS_BASIC(SCALE)
            Décalage vers la gauche de la mantisse CDEB d'un nombre donné par A.

            Le décalage se fait d'abord par groupe de 8 bits tant que c'est possible, puis continue bit à bit.

$03df       Initialise B à 0. B contiendra les bits les moins significatifs de la mantisse.
$03e1       [shiftr_8]
$03e1-$03ea Décale la mantisse de 8 bits (un registre complet) vers la droite.
$03ec       [end_256]
$03ec       La dernière soustraction a fait passer A négatif, on y ajoute 8+1.
$03ee       Sauvegarde de l'exposant restant dans A
$03ef-$03f2 S'il y a des bits à 1 dans le bas de la mantisse (DEB), on passe sur la méthode complète (plus lente) de shift vers la droite L fois.
$03f4       Sinon, on s'occupe uniquement de la partie haute de la mantisse (C)
$03f5       [msb_shift]
$03f5       Décrémentation du nombre de décalage restant (la boucle commence par le test, ce qui explique le 8+1 ajouté à A).
$03f6       Traitement terminé, routine terminée.
$03f7       Décalage à droite.
$03f8       Résultat dans C.
$03f9       Si le décalage a fait sortir un bit à 1, branchement vers la méthode complète.
$03fb       Le décalage n'a pas fait sortir de bit à 1, on continue avec le décalage de C uniquement.

$03fd       [fp_shift_r]
            %MS_BASIC(SHRLP)
            Décalage vers la droite L fois de la mantisse CDEB.
            Méthode complète.

$03fd       A prend 0. Et Carry est à 0 (important pour initialiser le décalage à droite)
$03fe       Décrémentation du nombre de décalage restant (la boucle commence par le test, ce qui explique le 8+1 ajouté à A).
$03ff       Traitement terminé, routine terminée.
$0400       Début du décalage du groupe CDEB vers la droite de 1.

$0401       [shft_right]
$0401-$0402 Décalage d'un bit vers la droite de CDEB, partie C.
$0403       [shift_rgt_2]
$0403-$0405 Décalage d'un bit vers la droite de CDEB, partie D.
$0406-$0408 Décalage d'un bit vers la droite de CDEB, partie E.
$0409-$040B Décalage d'un bit vers la droite de CDEB, partie B.
$040e       [unity]
$0412       [logtab]
$0412       Longueur du tableau.
$0413       [logtab_0]
$0413       4.811474800109863
$0417       [logtab_1]
$0417       6.105852127075195
$041b       [logtab_2]
$041b       -8.86266040802002
$041f       [logtab_3]
$041f       -2.054666757583618
$0423       [logtab2]
$0423       Longueur du tableau.
$0424       [logtab2_0]
$0424       1.0
$0428       [logtab2_1]
$0428       6.427842140197754
$042c       [logtab2_2]
$042c       4.545170783996582
$0430       [logtab2_3]
$0430       0.3535534143447876
$0434       [inst_log]
            %CODE
            Fonction BASIC : `LOG()`

$0434-$0436 Branche sur une erreur si l'argument, dans FAC, est négatif ou nul.
$0439       Appel le calcul du log.
$043c-$043f BCDE = ln(2)
$0442       Multiplie le résultat par ln(2)
$0444       [log]
$0444       L'argument de l'instruction log est ramenée dans BCDE.
$0447-$0449 Initialise l'exposant de FAC avec $80 (c'est-à-dire exposant 0)
$044c       Inverse le bit 7 de l'exposant du paramètre.
$044d       Et sauvegarde le résultat sur la pile.
$044e       Pousse FAC (l'argument du `log` avec son exposant à `$80`) sur la pile.
$0451       Fait pointer HL vers la table de facteurs pour `log`.
$0454       Calcule le polynôme avec les facteurs de `logtab`.
$0457-$0458 Récupère l'argument dans BCHL (car DE va être utilisé)
$0459       Pousse le résultat du polynôme sur la pile.
$045c       Reconstitue BCDE, argument du `log`.
$045d       Monte BCDE dans FAC.
$0460-$0463 Calcule le second polynôme avec les facteurs de `logtab2`.
$0466-$0467 Récupère BCDE, l'argument du `log`.
$0468       Division de l'argument dans BCDE par le polynôme.
$046b       Récupération de l'opération sur l'exposant de FAC (inversion du bit 7).
$046c       Résultat de la division dans la pile.
$046f       Placement du nombre dans A dans FAC (qui était la valeur de l'exposant)
$0472-$0473 Récupération du résultat du calcul qui avait été mis sur la pile.
$0474       Ajout avec FAC.
$0477       Un octet inutilisé.

            Cet octet semble être un reliquat du BASIC utilisé.
            Dans d'autres versions, la dernière multiplication de `LOG` est faite par enchaînement avec la routine suivante, et l'octet permet de sauter par dessus les deux `pop` qui suivent.

$0478       [fp_stk_mul]
            %CODE
            Appelé via la table des priorités

            Multiplication du nombre flottant sur la pile avec FAC.
$0478-$0479 Récupération du nombre flottant sur la pile dans BCDE.

$047a       [fp_bcde_mul]
            Multiplication flottante

            Multiplication de BCDE et de FAC.
$047a       Récupère le signe de FAC.
$047b       Retourne immédiatement si c'est 0.
$047c-$047e Ajoute les exposants de FAC et BCDE
$0481-$0482 Sauve le MSB de BCDE dans le premier buffer de travail.
$0485-$0486 Sauve le reste de BCDE dans le second buffer de travail.
            Ces deux buffers servent à garder l'argument de la multiplication.
$0489-$048d BCDE = 0
$048e-$0491 Place l'adresse de retour sur la pile vers la normalisation de BCDE.
$0492       Charge l'adresse de la multiplication sur 8 bits
$0495-$0496 Et la place sur la pile comme deux adresses de retour.
            Ainsi, les trois prochains RET provoqueront deux appels à `mul_8b` puis un appel à `bcde_norm`.
$0497       HL pointe vers le LSB de FAC.
$049a       [mul_8b]
$049a       Début de la multiplication sur 8 bits. Récupération de la partie FAC du nombre.
$049b       Et déplacement de HL vers l'octet suivant.
$049c-$049d Branchement si cette partie est nulle.
$049f       Sauvegarde de HL, qui pointe vers l'octet suivant de FAC.
$04a0       Compteur de 8 bits pour la multiplication partielle par A.
$04a2       [mul_8b_loop]
$04a2       Récupération du bit de poids faible dans le Carry.
$04a3       Sauvegarde du multiplicateur dans A
$04a4       Copie du MSB de BCDE dans A.
$04a5       Branche si le bit du multiplicateur était à zéro : pas d'addition.
$04a7       Sauvegarde de l'octet du multiplicateur et du compteur de bits.
$04a8       Récupération des deux octets bas de l'accumulateur pour la multiplication.
$04ab       Addition de cette partie basse avec la partie basse de BCDE (l'accumulateur de résultat)
$04ac       Le résultat devient le nouveau DE.
$04ad       Restauration de H (multiplicateur) et L (compteur de bits)
$04ae-$04b1 Addition des deux MSB (argument et accumulateur) en tenant compte de la retenue des parties basses.
$04b2       [no_add]
$04b2
$04b2-$04bc Décalage du résultat vers la droite de CDEB.
            Dans l'opération, les bits les plus faibles de la mantisse peuvent être perdus.
$04bd       Test si le décalage a amené un bit en position 5 de B (l'octet de récupération de la précision).
$04bf       Branche si ça n'est pas le cas.
$04c1-$04c4 Sinon, place un bit en position 6 de B, pour faire un arrondi vers le haut.
$04c5       [no_lost]
$04c5       Décrémente le compteur de bits
$04c6       Ramène l'octet de multiplicateur dans A
$04c7       Boucle s'il reste des bits à traiter
$04c9       [pop_hl_ret]
$04c9       Restaure l'adresse de l'octet de FAC à traiter.
$04ca       Ce RET va rappeler deux fois la multiplication puis la normalisation de BCDE (cf. le commentaire plus haut)
$04cb       [byte_shift]
$04cc-$04ce Décalage d'un octet complet de l'accumulateur CDEB.
$04cf       Voir les commentaires ci-dessus sur l'effet de RET dans cette routine de multiplication.

$04d0       [fp_div_10]
            %MS_BASIC(DIV10)
            Division de FP par 10

$04d0       Place FAC sur la pile
$04d3-$04d6 Monte le nombre "10" dans BCDE
$04d9       Monte BCDE dans FAC

$04dc       [fp_stk_div]
            Appelé via la table des priorités

            Division du nombre flottant sur la pile par FAC.
$04dc-$04dd Extrait BCDE depuis la pile.
$04de       [fp_bcde_div]
            Division du nombre BCDE par FAC.
$04df-$04e2 Branche vers une erreur de division par zéro si FAC est nul.
$04e4-$04e7 Soustrait les exposants des deux nombres (celui de BCDE par celui de FAC)
$04e8       Ajoute 1 à l'exposant
$04eb       Si boucle sur zéro, branche vers un dépassement de capacité.
$04ec       Ajoute 1 à l'exposant à nouveau
$04ef       Et vérifie à nouveau un dépassement de capacité.
$04f0       Fait pointer HL sur le MSB de FAC.
$04f1       Charge le MSB de FAC dans A.
$04f4       Et le sauve dans la mémoire de travail de la division.
$04f5-$04f6 Fait de même pour l'octet du milieu de FAC
$04f9-$04fb Et enfin pour l'octet le moins signifiant.
$04fe       Charge le MSB de BCDE dans B.
$04ff       Sauve la partie basse de BCDE dans HL.
$0500-$0503 CDE = 0. Contiendra le quotient de la division.
$0504       Dépassement/VLSB
$0507       [fp_div_loop]
$0507       Sauve la partie basse du dividende
$0508       Sauve la partie haute (B) du dividende.
$0509       Prend le LSB du dividende
$050a       Soustrait le diviseur (injecté dans la routine) du dividende (LHB).
            La routine de division, copiée en RAM au démarrage, est la suivante :

                div_subr:    sub      a,$00 ; LSB
                             ld       l,a
                             ld       a,h
                             sbc      a,$00 ; Middle
                             ld       h,a
                             ld       a,b
                             sbc      a,$00 ; MSB
                             ld       b,a
                             ld       a,$00 ; VLSB
                             ret

$050d       Continue la soustraction en accumulant les dépassements dans `fdivc_4`
$050f       Complémente le Carry
$0510       Branche si le diviseur était plus grand que le dividende.
$0512       Sinon, sauve le compteur de dépassement.
$0515-$0516 Supprime le diviseur de la pile.
$0517       Met le Carry à 1
$0518       Saute par dessus les deux `pop` suivant
$0519       [restore_div]
$0519-$051a Restaure le diviseur depuis la pile.
$051b       Prend le MSB du quotient.
$051c       Incrémente
$051d       Décrémente
$051e       Amène le Carry vers le bit 7 et le bit 0 vers le Carry.
$051f       Branche si le résultat est positive.
$0522       Rotation dans l'autre sens pour restaurer A.
$0523       Récupération du nombre de dépassements.
$0526       Rotation vers la droite.
$0527       Masque avec $c0
$0529       Sauve AF
$052a-$052d Branche si L = H = B = 0, c'est-à-dire qu'il n'y a plus rien à diviser.
$052f       Sinon, A = $20
$0531       [div_end]
$0531       Restaure HL (qui était AF)
$0532       Prépare les drapeaux pour l'arrondi.
$0533       Branche vers l'arrondie.
$0536       [div_2]
$0536       Ramène le Carry, qui a servi au branchement conditionnel, à sa place.
$0537-$0539 Décale E vers la gauche
$053a-$053c Décale D vers la gauche (avec le bit sorti de E)
$053d-$053f Décale C vers la gauche (avec le bit sorti de D)
$0540       Double HL
$0541-$0543 Décale B vers la gauche (avec le bit sorti du doublement de HL)
$0544-$0548 Décale `fdivc_4` vers la gauche (avec le bit sorti du doublement de B)
$054b-$054e Saute si C, D ou E contiennent encore des bits à 1 (la division continue)
$0550       Sauve HL
$0551       Pointe vers l'exposant de FAC.
$0554       Décrémente l'exposant
$0555       Restaure HL
$0556       Si l'exposant est non nul, on boucle vers la suite de la division.
$0558       Sinon, on a perdu toute précision, FAC passe à zéro et la division est terminée.
$055b       [add_exp]
            %MS_BASIC(ADDEXP)
            Ajoute ou soustrait l'exposant de BCDE à celui de FAC.

            Entrée :
            - L = 0, ajoute
            - L = $FF, soustrait

$055b-$055d Branche si l'exposant du dividende est zéro.
$055f       Place l'argument (ajoute ou soustrait) dans A.
$0560       HL pointe vers l'exposant de FAC.
$0563       Si l'argument était L = 0, ne fait rien, si L = FF, complément à 1 de l'exposant.
$0564       Ajoute les deux exposants.
$0565       Résultat des exposants dans BCDE.
$0566       Récupération de Carry dans le bit de poids fort de A
$0567       Détection du dépassement de capacité de l'addition précédente.
$0568       Copie l'exposant dans A.
$0569       Branche en cas de possible dépassement de capacité.
$056c       Normalise l'exposant autour de 128.
$056e       Et le place dans FAC.
$056f       Branche si l'exposant est zéro.
$0572       Sinon, extrait le bit de signe.
$0575       Place le nouvel exposant.
$0576       Fait pointer HL juste avant l'exposant (MSB de FAC)
$0578       [truc]
            %CODE
$0578       [ovrflw_tst1]
$0578       Chercher le signe de FAC.
$0578       Prend son opposé
$0578       Nettoie la pile
$057b       [ovrflw_tst2]
$057b       Vérifie si la valeur est nulle (l'exposant ou le signe)
$057c       [exp_no_add]
$057c       Retire l'adresse de retour de la pile.
$057d       Si le résultat est positif, le résultat est zéro, on branche vers FAC = 0
$0580       Sinon, c'est un dépassement de capacité, on branche vers l'erreur.

$0583       [fp_x_10]
            %MS_BASIC(MLSP10)
            Multiplication de FAC par 10

$0583       Récupère FAC dans BCDE
$0586-$0588 Si BCDE est nul, retour immédiat (il suffit de vérifier l'exposant B)
$0589       En ajoutant 2 à l'exposant, on multiplie le nombre par 4
$058b       Sortie si Overflow avec le message d'erreur
$058e       Sinon, on remet l'exposant en place dans BCDE
$058f       Ce nombre x4 est ajouté à FAC, pour un résultat de x5
$0592-$0595 Incrémente directement l'exposant dans FAC, pour obtenir x10.
$0596       Retour si on n'a pas fait passer l'exposant à zéro, cela s'est bien passé.
$0597       Sinon, c'est un dépassement de capacité.

$059a       [getsign_2]
$059d       Saute le `cpl` qui suit
$059e       [ret_cmp]
$059e       %CODE
            Prend le complément de A.
$059f       Rotation à gauche via Carry, qui contient donc le bit de poids fort de A.
$05a0       [flag_diff]
$05a0       Soustraction de A avec A avec retenu.
$05a1       Saute si la rotation avait débordée dans la retenue.
$05a2       Sinon, augmente A de 1 (autrement, dit A = 1 puisque la soustraction avait donné 0)
            Au final, le bit de poids fort de A est transformé en -1 (si bit à 0) ou 1 (si bit à 1)
$05a4       [inst_sgn]
            %CODE,MS_BASIC(SGN)
            Fonction BASIC `SGN()`.

            Place dans FAC le nombre entier dépendant du signe initial de FAC (-1, 0 ou 1).

$05a5       [a_to_fac]
            Place le contenu de A en tant qu'entier sur 8 bit vers FAC.
$05a5-$05a7 BCDE est préparé avec les valeurs $80,xx,$00,$00. A prendra la place de xx.
$05aa       [bade_to_fac]
            Place BADE sous format de nombre flottant dans FAC.
$05aa       HL pointe sur FAC.
$05ad       Place la partie manquante de BCDE.
$05ae       Place l'exposant dans FAC.
$05af       Initialise B comme VLSB, à 0, pour donner CDEB.
$05b1       Pointe HL vers le bit de signe de FAC.
$05b2       Bit de signe à 1 (ce qui signifie positif, ce bit étant inversé par rapport à la forme normalisée BCDE)
$05b4       Place le bit de signe réel de A dans Carry
$05b5       Puis normalise.

$05b8       [inst_abs]
            %CODE,MS_BASIC(ABS)
            Fonction BASIC `ABS()`.

            Place dans FAC la valeur absolue de FAC.
$05b8       Prend le signe de FAC
$05b9       Retour immédiat si le signe est positif
$05ba       [inv_sign]
            Change le signe de FAC par son opposé
$05ba-$05bd Prend le MSB de FAC, dont le bit de poids fort est le bit de signe.
$05be       Inverse le bit de poids fort.
$05c0       Replace MSB avec le nouveau bit de signe.

$05c2       [fac_to_stck]
            Place le contenu de FAC sur la pile.

            Modifie :
            - DE
$05c2       Préserve HL.
$05c3       Récupère les deux premiers octets de FAC.
$05c6       Les place sur la pile.
$05c7       Restaure l'adresse de retour.
$05c8       Récupère les deux octets suivants de FAC.
$05cb       Les place sur la pile.
$05cc       Restaure l'adresse de retour.
$05cd       Restaure HL

$05cf       [hl_to_fac]
$05cf       La valeur numérique pointée par HL est extraite dans BCDE.

$05d2       [bcde_to_fac]
            Place BCDE dans FAC.

            Préserve HL et BCDE.
$05d2       Échange DE et HL pour préserver HL et récupérer la partie basse du nombre
$05d3       Place la partie basse du nombre dans le début de FAC.
$05d6-$05d7 Charge HL avec BC, la partie haute du nombre et son exposant.
$05d8       Les place dans la seconde partie de FAC.
$05db       Restaure HL et DE.

$05dd       [fac_to_bcde]
            Extrait le contenu de FAC vers BCDE
$05dd       HL pointe vers le début de FAC.

$05e0       [hl_to_bcde]
            %MS_BASIC(LOADFP)
            Charge BCDE avec le nombre pointé par HL.
$05e0-$05e6 Place le contenu de FAC octet par octet dans BCDE
$05e7       [inc_hl]
$05e8       Incrémente une dernière fois HL.

$05e9       [fac_to_hl]
            Copie le contenu FAC vers ce que pointe HL.
$05e9       Fait pointer DE sur FAC

$05ec       [cpy_detohl_4]
            Copie le contenu des 4 premiers octets pointés par DE vers ce que pointe HL.
$05ec       Initialise le compteur de boucle à 4.
$05ee       [cpy_4_loop]
$05ee       Récupère l'octet pointé par DE
$05ef       Le copie vers ce que pointe HL
$05f0       Incrémente DE
$05f1       Incrémente HL
$05f2       Boucle selon le compteur B

$05f5       [ext_sign]
            Extrait le signe de BCDE et FAC et place 1 à la place.
            Sauve le signe de FAC dans l'octet de signe.

            Condition: BCDE est plus petit que FAC.

            Sortie :
            - Bit 7 de A à 1 si les signes de BCDE sont identiques, ou 0 si non.
            - HL pointe sur l'octet de signe
$05f5       Fait pointer HL vers le MSB de FAC
$05f8       Copie MSB vers A
$05f9       Rotation à gauche, ce qui place le bit de signe de FAC dans Carry et dans le bit 0 de A.
$05fa       Met le Carry à 1.
$05fb       Puis rotation à droite. Le MSB à donc son bit de poids fort à 1 et Carry contient le bit de signe initial.
$05fc       Replace le MSB de FAC, avec le 1 implicite de la mantisse explicité.
$05fd       Inverse le Carry (positif devient 1, négatif devient 0)
$05fe       Met le Carry dans le bit 7 de A, par rotation.
$05ff-$0600 Place HL après l'exposant, sur l'octet contenant le signe.
$0601       Place l'octet de signe.
$0602-$0607 Effectue la même opération avec BCE.
$0608       XOR entre les deux bits de signe (celui de BCDE et de FAC). BCDE non opposé, FAC opposé.
            Le bit 7 de A est donc à 1 si les deux nombres étaient de même signe, 0 sinon.

$060a       [cmp_num]
            %MS_BASIC(CMPNUM)
            Compare les nombres BCDE et FAC (-1 si FAC < BCDE, 0 si FAC = BCDE, 1 si FAC > BCDE)
$060a-$060c Si BCDE est nul, revient à calculer le signe de FAC.
$060f-$0612 Place sur la pile l'adresse de retour qui sera donc appelée au prochain RET.
$0613       Prend le signe de FAC.
$0614       Prend le MSB de BCDE (avec son signe)
$0615       Si FAC est nul, termine ici (et donc appelle ret_cmp qui transforme le bit de signe de BCDE en résultat -1/1)
$0616       Fait pointer HL sur le MSB de FAC.
$0619       Combine les deux signes (seul le bit 7 est important ici). Si les deux signes sont identiques, alors le bit 7 est à 0, sinon, il est à 1 et le drapeau M est à 1.
$061a       Remet le MSB de BCDE dans A
$061b       Termine si les signes étaient différents (le résultat est donc fonction du signe de BCDE)
$061c       Les nombres sont de même signe, on appel la comparaison générique.
$061f       Amène le Carry dans le bit 7.
$0620       Le combine avec le bit de signe de BCDE
$0621       Branche sur le calcul du résultat.
$0622       [cmp_fp]
            Compare les nombres flottants BCDE et FAC de même signe.

            Préserve BCDE et FAC.
$0622       HL pointait sur MSB à l'appel, on le décale vers l'octet de signe de FAC
$0623       Charge l'exposant de BCDE dans A.
$0624       Compare les exposants.
$0625       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$0626       HL pointe à nouveau sur MSB
$0627-$0628 Compare les deux MSB.
$0629       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$062a       HL pointe sur l'octet du milieu de FAC
$062b-$062c Compare les deux octets du milieu.
$062d       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$062e       HL pointe sur le LSB de FAC.
$062f-$0630 Compare les deux LSB.
$0631       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$0632       Arrivé ici, les deux nombres sont identiques, on retire de la pile l'adresse de retour vers `cmp_num`
$0633       Puis on retire l'adresse de retour qui branche vers `ret_cmp`.
$0634       Termine la comparaison avec A = 0.

$0635       [fp_to_int]
            %MS_BASIC(FPINT)
            Transforme un nombre flottant en décalant la mantisse jusqu'à ne garder que la partie entière.

            Entrées :
            - A contient l'exposant du nombre.
            - HL pointe sur FAC
$0635-$063a Si l'exposant est nul, retourne immédiatement (avec BCDE à zéro par la même occasion)
$063b       Sauvegarde de HL qui pointe sur FAC
$063c       BCDE prend la valeur de FAC.
$063f       Sortie des signes des nombres et mise en place des 1 de mantisse explicite.
$0642       Effectue à nouveau le XOR présent en fin de `ext_sign` pour retrouver le signe de BCDE (et FAC, qui sont identiques)
$0643       Met l'octet de signe dans H
$0644       Décrémente BCDE si le nombre est négatif.
$0647       Exposant maximal significatif pour un entier ($80 + 24)
$0649       Exposant maximum - exposant du nombre donne le nombre de bits de décalage.
$064a       Effectue le décalage de A bits. Après l'appel, on a donc le nombre sous forme entière 24 bits dans CDE.
$064d       Récupération du signe (en tant que bit de signe normal, non inversé)
$064e       Place le signe dans Carry.
$064f       Si le signe était 1 (donc négatif), appel l'arrondi vers le haut.
$0652       L'exposant de BCDE est mis à 0.
$0654       Si le nombre est négatif, prend son complément à 2.
$0657       Restaure HL

$0659       [dec_bcde]
            Soustrait 1 de BCDE

            Modifie :
            - A
$065d       Continue si la soustraction de 1 de DE nécessite une soustraction de DE.

$0660       [inst_int]
            %CODE,MS_BASIC(INT)
            Fonction BASIC `INT()`.
$0660       Faite pointer HL vers l'exposant de FAC.
$0663       Charge l'exposant dans A.
$0664       Comparaison avec l'exposant maximal intéressant pour une partie décimale ($80 + 24). Au delà, on est assuré que le nombre est un entier.
$0666       L'appel à cette routine par `inst_exp` a besoin du LSB de FAC dans A.
$0669       Si le nombre est déjà un entier, on retourne immédiatement.
$066a       Prend à nouveau l'exposant.
$066b       Transforme FAC en nombre entier dans CDE.
$066e       Puisque le nombre entier est complètement à droite de la mantisse, l'exposant est à $98. Le nombre se fera normaliser par la suite.
$0670-$0671 Mise sur la pile de l'octet le plus bas du nombre entier résultat, pour `inst_exp`.
$0672       Octet de poids fort de l'entier dans A.
$0673       Récupération du signe dans Carry
$0674       Normalisation du nombre.
$0677       Récupération de l'entier sur 8 bits dans A.

$0679       [dim_compute]
            %MS_BASIC(MLDEBC)
            Calcule l'index pour accéder à une entrée d'un tableau.

            La fonction sert aussi pour calculer l'espace nécessaire pour le tableau complet.
            Si l'index est trop grand, provoque une erreur BASIC d'Index hors des limites.

            Entrées :
            - BC contient l'index dans le tableau (ou dimension totale)
            - DE contient la taille d'une entrée pour cette dimension (4 octets pour la première dimension)

            Retour :
            - HL contient le pointeur vers l'emplacement mémoire (ou la taille). C'est BC * DE.
            - DE contient 0
            - BC est conservé
$0679       HL est initialisé à 0. Accumulateur pour la multiplication.
$067c-$067e Si BC == 0, retour immédiat.
$067f       Multiplication sur 16 bits.
$0681       [dim_loop]
$0681       Double HL (décalage vers la gauche)
$0682       Si dépasse la capacité, branche sur une erreur.
$0685-$0687 Double DE
$0688       Pas de Carry signifie que le bit de poids fort était 0, donc pas d'addition.
$068a       Sinon, ajout de BC à HL.
$068b       En cas de dépassement de capacité, branche sur une erreur.
$068e       [dim_no_add]
$068f       Boucle sur A (16 fois, pour les 16 bits)

$0692       [str_to_num]
            %MS_BASIC(ASCTFP)
            Transforme le texte pointé par HL en nombre dans l'accumulateur flottant FAC.

            Entrée :
            - HL pointe sur le buffer contenant la chaîne à transformer.

            Sortie :
            - Nombre dans FAC

$0692       %CHAR
            Cas hexa (commence par `&`)
$0694       Branchement vers le décodage hexadécimal.
$0697       %CHAR
            Nombre négatif.
$0699       Sauvegarde des drapeaux de la comparaison avec '-'
$069a       Branche si '-'
$069c       %CHAR
            Nombre positif spécifié
$069e       Branche si '+'
$06a0       Positionne HL un caractère avant dans les autres cas, car chget avance d'un avant la lecture.
$06a1       [skip_sign]
$06a1       Initialise l'exposant de FAC à 0. Effet de bord, A = 0
$06a4       Nombre de chiffres après le point (la virgule) (B = 0)
$06a5       Signe de l'exposant (D = 0)
$06a6       Puissance de 10 (E = 0)
$06a7       Met A à FF
$06a8       Met C à FF, drapeau pour situer le parsing avant ou après le point.
$06a9       [prse_flt_lp]
$06a9       Lecture du caractère suivant
$06aa       Cas d'un chiffre
$06ac-$06ae %CHAR
            Cas du caractère `.`
$06b0-$06b2 %CHAR
            Cas du caractère `e`
$06b4-$06b6 %CHAR
            Cas du caractère pas `E`
$06b8       [case_exp]
$06b8       Lit le caractère suivant.
$06b9       Récupére le signe de l'exposant.
$06bc       [exp_loop]
$06bc       Lecture d'un caractère de l'exposant.
$06bd       C'est un chiffre, on l'ajoute à l'exposant
$06bf       Ce n'est pas un chiffre, on vérifie le signe de l'exposant
$06c0       Saut s'il était positif, on a fini
$06c2-$06c4 S'il était négatif, on inverse la valeur dans E (l'exposant)
$06c5       Le drapeau de passage de point est augmenté pour s'assurer qu'on ne bouclera plus dans le parsing. La chaîne est terminée.
$06c6       [case_dot]
$06c6       Le drapeau du passage du point est incrémenté (pour le premier point, passe de FF à 00)
$06c7       Le drapeau vient de passer à 0, on entame donc une nouvelle partie du nombre.
$06c9       [exp_end]
$06c9       Que ce soit avec un deuxième point ou la fin de l'exposant, le parsing du nombre est terminé. Il faut le finaliser. On sauve le pointeur du buffer de texte.
$06ca-$06cb Soustrait le nombre de chiffre après la virgule de l'exposant. A contient donc l'exposant corrigé pour qu'il n'y ait pas de nombre après la virgule.
$06cc       [adj_loop]
$06cc       Si ce nombre est positif, on multiplie le nombre par autant de fois 10.
$06cf       Si ce nombre est positif, on a terminé (le drapeau ici est forcément positif si l'appel précédent a été fait)
$06d2       Met sur la pile le nombre de divisions par 10 à faire.
$06d3       Division par 10 du nombre
$06d6       Récupération de A
$06d7       Que l'on augmente
$06d8       [adjust_loop]
$06d8       Boucle autant de fois que nécessaire.
$06da       Restaure le pointeur vers le buffer de texte.
$06db       Restaure le test de la présence de '-' en début de nombre.
$06dc       S'il y avait un signe négatif, alors on inverse le signe de FAC.
$06df       Récupère le pointeur de buffer de texte dans HL.

$06e1       [adj_x_10]
            Multiplie FAC par 10 et décrémente A (si A est supérieur à 1)
$06e1       Si A était 0, retour immédiat
$06e2       [fac_x_10]
$06e2-$06e7 Multiplie FAC par 10 et décrémente A.

$06e9       [case_digit]
            Traitement d'un chiffre en ASCII dans A pour l'ajouter à FAC.

            B le nombre de chiffres après la virgule
            C est FF avant la virgule, 0 après (ou dans l'exposant)
            D est l'exposant
            E la puissance de 10

            HL pointe sur le buffer de texte

            Carry est à 1 car `chget` a récupéré un chiffre.

$06e9       Sauve l'exposant et la puissance de 10.
$06ea       D prend le caractère ASCII à traiter.
$06eb-$06ed Après la virgule, le compteur de chiffres décimaux est incrémenté (Carry = 1, C = 0)
$06ee-$06f0 Sauvegarde des registres
$06f1       Multiplie FAC par 10.
$06f4       Récupération de la valeur du caractère (depuis DE)
$06f5       %CHAR
            Transformation du chiffre en ASCII vers sa valeur numérique.
$06f7       Ajoute A à FAC
$06fa-$06fc Restaure les registres
$06fd       Continue la lecture.

$06ff       [add_a]
            Ajoute le nombre entier A à FAC
$06ff       Pousse FAC sur la pile
$0702       Monte A dans FAC
$0705       [fp_stk_add]
            %MS_BASIC(PADD)
            Ajoute le nombre flottant sur la pile à FAC.

            Appelé a travers la table des priorités
$0705-$0706 Récupère le nombre depuis la pile dans BCDE
$0707       Ajoute BCDE à FAC.

$070a       [add_to_exp]
            %MS_BASIC(EDIGIT)
            Ajoute le caractère ASCII dans A à l'exposant du nombre analysé.

            E la puissance de 10 du nombre analysé.

            HL pointe sur le buffer de texte

            Prend l'exposant actuel E et le multiplie par 10, ajoute le caractère de (HL) et en soustrait '0'
            Puis va chercher un autre chiffre pour l'exposant
$070a       Exposant dans A.
$070b-$070e Multiplie par 10
$070f       Ajoute le caractère pointé
$0710       %CHAR
            Et le transforme en sa valeur numérique.
$0712       Sauve le résultat dans E
$0713       Continue l'analyse de l'exposant.

$0715       [out_in]
            %MS_BASIC(LINEIN)
            Affiche le texte " en " (ou " in ", suivant la langue), suivi du numéro de ligne présent dans HL

            L'affichage se fait via `out_str` et donc dépend du périphérique sélectionné.
$0715       Sauve HL
$0716       Pointe vers les messages en français.
$0719       Récupère la langue configurée.
$071c-$071d Branche si c'est zéro (français)
$071f       Sinon pointe vers les messages en anglais.
$0722       [out_in_fr]
$0722       Affiche le message.
$0725       Restaure HL

$0726       [out_number]
            Affiche un nombre contenu dans HL sur le périphérique sélectionné.
$0726-$0729 Met sur la pile une adresse de retour vers `sharp_char`.
$072a       Envoie HL (l'argument) vers DE.
$072b       A = 0
$072c       B = $98 ($80 + 24), l'exposant pour nombre entier.
$072e       Monte le nombre dans FAC, préparé avec le nombre entier correspondant à ce qui était dans HL.

$0731       [fout]
            Construit la représentation ASCII contenu de FAC dans le buffer `fbuffr`.
$0731       HL pointe vers le buffer de travail (de 13 caractères de long)
$0734       Sauve le pointeur
$0735       Prend le signe de FAC
$0736       %CHAR
            Place un espace dans le buffer de travail.
$0738       Branche si le nombre est positif.
$073b       %CHAR
            Remplace l'espace par le signe moins.
$073d       [pos_sign]
$073d       Pointe sur le caractère suivant du buffer.
$073e       %CHAR
            Place un '0' dans le buffer.
$0740       Branche si le nombre à afficher est nul.
$0743       Sauve le pointeur de travail
$0744       Branche si FAC est négatif.
$0747       A = 0, le nombre de divisions par 0 qui vont être faites pour ramener la partie entière sur une zone affichable (6 chiffres)
$0748       Sauve AF
$0749       Vérifie si le nombre est inférieur à 999999.
            La suite de la routine cherche quel est le facteur multiplicatif de 10 pour que le nombre soit un entier de 6 chiffres.
            Ceci afin de trouver quelle est la partie significative affichable.
$074c       [six_digit]
$074c-$074f %CODE
            BCDE = 99999.9
$0752       Compare BCDE et FAC
$0755-$0756 Le nombre est plus grand que 99999.9, on a la partie affichable.
$0759       Récupération du compteur
$075a       Multiplication du nombre par 10 (la routine décrémente aussi A)
$075d       Sauvegarde du compteur
$075e       Boucle pour obtenir les 6 chiffres
$0760       [fout_big]
            Appelé lorsque FAC est trop grand pour être affiché en entier.
$0760       Divise FAC par 10
$0763-$0765 Augmente le compteur qui est sur la pile.
$0766       Vérifie à nouveau si le nombre est sous la borne affichable.
            Ce `call` est une récursion terminale. Lorsque le nombre aura été assez divisé, le dernier `jp (hl)` reviendra à l'instruction suivante.
$0769       [is_in_range]
$0769       Arrivé ici, la partie entière de FAC est sur 6 chiffres.
            Le compteur sur la pile contient l'inverse la puissance de 10 qu'il a fallu appliquer.
            Ajoute 0.5 à FAC pour arrondir.
$076c       Incrémente l'exposant.
$076d       Ramène FAC dans un entier dans BCDE
$0770       Remonte BCDE dans FAC
$0773       Initialise des bornes
$0776       Ramène le compteur du nombre de multiplications/divisions par 10 ayant été faites
$0777       Y ajoute la borne C (6)
$0778       +1
$0779       Branche vers l’écriture en 'E' si A + 6 + 1 < 0, donc si on a fait 8 multiplications par 10, ou plus (nombre strictement inférieur à 0.01)
$077c       Compare avec 8
$077e       Branche si A + 6 + 1 >= 8, donc si on a fait 1 division ou plus (nombre strictement supérieur à 999999)
$0780       A est à présent égal à l'inverse des puissances de 10 faites + 8.
$0781       Place ce nombre dans B (à la place du $03)
$0782       Place $02 dans A.
$0784       [form_ready]
$0784-$0785 Décrémente A deux fois.
$0786       Restaure le pointeur vers le buffer de travail.
$0787       Sauve AF. S'il n'y a pas besoin de notation 'E', A est à 0 et Z est à 1.
            Sinon, A contient la valeur de l'exposant.
$0788       Pointe sur le tableau des puissances de 10
$078b       Décrémente B, le nombre de chiffre avant la virgule.
$078c       Branche s'il reste des chiffres à afficher avant la virgule + 1.
$078e       %CHAR
            Sinon, place un point dans le buffer de travail.
$0790       Avance dans le buffer de travail.
$0791       %CHAR
            Prépare un zéro
$0793       Avance dans le buffer de travail.
$0794       [out_digit]
$0794       Décrémente le nombre de chiffres avant la virgule.
$0795       %CHAR
            Place un point dans le buffer de travail.
$0797       S'il n'y a plus de chiffre à afficher sur la partie entière, avance dans le buffer.
$079a-$079c Sauvegarde les registres (B = chiffres avant le point, HL = buffer de travail, DE = table des puissances de 10)
$079d       Ramène FAC vers BCDE
$07a0       Restaure le pointeur vers la table des puissances de 10.
$07a1       %CHAR
            '/' est ('0' - 1)
$07a3       [try_digit]
$07a3       Incrémente B
$07a4       LSB de BCDE
$07a5       Y soustrait le LSB dans la table des puissances
$07a6       Sauve le résultat
$07a7-$07aa Fait de même avec l'octet central (en tenant compte de la retenue)
$07ab-$07ae Puis avec le MSB (en tenant compte de la retenue)
$07af-$07b0 Revient au début de l'entrée courante dans la table des puissances de 10.
$07b1       La soustraction a réussi, on essai une nouvelle fois avec la même puissance de 10.
$07b3       La dernière soustraction a fait passer le nombre dans CDE négatif. On l'annule.
$07b6       L'addition précédente a amené HL sur le dernier octet de la puissance de 10, un octet plus loin pointe vers la puissance de 10 suivante.
$07b7       Le reste du nombre est remonté vers FAC.
$07ba       Le pointeur vers la table de puissances repasse dans DE
$07bb       Récupération du buffer de travail.
$07bc       Placement du chiffre en ASCII dans le buffer de travail.
$07bd       Pointe vers l'emplacement suivante du buffer.
$07be       Restaure le compte de chiffres avant la virgule (B) et total (C)
$07bf       Décrémente le compteur des puissances
$07c0       Boucle s'il en reste.
$07c2       Un chiffre avant la virgule de moins à afficher.
$07c3       Branche La partie avant la virgule est terminée, les 6 chiffres étaient de la partie entière.
$07c5       [strip_0]
$07c5-$07c9 Revient en arrière pour ignorer les '0' à droite de la partie décimale.
$07c7       %CHAR
$07cb       %CHAR
            Vérifie s'il y a un point.
$07cd       Si ce n'est pas le cas, remet la fin du buffer de travail un octet plus loin (conserve le chiffre)
$07d0       [fout_exp]
$07d0       Récupère AF pour savoir s'il y a besoin de la notation 'E'
$07d1       Branche si pas besoin.
$07d3       %CHAR
            Inscrit 'E' dans le buffer
$07d5       Avance dans le buffer.
$07d6       %CHAR
            Inscrit '+' dans le bufer
$07d8       Branche plus loin si l'exposant est positif.
$07db       %CHAR
            Remplace le '+' par un '-'
$07dd-$07de Complémente à 2 le registre A (prend l'opposé de la valeur de l'exposant)
$07df       [exp_pos]
            %CHAR
$07df       Initialise B avec '0' - 1, sur le même principe que précédemment
$07e1       [fout_e_loop]
$07e1       Passe au caractère ASCII suivant.
$07e2       Soustrait 10 de l'exposant
$07e4       Boucle tant que le résultat est positif
$07e6       Annule la dernière soustraction augmenté de $30 ('0' en ASCII), pour préparer l'affichage des unités.
$07e8       Avance dans le bufer de travail.
$07e9       Inscrit les dizaines.
$07ea       [out_zero]
$07ea       Avance dans le buffer de travail.
$07eb       Inscrit les unités
$07ec       Avance dans le buffer de travail.
$07ed       [fout_no_exp]
$07ed       C est nul à ce niveau là, ce qui permet de terminer la chaîne.
$07ee       Restaure HL à l'adresse initiale, c'est-à-dire le début du buffer de travail.

$07f0       [in_range]
            Vérifie que FAC est inférieur ou égal à 999999.
$07f3-$07f6 BCDE = 999999.
$07f6       Compare BCDE et FAC.
$07f9       Prépare le résultat.
$07fa       Récupère l'adresse de retour
$07fb       Branche si le nombre est trop grand
$07fe       `ret` simulé.

$07ff       [fp_half]
$07ff       Contient le nombre `0.5` flottant.
$0806       [powers_5]
$0806       100000
$0809       [powers_4]
$0809       10000
$080c       [powers_3]
$080c       1000
$080f       [powers_2]
$080f       100
$0812       [powers_1]
$0812       10
$0815       [powers_0]
$0815       1
$0818       [neg_fac]
            Stock un appel à l'inversion de signe au prochain `ret` de l'appelant.
$0818       Adresse de la routine qui sera appelée
$081b       Récupère l'adresse de retour dans HL et stock l'adresse de la routine sur la pile.
$081c       `ret` simulé.

$081d       [inst_sqr]
            %CODE,MS_BASIC(SQR)
            Fonction BASIC `SQR()`.

            Calcul la racine carrée de FAC.
$081d       Met FAC sur la pile
$0820-$0823 Mets 0.5 dans FAC. Ce qui prépare à l'exponentiation qui suit.
$0826       [fp_bcde_pow]
            %MS_BASIC(POWER)
            Calcul la puissance FAC du nombre flottant sur la pile.
$0826-$0827 Récupère le nombre sur la pile dans BCDE.
$0828       Prend le signe de FAC (ne s'intéresse qu'aux drapeaux, puisque A est écrasé juste après)
$0829       A prend l'exposant de BCDE.
$082a       Si la puissance est 0, branche vers l'instruction `EXP`, ce qui donne 1 pour résultat.
$082c       Branche si la puissance est positive.
$082f-$0830 Erreur si on tente de prendre une puissance négative de 0.
$0833       [pos_pow]
$0833-$0834 Si le nombre est nul avec une puissance positive, alors le résultat est zéro, que l'on construit à partir de A mis dans l'exposant de FAC.
$0837-$0838 Sauve le nombre sur la pile.
$0839       MSB de BCDE dans A.
$083a       Garde le bit de signe, met tout le reste à 1.
$083c       Met la puissance dans BCDE
$083f       Branche si le nombre de base est positif
$0842       Sauve le résultat du OR précédent.
$0843       Charge l'exposant de la puissance dans A.
$0846       La compare avec $99 (= $80 + 31)
$0848       Branche si l'exposant de la puissance est 32 ou plus.
$084a       Sinon, dépile le signe de la base
$084b       Et continue le calcul plus loin.
$084d       [big_power]
$084d       Dépile le signe de la base
$084e-$084f Pousse la puissance sur la pile
$0850       Prend la valeur entière de la puissance
$0853-$0854 Récupère la puissance dans BCDE
$0855       Sauve AF, A contient l'exposant entier.
$0856       Compare la puissance et sa valeur entière
$0859-$085a Récupère A sans toucher aux drapeaux
$085b       Exposant pair (0) ou impair (1) dans Carry.
$085c       [pos_base]
$085c-$0861 Monte le nombre argument (sur la pile) dans FAC.
$0864       Si l'exposant est impair et que la base était négative, le résultat final passera par une opposition de signe.
$0867       Si la base est négative, prend son opposée.
$086a-$086b Sauve la puissance dans la pile
$086c       Prend le `log` de FAC (la base)
$086f-$0870 Restaure la puissance
$0871       Multiplie FAC et BCDE (log(base) * power)
            Le fait d'enchaîner sur `inst_exp` va donner exp(log(base) * power),
            c'est-à-dire `base ^ power`.
$0874       [inst_exp]
            %CODE
            Fonction BASIC `EXP()`

            Retourne l'exponentielle de FAC.
$0874-$0877 BCDE = 1/ln(2)
$087a       Multiplie FAC par 1/ln(2)
$087d       Prend l'exposant de FAC
$0880       Compare avec $80 + 8.
$0882       Branche si plus grand : overflow
$0884       Compare avec $80 - 24
$0886       Branche si plus petit : le résultat est 1.
$0888       Amène FAC sur la pile
$088b       Prend la partie entière de FAC
$088e       Ajoute $81 au LSB en entier. On sait que le nombre entier tient forcément sur 8 bits grâce aux bornes d'exposants précédents.
$0890-$0891 Récupère le nombre en argument.
$0892       Si l'ajout précédent a donné zéro, c'est que l'exposant était $79, on branche sur overflow.
$0894       En on sauve le résultat.
$0895       Soustrait BCDE (l'exposant) de FAC (l'exposant en entier)
$0898       Pointe sur la table utilisée pour l'exponentiation.
$089b       Appelle le calcul du polynôme.
$089e       Récupère l'exposant
$089f       DE = 0
$08a2       C = 0, pour former BCDE avec une mantisse nulle et B l'exposant.
$08a3       Multiplie BCDE et FAC.
$08a6       [exp_too_big]
$08a6       Met FAC sur la pile
$08a9       [exp_big2]
$08a9       Prend l'exposant
$08ac       Test l'exposant
$08ad       Si l'exposant est positif, alors c'est un overflow
$08b0-$08b1 Restaure la pile
$08b2       Le résultat est 0
$08b5       [over_redir]
$08b5       Trampoline vers l'erreur de dépassement de capacité.

$08b8       [fac_to_1]
            Assigne 1 à FAC.
$08b8-$08bb BCDE = 1.0
$08be       Monte BCDE dans FAC.

$08c1       [exptab]
$08c1       Taille de la table utilisée par l'exponentielle.
$08c2       [exptab_0]
$08c2       0.0002074557705782354
$08c6       [exptab_1]
$08c6       0.0012710057199001312
$08ca       [exptab_2]
$08ca       0.00965065136551857
$08ce       [exptab_3]
$08ce       0.055496565997600555
$08d2       [exptab_4]
$08d2       0.2402271330356598
$08d6       [exptab_5]
$08d6       0.6931471824645996
$08da       [exptab_6]
$08da       1.0

$08de       [sum_series]
            %MS_BASIC(SUMSER)
            Prépare la somme polynomiale pour `sin` et `cos`.

            Met le paramètre (FAC) au carré et programme une multiplication par le paramètre à la sortie du calcul du polynôme.
$08de       Pousse FAC dans la pile.
$08e1-$08e4 Insère une opération de multiplication 'pile * FAC' au prochain `ret`.
$08e5       Sauve HL
$08e6       Met FAC dans BCDE
$08e9       Met FAC au carré
$08ec       Restaure HL
$08ed       [sum_ser_1]
            Effectue une somme polynomiale.

            Avec 4 coefficients, on a :
            c1.x^4 + c2.x^3 + c3.x + c4
$08ed       Pousse FAC sur la pile.
$08f0       Récupère le nombre de coefficients.
$08f1       Pointe vers le premier coefficient.
$08f2-$08f2 Charge le premier coefficient dans FAC. HL est avancé vers le coefficient suivant.
$08f5       Saute par dessus le `pop af` pour arriver sur le `pop bc`.
$08f6       [sum_ser_lp]
$08f6       Restaure AF.
$08f7-$08f8 Lit BCDE depuis la pile. Contient toujours l'argument initial.
$08f9       Décrémente le nombre de facteurs restants.
$08fa       Retourne si le nombre restant est de 0.
$08fb-$08fc Place BCDE sur la pile.
$08fd-$08fe Sauve les autres registres (HL pointe sur le coefficient suivant de la table, A est le compteur de coefficients).
$08ff       Multiplie BCDE (l'argument) et FAC (l'accumulateur de résultat)
$0902       Retrouve le pointeur sur les coefficients.
$0903       Charge le nombre suivant de la table dans BCDE. HL pointe sur le nombre qui suit.
$0906       Sauve le pointeur sur la table.
$0907       Ajoute le nombre à FAC.
$090a       Restaure le pointeur vers la table.
$090b       Et boucle

$090d       [inst_rnd]
            %CODE
$090e       Pointe vers la seed (pourquoi cette instruction n'est-elle pas dans reseed ?)
$0911       Si l'argument est négatif, reseed
$0914       Point vers le dernier nombre généré
$0917       Déplacement vers l'accumulateur flottant
$091a       Pointe vers la seed à nouveau
$091d       Retour si l'argument est 0, on renvoie le dernier nombre généré (qui est dans le FAC)
$091e       On ajoute la seed avec le contenu de A (qui est à 1 car le sign est positif)
$091f       ... uniquement les 3 premiers bits (0 à 7)
$0921       Prépare BC, offset de la table, avec B = 0
$0923       On sauve la seed
$0924       Avance dans la table des coefficients
$0925-$0927 Calcule BC est l'offset dans la table des coefficients (seed * 4, B étant à zéro)
$0928       On pointe vers la table des coefficients
$0929       Charge le coefficient en tant que FP dans BCDE
$092c       Multiplication du nombre en FAC avec le coefficient
$092f       Prend l'autre seed
$0932       L'incrémente...
$0933       Limite entre 0 et 3
$0935       Prépare B pour l'`adc` (addition avec retenue) qui suit.
$0937       Compare la seed à 1
$0939       Si A était zéro, alors Carry est à 1 et donc A passe à 1.
$093a       On sauve la seed
$093d       4 octets avant rnd_add
$0940-$0942 Index dans la table des additions
$0943       Pointe sur l'entrée de la table
$0944       Addition du contenu de la table avec FAC

$0947       [afterreseed]
$0947       Récupération de FAC dans BCDE
$094a       A récupère le poids faible de la mantisse
$094b       Met le poids fort de la mantisse dans le poids faible
$094c       Modifie des bits de A
$094e       Met le résultat en haut de la mantisse
$094f       HL pointe sur fac_1 (signe résultant). On y met $80 pour positif.
$0951       HL pointe sur l'exposant
$0952       Que l'on récupère dans B (étrange... on avait déjà récupéré dans BCDE)
$0953       On fixe l'exposant à $80 (donc puissance 0)
$0955-$0958 Incrémentation de la troisième seed
$0959       Récupération de sa valeur
$095a       Modulo 171
$095c       Branchement sauf si le modulo passe par zéro
$095e-$0961 Dans ce cas, on bouge un peu la mantisse
$0962       [rnd_cnt]
$0962       Normalisation
$0965-$0968 Copie FAC dans (HL), donc dans le dernier numéro généré.
$096b       [reseed]
            Réinitialisation du générateur aléatoire.
$096c-$096f Place A dans les trois octets du nombre précédemment généré.
$0970       Puis continue avec le prochain nombre généré.
$0972       [rnd_add]
            Table utilisée par le générateur aléatoire.
$0972       environ 4.626181748790259e-08
$0976       [rnd_add_1]
$0976       environ -6.841145960834183e-08
$097a       [rnd_add_2]
$097a       environ 5.723364893128746e-08

$097e       [inst_cos]
            %CODE,MS_BASIC(COS)
            Fonction BASIC `COS()`

            Place le cosinus de FAC dans FAC.
$097e       Pointe vers la valeur PI/2
$0981       Ajoute PI/2 à FAC, car cos(x) = sin(x + pi/2)
$0984       [inst_sin]
            %CODE,MS_BASIC(SIN)
            Fonction BASIC `SIN()`

            Place le sinus de FAC dans FAC.
$0984       Prends l'exposant de FAC.
$0987       Le compare avec $77 ($80 - 9)
$0989       Retourne avec FAC non touché si l'exposant est petit (inférieur à environ 0.0019)
            En effet, pour des petits nombres, x est une approximation de sin(x)
$098a-$098d Récupération du MSB dans A.
$098e       Branche plus loin si c'est un nombre positif
$0991       Comme sin(-a) = -sin(a), on rend le paramètre positif.
$0993       On remonte le MSB dans FAC
$0996-$0999 En retour de fonction, `ret` branchera vers la routine qui prendra l'opposée de FAC.
$099a       [sin_pos]
$099a-$09a3 Multiplie l'angle paramètre par 1/(2*pi) (BCDE) et pousse le résultat sur la pile.
$09a6       Et on prend la valeur entière de FAC.
$09a9-$09aa On récupère le résultat de la multiplication dans BCDE
$09ab       Afin d'en obtenir la partie décimale.
            Ce qui donne un emplacement sur le cercle trigonométrique.
$09ae-$09b1 BCDE = 0.25
$09b4-$09b7 Branche plus loin si le résultat est inférieur à 0.25, c'est-à-dire le premier quart du cercle trigonométrique.
$09ba-$09c0 Ajoute BCDE = -0.25 à FAC.
$09c3-$09c9 Ajoute BCDE = -0.5 à FAC. Cela donne une soustraction globale de l'emplacement de 0.75.
$09cc       Récupère le signe de FAC
$09cd       S'il est positif, cela signifie que l'angle se situait dans le quatrième quart.
            La fonction sinus étant symétrique verticalement sur le cercle, la valeur est ramenée pour désigner le troisième quart dans l'autre sens, en opposant le signe.
$09d0-$09d6 Rotation du cercle d'un quatre de cercle, avec ajout de BCDE = 0.25.
$09d9       Inverse le signe de la position sur le cercle.
$09dc       [min_quarter]
$09dc-$09df Prend le MSB de FAC afin d'en déterminer le signe.
$09e0       Et pousse le résultat dans la pile.
$09e1       S'il est positif, branche plus loin
$09e4-$09e6 Sinon, inverse le signe afin d'opposer le nombre dans FAC.
$09e9       [sin_pos_2]
$09e9       Pointe vers la table des coefficients pour le sinus.
$09ec       Calcul du polynôme.
$09ef       Récupère le signe du MSB initial.
$09f0       S'il était positif, on s'arrête là.
$09f1-$09f6 Sinon, on inverse le signe.
$09f9       Ici, si l'angle était initialement négatif, un appel à `inv_sign` est effectué.
$09fa       [half_pi]
$09fa       PI/2
$09fe       [quarter]
$09fe       0.25
$0a02       [sintab]
$0a02       Taille de la table pour le sinus
$0a03       [sintab_0]
$0a03       Environ : 39.71091842651367
$0a07       [sintab_1]
$0a07       Environ : -76.57498931884766
$0a0b       [sintab_2]
$0a0b       Environ : 81.60223388671875
$0a0f       [sintab_3]
$0a0f       Environ : -41.341678619384766
$0a13       [sintab_4]
$0a13       Environ : 6.2831854820251465
$0a17       [inst_tan]
            %CODE,MS_BASIC(TAN)
            Fonction BASIC `TAN()`

            Place la tangente de FAC dans FAC par calcul du sinus, du cosinus, puis de la division du premier par le second.
$0a17       Pousse FAC sur la pile
$0a1a       Calcule le sinus de FAC.
$0a1d-$0a1e Récupération de l'angle initial dans BCHL
$0a1f       Pousse le sinus sur la pile
$0a22       Échange HL et DE pour reconstituer BCDE
$0a23       Monte BCDE dans FAC
$0a26       Calcule son cosinus.
$0a29       Divise sinus (sur la pile) par cosinus (dans FAC).
$0a2c       [inst_atn]
            %CODE,MS_BASIC(ATN)
            Fonction BASIC `ATN()`

            Place l'arc-tangente de FAC dans FAC.
$0a2c       Récupère le signe de FAC
$0a2d-$0a30 Si le nombre est négatif, on prend l'opposé de son signe ainsi que du signe de son exposant (-1/x)
$0a33       Récupère le MSB de FAC
$0a36       Comparaison avec $80 ($80 + 1)
$0a38       Branche si le nombre est inférieur à 1.
$0a3a-$0a3e BCDE = 1
$0a3f       Calcule 1/x
$0a42-$0a45 Après le calcul, `ret` branchera sur une soustraction de l'angle par ce que pointera HL
$0a46       [atn_1]
$0a46       Pointe HL sur la table des coefficients pour `atn`.
$0a49       Calcule le polynôme.
$0a4c       Fait pointer HL sur pi/2, pour le cas où `ret` branche vers la soustraction.
$0a4f       Retour, ou branchement sur la soustraction.

$0a50       [atantab]
$0a50       Taille de la table pour atan
$0a51       [atantab_0]
$0a51       1/17
$0a55       [atantab_1]
$0a55       -1/15
$0a59       [atantab_2]
$0a59       1/13
$0a5d       [atantab_3]
$0a5d       -1/11
$0a61       [atantab_4]
$0a61       1/9
$0a65       [atantab_5]
$0a65       -1/7
$0a69       [atantab_6]
$0a69       1/5
$0a6d       [atantab_7]
$0a6d       -1/3
$0a71       [atantab_8]
$0a71       1/1

$0a75       [inst_play]
            %CODE,SECTION(gr)
            == DEBUT DE SECTION GR (manipulations graphiques et sonores) ==
            Commande BASIC `PLAY`

            Joue une séquence de notes dans un langage spécialisé contenu dans la chaîne de caractères en paramètre.

            Comme le rafraîchissement de l'écran est désactivé pendant PLAY, une note dans le manuel indique qu'il
            faut provoquer un rafraîchissement avant l'appel à PLAY pour être a jour de l'affichage, en appelant
            `DISPLAY`.

$0a75       Appel du `hook` de PLAY.
$0a78       Désactivation du rafraîchissement.
$0a7c       Lecture de l'expression en paramètre.
$0a7f       Sauve le pointeur.
$0a80       Récupère le pointeur vers le descripteur de chaîne résultante.
$0a83       BCDE contient les informations de chaîne. BC = pointeur vers les données, E = nombre de caractères.
$0a86       Augmente de 1 le nombre de caractères.

$0a87       [play_impl]
            Joue une séquence sonore

            Entrées :
            - BC = Pointeur vers la séquence ASCII
            - E = taille du buffer
            - Le pointeur vers le texte BASIC a été poussé sur la pile.
$0a87       Vérifie si l'utilisateur demande d'arrêter le programme.
$0a8a       Lecture du caractère suivant de la chaîne.
$0a8b       Pointe vers le caractère suivant.
$0a8c       Réduit le nombre de caractères restant.
$0a8d       Branche si le buffer est épuisé.
$0a90       %CHAR
$0a90-$0a92 Branche si le caractère est ','
$0a94       %CHAR
$0a94-$0a96 Branche si le caractère est '|'
$0a98       %CHAR
$0a98-$0a9a Branche si le caractère est ' '
$0a9c       %CHAR
$0a9c-$0a9e Erreur de syntaxe si le caractère est inférieur à 'A'
$0aa1       Passe les caractères en majuscules.
$0aa3       %CHAR
$0aa3-$0aa5 Branche si le caractère est 'O'
$0aa8       %CHAR
$0aa8-$0aaa Branche si le caractère est 'R'
$0aad       %CHAR
$0aad-$0aaf Branche si le caractère est 'T'
$0ab2       %CHAR
$0ab2-$0ab4 Erreur de syntaxe si le caractère est supérieur ou égal à 'H'
$0ab7       %CHAR
            Soustraction par 'A' pour avoir la hauteur de la note.
$0ab9-$0aba hauteur = (A * 2) + 1
$0abb       Sauve la hauteur dans D
$0abc       Lit le caractère suivant.
$0abd       %CHAR
$0abd-$0abf Branche plus loin si ce n'est pas un '+'
$0ac1       Si c'est un '+', incrémente le pointeur vers la chaîne de commandes.
$0ac2       Augmente la hauteur de 1
$0ac3       Réduit le nombre de caractères restant.
$0ac4       [not_sharp]
$0ac4       %CHAR
$0ac4-$0ac6 Branche plus loin si le caractère suivant la note n'est pas '-'
$0ac8       Incrémente le pointeur vers la chaîne de commandes.
$0ac9       Réduire la hauteur de 1.
$0aca       Réduit le nombre de caractères restant.
$0acb       [not_flat]
            Récupère l'information sur l'octave.
$0ace       Ajoute la note à l'octave.
$0acf       Sauve le résultat dans D.
$0ad0       Récupère le paramètre de longueur de note dans HL
$0ad3       Sauve la valeur sur la pile
$0ad4       DE ayant été préservé, ramène la hauteur de note dans A.
$0ad5       Passe sur les registres alternatifs de BC, DE, HL
$0ad6-$0ad7 DE = hauteur de la note
$0ad9       HL pointe sur la table des sons
$0adc-$0ade Chaque entrée dans la table comprends 3 octets.
$0adf       C prend le premier des octets
$0ae0-$0ae1 B prend le second des octets
$0ae2       Sauve la valeur dans `sonsav_hi`
$0ae6-$0ae7 A prend le troisième octet de l'entrée
$0ae8       Récupère la longueur de la note depuis la pile dans DE
$0ae9       Multiplie la longueur par le troisième paramètre de la note.
$0aec       Met le Carry à zéro, essentiellement.
$0aed-$0aef Divise DE par deux.
$0af1       Met le Carry à zéro.
$0af2-$0af4 Divise DE par deux.
$0af6       Met le Carry à zéro.
$0af7-$0af9 Divise DE par deux.
$0afb       Récupère le `tempo` actuel.
$0afe       Multiplie DE (premier paramètre du son divisé par 8) par A (le tempo). Résultat dans DE.
$0b01       Met le Carry à zéro.
$0b02-$0b04 Divise DE par deux.
$0b06       Met le Carry à zéro.
$0b07-$0b09 Divise DE par deux.
$0b0b       Émet le son.
$0b0e       Boucle vers la prochaine définition de note.

$0b11       [play_exit]
$0b11       Restauration du HL initial, pointeur sur le texte BASIC.
$0b12-$0b16 Provoque un rafraîchissement 3 IRQ plus tard.

$0b1b       [octave]
            Décodage de la commande 'O' dans une instruction PLAY, indiquant un changement d'octave.

            Pour cela, décode un nombre entre 1 et 4 inclus, le multiplie par 14 et sauve le résultat dans `tmpsav`.
$0b1b       Lecture du caractère suivant.
$0b1c       Incrémente le pointeur sur le buffer de commandes.
$0b1d       Réduit le nombre de caractères restants.
$0b1e       S'il n'y en a plus, génère une erreur d'argument manquant.
$0b21       %CHAR
$0b26       %CHAR
$0b21-$0b28 Branche sur une erreur de syntaxe si l'argument n'est pas entre '1' et '4'.
$0b2b       %CHAR
            Soustrait '1' à l'argument pour en obtenir sa valeur numérique.
$0b2d-$0b32 Multiplie l'octave par 14.
$0b33       Sauve la valeur d'octave courante.
$0b36       Boucle sur la prochaine commande.

$0b39       [tempo]
            Décodage de la commande 'T' dans une instruction PLAY, indiquant un changement de tempo.

            Pour cela, décode un nombre de 1 à 3 chiffres décimaux, le divise par 4 et y ajoute 1 puis sauve le résultat dans `tmpsav`.
$0b39       Lit le premier caractères du paramètre.
$0b3a       %CHAR
            En soustrait '0' pour obtenir la valeur numérique.
$0b3c       Branche sur une erreur de syntaxe si la valeur est trop basse.
$0b3f-$0b41 Fait de même si la valeur est trop haute (plus de 9)
$0b44       Charge la valeur dans L
$0b45-$0b46 Caractère suivant
$0b47       S'arrête si la chaîne de commandes est épuisée.
$0b4a       %CHAR
$0b49-$0b50 Lit le prochain chiffre ou arrête le décodage.
$0b52       Sauvegarde la nouvelle valeur dans H
$0b53-$0b58 Multiplie A par 10
$0b59       Y ajoute le nouveau chiffre.
$0b5a       Met le résultat dans L.
$0b5b-$0b5d Caractère suivant.
$0b5f-$0b66 Lit le prochain chiffre ou arrête le décodage.
$0b68-$0b70 Multiplie à nouveau L par 10 et ajoute le nouveau chiffre.
$0b71-$0b72 Pointe sur le caractère suivant de la chaîne de commandes.
$0b73       [tempo_done]
$0b73       La valeur décodée est dans L, elle passe dans A.
$0b74       Passe le Carry à 0.
$0b75       Divise la valeur par 2.
$0b76       Passe le Carry à 0.
$0b77       Divise la valeur par 2.
$0b78       Augmente la valeur de 1
$0b79       Sauve la valeur de tempo calculée.
$0b7c       Boucle sur la prochaine commande.

$0b7f       [play_pause]
            Décodage de la commande 'R' dans une instruction PLAY, indiquant une pause (une respiration).
$0b7f       Décodage de la longueur de la respiration.
$0b82       Sauvegarde de la valeur
$0b83       Échange les registres par les registres secondaires.
$0b84       Récupère la longueur de la note dans DE
$0b85       Charge la valeur du tempo.
$0b88       Multiplie le tempo par la longueur de la respiration.
$0b8b       [pause_lp_1]
$0b8b       Décrémente la longueur de la pause
$0b8c       Initialise un compteur pour la seconde boucle
$0b8e       [pause_lp_2]
$0b8e       Attente
$0b8f       Boucle sur B. 1 + 3 Cycle M par boucle, 4 + 13 États T par boucle. Sauf pour la dernière, 1 + 2 / 4 + 8. Total: 767 Cycles / 3259 États. Environ 814.74 ns
$0b91-$0b93 Boucle si DE n'est pas nul (2 * 4 + 10 États T)
$0b95       Revient sur les registres initiaux.
$0b96       Boucle sur la commande suivante.

$0b99       [note_length]
            Récupère un potentiel nombre décimal de deux chiffres maximum dans le buffer fourni à 'play` et en retourne la valeur dans HL.

            Préserve DE.

$0b99       %NOT_LABEL
            Valeur par défaut de HL
$0b9c       Caractère dans le buffer de commande.
$0b9d       %CHAR
            Soustrait '0'
$0b9f       Retourne immédiatement si inférieur à 0 (et donc, sort avec HL = $0010)
$0ba0       Compare avec 10.
$0ba2       Retourne si le caractère était supérieur à '9'
$0ba3       Charge la première valeur dans L
$0ba4       et H contient 0.
$0ba6       Pointe vers le caractère suivant.
$0ba7       Réduit le nombre de caractères restant.
$0ba8       Si la chaîne est épuisée, retourne.
$0baa       %CHAR
$0ba9-$0baf Même traitement pour le nouveau caractère.
$0bb0       Sauve DE
$0bb1       Double HL
$0bb2-$0bb3 Transfert HL dans DE
$0bb4-$0bb6 Multiplie HL par 10.
$0bb7-$0bb8 Charge la valeur des unités dans DE
$0bba       Ajoute HL et DE
$0bbb       Restaure DE
$0bbc       Pointe vers le caractère suivant.
$0bbd       Réduit le nombre de caractères restant.

$0bbf       [sound_data]
            14 notes sur 4 octaves = 56 notes
            56 notes * 3 octets = 168 octets

            Les deux premiers octets de chaque note est sauvé dans `sonsav`, il s'agit des périodes qui forment les deux phases du son.
            Le troisième octet est un facteur multiplicatif pour obtenir la longueur de la note.

$0c6a       [inst_sound]
            %CODE
$0c6a       Appel le `hook` pour l'instruction SOUND.
$0c6d       Récupère le premier paramètre.
$0c70-$0c71 Branche si le premier paramètre n'est pas 0.
$0c73       Sinon, le paramètre est forcé à 1
$0c74       [snd_val_ok]
$0c74       Passage sur les registres alternatifs.
$0c75-$0c76 DE prend la valeur du premier paramètre.
$0c78-$0c79 Période du son = 256 - A
$0c7a       Cette valeur est mise dans C
$0c7b       Bascule sur les registres primaires.
$0c7c       Vérification de la présence d'une virgule
$0c7d       %DATASKIP
$0c7e       Récupère le deuxième paramètre.
$0c81       Bascule sur les registre alternatifs.
$0c82       Multiplie DE (le premier paramètre) par A (le second paramètre)
$0c87       [de_div_16]
$0c85-$0c8c Divise DE par 16
$0c8e       Et l'incrémente.
$0c8f       Bascule sur les registres primaires.
$0c91       %CHAR
$0c90-$0c95 Vérifie la présence du troisième paramètre, optionnel.
            Branche s'il n'existe pas, avec la valeur par défaut A = 0.
$0c97-$0c98 Sinon, récupération dans A du troisième paramètre
$0c9b       [no_cycle]
$0c9b       Bascule sur les registres secondaires.
$0c9c       Sauvegarde du troisième paramètre
$0c9d-$0c9e Première période = période du son + cycle
$0ca1       Récupère le troisième paramètre dans H
$0ca2-$0ca4 Deuxième période = période du son - troisième paramètre

$0ca7       [snd_emit]
            Émet un son

            Entrées :
            - sonsav_hi et sonsav_lo indiquent les périodes des deux phases du son
            - DE contient la durée du son

            [ArticleBeep]
$0ca7       Désactive les interruptions.
$0ca8       [snd_dur_lp]
$0ca8       Boucle sur la durée du son. Pousse HL
$0ca9       Et récupère. Semble être là pour le timing, HL étant écrasé ensuite.
$0caa       Met A à 0
$0cac       Récupère la valeur des deux périodes.
$0caf       [snd_low]
$0caf       Attente de 74 états
$0cb2       Décrémente le nombre de première période.
$0cb3       Boucle tant qu'il est différent de zéro.
$0cb6-$0cb8 Mise à état haut de la sortie son (bit 3 de $af à 1)
$0cba       Décrémente la durée totale du son
$0cbb-$0cbe Attente totale de 63 états.
$0cc1       [snd_high]
$0cc1       Attente de 74 états.
$0cc4       Décrémente la valeur de la seconde période.
$0cc5       Boucle tant que le nombre est différent de zéro.
$0cc8-$0cca Mise à état bas de la sortie son (bit 3 de $af à 0)
$0ccc-$0cce Boucle si DE n'est pas nul.
$0cd1       Réactive les interruptions
$0cd2       Bascule sur les registres alternatifs.

$0cd4       [de_mul_a]
            Multiplication de DE par A, avec le résultat dans DE.

            Entrées :
            - A, le multiplicateur
            - DE, le registre à multiplier

            Sortie :
            - DE, le résultat de DE multiplié par A
            - HL contient le DE initial multiplié par 256, par effet de bord.

            Préserve :
            - A

            Sortie : HL = DE << 8 (autrement dit, H <- E) ; DE = DE * A ; A inchangé
$0cd4       Multiplication sur 8 bits
$0cd6       Accumulateur à 0
$0cd9       [next_bit]
$0cd9       Rotation à droite avec le bit de poids faible dans Carry
$0cda       Si le bit était 0, pas d'addition à effectuer.
$0cdc       Sinon, ajout de DE dans HL
$0cdd       [dont_add]
$0cdd       Passe le Carry à 0
$0cde-$0ce0 Multiplication de DE par 2 (décalage de DE de 1 vers la gauche)
$0ce2       Traite le bit suivant.
$0ce4       Récupère le résultat dans DE

$0ce6       [wait_74s]
            Attente de 74 states (états T), incluant le `call`.
$0ce6       20 states
$0ce7       20 states
$0ce8       [wait_34s]
$0ce8       5 states
$0ce9       [wait_29s]
$0ce9       11 states (+ `call` 18 states)
$0cea       Trois octets inutilisés (en code, `dec b`, `reti`)

$0ced       [inst_sete]
            %CODE
            Commandes BASIC `SETET` et `SETEG`

            L'interpréteur branche ici pour la commande `SETE` qui n'est pas une vraie commande.
            La routine se charge de déterminer à partir du caractère suivant de quelle commande il s'agit.

            En effet, les deux commandes sont similaires, on peut considérer que `E` ou `G` est le premier argument
            de la commande.

$0ced-$0cee Récupère dans A le caractère pointé par HL et incrémente HL, pointeur vers le texte BASIC.
$0cef       Paramètre par défaut dans B si la commande est `SETET`
$0cf1       %CHAR
$0cf1-$0cf3 Branche si la commande est `SETET`
$0cf5       Paramètre dans B si la commande est `SETEG`
$0cf7       %CHAR
$0cf7-$0cf9 Si le caractère paramètre n'est pas 'G'. branche vers une erreur de syntaxe.
$0cfc       [setet]
$0cfc       Sauve l'argument B dans la pile (C n'est pas utilisé).
$0cfd       Désactive le rafraîchissement de l'écran.
$0d01       Récupère le premier argument sous forme d'octet dans A.
$0d04-$0d06 Ce paramètre doit être au minimum 32, branche vers une erreur si ce n'est pas le cas.
$0d09       Met le bit 7 du paramètre à 1.
$0d0b       Transfert le paramètre dans E
$0d0c       Prépare la commande pour le VDP.
$0d0e       Bascule sur AF alternatif.
$0d0f       Envoie la commande $22 avec le premier paramètre modifié au VDP.
$0d12-$0d13 Récupère puis remet sur la pile l'argument préparé suivant si on est dans `SETET` ou `SETEG`.
$0d14       Inverse le bit 7 de A (ce qui inverse les $c0 et $40)
$0d16-$0d19 Envoie la commande $21 avec la valeur déduite de la commande utilisée. (VDP : R1 = mode)
$0d1c-$0d20 Envoie la commande $20 avec l'argument $03 au VDP (VDP : R0 = 3, c'est-à-dire KRG+Incr)
$0d23       Prépare la commande $24 pour le VDP
$0d25-$0d27 Bascule de registre AF alternatif le temps de récupérer le premier argument (numéro de caractère) dans E
$0d28       On récupère dans A le numéro de caractère.
$0d29-$0d2b On ne garde du paramètre que les bits de 2 à 7 (dans les bits 0 à 5)
$0d2d-$0d2e Envoie la commande $24 avec comme paramètre ce nombre modifié (VDP : R4 = (caractère >> 2) & $1f)
$0d31       Préparation de la commande $25 pour le VDP
$0d33       Bascule sur AF initial.
$0d34       On garde les 2 bits de poids faible de l'argument.
$0d36       Récupération du type de commande depuis la pile (dans B)
$0d37-$0d38 Préparation de l'argument pour la commande comme l'union du type de commande (B) et des 2 bits de poids faibles.
$0d39       Envoi de la commande $25 avec cet argument au VDP (VDP : R5 = (A & $03 | mode)
$0d3c-$0d40 Envoi de la commande $20 avec l'argument $34 au VDP (VDP : R0 = OCT Write AP NoIncr, écrit R1 en mémoire désignée par R4 R5)
$0d43       Vérifie la présence d'une virgule dans le buffer texte du BASIC.
$0d44       %DATASKIP
$0d45       Vérifie la présence d'un début de chaîne de caractères.
$0d46       %DATASKIP
$0d47       Décrémente le pointeur vers le texte BASIC pour préparer le décodage de la valeur hexadécimale.
$0d48       Il y a 10 valeurs de lignes a décoder.
$0d4a       [set_rd_data]
$0d4a       Récupère une valeur hexadécimale codée en ASCII vers A.
$0d4d       Sauve le compteur de lignes.
$0d4e       8 bits à traiter
$0d50       [invert_byte]
$0d50       Met le bit de poids fort dans Carry
$0d51       Met le Carry dans le bit de poids fort de C avec rotation.
$0d53       Boucle sur les 8 bits
$0d55       Met dans A le résultat, qui est la valeur initiale « miroir » (le bit 7 est à présent le bit 0)
$0d56       Récupère le compteur de ligne.
$0d57-$0d5a Envoi de la commande $29 avec l'argument de la ligne au VDP (VDP : R1 = A + Execute)
$0d5d       Attend que le VDP soit prêt.
$0d60-$0d62 Envoi de la commande $25 au VDP (VDP : lecture de R5).
$0d64       Lecture de la réponse.
$0d66-$0d6b Envoi de la commande $25 avec l'argument retourné augmenté de 4 (VDP : R5 = R5 + 4)
$0d6e       Boucle sur la lecture de la ligne suivante.
$0d72       %CHAR
$0d70-$0d76 Lecture des guillemets de fin optionnels.
$0d77       [sete_end]
$0d77       Réactivation du rafraîchissement de l'écran.

$0d7c       [send_to_vdp]
            Envoi d'une commande au Video Display Processor (EF9345)

            La commande est envoyée sur le port $8F.
            La donnée associée est envoyée sur le port $CF

            Entrée :
            - D est la commande à envoyer
            - E son argument

            Modifie :
            - C

            [ArticleVDP]
$0d7c       Préparation du port de sortie pour la commande
$0d7e       Envoi de la commande
$0d80       Préparation du port de sortie pour la donnée
$0d82       Envoie de la donnée

$0d85       [setext_impl]
            Redéfinition d'un caractère


            Entrées :
            - A[6:0] contient le caractère à changer (sur 7 bits).
            - A[7] contient la nature de la palette (0 == Texte, 1 == Graphique)
            - HL pointe sur le buffer de 10 octets avec les valeurs de caractère.

            Normalement appelé depuis `setext`.

$0d85-$0d8b Si le bit 7 de A est à 0, alors B prend $C0 (mode texte), sinon B prend $40 (mode graphique)
$0d8d       [setext_gr]
$0d8d       Sauve le paramètre B qui vient d'être choisi.
$0d8e       Désactivation du rafraîchissement de l'affichage.
$0d92       Bit 7 de A, le caractère à modifier, passe à 1.
$0d94       L’argument est mis dans E.
$0d95       Préparation de la commande pour le VDP
$0d97       Bascule sur le registre AF alternatif.
$0d98       Envoi la commande $22 au VDP, avec en argument le numéro de caractère modifié (VDP : R2 = caractère).
$0d9b       Récupération de la valeur de B, le choix du mode graphique ou texte, dans A.
$0d9c       Remise du contenu de BC sur la pile.
$0d9d       Inversion du bit 7 de A, ce qui inverse les valeurs $c0 et $40 choisies au début.
$0d9f-$0da2 Envoi la commande $21 au VDP avec le choix texte/graphique (VDP : R1 = mode).
$0da5-$0da9 Envoi al commande $20 au VDP avec l'argument $03 (VDP : R0 = 3, c'est-à-dire KRG+Inc).
$0dac       Prépare la commande $24 pour le VDP
$0dae       Récupération, à travers E, de la valeur de A en entrée de fonction (avec les trois lignes suivantes)
$0daf-$0db1 Bascule de registre AF alternatif le temps de récupérer le premier argument (numéro de caractère) dans E
$0db2-$0db4 On récupère dans A le numéro de caractère. On ne garde du paramètre que les bits de 2 à 7 (dans les bits 0 à 5)
$0db6-$0db7 Envoie la commande $24 avec comme paramètre ce nombre modifié (VDP : R4 = (caractère >> 2) & $1f).
$0dba       Préparation de la commande $25
$0dbc       Bascule sur AF initial.
$0dbd       On garde les 2 bits de poids faible de l'argument.
$0dbf       Récupération du type de commande depuis la pile (dans B)
$0dc0       Préparation de l'argument pour la commande comme l'union du type de commande (B) et des 2 bits de poids faibles.
$0dc1-$0dc2 Envoie de la commande $25 avec cet argument au VDP (VDP : R5 = (A & $03) | mode)
$0dc5-$0dc9 Envoi de la commande $20 au VDP avec l'argument $34 (R0 = OCT Write AP NoInc, écrit R1 en mémoire désignée par R4 R5)
$0dcc       10 lignes de pixels à transférer.
$0dce       [setext_read]
$0dce       Récupère la valeur suivante de la redéfinition de caractère.
$0dcf       Pointe HL vers la valeur suivante
$0dd0       Sauve sur la pile le compteur de lignes (B)
$0dd1       Prépare la boucle interne, 8 bits à traiter.
$0dd3       [setext_inv]
$0dd3-$0dd8 Inverse (miroir) bit à bit la définition lue dans A.
$0dd9       Récupère le compte de lignes dans B
$0dda-$0ddd Envoi de la commande $29 au VDP avec en argument la description « mirroir » (VDP : R1 = A + Execute)
$0de0       Attente que le VDP soit prêt
$0de3-$0de7 Envoi de la commande $25 au VDP pour lecture de donnée. (VDP : lecture de R5).
$0de9-$0dee Envoi de la commande $25 au VDP avec la valeur lue augmentée de 4 (VDP : R5 = R5 + 4).
$0df1       Boucle sur la ligne suivante
$0df3       Réactivation de l'affichage

$0df8       [inst_tx]
            %CODE
            Commande BASIC `TX`.

            Initialise le mode texte.

            Les registres touchés sont les registres en RAM, ils sont pris en compte par les commandes BASIC, pas
            directement envoyés au VDP>
$0df8-$0dfa Sélection des caractères en ROM du VDP.
$0dfd       [char_switch]
$0dfd       Sauvegarde la valeur de A, qui contient le paramètre mis par les différentes routines pour `TX`, `ET` , `GR`, `EG` (1 pour graphique, 0 pour texte)
$0dfe       Mis à 1 les 3 bits de poids faibles, ce qui signifie que la couleur d'affichage est b111.
$0e00       Place la valeur dans le registre `attcar`.
$0e03       Récupère la valeur de A initiale et les drapeaux lors de l'appel de la routine.
$0e04       Si Z était à 1, cela signifie qu'il n'y avait pas de paramètre. Retour immédiat.
$0e05       Récupère le premier paramètre dans A, entier 8 bits qui contient la couleur d'écriture sur 3 bits.
$0e08       Sauve la valeur
$0e09       N'en garde que les 3 bits de poids faible.
$0e0b       Sauve la valeur dans D.
$0e0c       Prend la valeur du registre `attcar`.
$0e0f       En garde les 5 bits de poids forts.
$0e11       Fait l'union avec la valeur du paramètre.
$0e12       Replace la nouvelle valeur dans `attcar`.
$0e15       Restaure la valeur des drapeaux après `getbyt_impl`. Z est à 1 si on était en fin de ligne.
$0e16       Dans ce cas, retour immédiat.
$0e17       Sinon, il doit y avoir une virgule.
$0e18       %DATASKIP
$0e19       Récupère le second paramètre dans A, entier 8 bits qui contient l'état des caractères sur 3 bits
            pour le texte, ou bien la couleur du fond pour le mode graphique.
$0e1c       Sauve la valeur et les drapeaux.
$0e1d-$0e22 Garde les 3 bits de poids faible et les déplace de 4 bits vers la gauche.
$0e23-$0e26 Met à jour `attcar` (double hauteur, double largeur et inverse vidéo / couleur de fond)
$0e29-$0e2a Retour immédiat si la commande est terminée.
$0e2b       Sinon, il doit y avoir une virgule.
$0e2c       %DATASKIP
$0e2d       Récupère le troisième paramètre dans A, entier 8 bits qui contient le clignotement sur 1 bit.
$0e30-$0e31 Retour immédiat si la valeur est 0.
$0e32       Sinon, on passe directement le bit 3 de `attcar` à 1.

$0e37       [inst_gr]
            %CODE
            Commande BASIC `GR`.

            Initialise le mode graphique.

            Utilise la routine générique avec les paramètres :
            - caractères en ROM
            - mode graphique
$0e37       Indique que les caractères sont à prendre en ROM
$0e3b       Sélectionne le mode graphique

$0e40       [inst_et]
            %CODE
            Commande BASIC `ET`.

            Initialise le mode texte étendu (texte spécial).

            Utilise la routine générique avec les paramètres :
            - caractères en RAM
            - mode texte
$0e44       Indique que les caractères sont à prendre en RAM du VDP
$0e40       Sélectionne le mode texte.

$0e49       [inst_eg]
            %CODE
            Commande BASIC `EG`.

            Initialise le mode graphique étendu (graphie spécial).

            Utilise la routine générique avec les paramètres :
            - caractères en RAM
            - mode graphique
$0e49       Indique que les caractères sont à prendre en RAM du VDP
$0e4b       Sélectionne le mode graphique.

$0e51       [inst_init]
            %CODE
            Commande BASIC `INIT`.

            Initialise la couleur de l'écran, et l'efface.

$0e51       Initialise `attcar` à 0 (couleur 0, pas de clignotement, pas de double hauteur/largeur, couleurs non inversées)
$0e55       Sauve le pointeur de texte BASIC.
$0e56       Prépare un paramètre $e6 par défaut pour `attbak`.
$0e58       S'il n'y a pas de paramètre, branche à la fin de la routine.
$0e5a       Restaure le pointeur de texte BASIC.
$0e5b       Lit le premier paramètre (couleur de fond)
$0e5e       Branche si c'était le dernier paramètre.
$0e60       Sauve le résultat
$0e61       Le caractère suivant doit être une virgule
$0e62       %DATASKIP
$0e63       Lecture du second paramètre (couleur de bord)
$0e66       Prend les 3 bits de poids faibles.
$0e68       Les sauve dans B.
$0e69       Prend la valeur actuel du registre `cursor`.
$0e6c       En garde les 5 bits de poids forts.
$0e6e       Union avec le paramètre de couleur de bord.
$0e6f       Sauvegarde de la couleur de fond dans le registre `cursor`.
$0e72       Restaure AF, résultat du premier paramètre.
$0e73       [init_color]
$0e73       Sauve le pointeur de texte BASIC.
$0e74       Garde les 3 bits de poids faible du premier paramètre (couleur de fond)
$0e76       Sauve le résultat dans L
$0e77-$0e7a Décale la couleur de 4 vers la gauche, pour la positionner dans la couleur de fond graphique.
$0e7b       Ajoute la couleur de fond texte.
$0e7c       Le bit 7 de `attbak` doit être à 1 pour le format code court/40 colonnes du VDP.
$0e7e       [init_end]
$0e7e       Efface l'écran avec la nouvelle couleur de fond.
$0e81       Restaure le pointeur de texte BASIC.

$0e83       [inst_cursor]
            %CODE
            Commandes BASIC `CURSORX` et `CURSORY`

            L'interpréteur branche ici pour la commande `CURSOR` qui n'est pas une vraie commande.
            La routine se charge de déterminer à partir du caractère suivant de quelle commande il s'agit.

            En effet, les deux commandes sont similaires, on peut considérer que `X` ou `Y` est le premier argument
            de la commande.

$0e85       %CHAR
$0e83-$0e87 Branche si le caractère suivant est un 'Y'
$0e89       %CHAR
$0e89-$0e8b Si ce n'est pas 'X' non plus, provoque une erreur de syntaxe.
$0e8e       Récupère l'argument dans A en tant qu'entier sur 8 bits.
$0e91-$0e95 La valeur maximale pour la colonne est 39.
$0e97       [set_curx]
$0e97       Met le numéro de colonne passé en argument dans la variable système.

$0e9b       [cursory]
$0e9b       Récupère l'argument dans A en tant qu'entier sur 8 bits.
$0e9e-$0ea2 La valeur maximale pour la ligne est 24.

$0ea4       [set_cury]
$0ea4       Met le numéro de ligne passé en argument dans la variable système.

$0ea8       [inst_scroll]
            %CODE
            Commande BASIC `SCROLL`

            Cette commande permet le défilement de l'écran.
            Inverse de la commande `PAGE`.
$0ea8-$0ead Met à 0 le bit 7 du registre `picflg`.

$0eb1       [inst_page]
            %CODE
            Commande BASIC `PAGE`

            Cette commande empêche le défilement de l'écran.
            Inverse de la commande `SCROLL`.

$0eb1-$0eb6 Met à 1 le bit 7 du registre `picflg`.

$0eba       [inst_stickx]
            %CODE
            Fonction BASIC `STICKX()`

            Renvoie la valeur gauche (255)/repos (0)/droite (1) des commandes de joystick ou au clavier.

$0eba       Tranforme la valeur dans FAC en entier dans A.
$0ebd       Appelle la routine système.
$0ec0       Branche sur le retour de fonction avec le résultat dans A.

$0ec3       [stkh_impl]
            Vérification de l'axe horizontal pour les déplacements.

            L'axe horizontal est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de sélection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.

            Sortie :
            - A = 0, aucune action selon l'axe horizontal.
            - A = 1, action vers la droite.
            - A = 255, action vers la gauche.

            Modifie :
            - AF, B

            Normalement appelé depuis `stkh`.
$0ec3       Prépare la valeur de retour.
$0ec5       Restreint le paramètre d'entrée entre 0 et 3.
$0ec7       Branche pour le cas 0.
$0ec9-$0eca Branche pour le cas 1.
$0ecc-$0ece Lecture de la flèche vers le gauche du clavier
$0ed0       Branchement si la touche n'était pas appuyée (une touche appuyée est mise à 0)
$0ed2       La touche gauche à été appuyée, B passe à -1/255
$0ed3       [stkv_nol_k]
$0ed3       Lecture de la flèche vers le droite du clavier
$0ed5       Branche vers la partie finale commune.

$0ed7       [stkh_joy0]
$0ed7-$0ed9 Lecture du joystick 0 vers la gauche.
$0edb       Branche si le joystick n'était pas vers la gauche.
$0edd       Le joystick était vers la gauche, B passe à -1/255.
$0ede       [stkh_nol_0]
$0ede       Lecture du joystick 0 vers la droite.
$0ee0       Branche vers la partie finale commune.

$0ee2       [stkh_joy1]
$0ee2-$0ee4 Lecture du joystick 1 vers la gauche.
$0ee6       Branche si le joystick n'était pas vers la gauche.
$0ee8       Le joystick était vers la gauche, B passe à -1/255.
$0ee9       [stkh_nol_1]
$0ee9       Lecture du joystick 1 vers la droite.

$0eeb       [stk_end]
$0eeb       Branche à la fin de la fonction si la détection vers la droite n'a rien donné.
$0eed       Sinon, incrémente B, ce qui ramène B à 0 si les deux directions étaient valides, sinon, l'amène à 1.

$0eee       [stk_exit]
$0eee       Place le résultat dans A.

$0ef0       [inst_sticky]
            %CODE
            Fonction BASIC `STICKY()`

            Renvoie la valeur bas (1)/repos (0)/haut (255) des commandes de joystick ou au clavier.

$0ef0       Transforme la valeur dans FAC en entier dans A.
$0ef3       Appelle la routine système.
$0ef6       Branche sur le retour de fonction avec le résultat dans A.

$0ef9       [stkv_impl]
            Vérification de l'axe vertical pour les déplacements.

            L'axe vertical est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de sélection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.

            Sortie :
            - A = 0, aucune action selon l'axe vertical.
            - A = 1, action vers le bas.
            - A = 255, action vers le haut.

            Modifie :
            - AF, B

            Normalement appelé depuis `stkv`.

$0ef9       Prépare la valeur de retour.
$0edb       Restreint le paramètre d'entrée entre 0 et 3.
$0edf       Branche pour le cas 0.
$0eff-$0f00 Branche pour le cas 1.
$0f02-$0f04 Lecture de la flèche vers le haut du clavier
$0f06       Branchement si la touche n'était pas appuyée (une touche appuyée est mise à 0)
$0f08       La touche haute à été appuyée, B passe à -1/255
$0f09       [stkv_noup_k]
$0f0b       Lecture de la flèche vers le bas du clavier
$0d0d       Branche vers la partie finale commune.

$0f0f       [stkv_joy0]
$0f0f-$0f11 Lecture du joystick 0 vers la haut.
$0f12       Branche si le joystick n'était pas vers la haut.
$0f15       Le joystick était vers la haut, B passe à -1/255.
$0f16       [stkv_noup_0]
$0f16       Lecture du joystick 0 vers le bas.
$0f18       Branche vers la partie finale commune.

$0f1a       [stkv_joy1]
$0f1a-$0f1c Lecture du joystick 1 vers la haut.
$0f1e       Branche si le joystick n'était pas vers la haut.
$0f20       Le joystick était vers la haut, B passe à -1/255.
$0f21       [stkv_noup_1]
$0f23       Lecture du joystick 1 vers le bas.

$0f25       [inst_action]
            %CODE
            Fonction BASIC `ACTION()`

            Renvoie la valeur du bouton d'action appuyé (1) ou repos (0) des commandes de joystick ou au clavier.

$0f25       Transforme la valeur dans FAC en entier dans A.
$0f28       Appelle la routine système.
$0f2b       Branche sur le retour de fonction avec le résultat dans A.

$0f2e       [stka_impl]
            Vérification du bouton d'action.

            Le bouton d'action est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de sélection contenue dans A.

            Cette routine est modifiée en ROM 1.1 par rapport à la version ROM 1.0 pour prendre en compte deux boutons.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour la barre espace du clavier.

            Sortie :
            - A et B = 0, aucune action.
            - A et B = 1, bouton actif.

            Modifie :
            - AF, B

            Normalement appelé depuis `stka`.

$0f2e       Prépare la valeur de retour.
$0f30       Restreint le paramètre d'entrée entre 0 et 3.
$0f32       Branche pour le cas 0.
$0f34-$0f35 Branche pour le cas 1.
$0f38-$0f3a Vérification de l'appui de la touche ESPACE
$0f3c       Branche vers la partie finale commune.

$0f3e       [stka_joy0]
            Partie étendue par rapport à la ROM 1.0 pour prendre en compte deux boutons.
$0f3e       Vérification de l'appui sur le bouton action du joystick 0
$0f40       Complément à 1.
$0f41       Masque sur le bits 4 et 5.
$0f43-$0f46 Décalage pour amener le résultat sur les bits 0 et 1
$0f47       Résultat aussi dans B.

$0f49       [inst_key]
            %CODE
            Fonction BASIC `KEY()`.

            Retourne la valeur ASCII correspondant au caractère de la touche enfoncée.

$0f49       Préserve HL
$0f4a       Scan le clavier
$0f4d       Restaure HL
$0f4e       Essentiellement, met le drapeau Z à 1 si aucune touche n'a été détectée.
$0f4f       Retour de fonction avec la valeur dans A.

$0f52       [inst_delim]
            %CODE
            Commande BASIC `DELIM`.

            Écrit un délimiteur avec des attributs spécifiques.
            Provoque un rafraîchissement de l'écran.

$0f52       Récupère la valeur de `attcar`
$0f55       La sauve sur la pile
$0f56-$0f58 Sauve 0 sur la pile.
$0f59       Prend le premier argument de la commande.
$0f5c       Limité entre 0 et 7 (4 bits de poids faible).
$0f5e       Récupère 0 dans D.
$0f5f       Compare l'argument à 0.
$0f60       Pousse le résultat sur la pile.
$0f61       Vérifie la présence d'une virgule.
$0f62       %DATASKIP
$0f63       Prend le second argument de la commande.
$0f66       Limité entre 0 et 7.
$0f68-$0f6b Décale le résultat de 4 vers la gauche.
$0f6c       Récupère le premier argument dans D
$0f6d       Union des deux arguments (les deux couleurs)
$0f6e       Le bit 7 de `attcar` est toujours 1
$0f70       Place les nouvelles couleurs dans `attcar`.
$0f73       Vérifie la présence d'une virgule.
$0f74       %DATASKIP
$0f75       Prend le troisième argument de la commande.
$0f78       Test le bit 0 de l'argument.
$0f7a       Prépare le résultat si l'argument est 0, $80.
$0f7c       Branche si l'argument est 0 (plus généralement, pair)
$0f7e       Si l'argument est 1 (plus généralement, impair), le résultat est $84
$0f80       [delim_norm]
$0f80       Préserve HL
$0f81       Affiche le délimiteur
$0f84       Restaure HL
$0f85       Récupère la valeur initiale de `attcar`
$0f86       Et la restaure.
$0f89       Demande un rafraîchissement de l'écran.

$0f8e       [inst_screen]
            %CODE
            Commence BASIC `SCREEN`

            Contrairement à ce que le manuel indique, l'appel de la commande a un effet, celui
            de forcer un rafraîchissement de l'écran.

$0f8e-$0f92 Force l'affichage et met le compteur de rafraîchissement à 1
$0f96       Attend la prochaine interruption qui provoquera un rafraîchissement

$0f98       [inst_display]
            %CODE
            Commande BASIC `DISPLAY`

            Indique la période de rafraîchissement de l'écran et provoque un rafraîchissement de l'écran à la prochaine
            interruption.

$0f9a       Valeur par défaut pour DISPLAY, 32
$0f9a       Branche si DISPLAY a été appelé sans argument.
$0f9c       Récupère l'argument de la commande dans A.
$0f9f       [display_def]
$0f9f       Inscrit la valeur de la période dans le registre `intrat`, utilisé par l'IRQ pour décider de quand rafraîchir l'écran.
$0fa2       Branche sur l'instruction SCREEN, qui provoque un rafraîchissement à la prochaine interruption.

$0fa4       [inst_store]
            %CODE
            Commande BASIC `STORE`

            Contrairement à ce que le manuel indique, l'appel de la commande a un effet, celui
            de faire prendre la plus grande période possible pour un rafraîchissement d'écran, et de
            retarder le prochain du maximum (256 interruptions).

$0fa4       Met à 0 la période d'affichage qui est la plus grande possible, car le compteur est toujours décrémenté avant de tester s'il est à zéro.
$0fa8       Met le compteur d'interruption actuel à 0.

$0fad       [inst_call]
            %CODE
            Commence BASIC `CALL`

            Évalue l'argument, en prend la partie entière, puis utilise le vecteur `calhk` comme tremplin pour appeler l'adresse obtenue.
$0fad       Évalue l'expression numérique qui suit la commande.
$0fb0       En prend la partie entière dans DE.
$0fb3       $C3 est l'opcode pour `call`.
$0fb5       Place l'opcode dans `calhk`
$0fb8       Place l'adresse à la suite
$0fbc       Branche vers le tremplin.

$0fbf       [str_to_hex]
            Décode une valeur hexadécimale formée par deux caractères ASCII pointés par HL.

            Entrée :
            - HL pointe sur le caractère précédent la première valeur

            Sortie :
            - A contient la valeur

$0fbf       Décode la valeur hexadécimale pointée par HL.
$0fc2       Branche sur une erreur de syntaxe si le décodage a échoué.
$0fc5-$0fc9 Multiplie le résultat par 16 et le place dans C.
$0fca       Décode la seconde valeur hexadécimale.
$0fcd       Branche sur une erreur de syntaxe si le décodage a échoué.
$0fd0       Complète l'octet.

$0fd2       [get_hex]
            Lecture d'un chiffre hexadécimal depuis HL.

            Entrée :
            - HL pointe un octet avant le caractère (la routine l'avance, comme toutes les routines de lecture de caractère)

            Sortie :
            - Carry est à 1 si le caractère n'était pas un chiffre hexadécimal
            - Carry est à 0 si le caractère était un chiffre hexadécimal
            - Dans ce cas, A contient la valeur du chiffre.

$0fd2-$0fd3 Acquisition du caractère.
$0fd4       %CHAR
$0fd4-$0fd6 Branche si le caractère est inférieur à '0' en ASCII.
$0fd8       Comparaison avec ':' (juste après '9')
$0fd8       %CHAR
$0fd8-$0fda Branche si le caractère est inférieur à ':', il est entre '0' et '9' inclus.
$0fdc       Si le caractère est alphabétique, il est à présent forcé à sa version majuscule.
$0fde       %CHAR
$0fde-$0fe0 Branche si le caractère est inférieur à 'A' en ASCII
$0fe2       %CHAR
$0fe2-$0fe4 Branche si le caractère est supérieur ou égal à 'G'.
$0fe7       Soustrait $37 à A pour obtenir la valeur ('A' - $37 donne $0A)
$0fe9       [valid_hex]
$0fe9       Si le caractère était entre '0' et '9', ne garde que la partie basse, ce qui transforme le caractère en sa valeur numérique.

$0fec       [invalid_hex]
$0fec       Le caractère n'était pas un chiffre hexadécimal. Le Carry est mis à 1.

$0fee       Padding de fin de section. Ces octets ne sont pas utilisés.

$1000       [start]
            %SECTION(biinit)
            == DEBUT DE SECTION BIINIT (BASIC INITIALISATION) ==
            C'est ici que commence l’initialisation complète de la machine.
            La première étape est de recopier le contenu de la ROM dans
            l'espace RAM adressable. Adressable ne signifie pas que de la RAM
            est effectivement branchée. Cela ne pose pas de problème au
            niveau hardware du VG5000 d'envoyer une demande d'écriture.

            Le contenu de la mémoire est ensuite lu et comparé à la ROM.
            Tant que c'est identique, c'est qu'il y a quelque chose de branché
            qui répond correctement. Dès que c'est différent, c'est qu'on est
            sorti de la zone de la mémoire inscriptible disponible.

            La dernière adresse valide est stockée dans $4895 (`stktop`) et
            dans SP, le registre pointeur de pile (Stack Pointer)

            On remarquera que si une ROM répond avec un contenu identique à
            la ROM à une adresse multiple de 16ko, l'initialisation va
            penser que c'est de la RAM accessible.

$1000       Désactivation de l'IRQ.
$1001-$100a Copie de la ROM en boucle sur toute la mémoire adressable.
$100c-$100d Transfert de HL (qui vaut $c000) vers BC. DE vaut $0000 suite à `ldir`.
$100e       HL pointe sur la première adresse RAM.
$1011       [check_mem]
$1011       Lecture de l'octet pointé par HL
$1012       Comparaison de A et (HL), incrémentation de HL, décrémentation de BC
$1014       DE pointe sur l'octet suivant
$1015       Branche si le deux octets comparés étaient différent.
$1017       Sinon, on boucle selon le compteur BC.

$101a       HL a bouclé vers $0000. Saute par dessus le `dec hl` qui suit.
$101a       %DATASKIP

$101b       [mem_differs]
            Après avoir initialisé le pointeur de pile, la seconde
            étape de l'initialisation consiste à remplir les vecteurs
            utilisateur par des instructions spécifiques. Ces vecteurs, situés
            en RAM, permettent d'intervenir lors de certaines opérations avec
            du code écrit par l'utilisateur et donc de modifier le comportement
            du système.

            [ArticleHooks]

$101b       HL pointe sur la dernière adresse valide.
$101c       SP prend aussi cette valeur
$101d       Ainsi que le registre `stktop`

$1020       A est initialisé avec l'opcode pour `ret`
$1022       HL pointe vers le premier hook, `inthk`
$1025       Sur une longueur amenant jusqu'à `inphk` compris.
$1027       [hk_ini_lop]
$1027       Place un `ret` à l'adresse pointée par HL
$1028       Avance HL
$1029       Boucle sur la longueur de B. Tous les hooks sont initialisés avec des `ret`.
$102b       A est initialisé avec l'opcode pour `jp`
$102d-$1033 Place un `jp` dans les adresse d'exécution des commandes BASIC `LPEN`, `DISK` et `MODEM`.

            Ces adresses sont aussi appelées respectivement `lpnhk`, `dskhk` et `modhk`.

            Ces instructions sont en RAM, ce qui permet de les router initialement vers une routine
            affichant une erreur, puis de les router vers les vraies commandes lorsque le
            périphérique est pris en charge.
$1036       Adresse de la routine affichant une erreur de périphérique non présent.
$1039-$103f Place cette adresse après tous les `jp` des trois instructions précédentes.
$1042-$1048 Étrangement, le hook de l'interruption non masquable, lors du boot, est branchée vers
            une routine qui passe le système en anglais.

$104b       IX prend la valeur $47FA qui est la base de la zone de données graphiques.

            Attention, la valeur de IX doit rester constante. Le système
            considère que IX est en tout temps égal à $47FA et référence
            certaines variables par index par rapport à IX.

            Si IX doit changer, il faut veiller à désactiver l'IRQ (ou faire en
            sorte d'en sortir juste après le hook `inthk`) et ne rien appeler
            qui concerne l'affichage sans avoir restauré IX.

            Cette troisième phase initialise le processeur graphique EF9345.
            Pour commencer, une séquence est envoyée au périphérique, puis
            quelques variables en RAM sont initialisées.

            La séquence, envoyée par `regst`, est détaillée au label correspondant.

$104f       HL pointe sut la séquence à envoyer au VDP.
$1052       Envoie la séquence au VDP.
$1055       Initialisation du registre `intdiv`, compteur d'interruptions à 5.
$1059       Initialisation du registre `intact`, permission de rafraîchissement à faux.
$105d       Initialisation du registre `fklock` : utilisation des majuscules à vrai.
$1061       Passage du Z80 en Mode 1.

$1063       Réactivation de l'IRQ.
$1064-$1067 Numéro de départ d'un listing à l'écran.
$106a       Initialisation du registre `cursor` (registre MAT du VDP)
            Couleur de marge (activée) Cyan.
            Curseur affiché plein clignotant.
            Simple hauteur.
$106e       Réinitialisation des paramètres de l'écran
$1071-$107a Recopie une série de valeurs en RAM pour initialiser des registres à partir de `ramlow`.

            Cela comprend entre autre le squelette de la routine de division de nombres flottants ou
            encore les valeurs initiales du générateur de nombres aléatoires.

            Le dernier registre initialisé est `octsav`.

$107c-$107f Envoi 0 sur le port $ef (non utilisé) et sur $AF, pour la son/k7.
            Le port $ef est censé être non utilisé. Cela active la branche \Y7 du décodeur 7807, qui n'est pas branchée.
$1081-$1084 Modification de l'adresse du hook "nmihk" pour brancher vers `test_reset` qui traite le redémarrage utilisateur (Ctrl+Delta)
$1087       Initialise les registres BASIC et l'imprimante.
$108a       Retour à la ligne.
$108d       Marque la fin du buffer de travail du BASIC.
$1090       Place le 0 obligatoire un octet avant `(txttab)`.

$1093       Calcul des bornes de pile, memsize et place disponible
$1096       HL pointe deux octets avant SP.
$1097-$109b Branche vers une erreur de mémoire si HL est inférieur à $03e8.
            Cela signifierait que `SP` était à `$03ea`. Ce qui semble très bas pour un démarrage...
$109e       DE = -50
$10a1       `memsiz` prend la valeur de HL (deux octets avec `(stktop)`)
$10a4       Soustrait 50 de HL
$10a5       Le haut de la pile `(stktop)` est placé 50 octets avant `memsiz`, pour laisse la place pour les chaînes.
$10a8       Efface et réinitialise les variales internes BASIC.
$10ab       Récupération du haut de la pile
$10ae-$10b1 HL pointe sur `(stktop)` - 17.
$10b2-$10ba Calcul la différence entre le haut de la pile moins 17 et le début de la RAM utilisable.
$10bb       Cette taille disponible est poussée dans la pile.

$10bc
$10bc       Texte en double hauteur, double largeur.
$10c0-$10cc Affichage du texte de démarrage. "VG5000"
$10cf       Retour en simple hauteur, simple largeur.
$10d3-$10df Affichage du numéro de version.
$10e2       La taille utilisateur disponible est récupérée.
$10e3       Affiche la taille mémoire utilisateur disponible.
$10e6-$10ef Sélectionne le message "octets disponibles" en français ou anglais.
$10f2       [disp_fr]
$10f2       Affiche le message
$10f5       DE contient le marqueur d’extension ROM
$10f8-$10fb Place une adresse de retour sur la pile pour le prochaine `ret z`
$10fc       Initialise le pointeur à 0.
$10ff       %NOT_LABEL
$10ff       Initialise le pas d'avancement du pointeur.
$1102       [no_rom_ext]
$1102-$1103 Ajoute BC ($2000) à HL
$1105-$1107 Retourne si HL est égal à 0, c'est-à-dire quand tous les multiples de $2000 ont été vérifiées.
            Provoquera un retour à $113f.
$1108       Sauve HL
$1109-$110c HL = (HL)
$110d       Compare avec DE, le marqueur indiquant qu'une ROM est présente.
$110e       Restaure HL, pointeur vers les multiples de $2000
$110f       Boucle si une ROM n'a pas été détectée.
$1111-$1112 Un marqueur de ROM a été détecté, HL est positionné deux octets plus loin.
$1113-$1116 HL = (HL)
$1117       Branchement à l'adresse indiquée par la ROM. Un `ret` renverra vers `after_check`.

$1118       [test_reset]
            %CODE
            Gestion de l'interruption non masquable (NMI) via le vecteur `nmihk`.

            Teste si CTRL est appuyé et si oui, effectue un reboot à chaud.

            Plus exactement, pendant le boot, le vecteur est à `jp $0069`, puis à la fin du boot `jp $1118`

            [ArticleNMI]
$1118       Sauve AF
$1119-$111b Vérifie la touche CTRL
$111d       Si appuyé, branche vers le reboot à chaud.
$111f       Sinon, restaure AF.

$1122       [warm_boot]
            Reset à chaud.
$1122       Le haut de la pile pointe vers la fin du buffer de travail BASIC.
$1125-$1126 Sortie son à 0.
$1128       L'entrée des programmes se fait par le clavier (et non par la cassette)
$112b-$112c Remise à l'état haut du signal imprimante.
$112e       Activation de l'IRQ
$112f-$1132 La première ligne du listing à l'écran est 1.
$1135       Initialisation du registre `cursor` (registre MAT du VDP)
            Couleur de marge (activée) Cyan.
            Curseur affiché plein clignotant.
            Simple hauteur.
$1139       Initialisation de l'écran
$113c       Initialisation des registres (dont la pile)
$113f       [after_check]
$113f-$1142 Joue la mélodie de démarrage.
$1145       Boucle sur l'invite utilisateur.

$1148       [vg5000_txt]
$1163       [version_txt]
$116d       [start_music]

$1179       [init_ef_seq]
            Séquence d’initialisation de l'EF9345 au démarrage.

            VDP - $28/$81 -> TGS prend la valeur de R1. L'exécution d'une première commande permet d'initialiser l'état d'occupation du VDP.
            VDP - $29/$00 -> TGS = R1 = 0 (625 lignes, non entrelacé, no-input-resync, output VSync+HSync, Service Row = 0, 40 Char
            VDP - $20/$82,$29/$6e -> MAT = $6e (Marge = B+G, Insert Marge, Curseur plein/flash, Curseur affiché, simple hauteur(
            VDP - $20/$83,$29/$f7 -> PAT = $f7 (Ligne 0 'ON', Bulk haut et bas activé, pas de conceal, insert mode : Active Area, Flash ON, Format court pour le 40 colonnes)
            VDP - $20/$84,$29/$13 -> DOR = $13 (Block G0=3, Block G1=1<<1, Block Q=0<<3)
            VDP - $20/$87,$29/$08 -> ROR = $08 (Z=0, Y=8)
            VDP - $26/$08 -> R6=$08
            VDP - $27/$00 -> R7=$00
            VDP - $28/$02 -> KRG sans incrémentation avec MP=$0800 (R1 = $08, R2 = $00 d'initialisation)
$1179       Taille de la séquence
$117a       [init_data]

$1194       [i_ramlow]
            %CODE
            Liste des valeurs qui sont copiées dans les variables système au boot.

            Toutes les étiquettes préfixées par `i_` sont les équivalents des variables système sans ce préfixe.

$1197       [i_usrloc]
            %CODE
$119a       [i_div_subr]
            %CODE
$119a-$11a7 Cette routine fait partie des valeurs montées en RAM au démarrage.
            Elle contient la soustraction du dividende par le diviseur.
            Les valeurs sont injectées à la place des $00 par la routine de
            division.
$11a9       [i_rndcnt]
$11d2       [i_lptpos]
$11d3       [i_prtflg]
$11d4       [i_getflg]
$11d5       [i_picflg]
$11d6       [i_cascom]
$11d7       [i_rawprt]
$11d8       [i_prtstt]
$11d9       [i_prtcom]
$11da       [i_prtint]
$11dc       [i_prtxlt]
$11de       [i_contbl]
$11de       Table de redirection des touches de contrôle vers les caractères accentués.
$11e8       [i_autflg]
$11e9       [i_autlin]
$11eb       [i_autinc]
$11ed       [i_allflg]
$11ee       [i_linlen]
$11ef       [i_clmlst]
$11f0       [i_curlin]
$11f2       [i_txttab]
$11f4       [i_frgglg]
$11f5       [i_kbdtbl]
$11f7       [i_tmpsav]
$11f8       [i_octsav]

$11f9       [keybfr_0]
            %SECTION(txtfil)
            == DEBUT DE SECTION TXTFIL (messages textuels) ==

$1201       [keybfr_1]
$1209       [keybfr_2]
$1211       [keybfr_3]
$1219       [keybfr_4]
$1221       [keybfr_5]
$1229       [keybfr_6]
$1231       [keybfr_7]
$1239       [keybfr_s0]
$1241       [keybfr_s1]
$1249       [keybfr_s2]
$1251       [keybfr_s3]
$1259       [keybfr_s4]
$1261       [keybfr_s5]
$1269       [keybfr_s6]
$1271       [keybfr_s7]
$1279       [keysfr_c0]
$1281       [keysfr_c1]
$1289       [keysfr_c2]
$1291       [keysfr_c3]
$1299       [keysfr_c4]
$12a1       [keysfr_c5]
$12a9       [keysfr_c6]
$12b1       [keysfr_c7]
$12b9       [keybeng_0]
$12c1       [keybeng_1]
$12c9       [keybeng_2]
$12d1       [keybeng_3]
$12d9       [keybeng_4]
$12e1       [keybeng_5]
$12e9       [keybeng_6]
$12f1       [keybeng_7]
$12f9       [keybeng_s0]
$1301       [keybeng_s1]
$1309       [keybeng_s2]
$1311       [keybeng_s3]
$1319       [keybeng_s4]
$1321       [keybeng_s5]
$1329       [keybeng_s6]
$1331       [keybeng_s7]
$1339       [keyseng_c0]
$1341       [keyseng_c1]
$1349       [keyseng_c2]
$1351       [keyseng_c3]
$1359       [keyseng_c4]
$1361       [keyseng_c5]
$1369       [keyseng_c6]
$1371       [keyseng_c7]
$1379       [errors_fr]
$13ef       [out_mem_fr]
$153f       [errors_eng]
$159e       [out_mem_eng]
$16c6       [txt_fre_fr]
$16db       [txt_fre_en]
$16e8       [txt_line_fr]
$16ef       [txt_line_en]
$16f5       [txt_undeffr]
$1702       [txt_undefen]
$170f       [txt_igno_fr]
$172d       [txt_igno_en]
$173c       [txt_redo_fr]
$1752       [txt_redo_en]
$1763       [txt_arret]
$176a       [txt_break]
$1771       [txt_in_fr]
$1776       [txt_in_en]
$177b       [txt_foun_en]
$1782       [txt_skip_en]
$1788       [txt_abrt_en]
$17af       [txt_diff_en]
$17be       [txt_nrdy_en]
$17e0       [txt_abrt_fr]
$17a4       [txt_bad_en]
$17d1       [txt_foun_fr]
$17d9       [txt_skip_fr]
$1814       [txt_diff_fr]
$1802       [txt_bad_fr]
$182f       [txt_nrdy_fr]
$1845       [prtxlt_tbl]
            Table de conversion pour l'imprimante.

            Référencée à travers `(prtxlt)` qui est initialisée à cette adresse au boot.

            La ROM 1.0 a un bug dans cette table. Le caractère $f2 est répété deux fois, le $f1 est absent.
            C'est une correction présente dans la ROM 1.1

$1945       [inst_save]
            %CODE,SECTION(bicset)
            == DEBUT DE SECTION BICSET (gestion haut niveau de la cassette) ==
            Commande BASIC `SAVE`

            Sauvegarde du listing BASIC en ASCII.
            Attention, la routine efface tout le contenu mémoire à la fin.

$1945       Lit le paramètre de vitesse et initialise les valeurs correspondantes.
$1948       Récupère les paramètres de lignes de début et fin (optionnels)
$194b       Sauve le pointeur de texte BASIC
$194c       Sauve le premier numéro de ligne de la paire.
$194d       Initialise les paramètres d'enregistrement pour la cassette.
$1950       DE contient le numéro de première ligne à sauver.
$1951-$1954 Place $0000 dans `retadr`, numéro de ligne BASIC à décoder
$1957-$1959 La sortie de caractère se fait sur K7
$195c-$1961 Met $82 en premier octet de la zone des variables qui va servir de buffer de travail.
$1962       Pointe sur l'octet suivant de la zone des variables.
$1963       Met HL dans ($4810 + $10) (`ft` + $10) (adresse de départ dans le descripteur de K7)
$1966       Met $82 dans ($4810 + $14) (`ft` + $14) (premier octet de la somme de contrôle).
$1969       Envoie le listing vers le buffer de travail.
$196c-$196e Envoie $b3 vers le buffer de travail de la k7.
$1971       Récupère le contenu de (ft + $14) (premier octet de la somme de contrôle).
$1974       Écrit le buffer sur la k7.
$1977       Affiche les erreurs potentielles.
$197a       Restaure le pointeur du texte BASIC.
$197b       Réinitialise la mémoire du programme. Le programme est effacé.

$197e       [inst_load]
            %CODE
            Commande BASIC : `LOAD`

            Charge un listing qui a été sauvé en ASCII.
            Le listing chargé est mélangé à celui existant.

$197e       Lecture de la paire de ligne à charger.
$1981-$1986 Annule les drapeaux d'erreurs qui auraient pu être levés précédemment.
$1989       Coupe l'insertion vidéo
$198c-$198e Couleur de la marge à 5 (Magenta)
$1991       Calibre la k7 en lisant l'amorce du fichier.
$1994       Branche si interruption ou erreur.
$1996       Lecture de la k7 avec préservation des registres.
$1999       Branche si interruption ou erreur.
$199b       Compare l'octet lu à $82 qui est le marqueur d'une sauvegarde ASCII via `SAVE`.
$199d       Lève le Carry
$199e       Branche si A était différent de $82
$19a0       Enregistre l'octet dans `(low)`
$19a3       Lecture du contenu du fichier ASCII.
$19a6       [load_end]
$19a6       Si Carry à 1, affiche le message d'abandon et boucle sur l'invite du BASIC.
$19a9-$19ad Lecture d'une donné, le dernier octet, en préservant aussi AF. Ce dernier octet n'est pas utilisé et permet de se caler à la fin des données avant d'éteindre le moteur.
$19ae       Extinction de la k7 et restauration de la couleur de marge.
$19b1       Branche plus loin si le chargement s'est bien déroulé.
$19b3-$19c2 Affiche le message Sortie de mémoire dans la bonne langue.
$19bf       [load_nok]
$19c5       [load_ok]
$19c5       Charge la variable des états de k7
$19c8-$19ca Branche plus loin s'il n'y a aucune erreur inscrite.
$19cc-$19cf Affiche "Mauvais fichier"
$19d2       [load_nerr]
$19d2-$19d5 Affiche le message "Pause..."
$19d8-$19d9 Annule la commande AUTO
$19dc-$19dd Met $ff dans (`getflg`) pour indiquer que l'entrée de la boucle BASIC se fera depuis le buffer rempli par LOAD.
$19e0       Revient à l'interpréteur BASIC.

$19e3       [pause_msg]
$19ed       [inst_csave]
$19ed       %CODE,CHAR
$19ed-$19ef Branchement pour "CSAVEM"
$19f1       %CHAR
$19f1-$19f3 Branchement pour "CSAVES"
$19f5-$19f7 Branchement pour "CSAVE*". Comme la multiplication est tokenisé, c'est le numéro du token qui est comparé et non le caractère `*`.
$19f9       %CHAR
$19f9-$19fb Branchement pour "CSAVEX"
$19fd       %CHAR
$19fd-$19ff Branchement pour "CSAVEL"
$1a02       Du coup, ça doit être "CSAVE"
$1a03       [csave_prm]
$1a03       Déplacement au caractère suivant lorsque l'on vient d'un "SAVE" suivi d'un caractère paramètre.
$1a05       %CHAR
            Place un espace dans le type de fichier en cas de "CSAVE" sans caractère paramètre.
$1a07       Met le type de fichier contenu dans A dans le descripteur de type de fichier.
$1a0a       Récupère et initialise le paramètre de vitesse d'écriture.
$1a0d       Récupère et envoie le nom de fichier vers le description de fichier.
$1a10       Initialise le reste de la description de fichier.
$1a13       Sauvegarde HL
$1a14       Calcul le sumcheck et écrit la description de fichier K7.
$1a17       Branche en cas d'erreur ou d'interruption de commande.
$1a19       Écrit le contenu du fichier sur la K7.
$1a1d       [stp_or_abrt]
$1a1d       Sauvegarde HL
$1a1e       [csave_skip]
$1a21       Branche s'il n'y a pas eu d'erreur ni d'interruption de commande.
$1a23-$1a26 Inscrit l'erreur "ABORT" dans la variable `cascom`
$1a28       Pointe sur le message d'erreur en français.
$1a2b-$1a2f Branche si le système est en français.
$1a31       Sinon pointe vers le message d'erreur en anglais.
$1a34       [print_abort]
$1a34       Écrit le message d'erreur.
$1a37       [csave_ok]
$1a37       Restaure HL le pointeur vers le buffer de texte BASIC.

$1a39       [inst_cload]
            %CODE
$1a39       Compare le caractère paramètre avec le token pour '*'
$1a3b       Sauve le caractère paramètre potentiel dans la version du descripteur de fichier.
$1a3e       Branche si le caractère n'était pas '*'
$1a40       Si c'était '*', alors avance d'un caractère dans le buffer de texte BASIC.
$1a41       [not_star]
$1a41       Place le caractère paramètre potentiel dans le type de fichier du descripteur de fichier.
$1a44       %CHAR
$1a44-$1a46 Branche pour la commande `CLOADA`, qui charge un programme sans effacer l'existant.
$1a48-$1a4a Branche pour la commande `CLOAD?` qui compare la version sur bande et celle en mémoire.
$1a4c       Les cas `CLOAD` et `CLOAD*`

$1a4d       [cload_a]
$1a4d       Avance d'un octet dans le buffer de texte BASIC.
$1a4e       Efface A

$1a50       [cload_vrfy]
$1a50       Complémente A, ce qui donne $FF, car A est à 0 depuis la soustraction qui a causé le branchement ici.
$1a51       Avance d'un octet dans le buffer de texte BASIC.
$1a52       Ce qui donne A = $FF et Carry à 0 pour `CLOAD?`, A = $00 et Carry à 1 dans les autres cas.
$1a54       On pousse sur la pile A ainsi que les drapeaux de la comparaison avec $01.
$1a55-$1a5a Efface les erreurs systèmes k7 de la variable `cascom`
$1a5d       Copie le paramètre potentiel nom de fichier dans le descripteur de fichier.
$1a60       Lit le potentiel second paramètre.
$1a63       Éteint la marge de l'écran.

$1a66       [read_file]
$1a66-$1a68 Change la couleur de la marge à 1 (Rouge)
$1a6b       Calibre la vitesse de lecture.
$1a6e       Branche en cas d'erreur ou d'interruption de commande.
$1a70       Lit le début du descripteur de fichier en décalé.
$1a73       Branche en cas d'erreur ou d'interruption de commande.
$1a75       Pointe vers ce qui actuellement contient le nom de fichier chargé depuis la k7, à cause du chargement décalé.
$1a78       Compare le nom de fichier trouvé avec celui dans le descripteur de fichier.
$1a7b       Branche si les deux noms correspondent (comme la correspondance se fait sur le nombre de caractère du paramètre de `CLOAD`, un nom vide est toujours un succès.
$1a7d-$1a86 Charge dans HL l'adresse du texte "Skip: " dans la bonne langue.
$1a89       [out_skip]
$1a89       Affiche le message "Skip: " si l'utilisateur ne l'a pas désactivé.
$1a8c-$1a8e Change la couleur de la marge à 4 (Bleu)
$1a91       Lance une nouvelle calibration
$1a94       Branche en cas d'erreur ou d'interruption de commande.

$1a96       [sync_silenc]
$1a96       Cherche 10 octets à 0 entre les deux enregistrements.

$1a98       [read_zero]
$1a98       Lit un octet depuis la k7
$1a9b       Branche en cas d'erreur ou d'interruption de commande.
$1a9d-$1a9e Boucle si l'octet lu n'est pas 0.
$1aa0       Lit 10 octets nuls.
$1aa2       Lit le fichier suivant.

$1aa4       [file_found]
$1aa4-$1aad Pointe vers le message de fichier trouvé dans la bonne langue.
$1ab0       [out_found]
$1ab0       Affiche le message si l'utilisateur ne l'a pas désactivé.
$1ab3-$1ab5 Change la couleur de la marge à 2 (Vert)
$1ab8       Premier caractère du descripteur de fichier lu, qui contient donc le type de fichier.
$1abb       %CHAR
$1abb-$1abd Branche si le type n'est pas ' ' (caractère espace)
$1ac2       %CHAR
$1abf-$1ac4 Branche si la commande utilisée est `CLOADA`
$1ac6       Récupère le résultat de la détection d'un `CLOAD?`
$1ac7       Utilise FAC pour sauver A temporairement.
$1aca       Si le Carry est à 1, casse la première chaîne du programme en mémoire.
$1acd       Restaure la valeur de A.
$1ad0       Compare A avec 1...
$1ad2       ... et pousse le résultat dans la pile.
$1ad3       [keep_prog]
$1ad3       Détermine l'adresse mémoire de destination du chargement, dans HL.
$1ad6       Récupère le résultat de la comparaison précédente.
$1ad7       Lecture ou vérification des données depuis la k7.
$1ada       Termine l'opération de chargement.

$1adb       [cload_end]
$1adb       Restaure DE
$1adc       Arrête le moteur k7.
$1adf       Pointe HL vers la variable du contrôle et erreurs de k7.
$1ae2       Branche en cas d'erreur de lecture ou d'interruption de commande.
$1ae4       Branche en cas de mémoire pleine.
$1ae6-$1ae7 C est $00 pour un chargement et $ff pour une vérification (CLOAD?)
$1ae8       Charge le contenu de `cascom` dans A
$1ae9       En cas de chargement, finalise l'opération.
$1aeb-$1aed Sinon, en vérification, branche si `cascom` a signalé une erreur.

$1aef       [ok_clear]
            Affiche le message d'invite "Ok!" et réinitialise les variables internes du BASIC.
$1aef-$1af2 Affiche la chaîne "Ok!"
$1af5       Branche pour réinitialiser les variables et boucler sur le moniteur.

$1af8       [mem_out_k7]
            Indique une erreur de fichier trop grand dans `cascom` et affiche une erreur de dépassement de mémoire.
$1af8       Signale l'erreur de fichier trop grand dans `cascom`
$1afa-$1afc Affiche l'erreur "Out of Memory"

$1aff       [abort_n_ok]
            Indique une erreur d'abandon dans `cascom` et affiche l'erreur correspondante dans la bonne langue.
$1aff       Signale l'erreur d'abandon dans `cascom`
$1b01-$1b0d Pointe vers le texte d'erreur dans la bonne langue et branche vers l'affichage de l'erreur avant de boucler dans le moniteur BASIC.

$1b0f       [out_k7_err]
$1b0f       %CHAR

$1b0f-$1b11 Branche si ce n'était pas un cas d'erreur de vérification.
$1b13-$1b1f Prépare l'affichage du message d'erreur de vérification dans la bonne langue.
$1b21       [out_bad_fle]
$1b24       [print_n_ok]
$1b27       Continue vers la boucle BASIC.

$1b2a       [bad_file]
            Charge le message "Mauvais fichier" dans la bonne langue.

            Sortie :
            - HL pointe sur le texte dans la bonne langue.

$1b36       [load_contnt]
            Finalise le chargement.

$1b36-$1b38 Branche si l'utilisateur a activé le mode `return if error`.
$1b3a-$1b3c Branche s'il y a une erreur système.

$1b3e       [ret_if_err]
$1b3e       A prend le type de fichier lu.
$1b41       %CHAR
$1b41-$1b43 Branche si le type de fichier lu est `M`.
$1b45       %CHAR
$1b47       Branche si le type de fichier lu n'est pas ` `.
$1b49       Charge `cascom` dans A.
$1b4a-$1b4c Branche s'il y a une erreur signalée.
$1b4e       Construit le chaînage du listing BASIC chargé.
$1b51       À la fin du chaînage, HL pointe à la fin du listing, qui devient donc l'adresse pour les variables, mis dans `(vartab)`.

$1b54       [load_in_mem]
            Finalise le chargement de fichier binaire (type M).
            Les données sont déjà en mémoire.

$1b54-$1b58 Branche si le moniteur BASIC est désactivé (à cause de l'octet de protection)
$1b5a       Pointe vers le buffer de travail.
$1b5d-$1b5f Branche si le premier octet du buffer de travail est nul.
            Le buffer contient le numéro de ligne sur lequel démarrer le programme BASIC après le chargement. Ou nul.
$1b61       %CHAR
$1b61-$1b63 Branche si le premier octet du buffer de travail est `0`.
$1b65       Il y a un numéro de ligne spécifié. Place le pointeur vers le texte BASIC dessus et branche indirectement vers l'instruction `RUN`.

$1b67       [run_or_end]
$1b67       Lecture du descripteur de fichier en décalé, donc numéro de ligne de départ (en ASCII)
$1b6a-$1b6c Branche si le premier octet n'est pas nul, il y a un numéro de ligne auquel démarrer.

$1b6e       [end_rd_file]
$1b71       %CHAR
$1b6e-$1b73 Si le type de fichier lu est `M`, branche vers la restauration du pointeur vers le texte BASIC et termine la routine.
$1b75       Branche vers le moniteur BASIC.

$1b78       [run_k7_at]
            La routine recopie le numéro de ligne de départ du BASIC et met le système dans un état où l'instruction `RUN` suivi d'un numéro de ligne aurait été entré.

            Entrées :
            - HL pointe vers un buffer temporaire pour y placer l'argument pour `RUN`.
            - DE pointe vers le buffer source contenant le numéro de ligne BASIC.

$1b78       Sauve HL
$1b79       5 octets à copier.
$1b7b       [cp_line_nb]
$1b7b-$1b7f Copie des 5 octets du descripteur de fichier vers le buffer pointé par HL (un buffer temporaire)
$1b81       Restaure HL.
$1b82       [k7_run]
$1b82       Pour quelle raison décrémenter A ?
$1b83       Branche sur l'instruction RUN.

$1b86       [hl_contxt]
$1b86       Restaure le pointeur vers le texte BASIC.

$1b8a       [get_bauds]
            Récupère le paramètre optionnel de vitesse sur les opérations K7, et place le drapeau correspondant dans `cascom`.
$1b8a       Replace le pointeur de texte sur le caractère précédent
$1b8b       Afin de récupérer le caractère.
$1b8c       Retourne tout de suite s'il n'y a rien.
$1b8d       %CHAR
$1b8d-$1b8f Retourne s'il n'y a pas une `(`
$1b90       Sinon, récupère le caractère suivant.
$1b91       S'il n'y a rien, c'est une erreur de syntaxe
$1b94       %CHAR
$1b94-$1b96 Saute si le paramètre est 1
$1b98       %CHAR
$1b98-$1b9a Si ce n'est pas 2, c'est un appel illégal.
$1b9d       [valid_bauds]
$1b9d       Met dans D l'argument entre parenthèses (qui est la vitesse d'enregistrement)
$1b9e-$1b9f Si la commande s'arrête là, c'est une erreur de syntaxe.
$1ba2       Vérifie que le caractère suivant est ')' ou c'est aussi une erreur de syntaxe.
            Caractère ')'
$1ba3       %DATASKIP
$1ba4       Sauve HL
$1ba5-$1ba8 Met le drapeau de vitesse de la cassette à 0 (1200 bauds)
$1baa-$1bab Test le bit de poids faible de l'argument ('1' ou '2' en ASCII, soit $31 ou $32).
$1bad       Saute s'il n'est pas nul, c'est-à-dire si l'argument était '1'.
$1baf       Sinon, passe le drapeau de vitesse à 1, pour '2400 bauds'
$1bb1       [bauds_keep]
$1bb1       Restaure HL


$1bb3       [buf_to_name]
            Amorce le remplissage du nom de fichier par le contenu pointé par HL.
$1bb3-$1bb4 Le nom de fichier est une chaîne de caractères vide.
$1bb7       Placement sur l'octet précédent du buffer.
$1bb8       Lecture du premier octet.
$1bb9       Retour si la ligne est terminée (pas de nom de fichier en paramètre)

$1bba       [name_to_ft]
            Place le nom de fichier en paramètre d'une commande dans FT.
$1bba       Lit l'expression de alphanumérique. Au retour, DE pointe vers l'adresse de la chaîne, et C contient sa longueur.
$1bbd       Sauve le pointeur de texte BASIC.
$1bbe       La longueur de la chaîne est mise dans B.
$1bbf       6 caractères maximum.
$1bc1       HL pointe vers le nom de fichier du descripteur de fichier.

$1bc4       [cpy_name_lp]
$1bc4-$1bc7 Copie le caractère pointé par DE vers le buffer pointé par HL et incrémente les deux pointeurs.
$1bc8       Décrémente le compter.
$1bc9       Si le compteur tombe à zéro, on sort de la boucle (6 caractères maximum pour le nom de fichier)
$1bcb       Boucle sur la taille de la chaîne, qui s'arrêtera si B est inférieur à 6.
$1bcd       Si on s'est arrêté avant 6 caractères, place un $00 de terminaison de chaîne.
$1bcf       [cp_name_end]
$1bcf       Restaure le pointeur vers le buffer de texte BASIC.

$1bd1       [read_ft]
            Se synchronise sur les 10 premiers octets de l'en-tête, puis charge le descripteur de fichier.

            Ce chargement se fait de manière incomplète et en décalé. Il s'agit en effet de conserver les
            informations déjà présentes dans le descripteur pour identifier le fichier.

$1bd1       En attente de 10 fois l'octet d'en-tête.

$1bd3       [rd_ft_head]
$1bd3       Lit un octet depuis la k7
$1bd6       Retourne en cas de problème ou d'interruption de commande
$1bd7-$1bd9 Boucle tant que $d3 n'est pas lu depuis la k7.
$1bdb       Boucle 10 fois
$1bdd       Charge dans HL l'adresse du premier numéro de ligne dans le descripteur de fichier.
$1be0       Lit $16 (22) octets.

$1be2       [read_ft_pl]
$1be2       Lit un octet depuis la k7.
$1be5       Retourne en cas de problème ou d'interruption de commande
$1be6-$1be7 Remplit le descripteur de fichier avec les octets lus.
$1be8       Boucle sur les 22 octets.

$1beb       [cmp_filenam]
            Compare le nom de fichier du descripteur de fichier avec les 6 premiers caractères pointés par HL.

            La comparaison s'arrête dès la fin du nom du descripteur de fichier.

            Retour:
            - Z à 1 si la le nom dans le descripteur de fichier est identique au début du nom pointé par HL.
            - Z à 0 sinon.

$1beb       BC pointe vers le nom de fichier du descripteur de fichier.
$1bee       Comparaison de 6 caractères.

$1bf0       [cmp_bytes]
$1bf0-$1bf2 Retour dès que BC pointe vers un octet nul.
$1bf3-$1bf4 Compare les deux octets pointés par BC et HL respectivement.
$1bf5-$1bf6 Avance les deux pointeurs.
$1bf7       Retour si les deux octets sont différents.
$1bf8       Décrémente le compteur de caractères.
$1bf9       Boucle 6 fois.

$1bfc       [out_k7_msg]
            Affiche le message k7 pointé par HL suivi par le nom de fichier lu depuis la k7.

            Si le bit 0 de `cascom` est à 1, n'affiche que le retour chariot, et n'affiche pas le message.

$1bfc-$1bfd Préserve DE et AF
$1bfe-$1c01 Vérifie si l'utilisateur veut supprimer l'affichage des messages k7.
$1c03       Branche si ce n'est pas le cas (bit 0 à 1)
$1c05       Affiche la chaîne pointée par HL.
$1c08       Pointe vers l'actuel nom de fichier chargé depuis la k7.
$1c0b       6 caractères maximum à afficher
$1c0d       [out_filenam]
$1c0d-$1c0f Branche si on a atteint la fin du nom, plus court que 6 caractères.
$1c11       HL pointe un caractère plus loin.
$1c12       Affichage du caractère.
$1c13       Boucle 6 fois maximum.

$1c15       [end_k7_msg]
$1c15       Affiche un retour chariot (même si les messages ne sont pas affichés)
$1c18-$1c1f Provoque un rafraîchissement de l'écran, fin que le message soit visible.
$1c20       [skip_k7_msg]
$1c20-$1c21 Restaure AF et DE

$1c23       [mk_chain_k7]
            Construit le chaînage du listing BASIC lu depuis la k7.

            Sortie :
            - HL pointe vers le premier emplacement libre après le listing BASIC.

$1c23       Charge `(txttab)`, le début du programme en BASIC, dans DE
$1c27       [next_line]
$1c27-$1c28 HL = DE
$1c29-$1c2d Retour immédiat à la fin du chaînage du programme BASIC (le pointeur vers la ligne suivante est à 0).

$1c2e       [skip_16b]
$1c2e-$1c2f Passe sur le numéro de ligne.

$1c30       [read_byte]
$1c30       Lit le premier caractère ou token de la ligne BASIC.
$1c31       Et déplace le pointeur de lecture un octet plus loin.
$1c32-$1c34 Branche si le token est le marqueur de nombre sur 16 bits, afin de passer par dessus ces deux octets.
$1c36-$1c37 Branche si le caractère ou le token n'est pas nul.
$1c39       On est arrivé à la fin de la ligne. En échangeant HL et DE, DE contient le pointeur après la fin de ligne, et HL le pointeur sur le début de la ligne.
$1c3a-$1c3c Écrit dans l'adresse de chaînage de la ligne courante l'adresse de la ligne suivante.
$1c3d       Cherche la ligne suivante.

$1c3f       [k7_advance]
$1c3f       Incrémente HL, pointeur vers le texte BASIC.
$1c40       Initialise le compteur B à 3.
$1c42       Branche sur la suite de la routine.

$1c45       [init_ft]
            Initialise le descripteur de fichier

            Les champs effacés sont :
            - numéro de version
            - numéro de ligne de départ
            - octet de protection
            - position de checksum

            Les champs initialisés sont :
            - octet de protection avec la valeur de `(allflg)`
            - adresse de départ
            - longueur du fichier

$1c45       Sauve HL
$1c46       HL pointe le numéro de version du descripteur de fichier.
$1c49       A = 0
$1c4a       Efface 9 octets.
$1c4c       [zero_ft]
$1c4c-$1c4d Met l'octet pointé à 0.
$1c4e       Fin de la boucle d'effacement
$1c50       Récupère l'octet de protection actuel.
$1c53       Et le place à sa position dans FT
$1c56       Récupère le type du fichier depuis FT
$1c59       %CHAR
$1c59-$1c5b Branche si le type n'est pas ' '
$1c5d       Traitement du type ' ' (CSAVE simple)
$1c60       Récupération dans HL de (txttab) (début du listing BASIC)
$1c63       Sauve HL contenant `(txttab)` vers DE.
$1c64       Récupération dans HL de (vartab) (début des variables, et aussi fin + 1 du listing BASIC)
$1c67       Préparation de la soustraction en effaçant la Carry
$1c68       Soustraction des deux pointeurs pour avoir la taille de la zone BASIC
$1c6a       [wrt_k7_len]
$1c6a       Écriture de la taille du fichier dans le descripteur de fichier.
$1c6d       Branche vers la récupération optionnelle du numéro de ligne.

$1c6f       [ft_type_4d]
$1c6f       %CHAR
$1c71       Branchement si le type de fichier n'est pas 'M' ($4d).
$1c73       Traitement du type $4d (CSAVEM). Récupération du pointeur de parsing.
$1c74       Vérification de la présence d'une virgule ou erreur de syntaxe
$1c75       %DATASKIP
$1c76       Évaluation du paramètre numérique (S = adresse du premier octet à stocker)
$1c79       Valeur entière dans DE
$1c7c       Placement de l'adresse de départ dans FT+16 (adresse de départ)
$1c80       Vérification de la présence d'une virgule ou erreur de syntaxe
$1c81       %DATASKIP
$1c82       Évaluation du paramètre numérique (T = longueur à stocker)
$1c85       Valeur entière dans DE
$1c88       Sauvegarde du pointeur de parsing
$1c89       Placement de la longueur dans HL
$1c8a       Et branchement sur la suite identique à CSAVE (pour l'écriture de la longueur et le paramètre optionnel I)
$1c8c       [ft_type_53]
            Traitement du type de fichier $53 (sauvegarde de l'écran)
$1c8c       %CHAR
$1c8e       Branchement si le type n'est pas 'S' ($53)
$1c90-$1c93 L'adresse de départ est celle de l'écran
$1c96       %NOT_LABEL
            HL prend la taille de l'écran.
$1c99       [wrt_k7_len2]
$1c99       Place HL dans la taille du fichier du descripteur de fichier.
$1c9c       Termine la commande d'initialisation du descripteur de fichier.

$1c9e       [ft_type_bb]
            Traitement de CSAVE*
$1c9f       Récupère le pointeur de parsing.
$1ca1       Branchement si le type n'est pas $bb (qui est le token de '*')
$1ca3       Récupération des informations de tableau
$1ca6       Sauvegarde du pointeur de parsing
$1ca7       Sauvegarde de l'adresse du tableau dans l'adresse de départ de FT
$1cab       Placement de la longueur (DE) dans HL
$1cac       Mutualisation d'écriture de longueur sans autre paramètre.

$1cae       [ft_type_58]
            Traitement de CSAVEX
$1cae       Lecture de l'expression chaîne de caractère
$1cb1       Placement de l'adresse de début de chaîne
$1cb5       Placement de la longueur de la chaîne.

$1cba       [k7_line_prm]
            Récupération du paramètre optionnel de numéro de ligne
$1cba       Récupère le pointeur vers le texte BASIC
$1cbb-$1cbc Lit le caractère pointé.
$1cbd       S'il n'y a pas de paramètre optionnel, on a terminé.
$1cbe       Sinon, il doit y avoir une virgule ou bien c'est une erreur de syntaxe.
$1cbf       %DATASKIP
$1cc0       DE pointe sur le numéro de la première ligne BASIC du descripteur de fichier.
$1cc3       Récupération des 5 prochains octets directement (il n'y a pas de traduction en entier pour ce paramètre, il est sauvé directement en ASCII)
$1cc5       [prm_i_loop]
$1cc5       Sauvegarde du pointeur de parsing
$1cc6       [ft_end]
$1cc6       Récupération du pointeur de parsing
$1cc7       Si on a terminé le parsing, on sort de la fonction
$1cc8       Si le caractère n'était pas un chiffre, c'est une erreur de syntaxe.
$1ccb       Copie du chiffre (en caractère) vers FT
$1ccc       DE pointe sur le caractère suivant dans FT
$1ccd       Lecture du prochain caractère sur la ligne à parser.
$1cce       Il reste des caractères à parser.
$1cd0       La limite de 5 chiffres à été atteinte, on sort.

$1cd1       [cload_prm_2]
            Lecture du second paramètre de `CLOAD`.

            Soit une virgule suivi d'un numéro de ligne.
            Soit un nom de variable (chaîne ou tableau).

            Sorties:
            - A = 0 s'il y a un paramètre numéro de ligne, ou pas de paramètre.
            - A = -1 s'il y a un paramètre de type alphanumérique
            - A = 1 s'il y a un paramètre de type tableau
            - Le numéro de version du descripteur du fichier est égal à A
            - DE contient l'adresse de la variable ou du tableau
            - `(contxt)` contient le pointeur vers le buffer de texte BASIC.


$1cd1-$1cd2 A et C à 0.
$1cd3-$1cd4 Lecture d'un caractère depuis le buffer de texte BASIC.
$1cd5       Fait pointer DE vers `buf`, le buffer temporaire de traitement BASIC.
$1cd8       Y place le caractère lu.
$1cd9       Branche si la chaîne est terminée (pas de paramètre supplémentaire)
$1cdb       %CHAR
$1cdb-$1cdd Branche si le caractère lu n'est pas une virgule (pour les cas où le deuxième argument est un nom de variable)
$1cdf       Lit 5 caractères maximum.

$1ce1       [prm_i_lp2]
$1ce1       Lecture d'un caractère.
$1ce2       Branche si la chaîne est terminée.
$1ce4       Branche vers une erreur de syntaxe si le caractère n'était pas numérique.
$1ce7       Écrit le chiffre vers le descripteur de fichier qui pointe vers le buffer temporaire `buf`
$1ce8       Et avance le pointeur
$1ce9       Boucle selon le compteur B, 5 chiffres maximum.

$1ceb       [prm_end]
$1ceb       Sauve HL, qui pointe sur le buffer de texte BASIC, dans `(contxt)`. Sera récupéré en fin de routine au besoin.
$1cee-$1cef Met dans la version du descripteur de fichier -1 s'il y a un paramètre alphanumérique, 1 s'il y a un paramètre tableau et 0 sinon.

$1cf3       [r_varname]
$1cf3       Sauve HL, pointeur vers le buffer de texte BASIC, sur la pile.
$1cf4       Et l'incrémente.
$1cf5       Lecture du caractère, qui est le second du paramètre.
$1cf6       %CHAR
$1cf6-$1cf8 Branche si le marqueur de variable alphanumérique est trouvé.
$1cfa-$1cfb Sinon, lit le caractère suivant.
$1cfc       %CHAR
            Et le compare avec le marqueur de variable alphanumérique.
$1cfe       [varname_end]
$1cfe       Restaure le pointeur sur le buffer de texte BASIC initial.
$1cff       Et le sauve à nouveau.
$1d00       Sauvegarde de BC.
$1d01       Branche si un marqueur de variable alphanumérique n'a pas été trouvé. Il s'agit d'un nom de tableau.
$1d03-$1d08 La commande était `CLOAD*`, il s'agit donc d'un tableau alphanumérique.
$1d0a       Il s'agit du nom d'une variable alphanumérique, elle est évaluée, ce qui provoquera le chargement de son adresse dans DE et sa longueur dans BC (avec B à 0)
$1d0d       Restauration de BC.
$1d0e       C est diminué de 1 pour le mettre à $FF.
$1d0f       [pophl_end]
$1d0f       Récupération du pointeur vers le buffer de texte BASIC.
$1d10       Termine la commande.

$1d12       [arry_name]
$1d12       Charge le nom du tableau. Le pointeur sera dans DE.
$1d15       Restauration de BC.
$1d16       Incrémente C pour le mettre à 1.
$1d17       Termine la commande.

$1d19       [load_addres]
            Place dans HL l'adresse à laquelle les données doivent être chargées depuis la K7.

            Sortie :
            - HL pointeur vers la zone de données à écrire.

$1d19       A prend le type de fichier lu depuis la k7
$1d1c       %CHAR
$1d1c-$1d1e Branche s'il est différent d'un espace
$1d23       %CHAR
$1d20-$1d25 C'est un programme en BASIC. Branche si la commande utilisée n'est pas `CLOADA`
$1d27-$1d2b `CLOADA`, le chargement se fera vers deux octets avant `(vartab)`, c'est-à-dire à la suite du programme BASIC actuellement en mémoire.

$1d2d       [txttab_hl]
$1d2d       `CLOAD`, le chargement se fera vers `(txttab)`, c'est-à-dire à la place du programme BASIC actuellement en mémoire.

$1d31       [bin_format]
            %CHAR
$1d31-$1d33 Branche si le type n'est pas `M`
$1d35       Format de 'CSAVEM`, binaire, le chargement se fera vers l'adresse dans `(high)` qui est l'emplacement décalé de l'adresse cible pour le descripteur de fichier.

$1d39       [scr_format]
            %CHAR
$1d39-$1d3b Branche si le type n'est pas `S`
$1d3d       Format de `CSAVES`, le chargement se fera vers le buffer de l'écran.

$1d41       [var_or_ary]
$1d41       Chargement d'une variable ou d'un tableau, HL pointe vers le descripteur de la variable.
$1d44-$1d46 Branche si ce n'est pas le format `CSAVE*`
$1d48-$1d4c Branche si le format dans le descripteur de fichier n'était pas 1, on charge une variable.
$1d4e       Va chercher le tableau à charger.
$1d51       Sauve BC
$1d52       [verify_mem]
$1d52       Sauvegarde HL temporairement dans `(contxt)`
$1d55       Récupération dans HL du nombre d'octets à charger depuis le descripteur de fichier lu.
$1d58       Compare le contenu de `handler` et DE, l'adresse du tableau.
$1d59       BC récupère le nombre d'octets à charger depuis la pile.
$1d5a-$1d5b Retour si Carry est à 1 ou Z est à 1
$1d5c       Restaure HL.
$1d5f       Arrête la K7
$1d62       Branche vers le message d'erreur de dépassement de capacité.

$1d65       [var_format]
$1d65-$1d69 Vérifie que le format de fichier est bien $FF
$1d6b       Lit une expression alphanumérique.
$1d6e       Sauve l'adresse du résultat.
$1d6f       Sauve DE
$1d70       BC dans DE
$1d71       Continue sur le code commun variable et tableau.

$1d73       [wrg_format]
$1d73       Arrête la K7.
$1d76       Branche sur une erreur d'opération illégale.

$1d79       [fetch_dim]
            Récupère le pointeur et la longueur vers un tableau DIM.
            Utilisé par les routines de k7.

            Entrée :
            - HL pointe vers le texte BASIC

            Sorties :
            - BC pointe sur la zone mémoire contenant le descripteur du tableau
            - HL pointe vers le texte BASIC avec le descripteur de tableau

$1d79-$1d7b Mise à 1 de `subflg` pour demander la recherche d'un tableau
$1d7e       Recherche de la variable
$1d81       "Appel illégal" si le tableau n'a pas été trouvé
$1d84       Remise à 0 de `subflg`.

$1d88       [rd_str_expr]
            Évalue une expression de type chaîne de caractères.

            Entrée :
            - HL pointe vers le texte BASIC

            Sorties :
            - DE pointe vers l'adresse du descripteur de chaîne.
            - C contient la longueur de la chaîne.
$1d88       Évaluation de l'expression
$1d8b       Sauve HL
$1d8c       DE pointe sur l'adresse de la chaîne évaluée, C contient la longueur et A le premier caractère. HL pointe sur le deuxième octet de l'adresse de la chaîne dans son descripteur.
$1d8f-$1d91 Recalage de HL pour pointer vers la taille de la chaîne dans son descripteur.
$1d92-$1d94 Taille de la chaîne dans BC.
$1d95       Restauration de HL, pointeur vers le texte BASIC.

$1d97       [sd_char_k7]
            Envoie vers le buffer d'écriture de la k7 un octet ASCII sur 7 bits.
            Utilisé par `SAVE` à travers `outdo` ainsi qu'en direct pour envoyer l'octet de terminaison.

            Entrée :
            - A contient le caractère à écrire. Seuls les 7 bits de poids faible sont pris en compte.
            - (ft_addr) contient l'adresse de destination pour le caractère.

$1d97       Met le bit de poids fort de A à 1.
$1d99       Sauve HL
$1d9a       HL pointe vers la zone à sauver déclarée dans le descripteur de fichier.
$1d9d       Place l'octet à écrire à cette adresse.
$1d9e       Pointe sur l'octet suivant
$1d9f-$1da1 Branche si l'octet était $83 (marqueur de fin de listing)
$1da3-$1da4 Sélectionne l'écran comme périphérique de sortie.
$1da7       Vérifie la mémoire restante entre HL et la pile.
$1daa-$1dac Sélectionne la k7 comme périphérique de sortie.
$1daf       Sauve DE
$1db0       Récupère l'adresse de la prochaine ligne à exécuter dans DE.
            Cette variable est positionnée lorsque le pointeur de texte BASIC est positionné au début d'une ligne.
            Elle contient alors un pointeur vers la ligne suivante.
$1db4-$1db6 Branche si la ligne actuellement exécutée en BASIC est 0. Ce qui signifie que l'on n'est pas au début d'une ligne.
            Dans le cas contraire, le code qui suit va décaler le contenu du listing pour s'assurer d'avoir de la place.
            C'est pour cela que le listing est détruit lors de la sauvegarde.
$1db8       Efface les drapeaux pour la soustraction qui suit.
$1db9       HL contient la différence de mémoire entre les prochaines données de ligne à sauver et le buffer de travail pour la sauvegarde.
$1dbb       Sauve cette valeur sur la pile.
$1dbc-$1dbf Réinitialise `(retadr)` avec la valeur de `(txttab)`, début du listing.
$1dc2       Place HL (début de listing) dans DE, HL pointe vers les prochaines données à sauver.
$1dc3       Récupère la différence calculée dans BC.
$1dc4       Déplace les données restantes du listing vers `(txttab)`.
$1dc6       Sauve DE, qui pointe après les données qui ont été déplacées.
$1dc7       Différence entre la fin du buffer de travail et la fin des données copiées.
$1dc9       Sauve cette taille dans DE.
$1dca-$1dcf Déplace l'adresse de début des variables de cette taille vers le début de la mémoire.
            C'est le nouvel emplacement pour `(vartab)`, puisqu'un morceau du listing a été effacé.
$1dd2       Récupère dans HL l'adresse de destination après la copie.
$1dd3       [sd_direct]
$1dd3       Restaure le DE initial.
$1dd4       [sd_char_end]
$1dd4       Sauve HL dans `(ft_addr)`, pointeur vers la prochaine position du buffer de traitement.
$1dd7       Se replace sur le dernier caractère ayant été traité.
$1dd8-$1ddd Met à jour la somme de contrôle par XOR successifs des octets écrits.
$1dde       Restaure HL.


$1de0       [save_asc_k7]
            Écrit le buffer initialement rempli par `SAVE` sur la k7.

$1de0       Récupère le pointeur sur la fin de la zone de travail.
$1de3       Y place A, la somme de contrôle.
$1de4       Avance HL, pointeur vers le buffer de travail contenant les données à écrire.
$1de5       Met (vartab) dans DE
$1de9       Met A à 0, mais surtout passe le Carry à 0.
$1dea       Différence entre HL, pointeur vers la fin du buffer de travail, et DE, le début.
$1dec       Ce qui donne la taille du buffer, que l'on pousse sur la pile.
$1ded       A = $ff pour le paramètre de l'appel suivant.
$1dee       Démarre la k7 et envoie l'entête de synchronisation.
$1df1       Récupère la taille du buffer.
$1df2       Retour en cas d'erreur.
$1df3       [write_byte]
$1df3       Lecture d'un caractère du buffer dans A.
$1df4       Pointe dans le buffer un octet plus loin.
$1df5       Décrémente la taille du buffer restante.
$1df6       Écrit l'octet sur la k7
$1df9       Retour en cas d'erreur.
$1dfa-$1dfc Boucle s'il reste des octets à envoyer.
$1dfe       A = $FF
$1dff       Envoie le signal de synchronisation de fin.

$1e02       [load_ascii]
            Charge depuis la k7 un programme en ASCII

$1e02       HL pointe sur le début de la zone des variables.
$1e05-$1e08 Puis 20 caractères plus loin.
$1e09       Enregistre le résultat dans `high`
$1e0c-$1e0d HL dans DE
$1e0e       Pointe DE un octet plus loin. DE pointe sur le début de ligne. HL va avancer pour remplir le buffer.
$1e0f       BC à 0 (B était déjà à 0)
$1e11       [read_part]
$1e11       Dernier octet lu sur 7 bits. Lors de l'écriture, le format ASCII met le bit 7 à 1 sur tous les octets.
$1e13       Placé dans la zone pointée par HL
$1e14-$1e16 Branche si la valeur est 3, marqueur de fin du listing ($83 sur la k7)
$1e18-$1e1d Change la couleur de la marge.
$1e20       Envoi le changement de couleur au VDP. La commande actuelle est $82, placée par `margin_col`.
$1e22-$1e25 Branche s'il n'y a plus de mémoire (Carry est à 0)
$1e27       Sinon pointe un octet plus loin
$1e28       Lit un octet
$1e2b       Retour si interruption ou erreur.
$1e2c       Sauvegarde AF, A contient l'octet lu.
$1e2d-$1e2f Branche si ce n'était pas $8d, afin de continuer à acquérir les caractères et calculer la somme de contrôle.
$1e31-$1e32 Sinon, une ligne entière vient d'être lue.
            Sauvegarde HL (pointeur du buffer) et DE (début de la ligne) sur la pile
$1e33       Ramène DE, qui pointe vers le début de ligne, dans HL.
$1e34       Décodage d'un numéro de ligne.
$1e37-$1e38 Le résultat, dans DE, est mis dans BC
$1e39       Rétablit la valeur lue de A afin de calculer la somme de contrôle.
$1e3b       Restaure DE, qui pointe un sur le début de la ligne qui vient d'être acquise.
$1e3c       [xor_sumchk]
$1e3c-$1e40 Ou exclusif de A avec le caractère pointé dans le buffer pour calculer le sumcheck.
$1e41       Restaure HL
$1e42       Restaure AF
$1e43       Boucle vers la prochaine partie à lire.
$1e45       [vrfy_lines]
$1e45-$1e47 Branche si BC, le numéro de la ligne courante, est 0
$1e49       Préserve HL, qui pointe sur la fin de la ligne acquise.
$1e4a       A à 0
$1e4b       Charge le dernier numéro de ligne de l'intervalle.
$1e4e-$1e50 Branche si la ligne est supérieure à la dernière ligne.
$1e52       Charge le premier numéro de ligne de l'intervalle.
$1e55-$1e59 Branche si le numéro de ligne courant est supérieur au premier numéro de l'intervalle.
$1e5b       [ignore_line]
$1e5b       Restaure le pointeur vers la fin de la ligne acquise.
$1e5c       [commit_line]
$1e5c-$1e5d Suivant le chemin d'arrivée, la ligne précédente est avancée au pointeur du buffer (la ligne est donc gardée) ou bien le pointeur actuel est remis en début de ligne (la ligne est donc ignorée, car elle sera écrasée).
$1e5e       BC, le numéro de ligne courant, à 0
$1e61       [pre_sumchk]
$1e61       Restaure AF
$1e62       [end_verify]
$1e62       Préserve AF
$1e63       Préserve HL

$1e66       [keep_line]
$1e66       Restaure HL
$1e67       Échange DE et HL (ligne précédente et pointeur actuel)

$1e6a       [one_more]
$1e6a       Lecture d'un octet
$1e6d       Branche si ni erreur ni interruption.
$1e6f       Interruption ou erreur, retour.

$1e70       [check_sum]
$1e70       Lecture d'un octet
$1e73       Retour si interruption ou erreur
$1e74       Fin des données. Préserve HL, qui pointe vers le buffer d'acquisition.
$1e75-$1e78 Soustrait le caractère lu de celui dans `low` qui contient la somme de contrôle.
$1e79       Signal une erreur de somme de contrôle si le résultat n'est pas 0.
$1e7c       Restaure HL, pointeur vers le buffer d'acquisition.
$1e7d-$1e80 Branche s'il n'y a plus de mémoire
$1e82       A à 0 et donc Z est à 1.

$1e84       [chk_no_mem]
$1e84       Échange DE et HL
$1e85-$1e87 Place $03 dans le caractère pointé par HL, le buffer d’acquisition, afin de forcer un marqueur de fin de données en cas de manque de mémoire.

$1e89       [fetch_next]
            Récupère un octet lu avec `LOAD` depuis l'adresse stockée en `(high)`.
            Provoque le basculement vers le périphérique clavier à la fin du buffer.

            Entrée :
            - L'adresse à lire est dans `(high)`

            Sortie :
            - A contient l'octet lu si ce n'était pas le marqueur de fin. Drapeau Z à 0.
            - A contient 0 si l'octet lu était le marqueur de fin. Drapeau Z à 1.

$1e89-$1e8f A contient le prochain octet lu et l'adresse dans `(high)` est incrémentée.
$1e93-$1e95 Retour si la valeur lue n'est pas le marqueur de fin de listing.
$1e96-$1e97 Replace le périphérique d'entrée sur le clavier
$1e9a       Réinitialise le moniteur après avoir affiché "Ok!"

$1e9d       [k7_1200]
$1e9d       Paramètre K7 pour 1200 bauds

$1ea2       [k7_2400]
$1ea2       Paramètre K7 pour 2400 bauds

$1ea7       [k7_set_prms]
            Remet le drapeau 'abort' à 0.
            Si le drapeau de suppression L/H/H n'est pas mis, alors recopie les informations de cycles de la K7 vers les paramètres actuels.
$1ea7-$1eaa Met le drapeau 'abort' de `cascom` à 0.
$1eac-$1ead Test le drapeau de suppression des informations de vitesse K7
$1eaf       Et sort de la routine s'il est mis
$1eb0-$1eb6 Prépare la copie des 5 octets de paramétrage de la K7
$1eb9-$1ebb Saute si le drapeau de vitesse de K7 est à 1200 bauds
$1ebd       Sinon, pointe vers les 5 octets suivants pour la vitesse à 2400 bauds.
$1ebe       [k7_params]
$1ebe       Copie les paramètres de vitesse de la K7

$1ec1       [k7_wr_data]
            Calcule le sumcheck des données puis Synchronise la K7, y écrit l'entête (D3) puis le contenu de FT.

$1ec1       Monte les timings en RAM
$1ec4       DE = adresse de démarrage des données
$1ec8       BC = taille des données à écrire
$1ecc-$1ece HL = 0

$1ecf       [k7_sum_lp]
$1ecf       Récupération de l'octet de donnée pointé par DE.
$1ed0-$1ed1 Ajoute la valeur de A à L (L += A)
$1ed2       A = 0, sans toucher aux drapeaux
$1ed4-$1ed5 Ajout de la retenue éventuelle à H. Ce qui donne au final : HL += A
$1ed6       Octet suivant
$1ed7       Et taille diminuée de 1
$1ed8-$1eda Boucle tant que BC est différent de 0, afin de calculer le sumcheck sur l'intégralité des données.
$1edc       Écriture de la somme de contrôle (`sumcheck`) dans le descripteur de fichier.
$1edf       A = $ff
$1ee0       Synchronisation de la K7
$1ee3       Retour en cas d'erreur ou d'interruption de commande.
$1ee4       Compteur à 10.
$1ee6       [k7_head_lp]
$1ee6-$1ee8 Écrit $d3 sur la k7.
$1eeb       Retour en cas d'erreur ou d'interruption de commande.
$1eec       Boucle 10 fois.
$1eee       Compteur à 22 taille du descripteur de fichier.
$1ef0       HL pointe vers le descripteur de fichier.

$1ef3       [k7_ft_lp]
$1ef3       Récupère l'octet courant du descripteur de fichier.
$1ef4       Pointe sur l'octet suivant.
$1ef5       Écrit l'octet sur la k7.
$1ef8       Retour en cas d'erreur ou d'interruption de commande.
$1ef9       Boucle 22 fois.


$1efc       [k7_write_pl]
            Synchronise la K7, y écrit l'entête (D6) puis le contenu des données.
$1efc       A = 0
$1efd       Synchronisation de la k7.
$1f00       Retour en cas d'erreur ou d'interruption de commande.
$1f01       Compteur à 10.

$1f03       [k7_split_lp]
$1f03-$1f05 Écrit $d6 sur la K7.
$1f08       Retour en cas d'erreur ou d'interruption de commande.
$1f09       Boucle 10 fois.
$1f0b       DE = Adresse de démarrage des données.
$1f0f       BC = Taille des données à écrire.
$1f13       [payload_wrt]
$1f13       Récupération de l'octet de données à écrire.
$1f14       Pointe vers l'octet suivant
$1f15       Décrémente la longueur des données restantes.
$1f16       Écrit l'octet sur la k7.
$1f19       Retour en cas d'erreur ou d'interruption de commande.
$1f1a-$1f1c Continue tant que la taille (BC) restante est non nulle.
$1f1e       Compteur à 10.
$1f20       [zero_wrt]
$1f20-$1f21 Écrit 0 sur la k7.
$1f24       Retour en cas d'erreur ou d'interruption de commande.
$1f25       Boucle 10 fois.

$1f28       [read_contnt]
            Charge les données du fichier sur la K7 vers la zone mémoire pointée par HL.

            Entrée :
            - HL contient l'adresse mémoire où charger les données chargées.
            - A est à 0 si on effectue un chargement, et à $FF si on effectue une vérification de fichier.

$1f28       Sauve HL, l'adresse de destination.
$1f29       Sauve AF, le paramètre chargement/vérification.
$1f2a       Calibre la lecture.
$1f2d       Retour (avec nettoyage de la pile) en cas d'erreur ou d'interruption de commande.
$1f30       Charge l'indicateur de protection dans le descripteur de fichier lu (qui est toujours décalé)
$1f33-$1f37 L'octet de protection du jeu contrôle la possibilité pour le moniteur BASIC de s'exécuter.
$1f38-$1f39 Récupère le paramètre de chargement/vérification  et l'adresse de destination.
$1f3a       Copie A, le masque de comparaison ou lecture, dans D
$1f3b       [read_ct]
$1f3b       Initialise la lecture de 10 octets d'entête.
$1f3d       [rd_ct_head]
$1f3d       Lecture d'un octet
$1f40       Retour en cas d'erreur ou d'interruption de commande.
$1f41-$1f43 Boucle tant que l'octet lu n'est pas `$d6`
$1f45       Lecture de 10 octets `$d6`
$1f47       Récupération du nombre d'octets à lire depuis la k7 (valeur du descripteur de fichier chargé)
$1f4b       [read_ct_pl]
$1f4b       Lecture d'un octet depuis la k7.
$1f4e       Retour en cas d'erreur ou d'interruption de commande.
$1f4f       Place l'octet lu dans E
$1f50       Sauve HL
$1f51-$1f5b Ajoute la valeur de l'octet lu au calcul du `sumcheck`.
$1f5e       Restaure HL, qui pointe vers la mémoire à remplir
$1f5f       Récupère l'octet qui vient d'être lu
$1f60-$1f62 En faisant la soustraction de l'octet lu et de l'octet présent en mémoire,
            masque par le sélecteur de vérification ou chargement, on branche en cas de chargement ou, en cas de vérification, si l'octet
            chargé et l'octet en mémoire sont identiques.
$1f64-$1f69 Sinon, il y a une erreur de vérification, qui est indiqué dans la variable `cascom`.
$1f6c       L'octet ne sera pas écrit en mémoire, et on continue
$1f6d       [byte_ok]
$1f6d       L'octet lu est écrit en mémoire.
$1f6e-$1f76 Changement direct de la couleur de marge.
$1f7b       %CHAR
$1f78-$1f7d Branche si le type de fichier lu n'est pas ' '.
$1f7f       Vérifie qu'il reste de la mémoire.
$1f82       Ou retourne immédiatement dans le cas contraire.

$1f83       [read_ct_cnt]
$1f83       Pointe vers l'octet suivant.
$1f84       Décrémente le nombre d'octets à charger.
$1f85-$1f87 Boucle s'il reste des octets à charger.
$1f89       Récupère dans C le sélecteur de chargement ou vérification.
            $ff pour une vérification, $00 pour un chargement.
$1f8a       Sauve HL
$1f8b       Charge la somme de contrôle calculée dans HL.
$1f8e       Charge dans DE la somme de contrôle lue depuis la k7.
$1f92       Compare les deux `sumcheck`.
$1f93       Restaure HL

$1f94       [sumchk_err]
$1f94       Retour si Z est levé.
$1f95-$1f98 Sinon, signal l'erreur de somme de contrôle dans la variable `cascom`
$1f9a       Et passe A à 0.

$1f9c       [check_mem_2]
            Vérifie qu'il reste assez de mémoire.

            Sortie :
            - A à $ff s'il n'y a plus assez de mémoire.
            - Carry est à 1 s'il reste de la place

$1f9c       Préserve HL
$1f9d-$1fa4 HL = $ffa0 - HL (afin de garder une pile minimale de $60). C'est un premier test avec la mémoire maximale adressable, qu'elle soit présente ou non.
$1fa5       Branche s'il y a eu retenue, et donc que HL est supérieur à la limite.
$1fa7       On obtient l'adresse de la pile plus la différence entre HL et le haut de la mémoire, afin de placer Carry.
$1fa8       Restaure HL
$1fa9       Retour si la pile augmentée de la place restante dépasse. Il y a encore de la place.
$1faa       Préserve HL (pour être cohérent avant la fin de la routine)
$1fab       [out_of_mem2]
$1fab       Restaure HL
$1fac-$1fad Valeur de retour de A à $ff

$1faf       [k7write_reg]
            Appel l'écriture sur la K7 en préservant les registres.
$1faf-$1fb1 Sauve les registres sur la pile
$1fb2       Appel à l'écriture
$1fb6       [pop_dehlret]
$1fb5-$1fb7 Restauration des registres.

$1fb9       [k7_read_reg]
            Appel la lecture de la K7 en préservant les registres.

$1fb9-$1fbb Sauve les registres sur la pile
$1fbc       Appel à la lecture
$1fbf-$1fc1 Restauration des registres.

$1fc3       [end_k7_marg]
            Arrête la lecture de la k7, y compris le moteur, et restaure la couleur de la marge d'affichage.

$1fc3       Arrête la lecture de la k7
$1fc6-$1fc9 Restaure `cursor`

$1fcd       [margin_off]
$1fcd-$1fd0 Sauvegarde la valeur de `cursor` dans une variable temporaire inutilisé de la multiplication.
$1fd3       Met le bit 6 de `cursor` à 0. Coupe l'affichage du curseur.
$1fd7-$1fdc Force un rafraîchissement du VDP.

$1fde       [margin_col]
            Modifie la couleur de la marge de l'écran.

            Commande directe au VDP.

$1fde-$1fe4 VDP - $28/$82, MAT = R1
$1fe6-$1ff0 VDP - $29/..., R1 = `(cursor)` avec la couleur de la marge remplacée par la couleur dans le registre E.
            Comme `(cursor)` représente `MAT` côté RAM, c'est un changement direct et temporaire sur le VDP.

$1ff3       [stka_joy1]
            Partie étendue par rapport à la ROM 1.0 pour prendre en compte deux boutons.
$1ff3       Vérification de l'appui sur le bouton action du joystick 0
$1ff5       Complément à 1.
$1ff6       Masque sur le bits 4 et 5.
$1ff8-$1ffb Décalage pour amener le résultat sur les bits 0 et 1
$1ffc       Résultat aussi dans B.

$1ffe       Padding de fin de section. Indiqués dans le Technical Bulletin comme deux octets libres.

$2000       [instr_table]
            $SECTION(bintrp)
            == DEBUT DE SECTION BINTRP (BASIC INTERPRETER) ==

            Le dernier pointeur d'instruction, sur `NEW`, est modifié entre la ROM 1.0 et la ROM 1.1

$2064       [funct_table]
$209d       [prekeywords]
$209e       [keywords]
$21fd       [keywstop]
$21fe       [prio_table]
$2213       [null_str]
$2214       [ok_str]
$2219       [back_stack]
            Appelé par `NEXT` et `RETURN`.

            Appelé par `RETURN`, dépile tous les blocs `FOR` jusqu'à trouver un bloc différent (probablement `GOSUB`).

            Retour :
            - HL pointe un octet après le début du bloc non `FOR` trouvé.
            - A contient le premier octet du bloc non `FOR` trouvé.

$2219       %NOT_LABEL
$2219-$221c HL = SP + 4, pour passer au-dessus des deux adresses de retour empilées (celle qui correspond au `call` ici, et celle de l'instruction)
$221d       [for_lookup]
            Cherche le bon bloc `FOR` dans la pile.

            Dans cette version du BASIC, il faut absolument spécifier une adresse.

            Entrée :
            - DE contient le pointeur vers la variable d'index que l'on cherche.
            - HL pointe dans la pile au niveau d'un bloc `FOR` ou `GOSUB` potentiel.

            Sortie :
            - HL pointe vers le bloc `FOR` correspondant, dans la pile au niveau du signe de `STEP`.
            - Drapeau Z à 1 si le bloc a été trouvé, 0 sinon.
            - BC est à $000d si le bloc a été trouvé.

$221d       Récupère le marqueur du bloc pointé par HL
$221e       Et pointe un octet plus loin.
$221f-$2221 Retourne si le marqueur n'est pas celui de l'instruction `FOR`.
$2222-$2225 BC = adresse de la variable associée pour `FOR`.
$2226       Sauve HL, pointeur vers le bloc `FOR` en cours d'analyse.
$2227-$2228 HL prend l'adresse du compteur pour `FOR`.
$2229       Compare HL avec l'index paramètre dans DE.
$222a       Prépare le déplacement du pointeur dans la pile en cas d'échec de comparaison.
$222d       Récupère le pointeur vers le bloc `FOR` en cours d'analyse, qui pointe sur le signe du `STEP`.
$222e       Retour si l'adresse de l'index recherché correspond.
$222f       Sinon, déplacement du pointeur d'analyse plus loin dans la pile.
            Les débuts de blocs sont séparés de 16 octets, desquels on retranche les 3 octets déjà traités, reste 13.
$2230       Boucle sur la recherche.

$2232       [str_err_dat]
            Copie le numéro de ligne trouvée dans `(datlin)` vers `(curlin)` puis affiche une erreur de syntaxe.

$2238       [stx_err_prt]
            Affiche une erreur "Erreur de syntaxe".

$223b       [divbyzero]
            Affiche une erreur "Division par Zéro".

$223e       [missfor]
            Affiche une erreur "NEXT sans FOR"

$2241       [redim]
            Affiche une erreur "Tableau redimensionné"

$2244       [undeffn]
            Affiche une erreur "Fonction utilisateur non définie"

$2247       [overflow]
            Affiche une erreur "Dépassement de capacité"

$224a       [missing_op]
            Affiche une erreur "Opérande manquante"

$224d       [wrong_op]
            Affiche une erreur "Opérande mal adaptée"

$2250       [no_device]
            %CODE
            Affiche une erreur "Device not supported"
            Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.

$2252       [error_out]
            Affiche un message d'erreur BASIC

            L'erreur est cherchée dans la table des messages correspondant à la langue.
            L'erreur n'est pas récupérable, elle enchaîne sur l'invite de commande BASIC.

            Entrée :
            - E contient le numéro de l'erreur
$2252       Réinitialisation.
$2255       Curseur à la ligne.
$2258       Pointe sur la table des erreurs en français.
$225b-$225f Branche si le système est en français.
$2261       Sinon, pointe vers la table des erreurs en anglais.
$2264       [err_msg_fr]
$2264-$2266 Ajoute 2 à l'erreur et prend le multiple de 2 inférieur
$2268-$226b Branche si E est inférieur à $2b
$226d       Sinon fixe l'erreur à $2a (autrement dit, E est maximum $2a)
$226f       [err_loop]
$226f       Prend l'octet pointé par HL.
$2270       Pointe un octet plus loin.
$2271-$2272 Boucle si l'octet n'est pas à 0.
$2274-$2275 E est décrémenté de 2.
$2276       Boucle tant que E n'est pas tombé à 0.

$2278       [disp_break]
            %MS_BASIC(ERRIN)
            Lorsqu'on arrive directement ici, c'est pour afficher un arrêt d'exécution en ligne (curlin)

$2278       Affiche le message d'erreur pointé par HL
$227b       Charge dans HL le numéro de ligne courante.
$227e-$2282 Si le numéro de ligne est 65534, cela provoque un reboot.
$2285-$2288 Branche si le numéro de ligne n'était pas $ffff
$228b       Évite le `pop bc` pour aller directement sur la boucle du moniteur BASIC.

$228c       [nok_loop]
            %MS_BASIC(POPNOK)
$228c       Enlève l'adresse présent dans la pile avant de continuer vers la boucle du moniteur BASIC.

$228d       [ok_loop]
            %MS_BASIC(PRNTOK)
            Boucle "Ok!" puis entrée dans le moniteur BASIC.

$228d       Réinitialise l'imprimante.
$2290       Met le curseur en début de ligne.
$2293-$2296 Affiche "Ok!"

$2299       [monitorloop]
            %MS_BASIC(GETCMD)

$2299-$229c Met la ligne courante du BASIC à -1 ($ffff), c'est-à-dire, pas de ligne courante
$229f-$22a3 Branche si `(autflg)` est à 0, `AUTO` n'est pas actif.
$22a5       Ligne courante du mode AUTO dans HL
$22a8       Patch de `AUTO`par rapport à la ROM 1.0, branche plus loin.
            Le patch consiste en l'affichage d'un signe montrant qu'une ligne est déjà existante.

$22ab       [out_space]
            Suivant si la ligne a déjà du contenu ou pas, le mode de numérotation automatique
            du mode `AUTO` arrivera sur `out_space` ou `out_loop`, puis continuera sur la boucle du moniteur.

$22ab       Affiche le caractère espace puis continue dans la boucle BASIC.

$22ad       [out_loop]
$22ad       Affiche le caractère qui est dans A puis continue dans la boucle BASIC. Le caractère est soit $20 soit $a0.

$22ae       [main_loop]
            Boucle de traitement du BASIC
$22ae       Acquisition d'une ligne de commande BASIC.
$22b1       Lorsque l'acquisition sort avec Carry à 1, une annulation a été demandée. On boucle alors sur l'acquisition d'une nouvelle ligne.

$22b3       Lorsqu'on arrive ici, la touche Entrée a été appuyée, la ligne est donc validée.
            HL pointe sur l'adresse précédente le buffer qui a été rempli (`buf`) par l’acquisition des touches ou par `LOAD`, et qui se termine par un $00.
$22b4-$22b5 Afin de tester si A est égal à zéro sans toucher au Carry, utilise une paire `INC`/`DEC` qui touche à Z mais pas à Carry.
$22b6       Le premier caractère entrée était $00, ce qui signifie que la ligne est vide, on boucle sur la moniteur.
$22b8       Sauve le drapeau Carry.
$22b9-$22bd Si `(allflg)` est différent de 0, la machine reboot. C'est le cas avec les programmes "protégés", dont l'interruption d'exécution provoque le reset de la machine.
$22c0       Tentative de lecture de numéro de ligne depuis le buffer pointé par HL
$22c3       DE, aui contient soit un numéro de ligne, soit 0, est sauvé sur la pile.
$22c4       Appelle la tokenisation de la ligne.
$22c7       A = 0, donc B = 0.
$22c8       Récupération du numéro de ligne dans DE
$22c9       Récupération des drapeaux. Le Carry est celui de `chget` et donc est à 1 si la ligne commence par un nombre.
$22ca       Branche si la ligne ne commençait pas par un nombre, c'est-à-dire pas par un numéro de ligne.
$22cd       Sauve le numéro de ligne.
$22ce       Sauve la taille du buffer résultat tokenisé.
$22cf       Sauve l'adresse du buffer résultat (HL pointe un octet avant le premier octet du buffer).
$22d0-$22d3 Augmente le numéro de ligne gérée par la commande `AUTO`. HL contient le numéro de ligne.
$22d4       Branche sur le code patché pour la ROM 1.1 qui introduit la vérification du numéro de ligne maximum.

$22d7       [line_record]
$22d7       Récupération de l'adresse du buffer résultat.
$22d8       Lecture du prochain caractère du buffer résultat.
$22d9-$22da Préparation et sauvegarde du test de caractère nul.
$22db       Recherche du numéro de ligne (depuis DE)
$22de       Branche si le numéro de ligne a été trouvé.
$22e0-$22e1 Sinon, récupère le résultat du test de caractère nul précédent ainsi que le caractère lu, en gardant la valeur sur la pile.
$22e2       Retourne au moniteur si le buffer était vide.
$22e5       Passe le Carry à 0, pour indiquer que la ligne n'a pas été trouvée.

$22e6       [prev_found]
$22e6       BC contient l'adresse de la ligne trouvée si elle l'a été, ou de la ligne suivante sinon.
            Cette adresse est sauvée dans la pile.
$22e7       Branche si le numéro de ligne n'a pas été trouvé.
$22e9       DE prend l'adresse suivante de la ligne trouvée.
$22ea       HL pointe vers la zone des variables.

$22ed       [erase_line]
$22ed-$22f0 Copie un octet de la ligne suivante vers la ligne cherchée
$22f1-$22f2 Boucle jusqu'à ce que DE atteigne HL. Autrement dit, la ligne courante est effacée par recopie de tout ce qui la suit à partir de son emplacement.
            Au passage, les pointeurs de chaînages à partir de cette ligne deviennent invalides.
$22f4-$22f6 Ajustement de la nouvelle valeur de `(vartab)` comme étant la dernière adresse recopiée dans le bloc précédent.

$22f9       [prev_nfound]
$22f9       Récupération dans DE de l'adresse initiale de la ligne trouvée (entre temps effacée) ou de la suivante si elle n'avait pas été trouvée.
$22fa       Récupération du résultat du test du token sauvé en $22e1 (fait en $22d9)
$22fb       Branche si la ligne est vide après le numéro de ligne.
$22fd       HL pointe sur l'adresse des variables
$2300       Récupération dans HL de la taille de la tokenisation
$2301       Récupération dans BC de l'adresse des variables `(vartab)`
$2302       HL contient la nouvelle valeur pour `(vartab)`.
$2303       Sauve cette valeur.
$2304       Déplacement du bloc de texte vers le haut de la mémoire pour faire la place nécessaire à la ligne qui arrive.
            La routine vérifie aussi qu'il y a assez de place en mémoire pour ça et génère une erreur BASIC dans le cas contraire.
$2307-$2308 Récupération et mise à jour de `(vartab)`. Fait uniquement si le déplacement mémoire a réussi.
$230b       Récupération dans HL de l'adresse de la ligne
$230c       Mise en place d'une valeur dans la première partie de l'adresse de chaînage.
            Nécessaire pour éviter que la reconstruction du chaînage ne confonde ce pointeur avec la fin du listing.
$230d       DE récupère le numéro de la nouvelle ligne.
$230e-$230f Déplace le pointeur vers l'emplacement du numéro de ligne.
$2310-$2313 Placement du numéro de ligne. HL pointe sur le début du contenu de la ligne (qui n'est pas encore là).
$2314       Sauvegarde du pointeur sur la ligne dans DE.
$2315       HL pointe sur le buffer de résultat de tokenisation.

$2318       [cpy_line]
$2318       Récupère l'octet source dans A.
$2319       Copie un octet de (HL) vers (DE), incrémente les deux et décrémente BC (qui n'est pas utilisé)
$231b-$231d Branche pour le cas normal de copie de caractère.
$231f-$2321 Copie des deux octets composant les entiers 16 bits décodés.
$2323       Boucle sur la copie du contenu de la nouvelle ligne.

$2325       [cpy_not_num]
$2325-$2326 Continue la copie tant que le caractère n'est pas nul. En sortie de boucle, la ligne a été insérée dans la partie texte.

$2328       [line_empty]
            Arrive ici si la ligne était vide (et donc a été effacée) ou a été transférée au bon endroit.
$2328       Réinitialise les pointeurs des zones mémoires du BASIC.
$232b       HL pointe sur (txttab)
$232c       DE pointe sur (txttab)
$232d       [make_chain]
$232d-$232e HL et DE pointent au même endroit, le début des données d'une ligne.
$232f-$2332 Si le pointeur vers la ligne suivante est nul, le chaînage est terminé.
            C'est la raison pour laquelle une valeur non nulle a été temporairement donnée au premier octet du pointeur.
$2335       HL pointe sur le numéro de ligne

$2336       [sk_2_bytes]
$2336-$2337 Avance de 2 octets.
            Soit pour le numéro de ligne et se positionner sur le premier octet du contenu de la ligne.
            Soit ensuite pour les nombre entiers sur 16 bits pré-encodés.

$2338       [adv_1byte]
$2338-$2339 Lecture d'un octet des données de la ligne.
$233a-$233c Si c'est le marqueur de nombre entier sur 16 bits, boucle pour passer avant de deux octets supplémentaires.
$233e-$233f Si l'octet n'est pas n'est pas nul, boucle pour avancer d'un octet.
$2341       Sinon, c'est la fin de la ligne. On ramène dans HL le pointeur de la ligne précédente.
$2342-$2344 Le pointeur vers la ligne suivante, à présent dans DE, est placé dans le pointeur de chaînage de la ligne précédente (HL).
$2345       Poursuite du chaînage.

$2347       [line_search]
            %MS_BASIC(SRCHLN)
            Cherche une ligne BASIC désignée par DE.

            Entrée :
            - DE contient le numéro de la ligne BASIC à chercher.

            Sorties :
            - `(prelin)` contient le pointeur vers la ligne précédente à celle recherchée ou 0 s'il n'existe pas de ligne précédente.
            - Carry à 1 si la ligne a été trouvée, 0 dans le cas contraire.
            - Z à 0 si la fin du listing a été atteinte sans trouver le numéro de ligne cherché.
            - BC pointe vers les données de la ligne cherchée. Sur les données de la ligne qui a dépassé sinon.
            - HL pointe vers les données de la ligne suivante si la ligne est trouvée. Contient le numéro de ligne qui a dépassé sinon.
            - DE contient toujours le numéro de la ligne BASIC à chercher.
            - Si la fin du listing a été atteinte, alors BC et HL pointent sur le pointeur final.

            En sortie, si Carry est levé, alors HL contient le pointeur vers la ligne de BASIC trouvée.
            Si Carry est reset, alors la ligne n'a pas été trouvée. BC contient le pointeur vers la ligne de numéro inférieur à celui cherché. HL contient la ligne suivante à celle pointée par BC.
            (prelin) contient toujours le pointeur vers la ligne cherchée précédemment.

$2347       Initialise BC à 0.
$234a       HL pointe vers la première adresse du listing BASIC.

$234d       [search_lp]
$234d       Met à jour la  dernière ligne trouvée.
$2351-$2352 BC = HL, pointeur vers un début de données d'une ligne.
$2353-$2357 Retour immédiat si le pointeur de chaînage est nul. On est arrivé en fin de listing.
            HL pointe toujours vers le début des données d'une ligne.
$2358-$2359 HL pointe à présent sur le numéro de ligne BASIC.
$235a-$235d Lecture du numéro de ligne dans HL.
$235e       Comparaison de HL (numéro de ligne pointée) et DE (numéro de ligne recherchée)
$235f-$2360 HL pointe à nouveau en début de données de la ligne.
$2361-$2364 Lecture dans HL du pointeur de chaînage. HL pointe donc vers les données de la ligne suivante.
$2365       Inverse la retenue. Si Z est à 1, alors C était à 0, il est donc passé à 1, indiquant que la ligne a été trouvée.
$2366       Retour immédiat si la ligne considérée était celle cherchée.
$2367       Inverse la retenue et la remet donc à l'état du test HL/DE précédent.
$2368       Retour immédiat si HL > DE dans le test de ligne. On a dépassé le numéro de la ligne cherchée, elle ne sera donc pas trouvée.
$2369       Boucle pour étudier la ligne suivante.

$236b       [tokenize]
            %MS_BASIC(CRUNCH)
            Effectue la tokenisation du buffer pointé par HL.

            Le résultat est construit dans la zone de travail `buf`.

            Entrée :
            - HL pointe vers le contenu à traiter

            Sortie :
            - HL pointe un octet avec le buffer résultat
            - DE pointe à la fin du buffer résultat
            - C contient la taille du buffer résultat
            - A est égal à 0

$236b-$236c Mise à 0 de `(dores)` pour signaler la tokenisation. À 1, le drapeau indique un mode « direct » (ou littéral).
$236f       Taille initial du buffer de sortie. Commence à 5 pour prévoir les 2 octets de numéro de ligne, 2 octets de chaînage, et le 0 final.
$2371       DE pointe sur le buffer de tokenisation
$2374       [analyze]
$2374       Récupération dans A du caractère à traiter
$2375       %CHAR
$2375-$2377 Branche si c'est un espace
$237a       Copie du caractère à traiter dans B.
$237b       %CHAR
$237b-$237d Branche si ce sont des guillemets.
$2380-$2381 Branche si c'est le caractère nul.
$2384-$2387 Préparation du test de drapeau de tokenisation
$2388       A est à nouveau le caractère à l'étude
$2389       Branche si on se trouve en mode littéral (non tokenisé)
$238c       %CHAR
$238c-$2390 Branche si le caractère est '?', avec A contenant la valeur du token pour `PRINT`.
$2393       A est à nouveau le caractère à l'étude
$2394-$2398 Branche si le caractère est '…', avec A contenant la valeur du token pour `DISK`.
$239b       A est à nouveau le caractère à l'étude
$239c       %CHAR
$239c-$239e Branche si le caractère est inférieur à '0'.
$23a0       %CHAR
$23a0-$23a2 Branche si le caractère est inférieur à '<'. Les chiffres et les caractères ':' et ';' sont traités comme des littéraux.
$23a5       [special_chr]
            À cet endroit, A contient un caractère hors chiffre ni ':; "?…\0'.
$23a5       Sauve le pointeur vers le buffer de travail sur la pile.
$23a6       DE pointe un octet avant le début du tableau des mots clés du BASIC.
$23a9       Sauve le compteur C, initialement égal à 5, sur la pile.
$23aa-$23ad Place sur la pile l'adresse qui sera utilisée par `ret` si le mot-clé n'a pas été trouvé.
$23ae       B initialisé à `$7F`. B sera incrémenté à chaque mot-clé essayé, et sera le numéro de token associé. Le premier token a donc pour numéro $80.
$23b0       A est à nouveau le caractère à l'étude
$23b1       %CHAR
$23b5       %CHAR
$23b1-$23bb Transforme les lettres minuscules en majuscules directement dans le buffer d'entrée.
$23bc       [not_lower]
$23bc       C contient le caractère à traiter
$23bd       HL pointe vers le tableau de mots-clés. DE vers le buffer d'entrée.
$23be       [next_keyw]
$23be       Avance le pointeur vers le tableau de mots-clés.
$23bf-$23c0 Boucle jusqu'au premier caractère du tableau avec un bit de poids fort à 1. Cela est le marqueur d'un nouveau mot-clé.
$23c3       Augmente l'index du mot-clé actuellement pointé.
$23c4-$23c5 A contient le premier caractère de la table des mots-clé, sur 7 bits, ce qui enlève le marqueur de premier caractère.
$23c7       Si le caractère est nul, alors la fin du tableau des mots-clé est atteinte, on sort.
            La sortie se fait vers l'adresse poussée précédemment sur la pile : `not_a_tk`.
$23c8-$23c9 Branche si le caractère pointé à traiter et celui du mot-clé sont différents. On cherche le mot-clé suivant dans le tableau.
$23cb       Le pointeur vers le tableau de mots-clés retourne dans DE.
            HL contient à nouveau l'adresse du buffer en traitement.
$23cc       Sauvegarde de HL.
$23cd       [cmp_kw]
$23cd       Avance le pointeur de mot-clé vers le caractère suivant.
$23ce       Place le caractère suivant dans A
$23cf-$23d0 Branche si on atteint un nouveau marqueur de mot clé. Cela signifie que le mot-clé a été trouvé.
$23d3       Place dans C le caractère courant du mot-clé.
$23d4       Place dans A le numéro de token trouvé.
$23d5-$23d7 Branche si le mot-clé actuel est `GOSUB`
$23d9-$23db Branche si le mot-clé actuel est `GOTO`
$23dd       [goto_or_sub]
$23dd       Lecture du caractère suivant du buffer d'entrée.
            Il faut se rappeler que la routine 'saute' les espaces.
$23de       Annule un déplacement de HL effectué par la lecture précédente.
            Cela a pour effet de sauter par dessus les espaces éventuels, permettant l'écriture `GO TO` ou `GO SUB`.
$23df       [no_space]
$23df-$23e0 Lecture d'un nouveau caractère depuis le buffer d'entrée.
$23e1       %CHAR
$23e1-$23e3 Branche si le caractère est inférieur à 'a'.
$23e5       Sinon, passage du caractère en majuscule.
            Il n'y a pas de vérification de caractère supérieur à 'z'. En effet, le tableau de mots-clés ne contient de toute façon que des caractères alphabétiques.
$23e7       [not_low]
$23e7-$23e8 Les caractères du buffer d'entrée et du mot-clé courant sont identiques, la comparaison continue.
$23ea-$23eb Le mot-clé ne correspond pas, on essaie le mot clé suivant après avoir récupéré le pointeur vers la chaîne à traiter depuis son début de mot.

$23ed       [kw_found]
$23ed       Sauvegarde dans C du numéro de token.
$23ee       L'adresse du début de mot sur la pile est nettoyée.
$23ef       L'adresse de retour en cas d'échec de recherche est dépilée.
$23f0       A prend le numéro de token (pourquoi ne pas avoir fait directement `ld a, b` ici?)
$23f1-$23f3 Branche si le token est $88 (`GOTO`)
$23f5-$23f7 Branche si le token est $8c (`GOSUB`)
$23f9-$23fb Branche si le token est $8b (`RESTORE`)
$23fd-$23ff Branche si le token n'est pas $b6 (`THEN`)
$2401       [test_number]
            Vérifie s'il y a un paramètre nombre derrière l'instruction
$2401       Sauve HL, pointeur vers le buffer d'entrée.
$2402       Lit le prochain caractère intéressant depuis le buffer d'entrée.
$2403       Restaure à nouveau HL, qui pointe au début de la partie à vérifier.
$2404       Si Carry est à 0, le caractère n'était pas un nombre, il n'y a pas donc pas de paramètre numérique.
$2406       Sauvegarde de HL, pointeur vers le buffer d'entrée, dans DE.
$2407       Récupération dans Y du compteur C initialement mis à 5.
$2409       Récupération dans HL du pointeur vers le buffer de travail.

$240a       [dec_number]
$240a       Le token est placé dans le buffer de travail lors de la première arrivé. Ensuite, c'est la virgule de séparation préparée plus loin qui sera copiée.
$240b       DE pointe sur l'octet suivant du buffer d'entrée.
$240c       Et on sauve DE sur la pile.
$240d       Utilisation des registres secondaires.
$240e       Récupération dans HL du buffer d'entrée
$240f       Remise sur la pile de l'adresse du buffer d'entrée.
$2410       Tentative de récupération d'un numéro de ligne depuis le buffer d'entrée HL.
$2413-$2415 Branche si le numéro de ligne est invalide (à 0).
$2417       Nettoyage de la pile en enlevant l'adresse du buffer d'entrée.
$2418       Octet bas du numéro de ligne dans A (exx n'echange pas AF, on garde donc une partie de numéro de ligne, voir plus loin)
$2419-$241a Mise dans la pile dans l'adresse de décodage ajustée à l'octet avant la dernière lecture de numéro de ligne.
$241b       On repasse aux registres initiaux.
$241c       On récupère dans DE le buffer d'entrée.
$241d       HL, qui pointe vers le buffer de travail, est incrémenté.
$241e       $0e est placé dans le buffer de travail comme marqueur de nombre entier sur 16 bits pré-décodé.
$2420-$2421 Placement de la première partie du numéro de ligne
$2422       Avancement dans le buffer de travail.
$2423-$2426 Récupération dans C de la seconde partie du numéro de ligne
$2427-$242b La taille du buffer de travail est augmentée de 3 (pour le token, le marqueur et la première partie du nombre)
$242d       [miss_line]
$242d       Comparaison de DE, buffer d'entrée, et de HL, buffer de travail.
$242e       DE doit toujours être plus loin que HL.
            Si HL rattrape DE, branche vers l'erreur Opérande manquante.
            C'est le cas par exemple si on entre `10 ONIGOTO1,2,3,4`.
$2431       HL contient le buffer en entrée, DE le buffer de travail.
$2432       Sauvegarde du buffer d'entrée.
$2433       Lecture du caractère suivant.
$2434       DE contient le buffer en entrée, HL le buffer de travail.
$2435       %CHAR
$2435-$2437 Branche si le caractère suivant n'est pas une virgule. Le décodage de l'instruction est terminé.
            La fin de la routine copiera la seconde partie du numéro de ligne décodé en cours.
            Il peut y avoir des virgules pour `ON ... GOTO` et `ON ... GOSUB`.
$2439       Sinon, on place la deuxième partie du numéro de ligne dans le buffer de travail.
$243a       Et on avance le pointeur vers le buffer de travail.
$243b       La taille du buffer de travail est augmentée.
$243d       %CHAR
            Préparation dans C d'une virgule pour la prochaine boucle.
$243f       Nettoie la pile du buffer d'entrée.
$2440       Boucle sur le paramètre potentiel suivant.

$2442       [invalid_lin]
$2442       Reviens sur les registres initiaux.
$2443       Récupération dans DE du buffer d'entrée
$2444       Recalage, puisqu'il n'y avait pas de numéro de ligne.
$2445       Poursuite du décodage.

$2447       [token_end]
$2447       Récupération du buffer d'entrée dans DE.
$2448       Sauvegarde du pointeur vers le buffer de travail.
$2449       Sauvegarde du compteur d'octets dans le buffer de travail.

$244b       [not_a_tk]
            Arrivée ici lorsque :
            - aucun mot clé n'a été trouvé
            - un mot clé suivi de paramètres numériques a été trouvé
$244b       HL pointe vers le buffer en entrée, DE pointe vers le buffer de travail.
$244c       [complete_tk]
            Arrive ici lorsqu'un token a été trouvé et que ses éventuels paramètres de type ligne ont été décodées.
$244c       Récupération du caractère C dans A.
            Dans le cas où l'on a réussi la tokenisation, C contient le token.
            Dans le cas où l'on a décodé un numéro de ligne, C contient la deuxième partie (haute) du numéro de ligne.

$244d       Récupération de C, qui contient la taille du buffer de travail.
$244e       DE pointe sur le buffer de travail.
$244f       [no_token]
            On arrive ici soit par un token, soit en copie directe du buffer d'entrée vers le buffer de travail.
            Quoiqu'il arrive, la donnée à copier est dans A.
$244f       Incrémente le pointeur vers le buffer d'entrée.
$2450       Copie la donnée actuelle dans le buffer de travail.
$2451       Avance le pointeur vers le buffer de travail.
$2452       Augmente la taille du buffer de travail.
$2453       %CHAR
$2453-$2455 Branche si le caractère est ':'
$2457       Avec la soustraction précédente, cela fait que l'on compare le caractère à $83
$2459       Branche si le caractère n'est pas le marqueur $83 (`DATA`)

$245b       [is_colon]
$245b       Si le caractère était ':', alors A est à 0. Sinon, le token était `DATA` et A est différent de 0, ce qui fait passer en mode littéral.

$245e       [not_data]
$245e       Avec la soustraction précédente, cela fait que l'on compare le caractère à $8E (`REM`)
$2460       Branche si le caractère n'est pas le marqueur $8E (`REM`) pour une nouvelle analyse de token
$2463       B = 0, qui sert de caractère marqueur de fin de copie.

$2464       [trailing]
            Recopie les caractères du buffer d'entrée vers le buffer de travail jusqu'à trouver le caractère marqueur fourni dans B.
$2465       A contient le prochain caractère du buffer d'entrée.
$2466       Sort si ce caractère est nul.
$2468-$2469 Branche si le caractère marqueur a été trouvé.

$246b       [ifquote]
$246b       Avance le pointeur vers le buffer d'entrée.
$246c       Copie le caractère dans le buffer de travail.
$246d       Incrémente la taille du buffer de travail.
$246e       Avance le pointeur vers le buffer de travail.
$246f       Boucle sur la copie littérale.

$2471       [ifnul]
            Arrive ici lorsque le buffer d'entrée a rencontré le caractère nul final.

$2471       HL est placé juste avant le buffer de travail.
$2474-$2478 Termine le buffer de travail avec trois caractères nuls.
$2479       Fin de la routine de tokenisation

$247a       [inst_for]
            Instruction BASIC : FOR

            La structure d'un bloc `FOR` est la suivante :
            - Marqueur $81 (1 octet)
            - Adresse de la variable associée (2 octets)
            - Signe du `STEP` (1 octet)
            - Valeur du `STEP` (4 octets, format BCDE)
            - Valeur du `TO` (4 octets, format BCDE)
            - Ligne où se trouve l'instruction `FOR` (2 octets)
            - Adresse de la première instruction après le `FOR` (2 octets)

            Pour un total de 16 octets.

            %CODE
$247a-$247c Indique que la recherche/création de variable se fait pour une commande `FOR`.
$247f       Juste après le `FOR` se trouve une assignation de variable. Au retour, DE pointe sur la variable.
            S'il y a une erreur de syntaxe après l'assignation, celle-ci à tout de même lieu.
$2482       Retire l'adresse de retour de l'instruction `LET` ($24ea)
$2483       Sauve le pointeur vers le texte BASIC qui pointe à présent après l'assignation de variable.
$2484       Cherche le début de l'instruction suivante.
$2487       Sauve le pointeur vers l'instruction suivant le `FOR`
$248a-$248d Pointe 2 octets au-dessus de la pile, c'est-à-dire après le pointeur vers le texte BASIC que l'on vient d'y pousser.

$248e       [search_for]
$248e       Cherche le bloc `FOR` associé à la variable pointée par DE.
$2491       Branche si un bloc `FOR` correspondant n'est pas trouvé.
$2493       Sinon, fait pointer vers la pile après le bloc `FOR` trouvé.
$2494       Sauve l'adresse de la variable associée.
$2495-$2498 DE pointe vers la première instruction qui suit le `FOR` trouvé (c'est-à-dire ayant la même variable).
$2499-$249b Sauve l'adresse de la pile après le `FOR` trouvé.
$249c       Récupère l'adresse de l'instruction suivant le `FOR` actuel.
$249f       Compare les deux adresses d'instruction suivante.
$24a0       Restaure le pointeur sur la pile après le bloc `FOR` trouvé.
$24a1       Restaure l'adresse de la variable associée.
$24a2       Les deux instructions suivantes étaient différentes, les deux blocs `FOR` ne sont pas identiques, on continue la recherche.
$24a4       Restaure le pointeur sur le texte BASIC en cours d'analyse, et n'en fait rien (nettoyage de la pile)
$24a5       Fixe l'adresse de la pile sur le bloc après le bloc `FOR` trouve, ce qui annule les blocs `FOR` intermédiaires.

            Cela est fait pour traiter les cas du type (invalide, mais exécutable) :
            > 10 FOR I = 1 TO 10
            > 20 FOR J = 10 TO 20
            > 30 PRINT I,J
            > 40 NEXT I
            La boucle FOR sur J n'empilera pas un nouveau bloc à chaque rencontre.

$24a6       Incrémente C pour une raison inconnue... La valeur est écrasée juste après.

$24a7       [no_for]
$24a7       Restaure le pointeur vers le texte BASIC
$24a8       HL = pointeur vers le texte BASIC
            DE ne semble pas être utilisé, un `pop hl` aurait suffi ?

$24a9-$24ab Vérifie qu'il y a de la place pour 8 niveaux de la pile.
$24ae       Sauve le pointeur vers le texte BASIC
$24af       HL pointe sur l'instruction suivant le FOR.
$24b2-$24b3 Insère l'adresse de cette instruction sous le pointeur texte BASIC dans la pile.
$24b4       Récupère le numéro de la ligne actuelle en exécution.
$24b7       Sauve la ligne courante sur la pile et récupère le pointeur vers le texte BASIC.
$24b8       Vérifie que la variable déclarée était de type numérique.
$24bb       Le token qui suit doit être $b3 (`TO`)
$24bc       %DATASKIP
$24bd       Évaluation de l'expression après `TO`
$24c0       Sauve le pointeur vers le texte BASIC
$24c1       Ramène l'expression vers `BCDE` en tant qu'entier 16 bits.
$24c4       Récupère le pointeur vers le texte BASIC
$24c5-$24c6 Sauve BCDE dans le bloc `FOR`
$24c7-$24cb BCDE = 1, `STEP` par défaut
$24cc-$24cd Vérifie si le token suivant est `STEP`
$24cf       A = 1, pour signaler le signe positif de `STEP`
$24d1       Branche s'il n'y a pas de token `STEP`
$24d3-$24d4 Sinon, évalue l'expression pour `STEP`
$24d7       Sauve le pointeur vers le texte BASIC
$24d8       Ramène l'expression vers `BCDE` en tant qu'entier 16 bits.
$24db       Teste le signe du `STEP`
$24dc       Récupère le pointeur vers le texte BASIC (dans A)

$24dd       [no_step]
$24dd-$24de Pousse la valeur du `STEP` dans le bloc `FOR`
$24df       Sauve le signe de `STEP`
$24e0       Remonte la pile d'octet, pour ignorer le registre `F`.
$24e1       Sauve le pointeur vers le texte BASIC
$24e2       Récupère l'adresse de la variable associée, placée par l'instruction `LET`.
$24e5       Met l'adresse de la variable sur la pile et récupère dans HL le pointeur vers le texte BASIC.

$24e6       [end_for]
$24e6-$24e9 Sauve $81 (marqueur du bloc `FOR`) sur la pile.

$24ea       [end_of_inst]
            %CODE,%MS_BASIC(RUNCNT)
            Appelée à la fin de chaque instruction lors d'une exécution.
            Recherche l'instruction suivante.

$24ea       Vérifie si une interruption de commande a été demandée.
$24ed       Sinon, sauve le pointeur de texte BASIC.
$24f1       %CHAR
$24f0-$24f3 Branche si le caractère suivant est `:`, la ligne n'est pas terminée, il faut exécuter l'instruction suivante.
$24f5-$24f6 Si le pointeur de texte BASIC ne pointe ni sur ':' ni sur le caractère nul de fin de ligne, c'est une erreur de syntaxe.
$24f9-$24fd Branche si l'adresse de chaînage de la ligne suivante est nulle. La dernière ligne du programme a été atteinte.
$2500-$2503 Lecture du numéro de la nouvelle ligne dans DE.
$2504       HL = le numéro de ligne, DE = pointeur vers les tokens de la ligne.
$2505       Mise à jour du numéro de la ligne courante.
$2508       DE = le numéro de ligne, HL = pointeur vers les tokens de la ligne. Prêt à exécuter la ligne suivante.

$2509       [exec_token]
            %MS_BASIC(EXECUTE)
            Exécute le contenu d'une ligne BASIC tokenisée.

$2509       Récupère le premier octet de l'instruction à exécuter.
$250a-$250d Met sur la pile l'adresse de retour vers laquelle aller à la fin de l'instruction.

$250e       [if_jump]
$250e       Si le caractère sur la ligne était nul, alors le retour provoquera le traitement de la fin de ligne.

$250f       [on_jump]
$250f-$2511 Branche si l'octet n'était pas un token (les tokens sont tous supérieurs à $80). Exécute par défaut l'assignation de variable.
$2514-$2516 Les 50 ($32) premiers tokens sont des instructions. Au-delà, provoque une erreur de syntaxe, ce n'est pas un token d'instruction.
$2519-$251b BC = (token - $80) * 2
$251d       Sauvegarde de HL, pointeur vers le texte BASIC, dans DE.
$251e       HL pointe vers la table des adresses d'instructions.
$2521       HL pointe vers l'adresse d’exécution de l'instruction.
$2522-$2524 BC contient l'adresse d’exécution de l'instruction.
$2525       L'adresse est mise sur la pile.
$2526       HL pointe vers le texte BASIC.
            La routine continue sur l'acquisition du prochain caractère signifiant du texte BASIC.
            Le `ret` qui terminera cette routine provoquera le branchement vers l'exécution de l'instruction, avec HL qui pointe vers le premier octet du texte BASIC.
            A contiendra le caractère lu, et les drapeau Carry et Z seront positionnés.

$2527       [get_char]
            Récupère le caractère suivant pointé par HL.

            Entrée :
            - HL pointe vers le buffer à lire

            Sortie :
            - A contient l'octet lu
            - Carry est à 0 si l'octet est supérieur ou égal à $3a (':')
            - Carry à 1 si c'est un chiffre, 0 sinon
            - Z à 1 si A est nul
$2529       %CHAR
$2527-$252b Lit le caractère suivant et retourne immédiatement si celui-ci est supérieur ou égal à ':', tout comme le fait `chget`

$252c       [chget_2]
            Suite du traitement de chget.

            A contient le caractère lu dans le buffer, qui est inférieur à $3a (':')
$252c-$252e Lit le caractère suivant si celui-ci était un espace. Les espaces ne sont pas significatifs.
$2530       Branche si le caractère est entre ' ' et ':'
$2532-$2534 Branche si le caractère est entre %0f et $1f (contient les caractères accentués, le caractère `DISK` et deux caractères de contrôle)
$2536-$2538 Branche si le caractère est inférieur strictement à $0d (une autre partie des caractères de contrôle, dont 0)
$253a       Reste les cas $0d (retour chariot, cas normalement impossible) et $0e (marqueur d'entier 16 bits).
            Le pointeur sur le texte BASIC est sauvé.
$253b-$253e Le position après le nombre entier sur 16 bits est mise dans `(contxt)`.
$2541       Et HL pointe à nouveau sur le texte BASIC en cours d'exécution.

$2542       [chget_std]
$2542       Place les drapeaux en fonction de la valeur de A.
$2543       Retour soit de `chget`, soit exécution de l'instruction donc l'adresse a été poussée sur la pile.

$2544       [chget_digit]
$2544       %CHAR
$2544-$2546 Carry à 1 si le caractère est supérieur ou égal à '0' et inférieur strictement à ':'. Donc un chiffre.
$2547-$2548 Permet de positionner le Z sans toucher à Carry.
$2549       Retour soit de `chget`, soit exécution de l'instruction donc l'adresse a été poussée sur la pile.

$254a       [read_index]
            %MS_BASIC(FPSINT)
            Lecture d'un nombre entier depuis une chaîne pointée par HL.

            En branchant avant `deint_impl`, le nombre doit être positif.
            En branchant vers `deint_impl`, le nombre peut être positif ou négatif.

            Entrée :
            - HL pointe vers un buffer de texte

            Sortie :
            - DE contient le nombre entier sur 16 bits

$254a       Cette première entrée est utilisée pour un index de tableau, et commence par ignorer le premier caractère.

$254b       [pos_int]
            %MS_BASIC(POSINT)
$254b       Évaluation de l'expression numérique pointée par HL. Utilisé par l'instruction `CLEAR`.

$254e       [dep_int]
            %MS_BASIC(DEPINT)
$254e       Vérifie le signe de l'expression dans FAC
$254f       Lance une erreur si le nombre est négatif.

$2552       [deint_impl]
            %MS_BASIC(DEINT)
$2552       Récupère l'exposant de FAC
$2555       Et le compare à $80+16 (donc 16).
$2557       Branche si l'exposant est inférieur ou égal à 16 (codé $80+$10). Dans ce cas, la partie entière du nombre peut tenir sur 16 bits.
$255a-$255d BCDE = -32768, qui est le seul nombre avec un exposant à $90 qui est valide.
$2560       Sauve le pointeur vers le texte BASIC.
$2561       Compare FAC et BCDE.
$2564       Restaure le pointeur vers le texte BASIC.
$2565       DE = $8000, soit -32768 sur 16 bits signé.
$2566       Si FAC = -32768, alors retour.
$2567       [ill_call]
$2567-$2569 Erreur "Illegal function call"

$256c       [get_lin_num]
            %MS_BASIC(ATOH)
            Lecture depuis le buffer pointé par HL d'un nombre entier positif.
            Ce nombre peut soit être exprimé en ASCII, soit déjà décodé avec le marqueur `$0e`.

            La routine est utilisée pour les numéros de ligne, et vérifie que le nombre est inférieur
            à 65529, numéro de ligne maximum.

            Entrée :
            - HL pointe sur un buffer de type texte BASIC

            Sortie :
            - DE contient le nombre entier décodé depuis HL
            - A contient le dernier caractère lu

$256c       Ajuste le pointeur vers le texte BASIC.

$256d       [get_lin_nu2]
$256d       Lecture du caractère. Un branchement direct ici permet d'accéder à la routine sans le recalage de HL.
$256e-$2570 Branche si le nombre est en ASCII.
$2572-$2575 Sinon, le nombre a déjà été codé, il est lu directement dans DE.
$2576       Puis lecture du caractère suivant dans A.

$2578       [ascii_num]
$2578       Revient en arrière dans le buffer d'entrée.
$2579       Initialise l'accumulateur de résultat à 0.
$257c       [num_decode]
$257c       Lecture d'un caractère depuis le buffer d'entrée.
$257d       Si le caractère n'était pas un chiffre, retour immédiat.
$257e       Sauve HL
$257f       Sauve AF
$2580-$2583 Compare l'accumulateur DE avec HL ($1998 = 6552), numéro de ligne maximum divisé par 10.
$2584       Branche à la fin de la fonction si l'accumulateur a dépassé le numéro de ligne maximum divisé par 10.
            Cela signifie que dans le cas contraire, le numéro de ligne est au maximum 6552 et qu'un nouveau chiffre a été lu.
            Par la suite, l'accumulateur va être multiplié par 10 et le nouveau chiffre ajouté, ce qui porte le numéro
            de ligne maximum à 65529.
$2586-$258b HL <- DE * 10. Au final, HL contient l'accumulateur multiplié par 10.
$258c       Restaure AF, A contient le nouveau caractère lu.
$258d       %CHAR
$258d-$2590 DE prend la valeur numérique du caractère lu, qui a déjà été vérifiée comme étant un chiffre en ASCII.
$2592       Ajoute le nouveau chiffre à l'accumulateur.
$2593       DE redevient l'accumulateur.
$2594       Restaure le pointeur vers le buffer d'entrée.
$2595       Traite un nouveau chiffre.

$2597       [num_dec_end]
$2597       Restaure AF, contenant le dernière caractère lu.
$2598       Restaure le pointeur vers le texte BASIC.

$259a       [inst_run]
            %CODE,%MS_BASIC(RUN)
            Instruction BASIC : RUN

            L'instruction RUN sans argument réinitialise les variables BASIC et fait pointer l'interpréteur vers la première ligne du programme.

            Avec un argument, le contexte BASIC est réinitialisé puis continue vers l'instruction `GOTO`.

$259a       Coupe l'affichage du curseur (au prochain rafraîchissement)
$259e       Branche s'il n'y a pas d'argument à la commande.
            La réinitialisation des variables va faire pointer la prochaine instruction au début du listing.
            L'adresse de retour étant `end_of_inst`, l'interpréteur enchaînera sur le programme depuis son début.
$25a1       Réinitialise les variables de contexte BASIC.
$25a4       Prépare le retour dans la boucle d'exécution.
$25a7       Branche vers l'instruction `GOTO` précédé de la mise sur la pile de BC.

$25a9       [inst_gosub]
            %CODE,%MS_BASIC(GOSUB)
            Instruction BASIC : GOSUB


$25a9-$25ab Vérifie qu'il y a 3 niveau dans la pile.
$25ae       Récupère l'adresse de retour dans BC
$25af       Sauve le pointeur d'exécution HL.
$25b0-$25b4 Met le numéro de la ligne courante au sommet de la pile. HL pointe sur le texte BASIC.
$25b5-$25b8 Place un marqueur `GOSUB` (`$8c`) sur la pile. La pile est ajustée pour ne pas retenir la partie `F` de `AF`.

$25b9       [run_from_ln]
$25b9       Remet l'adresse de retour sur la pile, puis enchaîne sur GOTO.
            Instruction partagée avec RUN pour lancer un programme depuis une ligne particulière.

$25ba       [inst_goto]
            %CODE,%MS_BASIC(GOTO)
            Instruction BASIC : GOTO

            Du fait d'ignorer ce qui se trouve après le numéro de ligne, une ligne qui contient "GOTO 20 HOP HOP" est valide.

$25ba       Lit le numéro de ligne dans DE.
$25bd       Le reste de la liste ne peut pas être atteint, on ignore jusqu'à la fin de la ligne.
$25c0-$25c1 Et sauve le pointeur ajusté sur la ligne suivante.
$25c2-$25c5 Compare la ligne courante (HL) et la ligne voulue (DE)
$25c6       Restaure le pointeur de texte BASIC.
$25c7       Appelle si le numéro de ligne voulue est au-delà de la ligne courante.
$25ca       Appelle si le numéro de ligne voulue est égale ou avant la ligne courante.
$25cd-$25ce Copie de la ligne trouvée dans HL
$25cf       Ajuste le pointeur vers la ligne un octet avant.
$25d0       Retour si la ligne a été trouvée.
$25d1       [udef_line]
$25d1-$25d3 Sinon, lance une erreur "Undefined line number"

$25d6       [inst_return]
            %CODE,%MS_BASIC(RETURN)
            Instruction BASIC : RETURN

$25d6       `RETURN` n'a pas de paramètre. S'il y a quelques chose derrière l'instruction, retour immédiat, ce qui provoquera une erreur de syntaxe.
$25d7-$25d9 DE à $ff évite qu'une variable associée à un bloc `FOR` soit valide par hasard, et permet donc de dépiler tous les blocs `FOR` jusqu'à un bloc non `FOR`.
            Après l'appel, A contient l'octet qui débute le bloc non `FOR` et HL pointe un octet plus loin.
$25dc       La pile est positionnée juste après le marqueur du bloc non `FOR` trouvé.
$25dd-$25e1 Si l'octet ne contient pas le marqueur de bloc `GOSUB` ($8c), alors branche sur une erreur "RETURN without GOSUB".
$25e4       Après le marqueur de bloc `GOSUB` se trouve le numéro de ligne qui contenait le `GOSUB`.
$25e5       Inscription de ce numéro de ligne dans `(curlin)`.
$25e8-$25eb Si on était en mode direct, HL est à $FFFF et A est donc à 0, la branche n'est pas prise. Sinon, la branche est prise.
            Mais sur cette implémentation, on ne fait rien de spécial. Ce qui permet un `RETURN` en mode direct (`GOSUB` vers un `STOP` permet de reprendre avec `RETURN`).

$25ed       [useless_jp]
$25ed       Préparation de l'adresse de retour de la fonction.
$25f0       L'adresse de retour est mise sur la pile, HL pointe vers l'instruction `GOSUB` du bloc.
$25f1       Évite le `pop hl` qui suit pour se caler sur l'instruction qui suit le `GOSUB` actuellement pointé par HL.

$25f2       [next_data]
            %MS_BASIC(NXTDTA)
            Un appel ici suppose que la chaîne à traiter est sur la pile.
            Enchaîne sur DATA pour faire pointer HL vers l'instruction suivante.

$25f3       [inst_data]
            %CODE,%MS_BASIC(DATA)
            Instruction BASIC : DATA

            En arrivant ici, C sera chargé avec $3a (':' == fin d'instruction).
            Ainsi, un marqueur possible sera $00, et l'autre ':'. L'instruction est ignorée jusqu'à la prochaine, qu'elle soit séparée par ':' ou par une fin de ligne.

$25f3-$25f4 Charge C avec $3a et continue sur le `NOP` plus bas.

$25f5       [inst_rem]
            %CODE,%MS_BASIC(REM)
            Instruction BASIC : REM
            En arrivant ici, C sera chargé avec $00.
            Ainsi, les deux marqueurs possibles seront tous les deux à $00. Le reste de la ligne sera ignoré.

$25f5       Charge C avec $00 quand on arrive directement ici.
$25f6       Avec le $0e précédent, forme ld c,$00, et sert d'adresse d'arrivée pour `inst_data`.
$25f7       Charge B, le second marqueur, avec $00.

$25f9       [rem_ex_lp]
$25f9-$25fb Échange le contenu de B et C.

$25fc       [rem_loop]
$25fc       Lit l'octet pointé par HL.
$25fd-$25ff Branche si ce n'est pas un marqueur d'entier 16 bits décodé.
$2601-$2604 Sinon, ignore le nombre codé et lit à nouveau le caractère pointé.

$2605       [no_number]
$2605-$2606 Retour si la fin de ligne a été atteinte.
$2607-$2608 Retour immédiat si le caractère marqueur de fin a été trouvé.
$2609       Sinon, HL pointe sur le caractère suivant.
$260a       %CHAR
$260a       Détection de chaîne de caractères.
$260c       Si on trouve un marqueur de chaîne de caractères, les deux marqueurs B et C seront échangés.
            Cela permet de protéger un ':' situé à l'intérieur d'une chaîne de caractères et ne pas considérer qu'il marque une fin d'instruction.
$260e       Sinon, on continue le traitement de la ligne.

$2610       [inst_let]
            %CODE
            Instruction BASIC : LET

$2610       En retour, DE pointe sur la variable, qui a été créée au besoin.
$2613       Vérifie la présence de l'opérateur '=' (tokenisé), ou génère une erreur de syntaxe.
$2614       %DATASKIP
$2615       Sauve le pointeur sur la variable.
$2616       Récupère le type de la variable.
$2619       Et le sauve sur la pile.
$261a       Évaluation de l'expression qui suit le signe '='.
$261d       Récupère le type de la variable.
$261e       Sauve le pointeur texte BASIC sur le pile et récupère le pointeur de variable dans HL.
$261f       Sauve l'adresse de la variable dans `(temp)`
$2622       Le type de la variable passe dans Carry (1 si chaîne, 0 si numérique).
$2623       Vérification de la compatibilité du type de l'expression et de la variable.
            Si la routine revient, c'est que les types étaient identiques.
$2626       Branche en cas de variable numérique.
$2628       [let_string]
            Assigne une chaîne de caractères à une variable.

$2628       Sauve le pointeur vers la variable.
$2629       Récupère depuis FAC le pointeur vers le descripteur de chaîne du résultat de l'expression.
$262c       Et sauve ce pointeur.
$262d-$262e Ignore la taille de la chaîne.
$262f-$2631 Adresse de la chaîne dans `DE`
$2632-$2635 Compare l'adresse de la chaîne avec `(txttab)`.
$2636       Branche si l'adresse de la variable est avant `(txttab)`, autrement dit, dans un buffer temporaire. Il faut donc créer une entrée.
$2638-$263b Vérifie si la chaîne se trouve entre `(txttab)` et `(strend)`, c'est-à-dire dans une zone allouée (programme, variable, tableau...).
            Le vrai test aurait probablement du être avec `(vartab)`. Une chaîne ne peut pas se trouve entre `(vartab)` et `(strend)`. Cela fonctionne donc quand même.
$263c       Récupère le pointeur sur le descripteur de chaîne.
$263d       Branche si la chaîne est dans une zone allouée.
$263f-$2643 Branche si la chaîne n'est pas dans le buffer temporaire de chaîne.
            Test inutile sur VG5000, puisque le buffer temporaire est de toute façon avant `(txttab)`. Relicat probable du portage BASIC sur cette machine.
$2645       On a déjà fait le `pop de`, on ignore le suivant.
$2646       [alloc_str]
$2646       Récupère le pointeur sur le descripteur de chaîne.
$2647       Récupération dans BC de la chaîne en haut du buffer de chaînes temporaires.
$264a       HL = pointeur de descripteur de la chaîne, BC = pointeur vers le contenu de la chaîne
$264b       Sauve la chaîne dans l'espace de sauvegarde des chaînes de caractères.

$264e       [pop_string]
$264e       Récupération de la chaîne temporaire en haut du buffer
$2651       Récupération de l'adresse de la variable.
$2652       Copie le descripteur de chaîne vers l'entrée de variable, ce qui donne sa valeur finale à la valeur (longueur et pointeur de chaîne).
$2655       Restauration du pointeur vers le texte BASIC.

$2657       [let_numeric]
            Assigne un nombre à une variable.

$2657       Sauve le pointeur vers la variable.
$2658       Copie le contenu de FAC vers la variable.
$265b       Restaure l'adresse de la variable dans DE.
            Cela permet à l'instruction `FOR` de récupérer la variable d’itération.
$265c       Restaure le pointeur vers le texte BASIC.

$265e       [inst_on]
            %CODE,%MS_BASIC(ON)
            Instruction BASIC : ON

$265e       Évalue l'expression qui suit `ON` sous la forme d'un entier sur un octet.
$2661       Lit le token qui suit.
$2662       Sauve le token dans B.
$2663-$2665 Branche si le token est `GOSUB`
$2667       S'assure que le token suivant est `GOTO`, ou provoque une erreur de syntaxe.
$2668       %DATASKIP
$2669       Recale le pointeur vers le texte BASIC.
$266a       [on_line]
$266a       Copie le résultat de l'évaluation vers C en tant que compteur.
$266b       [on_branch]
$266b       Décrémente le compteur
$266c       Ramène le token (`GOTO` ou `GOSUB`) dans A.
$266d       Si le compteur est arrivé à 0, provoque le saut en exécutant le token dans A avec la ligne pointée par HL.
$2670       Lecture du numéro de ligne.
$2673       %CHAR
$2673-$2675 Retour s'il n'y a pas de ligne supplémentaire.
$2676       Essaie le numéro de ligne suivant.

$2679       [inst_if]
            %CODE,%MS_BASIC(IF)
            Instruction BASIC : IF

$2679       Évaluation de l'expression qui suit `IF`.
$267c-$267f Branche si le token qui suit est `GOTO`
$2681       Sinon, s'assure que le token qui suit est `THEN` ou provoque une erreur de syntaxe.
$2682       %DATASKIP
$2683       Recale HL sur le token.

$2684       [if_line]
$2684       S'assure que l’expression du `IF` est de type numérique.
$2687       En prend son signe.
$2688       Si l'expression s'évalue à 0, elle est fausse. Branche sur l'instruction `REM` pour ignorer le reste de la ligne.
$268b       Lit l'octet suivant.
$268c-$268e Branche s'il s'agit d'un nombre sur 16 bits déjà décodé. C'est un numéro de ligne qui fonctionne comme un `GOTO`.
$2691       Sinon, exécute la suite de la ligne.

$2694       [inst_lprint]
            %CODE

            Instruction BASIC : LPRINT
$2694-$2696 Indique l'imprimante comme périphérique de sortie.

$2699       [print_next]
$2699-$269a Relit le caractère pointé par HL (car A a été utilisé).

$269b       [inst_print]
            %CODE
            Instruction BASIC : PRINT
$269b       Appel du `hook` sur `PRINT`.
$269e       Sans argument, affiche une ligne vide. C'est aussi le cas si le `hook` place le drapeau Z à 1.

$26a1       [pr_next_ct]
$26a1       Il n'y a plus d'expression à afficher, termine l'instruction.
$26a4-$26a6 Branche si le token `TAB(` a été trouvé.
$26a8-$26aa Branche si le token `SPC(` a été trouvé.
$26ac       Sauve le pointeur vers le texte BASIC.
$26ad       %CHAR
$26ad-$26af Branche si le caractère est ','
$26b1       %CHAR
$26b1-$26b3 Branche si le caractère est ';'
$26b6       Jette le pointeur vers le texte BASIC qui sera sauvé après la lecture de l'expression.
$26b7       Lecture de l'expression pointée par HL.
$26ba       Sauve le pointeur vers le texte BASIC.
$26bb-$26bf Branche si l'expression est de type chaîne.
$26c1       Sinon, transforme le résultat numérique dans FAC en chaîne de caractères.
$26c4       Transfert cette chaîne vers une chaîne de caractères temporaire (il ne s'agit pas des mêmes buffers temporaires)
$26c7       %CHAR
            Le nombre est suivi d'un espace.
$26c9       Récupère l'adresse de la longueur de la chaîne temporaire (le descripteur de chaîne temporaire est dans FAC).
$26cc-$26d0 Branche si le périphérique de sortie est l'écran.
$26d2-$26d5 Ajoute la position actuelle en colonnes de l'imprimante avec la longueur de la chaîne à imprimer.
$26d6       Compare le résultat avec 132.
$26d8       Puis branche plus loin.

$26da       [print_scr]
$26da-$26dd Place dans B la longueur d'une ligne à l'écran.
$26de       Dans A, la longueur d'une ligne à l'écran + 1.
$26df       Branche si la longueur d'une ligne est $ff, ce qui signifie qu'il n'y a pas de limite.
$26e1-$26e4 Sinon, ajoute la position du curseur en colonnes avec la longueur de la chaîne à écrire.
$26e5       Ajuste le résultat (A avait été incrémenté)
$26e6       Compare le résultat avec la longueur de la ligne.

$26e7       [print_adjst]
$26e7       Si ce que l'on doit afficher ou imprimer dépasse la longueur permise, un saut de ligne est envoyé.

$26ea       [no_limit]
$26ea       Émission de la chaîne de caractères vers le périphérique de sortie.
$26ed       A = 0, qui permet de passer par dessus le `call` juste après.

$26ee       [print_str]
$26ee       Émission de la chaîne de caractères vers le périphérique de sortie si c'était une chaîne de caractères.
$26f1       Restaure le pointeur vers le texte BASIC.
$26f2       Boucle vers l'évaluation de la potentielle expression suivante.

$26f4       [print_zone]
$26f4-$26f8 Branche si le périphérique de sortie est l'écran.
$26fa-$26fd Compare la position en colonnes de l'imprimante avec 117.

$2701       [zone_scr]
$2701-$2704 Place la position de la dernière zone dans B.
$2705-$2708 Place la position du curseur - 1 dans A.
$2709       Compare cette position avec la dernière zone.

$270a       [zone_crdo]
$270a       Si la colonne de la dernière zone est dépassée, alors émet un retour chariot.
$270d       Puis dans ce cas, branche sur l'impression à la suite.

$270f       [zones_loop]
$270f       Soustrait 13 de la position.
$2711       Tant que le résultat est positif.
$2713       Une fois négatif, prend le complément du résultat, ce qui donne le nombre d'espace à émettre.

$2716       [print_tab]
$2716       Sauve le token (`SPC(` ou `TAB(`)
$2717       Évalue l'expression numérique qui suit avec un résultat sur 8 bits.
$271a       S'assure qu'une parenthèse fermante est à la suite de l'expression, ou lance une erreur de syntaxe.
$271b       %DATASKIP
$271c       Recale le pointeur de texte BASIC.
$271d       Récupère le token.
$271e       Soustrait le token d'avec le token pour `SPC(`.
$2720       Sauve le pointeur de texte BASIC.
$2721       Branche si c'était `SPC(`.
$2723-$2727 Branche si le périphérique de sortie est l'écran.
$2729       Initialise A avec le numéro de colonne de l'imprimante.

$272e       [prepare_spc]
$272e       Initialise A avec la colonne à l'écran.

$2731       [print_spc]
$2731-$2732 Pour SPC(), A = argument de SPC() - 0
            Pour TAB(), A = argument de SPC() - colonne actuelle - 1
$2733       Continue à la suite si TAB() était inférieur à la colonne actuelle.

$2735       [output_spc]
$2735-$2736 Nombre d'espaces à émettre dans B
$2737       %CHAR
            Caractère espace à émettre dans A.
$2739       [out_spaces]
$2739       Émet l'espace.
$273a       Boucle autant de fois que le compteur B.

$273c       [print_cont]
$273c       Restaure le pointeur de texte BASIC.
$273d       Lit l'octet suivant.
$273e       Évaluation de l'expression potentielle suivante sans retour à la ligne s'il n'y en a pas.

$2741       [print_end]
$2741-$2742 Sélectionne l'écran comme périphérique de sortie.

$2746       [bad_input]
            %MS_BASIC(BADINP)
            Lorsque les données sont insuffisantes pour remplir les variables d'une instruction `READ` ou `INPUT`, cette routine est appelée.

$2746-$274a Branche dans le cas d'un `READ`
$274d       Jette le pointeur de données qui est sur la pile.
$275a       [redo_fr]
$274e-$275a Affiche "Redo from scratch" en fonction de la langue
$275d       Relance l'acquisition de données pour `INPUT`.

$2760       [inst_input]
            %CODE,%MS_BASIC(INPUT)
            Instruction BASIC : INPUT

$2760       Appeler `INPUT` en direct est illégal, l'instruction doit être dans un programme.
$2763       Appel du `hook` sur `INPUT`
$2767       %CHAR
$2766-$2767 S'il y a un '"' après INPUT, c'est qu'il y a un texte à afficher.
$2769       Reliquat de portage. Dans d'autres BASIC, A sert à permettre la sortie de caractères. Dans cette ROM, aucune des deux branches possibles n'utilise cette valeur.
$276b       Il n'y a rien à afficher, on passer directement à l'acquisition des données.
$276d       Évalue la chaîne de caractères à afficher.
$2770       Vérifie que le caractère suivant est un ';' ou provoque une erreur de syntaxe.
$2771       %DATASKIP
$2772       Sauve le pointeur sur le texte BASIC.
$2773       Affiche la chaîne de caractères
$2776       Évite le `push hl` qui suit.
$2777       [raw_input]
$2777       Sauve le pointeur sur le texte BASIC.
$2778       Patch de la ROM 1.1 pour ajouter le traitement de la continuité de ligne dans `INPUT`.
$277b       Branche sur l'acquisition des données.

$277d       3 octets inutilisés.
            Reliquat du patch de la routine pour `INPUT` dans la ROM 1.1

$2780       [prompt_2]
$2780       Acquisition des données.
$2783       Rend le curseur invisible.
$2787-$278e Efface la continuité de ligne et signal que l'on a terminé l'instruction `INPUT`.

$2792       Octet inutilisé du au patch de `INPUT` dans la ROM 1.1

$2793       [input_data]
$2793       Récupère le pointeur de texte BASIC dans BC (HL est utilisé par la ligne juste entrée pour l'INPUT)
$2794       Branche en cas d'interruption de commande.
$2797-$279a Lit le premier caractère de la chaîne entrée et prépare le drapeau Z (HL pointe un octet avant le buffer d'acquisition)
$279b       Sauvegarde le pointeur sur le texte BASIC.
$279c       Si le buffer était vide, branche pour ignorer le reste de l'instruction. Cela signifie que la ou les variables d'`INPUT` ne sont pas touchées.
$279f       %CHAR
            Dans le cas contraire, on ',' en caractère avant les données entrées. Cela permet d'utiliser la routine de `READ`.
$27a1       Continue vers la lecture de `DATA` par `READ`.

$27a3       [inst_read]
            %CODE,%MS_BASIC(READ)
            Instruction BASIC : READ

$27a3       Sauvegarde du pointeur vers le texte BASIC.
$27a4       HL pointe vers la prochaine zone de `DATA`.
$27a7       Initialise A avec $af pour signaler l'instruction `READ` à `(flginp)`. Saute par dessus le `xor a`.

$27a8       [read_data]
            %MS_BASIC(NXTITM)
$27a8       A = 0, pour signaler l'instruction `INPUT` à `(flginpu)`.
$27a9       Si A == 0, on est dans INPUT, sinon, on est dans READ. `(flginp)` porte plutôt mal son nom et devrait plutôt s'appeler `read drapeau`.
$27ac       HL = pointeur sur le texte BASIC, haut de la pile = pointeur vers les DATA (pour `READ`) ou le buffer d'acquisition (pour `INPUT`)
$27ad       Saute par dessus le teste de présence de ','.

$27ae       [data_loop]
$27ae       Vérifie la présence d'une virgule dans le texte BASIC. Sauf la première fois. C'est la virgule qui sépare les variables.
$27af       %DATASKIP
$27b0       Lecture d'un nom de variable. Retour dans DE.
$27b3       HL = pointeur vers les données, haut de la pile = pointeur vers le texte BASIC.
$27b4       Sauve le pointeur vers la variable sur la pile.
$27b6       %CHAR
$27b5-$27b8 Branche si le prochain caractère des données est ','.
            C'est pour cela que le buffer pour INPUT est amorcé avec un ','.
$27ba-$27be Branche pour l'instruction `READ`
$27c1       %CHAR
$27c1-$27c4 Il manque des données, lance une nouvelle acquisition de données.
            Le code ici est patché en ROM 1.1 pour indiquer que l'on est dans une instruction `INPUT`.
$27c7       Récupération du pointeur vers variable
$27c8       Récupération du pointeur sur le texte BASIC
$27c9       Branche en cas d'interruption de commande.
$27cc-$27cf Prépare le test du prochain caractère comme étant nul.
$27d0       Sauvegarde le pointeur sur le texte BASIC.
$27d1       Fin de ligne lors d'un `INPUT`, ignore le reste de l'instruction et cherche la suivante. Les variables non traitées ne sont pas modifiées.
$27d4       Sinon, il y a des données, sauve le pointeur vers la variable.

$27d5       [get_value]
$27d5       %MS_BASIC(ANTVLU)
$27d5-$27d9 Branche si la variable est de type numérique.
$27db       Sinon, lit le prochain caractère
$27dc-$27dd Copie le caractère dans D et B
$27de       %CHAR
$27de-$27e0 Branche si le premier caractère est '"', il s'agit d'un littéral
$27e2-$27e5 Prépare les cas  `INPUT`/`READ`
$27e6       Dans le cas `INPUT`, A, et donc D, contiendront 0. D marque la fin des données.
$27e7       Branche dans le cas `INPUT`.
$27e9       %CHAR
$27e9       Sinon, dans le cas `READ`, D est ':'. D marque la fin de instruction `DATA` et donc des données (0 est toujours cherché, quoi qu'il arrive).

$27eb       [data_sep]
$27eb       %CHAR
            B == ',', séparateur de données.
$27ed       Recalage de HL, au cas où le premier caractère n'était pas '"'.

$27ee       [lit_string]
$27ee       Lecture d'une chaîne de caractères terminée par l'un des caractères dans B et D.
$27f1       DE = pointeur sur la chaîne de caractères.
$27f2-$27f5 L'adresse de retour est fixée par HL, HL récupère l'adresse des données.
$27f6       Sauve le pointeur sur la chaîne de caractères lue.
$27f7       Tout est prêt pour l'assignation de la variable alphanumérique. Le retour se fera à l'adresse juste spécifiée, partie commune avec la lecture d'une donnée numérique.

$27fa       [num_data]
$27fa       Lecture de la virgule et se positionne sur le premier caractère intéressant.
$27fb       Lecture de la donnée sous forme d'un nombre.
$27fe       HL = pointeur vers la variable, haut de la pile = pointeur vers les données.
$27ff       Assigne la valeur lue dans FAC à la variable pointée par HL.
$2802       Récupération du pointeur vers les données.
$2803       [next_comma]
$2803-$2804 Lecture du caractère suivant de buffer de données.
$2805       Branche si le buffer données est vide
$2807       %CHAR
$2807-$2809 Branche si le caractère lu n'est pas ",".

$280c       [empty_data]
$280c       HL = pointeur sur le texte BASIC, haut de la pile = pointeur vers les données.
$280d-$280f Branche s'il reste des variables à traiter pour `INPUT` ou `READ`.
$2811       Récupération du pointeur vers les données.
$2812-$2815 Préparation du cas `INPUT` ou `READ`.
$2816       HL = pointeur vers les données, DE = pointeur vers le texte BASIC.
$2817       Branche dans le cas `READ`
$281a       Sinon, cas `INPUT`, sauvegarde le pointeur vers le texte BASIC.
$281b       Comme le cas est `INPUT` (A = 0), cela donne A = (HL). Ce qui prépare le drapeau Z pour conditionner l'affichage du message qui suit.
$281c-$2826 Pointe vers le message "Extra ignored" en fonction de la langue du système.
$2829       [ignore_fr]
$282a       S'il restait des données (drapeau Z à 0), affiche le message.
$282d       Restauration du pointeur d'exécution

$282f       [go_nxt_data]
$282f       Avance jusqu'à la prochaine instruction.
            %MS_BASIC(FDTLP)
$2832-$2833 Branche si ce n'est pas la fin de la ligne.
$2835-$2838 Sinon, vérifie si le chaînage de la ligne suivante est nul.
$2839-$283b Si oui, sors avec une erreur "Out of DATA".
$283e-$2842 Sinon, lit le numéro de ligne dans DE et l'inscrit dans `(datlin)`.charge la ligne de DATA courante.

$2846       [test_data]
$2846-$2849 Boucle si l'instruction suivante n'est pas DATA. Jusqu'à en trouver une ou sortir avec l'erreur précédente.
$284b       HL pointe vers la prochaine zone de données, retour à l'assignation.

$284d       [eval_num_ex]
            Évalue une expression et vérifie que le résultat est numérique.

            Entrée :
            - HL pointe sur une zone texte BASIC

            Sortie :
            - Résultat dans FAC, si l'expression était numérique.
$284d       Lecture d'une expression.

$2850       [type_eq_num]
            Vérifie que le type évalué est de type numérique.

            `(valtyp)` a dû être assigné au préalable.
$2850       Le `or $37` a pour but de passer le Carry à 0 et de sauter par dessus l'instruction `scf`.

$2851       [type_eq_str]
            Vérifie que le type évalué est de type chaîne de caractère.

            `(valtyp)` a dû être assigné au préalable.
$2851       Place le Carry à 1.

$2852       [type_eq_chk]
            %MS_BASIC(CHKTYP)
            Vérifie que deux types de variables sont égaux.

            Entrée :
            - Carry porte le premier type, 0 = numérique, 1 = chaîne de caractères
            - `(valtyp)` porte le second type, 0 = numérique, 1 = chaîne de caractères

            Sortie :
            - Si les deux types sont égaux, la routine revient.
            - Si les deux types diffèrent, la routine branche sur une erreur "Opérande mal adaptée"

$2852       Charge le type de l'expression la plus récemment évaluée.
$2855       Double sa valeur et ajoute la retenue (Carry).
$2856       Met en place les drapeaux.
$2857       Retour si le résultat est pair (0 pour deux numériques, ou 2 pour deux chaînes).
$2858       Branche sur l'erreur sinon.
$285b       4 octets inutilisés.

$285f       [paren_expr]
            Appelé lorsque l'on débute l'analyse d'une sous-expression entre parenthèses.

$285f       S'assure de la présence d'une parenthèse.
$2860       %DATASKIP

$2861       [read_expr]
            %MS_BASIC(EVAL)
            Lecture et évaluation d'une expression.

            Entrée :
            - HL pointe vers un texte BASIC

            Sortie :
            - FAC contient le nombre si l'expression est numérique.
            - FAC contient un descripteur de chaîne si l'expression est alphanumérique.

            Lorsqu'un opérateur est analysé, sont ajoutés sur la pile :
            - une adresse de retour (eval_2) qui sera utilisée par le `ret` de l'opérateur.
            - le premier paramètre de l'opérateur sous forme BCDE.
            - l'adresse d'exécution de l'opérateur.

$2861       Recalage du pointeur de texte BASIC.
$2862       La priorité actuelle d'opérateur est dans D.

$2864       [eval_1]
$2864       Sauve la priorité actuelle.
$2865-$2867 Vérification qu'il est possible d'ajouter 1 niveau (C) sur la pile
$286a       Lecture de la prochaine valeur.
$286d       [eval_1b]
$286d       Sauve le pointeur de texte BASIC.
$2870       [eval_2]
$2870       Récupère le pointeur de texte BASIC.
$2873       Récupère la priorité actuelle.
$2874-$2875 Comparaison avec la priorité de AND et OR
$2877       La priorité est au moins $78, vérification que l'on cherche un type numérique (d'après `(valtyp)`). Si on revient, c'est que c'était le cas.
$287a       Lecture dans A de l'octet suivant.
$287b       Sauve le pointeur vers le texte BASIC
$287e       $b9 est le token pour '+', qui est aussi le premier token des opérateurs.
$2880       Retour si l'octet lu est inférieur au token de '+', ce qui signifie que ce n'est pas un opérateur.
$2881       $c3 est le code de `SGN`, le token de première fonction prédéfinie.
$2883       Retour si l'octet lu fait partie des fonctions prédéfinie, ce qui signifie que ce n'est pas un opérateur.
$2884       Les trois derniers opérateurs sont les opérateurs relationnels : $c0 '>', $c1 '=', $c2 '<'.
$2886       Branche dans le cas d'un opérateur relationnel.
$2888-$288a E prend l'index de l'opérateur.
$288b       Branche si l'opérateur n'est pas '+'.
$288d-$2890 Z à 1 en cas de type chaîne de caractères.
$2891       A prend l'index de l'opérateur.
$2892       Branche si l'opérateur est '+' et que le type est chaîne de caractères. C'est une concaténation de chaînes.

$2895       [not_concat]
$2895-$2897 E prend l'index de l'opérateur multiplié par 3. Chaque entrée de la table comporte sa priorité suivi de l'adresse d'exécution de sa routine.
$2898       Charge la table des priorités
$289b-$289d Pointe vers le bon index de la table des priorités.
$289e       Sauve la priorité courante.
$289f       Récupère la priorité de l'opérateur.
$28a0       Compare les priorités.
$28a1       Si la nouvelle priorité est plus petite, le `ret` provoque le retour vers l'exécution de l'opérateur précédent.
$28a2       Sinon, HL pointe sur l'adresse de l'opérateur.
$28a3       Vérifie que le type est numérique.
$28a6       [op_stack]
$28a6       Sauve la priorité actuelle B.
$28a7-$28aa Sauvegarde de l'adresse de retour pour l'exécution de cet opérateur.
$28ab-$28ac Sauve le token (E) ainsi que sa priorité (D) dans BC
$28ad       Pousse la valeur de FAC sur la pile pour continuer la construction du bloc pour l'opérateur.
$28b0-$28b1 Restaure le token (E) ainsi que sa priorité (D) depuis BC
$28b2-$28b5 Récupère l'adresse d'exécution de l'opérateur dans BC.
$28b6       Met cette adresse sur la pile pour compléter le bloc pour l'opérateur.
$28b7       Restaure le pointeur vers le texte BASIC.
$28ba       Boucle sur la suite de l'analyse.

$28bd       [eval_comp]
            Évaluation d'un opérateur relationnel.

            Entrée :
            - A contient l'un de '>', '=', '<'

            Sortie :
            - D est l'addition des différents signes trouvés. '>' = 1, '=' = 2, '<' = 4.

            Par exemple, '>=' donne 3.

$28bd       Initialise la détection de opérateurs à deux caractères ('<=', '>=' et les autres)
$28bf       [comp_loop]
$28bf-$28c1 Branche si A est avant '>' (pas possible au premier passage)
$28c4-$28c6 Branche si A est après '<' (pas possible au premier passage)
$28c9       Compare avec '='. Carry sera mis à 1 pour '>', 0 dans les autres cas.
$28cb       Ce qui donne au final b11 pour '>', b10 pour '=' et b00 pour '<'.
$28cc       À la première boucle, A n'est pas changé (car D est à $00).
            En seconde boucle, tous les doublons (>>, << et ==) donnent $00, '<=' et '=<' donnent b01, '>=' et '=>' donnent b10
$28cd       Compare A et D
$28ce       À la première boucle, le caractère est mis dans D.
            À la seconde boucle, peu importe.
$28cf       À la première boucle, A ne peut pas être inférieur à D.
            Lors de la seconde, si A est inférieur à D, alors c'est une erreur de syntaxe.
$28d2       Le pointeur vers le texte BASIC est ajusté.
$28d5       Lecture du caractère suivant.
$28d6       Boucle sur le second caractère de la paire possible.

$28d8       [parse_value]
            %MS_BASIC(OPRND)
            Analyse une valeur.

            Entrée :
            - HL pointe vers le texte BASIC

            Cette valeur peut être numérique, alphanumérique, ou bien une fonction prédéfinie ou utilisateur.

$28d8-$28d9 Par défaut, le type est numérique.
$28dc       Lecture du prochain caractère significatif.
$28dd       Émet une erreur d'opérande manquante si le buffer est terminé.
$28e0       Branche si le caractère est un chiffre.
$28e3       %CHAR
$28e3-$28e5 Branche si c'est le début d'un nombre en hexadécimal, qui commence par "&"
$28e8-$28eb Branche si le caractère est entre 'A' et 'Z', c'est une variable.
$28ed-$28ef Le token pour '+' est ignoré car pris pour un opérateur unaire.
$28f1       %CHAR
$28f1-$28f3 C'est un nombre sans partie entière. Sauf pour analyse d'un nombre.
$28f6-$28f8 Token pour '-', c'est un nombre négatif. Saut pour analyse de l'opposé d'un nombre.
$28fa       %CHAR
$28fa-$28fc C'est une chaîne de caractères délimité par "
$28ff-$2901 Token pour 'NOT'. Branche sur l'évaluation d'un `NOT`.
$2904-$2906 Token pour 'FN'. Brance sur l'évaluation d'une fonction utilisateur.
$2909-$290b $c3 est le token pour `SGN`, la première des fonctions prédéfinies. Si le token est supérieur ou égal, branche vers á l'évaluation d'une fonction prédéfinie.
$290d       [eval_paren]
$290d       Le dernier choix possible est celui d'une sous-expression entre parenthèses.
            Appel de l'évaluation d'une expression qui doit commencer par une parenthèse ouvrante.

            Est aussi appelé comme sous-routine directement, pour évaluer une expression entre parenthèses, incluant les paramètres de fonctions.

$2910       Vérification de la parenthèse fermante associée.
$2911       %DATASKIP
$2912       Fin de l'évaluation de l'expression entre parenthèse. Le résultat est dans FAC.

$2913       [inst_minus]
            Évaluation de '-' comme opérateur unaire.

            Entrée :
            - HL pointe vers l'expression en cours.

            Sortie :
            - FAC contient l'évaluation de l'expression.
            - HL pointe vers la suite de l'expression.

$2913       Charge la priorité de l'opérateur unaire '-' dans D.
$2915       Puis évalue l'expression. Le retour se fera lorsqu'un opérateur de moins forte priorité sera trouvé (ou en fin d'expression).
$2918       Récupère le pointeur sur le texte BASIC.
$291b       Sauvegarde de ce pointeur sur la pile.
$291c       Prend l'opposé de FAC dans FAC.
$291f       [ret_num]
$291f       Vérifie que le type évalué est numérique.
$2922       Restaure le pointeur sur le texte BASIC.

$2924       [str_to_var]
            Charge dans FAC la valeur d'une variable indiquée dans le buffer de texte BASIC.

            Entrée :
            - HL pointe vers l'expression en cours.

            Sortie :
            - FAC contient la valeur de l'expression numérique ou le pointeur vers la chaîne de caractères.
            - HL pointe vers la suite de l'expression.

$2924       DE pointe sur l'adresse de la variable.
$2927       [from_eval]
$2927       Sauve le pointeur vers le texte BASIC.
$2928       HL = adresse de la variable, DE = peu importe
$2929       Sauve l'adresse de la variable dans les deux octets les moins significatifs de FAC.
$292c-$2930 Si le type de la variable est numérique, monte la valeur pointée par HL, le contenu de la variable numérique, dans FAC.
$2933       Restaure le pointeur vers le texte BASIC.

$2935       [function]
            %MS_BASIC(FNOFST)
            Exécute le code d'une fonction BASIC prédéfinie.

            Entrées :
            - A contient l'index de la fonction, basé sur `SGN` = 0.
            - HL pointe vers l'expression en cours.

            Sortie :
            - FAC contient la valeur de sortie de la fonction.
            - HL pointe vers la suite de l'expression.

$2935       Prépare l'index dans le tableau des fonctions.
$2937       Double l'index de la fonction.
$2938       BC = index de la fonction multiplié par 2, ce qui donne son offset.
$2939       Sauvegarde de l'offset dans le tableau.
$293a       Permet de se placer au niveau de la parenthèse après le nom de la fonction.
            Cela permet d'utiliser l'évaluation d'une expression entre parenthèses pour évaluer l'argument de la fonction.
$293b-$293e Branche si la fonction est `CHR$` ou avant.
            Les fonctions qui suivent sont les fonctions de traitement de chaînes de caractères qui ont plusieurs paramètres.
            Toutes les fonctions qui les précèdent ont un seul paramètre.
$2940       Sinon, c'est une fonction alphanumérique avec plusieurs paramètres. Évaluation du premier paramètre.
$2943       Vérification que le caractère suivant est ','
$2944       %DATASKIP
$2945       Le premier paramètre doit être alphanumérique.
$2948       Sauve le pointeur vers le texte BASIC.
$2949       HL = adresse du descripteur de la chaîne évaluée en premier paramètre.
$294c-$294d Que l'on place sous l'offset de la fonction dans la pile.
$294e       Restaure le pointeur vers le texte BASIC.
$294f       Évaluation du second paramètre, de type entier sur 8 bits.
$2952       DE = pointeur vers le texte BASIC, HL = entier évalué en second paramètre.
$2953       HL = offset de la fonction doublé, Haut de la pile = second paramètre.
$2954       Branche sur l'exécution de la fonction.
            Sur la pile se trouve :
            - la valeur du second paramètre.
            - le pointeur vers le descripteur de la chaîne en premier paramètre.

$2956       [eval_func]
$2956       Évaluation du premier et seul paramètre de la fonction.
$2959       HL = index doublé, Haut de la pile = pointeur vers le texte BASIC
$295a-$295d Prépare l'adresse de retour pour le prochain `ret` comme retour d'une fonction numérique.

$295e       [exec_func]
$295e-$2961 HL pointe dans le tableau d'adresse des fonctions celle correspondant à l'index
$2962-$2965 HL = adresse de la routine pour la fonction.
$2966       Branche vers l'exécution de la fonction prédéfinie.

$2967       [exp_sign]
            %MS_BASIC(SGNEXP)
            Retourne le signe du caractère ou token présent dans A.

            Entrées :
            - D = 0
            - A est le dernier caractère lu depuis le buffer d'analyse du nombre

            Retour :
            - HL pointe sur l'octet suivant à lire.
            - D = $ff si le signe est négatif
            - D = $00 si le signe est positif
            - Z à 1 si un signe était spécifié, à 0 sinon.

$2967       D = $ff
$2968-$296a Retour immédiat si l'octet lu est le token du signe '-'.
$296b       %CHAR
$296b-$296d Retour immédiat si l'octet lu est le caractère '-'.
$296e       D = 0
$296f       %CHAR
$296f-$2971 Retour immédiat si l'octet lu est le caractère '+'
$2972-$2974 Retour immédiat si l'octet lu est le token du signe '+'
$2975       Ce n'était pas un signe, recale HL, pointeur sur le texte analysé.


$2977       [fp_bcde_or]
            %CODE,%MS_BASIC(POR)
            Opérateur BASIC `OR`.

            Appelé lors de l'évaluation d'une expression via la table de priorités.

$2977       Marqueur pour le traitement de `OR`. A n'est pas 0.
$2978       [fp_bcde_and]
            %CODE,%MS_BASIC(PAND)
            Opérateur BASIC `AND`.

            Appelé lors de l'évaluation d'une expression via la table de priorités.

$2978       %CODE
            Marqueur pour le traitement de `AND`. A = 0
$2979       Sauve le marqueur de l'opérateur `OR` ou `AND`.
$297a       Le type de l'expression calculée doit être numérique, ou bien c'est une erreur.
$297d       Récupère FAC en tant qu'entier dans DE.
$2980       Récupère le marqueur de l'opérateur.
$2981       HL = valeur entière de l'expression, DE = pointeur vers le texte BASIC.
$2982-$2984 Récupère BCDE depuis la pile, qui contient l'autre argument de l'opérateur. Le premier argument se retrouve en haut de la pile.
$2985       Monte BCDE dans FAC.
$2988       Sauve le marqueur de l'opérateur.
$2989       Récupère FAC en tant qu'entier dans DE. On a donc un argument dans DE et l'autre en seconde position sur la pile.
$298c       Récupère le marqueur de l'opérateur.
$298d       Récupère l'autre argument.
$298e       Monte le LSB de BC dans A.
$298f       Prépare le branchement à la fin du traitement de l'opérateur.
$2992       Branche si l'opérateur est `OR`.
$2994-$2997 AC = BC & DE
$2998       Monte AC dans FAC et termine l'instruction.

$2999       [oper_or]
$2999-$299c AC = BC | DE
$299d       Monte AC dans FAC et termine l'instruction.

$299e       [relation_op]
$299e       Prépare l'adresse de retour si un bloc d'évaluation est poussé sur la pile.
            Comme la construction du bloc prend un pointeur vers une adresse, HL pointe vers une indirection vers la routine elle-même.
$29a1-$29a4 Récupère le type de l'évaluation. Carry à 0 signifie numérique ; chaîne de caractères sinon.
$29a5-$29a7 Place dans E l'opérateur décalé d'un bit vers la gauche avec le type de donnée en bit 0.
$29a8-$29ac Retour si la priorité est plus faible que $64.
$29ad       Sinon, met un nouveau bloc à évaluer sur la pile pour délayer la comparaison.

$29b0       [comp_addr]
$29b0       Adresse de la fonction qui suit, afin de pouvoir construire le bloc d'évaluation à dépiler ci-dessus.

$29b2       [compare]
            %CODE
$29b2-$29b4 L'opérateur et le type de donnée initialement dans C sont décompressés pour ramener le type de donnée dans Carry et l'opérateur tel que calculé initialement.
$29b5-$29b6 Récupère le premier argument de comparaison dans BCDE.
$29b7       Sauve l'opérateur et le type de donnée dans la pile.
$29b8       Vérifie que le type des deux arguments sont les mêmes, ou provoque une erreur.
$29bb-$29be L'adresse de retour sera la routine de résultat de la comparaison.
$29bf       Branche vers la comparaison de nombre si le type est numérique.
            La routine se terminant par des `ret`, la continuité se fera dans l'adresse poussée dans la pile juste au-dessus.
$29c2-$29c3 La comparaison de chaîne de caractères donne une valeur numérique, l'indique dans `(valtyp)`.
$29c6       Branche sur la comparaison de chaînes de caractères.

$29c9       [cmp_result]
            %CODE

            Calcul pour la sortie des opérateurs de comparaison.

            Entrée :
            - A contient un résultat de comparaison.

$29c9-$29ca Transforme le résultat de comparaison en opérateur équivalent.
            Si la relation était '<', alors A = $FF et Carry 1, au final, A = 1
            Si la relation était '=', alors A = $00 et Carry 0, au final, A = 2
            Si la relation était '>', alors A = $01 et Carry 0, au final, A = 4
$29cb       Dans B, récupère l'opérateur de la comparaison en court.
$29cc       Vérifie ce que la relation calculée a en commun avec l'opération demandée.
$29cd-$29cf Si A était à 0 (pas de relation commune), alors le résultat est $00
            Si A était différent de 0 (une relation commune au moins), alors le résultat est $FF
$29d0       A devient le résultat de la fonction en étant transféré dans FAC.

$29d3       [inst_not]
$29d3       Charge la priorité pour l'opérateur NOT.
$29d5       Lance une évaluation qui sortira et reviendra lorsqu'une priorité d'opérateur plus faible sera rencontrée.
$29d8       Vérifie le type numérique de la valeur obtenue.
$29db       Récupère FAC dans DE sous forme entière.
$29de-$29e2 Met dans AC la négation de DE.
$29e3       Monte AC dans FAC.
$29e6       Nettoie la pile.
$29e7       Continue l'évaluation.

$29ea       [inst_fre_2]
$29ea-$29ee AC = HL - DE, puis met le résultat dans FAC.

$29ef       [ac_to_fac]
$29ef       Copie C dans B, puis continue vers le transfert de AB vers FAC.

$29f0       [ab_to_fac]
$29f0       Met B dans D au format flottant BADE.
$29f1       Met E à 0.
$29f3-$29f6 Indique une valeur numérique.
$29f7       Place l'exposant $80+$10 dans le format BADE.
$29f9       Cela monte au final dans FAC le nombre entier initialement contenu dans la paire AB.

$29fc       [inst_lpos]
            %CODE
            Fonction BASIC : LPOS()

            La fonction LPOS retourne le numéro de colonne actuelle de l'imprimante.
            L'argument est ignoré.
$29fc       Récupère le numéro de colonne actuel de l'imprimante.
$29ff       Le retourne en tant que résultat de fonction.

$2a01       [inst_pos]
            %CODE
            Fonction BASIC : POS()

            La fonction POS retourne le numéro de colonne actuelle à l'écran.

            Si l'argument est 255, alors la fonction retourne plutôt le numéro de ligne actuelle à l'écran.
$2a01       Récupère l’argument en tant qu'entier 8 bits dans A.
$2a04       Incrémente A.
$2a05       Branche si le résultat est 0 (l’argument était 255)
$2a07-$2a0a Sinon, renvoie le numéro de colonne comme résultat.

$2a0c       [inst_posy]
$2a0c       Charge le numéro de ligne puis continue sur le retour de fonction avec résultat dans A.

$2a0f       [retfun_impl]
            Place A dans FAC.

            Appelé par les fonctions, donc le résultat est dans A.

            Entrée :
            - A contient la valeur de retour de la fonction.

            Note : il existe une autre routine un peu différente qui place A dans FAC (`a_to_fac`)
$2a0f-$2a10 Construit AB.
$2a11       Monte AB vers FAC.

$2a13       [inst_def]
            %CODE,%MS_BASIC(DEF)
            Instruction BASIC : DEF

            Définition d'une fonction utilisateur.

$2a13       Vérifie que l'on a affaire à une fonction (et définie l'entrée)
$2a16       Cette instruction ne peut pas être appelée en direct.
$2a19-$2a1c Prépare la valeur de retour, qui amènera à la prochaine instruction.
$2a1d       Sauve l'adresse de l'identifiant de fonction.
$2a1e       DE = 0
$2a21-$2a24 Branche si le caractère suivant n'est pas une parenthèse ouvrant.
            Dans cette version du BASIC, il n'est pas obligatoire de spécifier une variable locale.
            Dans ce cas, la variable sera prise dans le contexte global.
$2a26       Lit le caractère et avant d'un octet.
$2a27       Récupère l'identifiant (un nom de variable) en paramètre de la définition.
            `(subflg)` contient toujours $80, ce qui interdit l'utilisation d'un nom de tableau.
$2a2a       Sauve le pointeur vers le texte BASIC.
$2a2b       HL = pointeur sur la variable paramètre
$2a2c-$2a2f Lecture du nom du paramètre dans DE.
$2a30       Restaure le pointeur vers le texte BASIC.
$2a31       Vérifie que le paramètre est bien numérique.
$2a34       Le caractère suivant doit être une parenthèse fermante.
$2a35       %DATASKIP
$2a36       [no_param]
$2a36       Le caractère suivant doit être le token pour `=`.
$2a37       %DATASKIP
$2a38-$2a39 Copie le pointeur de texte BASIC dans BC.
$2a3a       HL = pointeur vers le descripteur de la fonction, Haut de la pile = pointeur sur le texte BASIC.
$2a3b-$2a3d Les deux premiers octets du descripteur de fonction pointent vers le texte BASIC décrivant la fonction.
$2a3e       Les deux octets suivant prendront la valeur de DE, c'est-à-dire le nom du paramètre.

$2a41       [inst_fn]
            Fonction BASIC : FN

            Exécute une fonction définie par `DEF FN`.

            Note : le contexte local de la fonction est traité dans la récupération de la variable.
            Un test y est fait pour vérifier si le nom de la variable est égal à celui dans `(prmnam)`.
            Si c'est le cas, alors DE est placé sur `(prmval)`.

            Pour traiter la valeur du paramètre, c'est dans la récupération de la variable qu'un test
            est fait entre le nom de la variable en cours en prmnam. Si c'est égal, la valeur prise
            l'est depuis `(prmval)`.

$2a41       Vérifie que ce qui suit est le nom de fonction.
$2a44       Sauve le pointeur vers le descripteur de fonction.
$2a45       Évaluation de l'expression argument de la fonction.
$2a48       Cette expression doit être numérique.
$2a4b       HL = pointeur sur le descripteur de la fonction, Haut de la pile = pointeur vers le texte BASIC.
$2a4c-$2a4f DE pointe vers le texte BASIC au niveau de la définition de la fonction (les deux premiers octets du descripteur).
$2a50-$2a52 Si le pointeur était nul, cela signifie que la fonction n'était pas définie. Branche vers une erreur.
$2a55-$2a58 HL = nom de la variable paramètre de la fonction.
$2a59       Le nom de la variable paramètre de la fonction est mise sur la pile.
$2a5a-$2a5d Sauve le nom actuellement dans `(prmnam)` sur la pile, afin de permettre des sous appels de fonction.
$2a5e       Place le nom du paramètre de la fonction dans `(prmnam)`.
$2a61-$2a68 Sauve la valeur actuellement dans `(prmval)`
$2a69       HL pointe sur `prmval`.
$2a6c       Sauve DE, le pointeur vers le texte BASIC de la fonction.
$2a6d       Sauve FAC, qui contient l'évaluation de l'argument de la fonction, dans `(prmval)`.
$2a70       Restaure le pointeur vers le texte BASIC vers HL.
$2a71       Lance l'évaluation du texte BASIC au niveau de la définition de la fonction.
$2a74       Recale le pointeur vers le texte BASIC de la fonction.
$2a75-$2a76 Branche vers une erreur de syntaxe si le dernier caractère lu n'est pas une fin de ligne ou d'instruction.
$2a79-$2a7e Replace l'ancienne valeur de paramètre de fonction dans `(prmval)`.
$2a81-$2a82 Replace l'ancien nom de paramètre de fonction dans `(prmnam)`.
$2a85       Restaure le pointeur vers le texte BASIC.

$2a87       [ill_direct]
            %MS_BASIC(IDTEST)
            Routine appelée pour vérifier qu'une instruction n'a pas été appelée en mode direct.

            Lance une erreur dans le cas contraire.
$2a87       Sauve le pointeur vers le texte BASIC.
$2a88-$2a8b HL = numéro de la ligne courante + 1
$2a8c-$2a8d A = 0 si le numéro de la ligne courante était $ffff (valeur en mode direct)
$2a8e       Restaure le pointeur vers le texte BASIC.
$2a8f       Retour si la ligne courante n'était pas $ffff.
$2a90-$2a92 Branche sur une erreur "Illegal direct" dans le cas contraire.

$2a95       [check_fn]
            Vérifie que ce qui est pointé par HL est un identifiant valide de nom de fonction utilisateur.

            Entrée :
            - HL pointe vers le texte BASIC au niveau du token `FN`

            Sortie :
            - DE pointe vers le descripteur de fonction. Si la fonction n'existait pas, l'entrée est vide.

$2a95       Vérifie que l'octet suivant pointé par HL est le token pour `FN`.
$2a96       %DATASKIP
$2a97-$2a99 Signale à la recherche d'identifiant que les tableaux sont interdits dans ce contexte.
$2a9c       A contient le caractère suivant avec le bit 7 à 1
$2a9d       Les identifiant de fonctions ont leur premier octet avec le bit de poids fort à 1 en interne.
            Prépare la lecture de ce nom en lisant le premier caractère et profite que A soit à $80.
$2a9e       Récupère l'entrée associée.
$2aa1       Les fonctions ne peuvent être que numériques.

$2aa4       [preget_byte]
            Appelle la fonction de récupération d'un entier depuis le pointeur vers le texte BASIC avec une lecture préalable d'un octet.

            Appelé par `SPC(` et `TAB(` dans une instruction `PRINT` afin d'ignorer la parenthèse ouvrante.

$2aa5       [getbyt_impl]
            %MS_BASIC(GETINT)
            Évalue une expression depuis un buffer texte BASIC et en retourne une valeur entière sur 8 bits.

            Provoque une erreur si l'entrée est trop grande.

            Entrée :
            - HL pointe sur la zone de texte BASIC

            Sortie :
            - A contient l'évaluation de l'expression
            - Les drapeaux sont placés en fonction de la lecture du caractère suivant l'expression.

$2aa5       Évalue l'expression pointée par HL

$2aa8       [to_int]
$2aa8       Récupère l'expression en tant qu'entier positif dans DE (a provoqué une erreur si l'expression était négative).
$2aab-$2aad Si D n'est pas nul, c'est que le nombre est trop grand. Branche vers une erreur.
$2ab0-$2ab1 Sinon, relis le dernier caractère de l'expression.
$2ab2       Place le résultat dans A.

$2ab4       [inst_peek]
            %CODE
            Fonction BASIC : PEEK

$2ab4       Récupère l'expression en argument de PEEK sous forme d'entier sur 16 bits dans DE.
$2ab7       Lit l'octet à l'adresse correspondante.
$2ab8       Retourne A comme résultat de la fonction.

$2abb       [inst_poke]
            %CODE
            Instruction BASIC : POKE
$2abb       Récupère dans DE le premier argument de POKE, qui est l'adresse.
$2abe       Sauve l'adresse.
$2abf       Vérifie que ce qui suit est une virgule.
$2ac0       %DATASKIP
$2ac1       Récupère dans A le second argument de POKE, qui est la valeur.
            Dans la ROM 1.0, la routine appelée retourne le résultat dans E, ce qui oblige un `ld a,e` supplémentaire.
$2ac4       Restaure l'adresse.
$2ac5       Place A dans l'adresse spécifiée.

$2ac7       Quatre octets inutilisés, reliquat du patch de l'instruction `POKE` en ROM 1.1.

$2acb       [poke_addr]
            %CODE
            Routine de récupération du premier argument pour `POKE`.
            Cette routine est séparée de la routine pour l'instruction pour une raison inconnue.

            Cette routine n'est pas appelée dans la ROM 1.0 certainement par erreur.
            Dans la ROM 1.1, elle est bien appelée par la routine pour `POKE`, mais une
            seule fois, ce qui laisse entière la question : pourquoi une routine
            séparée ?

$2acb       Lit l'expression pointée par HL
$2ace       Sauve le pointeur vers le texte BASIC.
$2acf       Récupère la valeur sous forme entière positive dans DE.
$2ad2       Restaure le pointeur vers le texte BASIC.

$2ad4       [acq_key]
            $SECTION(te)
            == DEBUT DE SECTION TE (TEXT EDITOR) ==
            Décode une touche du clavier.

            Affiche sa valeur à l'écran en traitant les touches spéciale.
            Dans le cas d'un traitement pour la commande INPUT, ignore certaines touches (haut, bas, LIST, EFFE,...)

            Les touches haut et bas ont un traitement spécial lorsqu'une LIST est en train d'être éditée.

            Les codes non filtrés sont envoyés à `outdo` pour traitement par le périphérique de sortie.

            Si une touche a été traitée, provoque un rafraîchissement de l'écran et renvoie 0 dans A.

            Sortie :
            - A est à 0 si aucune touche n'a été appuyée ou si elle a été traitée.
            - A est $0d si la touche ENTREE a été appuyée.

$2ad4-$2ad6 Sauve BC, DE et HL sur la pile.
$2ad7-$2adc Branche si une ligne a été validée par le moniteur (que ce soit en direct ou dans une instruction `INPUT`).
$2adf       Attente d'une interruption
$2ae0       Décode une touche du clavier.
$2ae3-$2ae4 Branche si aucun caractère n'a été validé.
            La routine ayant déjà fait `or a`, celui-ci semble inutile.
$2ae6       A contient la touche appuyée, Z correspond à A et M est à 1 si la touche est une touche de fonction.
            Pousse le tout sur la pile.
$2ae7       Bascule sur les registres alternatifs.
$2ae8-$2aeb Configure le son émis lors de l'appui d'un caractère.
$2aee       Pendant une durée très courte.
$2af1       Émet le son.
$2af4-$2afb Active la continuité des lignes logiques.
            Les deux `NOPs` sont un patch de la ROM 1.0 qui désactivait le défilement de l'écran.
$2afe       Restaure AF, touche appuyée et drapeaux.
$2aff       Branche si la touche validée était une touche de fonction.
$2b02       Comparaison de la touche appuyée avec la touche Entrée.
$2b04       Il s'agit de code patché par rapport à la ROM 1.0, on branche donc plus loin avant de revenir juste après.

$2b07       [acq_key_3]
            Suite du traitement de l'appui de touche, si la boucle BASIC est active.

$2b07-$2b09 Branche pour traiter la touche Déplacement vers le haut.
$2b0c-$2b0e Branche pour traiter la touche Saut de ligne.
$2b11-$2b13 Branche pour traiter la touche `LIST`.
$2b16       Poursuit le traitement de l'acquisition d'une touche appuyée.

$2b19       Octet inutilisé du au patch de la ROM 1.1

$2b1a       [key_effe]
            La touche EFFE a été appuyée
$2b1a-$2b1f Branche si le drapeau de commande INPUT est activé.
$2b21       Sinon, remet la valeur $1f dans la touche appuyée.

$2b23       [key_out]
$2b23       Au final, la touche appuyée est émise vers le périphérique sélectionné.

$2b24       [acq_sync]
$2b24-$2b2c Force un affichage à la prochaine interruption et attend la prochaine interruption.

$2b2d       [key_nul_ret]
            Efface la valeur de la touche activée.

            La touche a été soit affichée, soit traitée en tant que touche spéciale,
            soit est annulée car la touche n'a pas d'effet (dans une commande INPUT par exemple).

$2b2e       [key_acq_end]
$2b2e-$2b31 Restaure les registres en fin de traitement d'acquisition d'une touche de clavier.

$2b32       [bufferstart]
            Une ligne vient d'être validée par le moniteur BASIC, que ce soit en direct ou dans une instruction `INPUT`.
$2b32       Coordonnées de la ligne BASIC à décoder. H contient la ligne à l'écran, L est à 0.
$2b35       Copie du numéro de ligne dans A.
$2b36-$2b38 Branche si le numéro de ligne est 24 ou plus (la dernière ligne de l'écran)
$2b3a       Sauve les coordonnées de la ligne.
$2b3b-$2b3e Lecture du caractère en colonne 0 de la ligne suivante
$2b41       Restaure les coordonnées de la ligne.
$2b42       Branche si le curseur sur une ligne logique continuée.
$2b44       [if_line_24]
$2b44-$2b47 Branche si la colonne est 40 ou plus (la colonne la plus à droite est 39)
$2b49       [if_cnt_line]
$2b49       Sauve les drapeaux de comparaison. Z si le curseur est sur une ligne logique continuée
$2b4a-$2b4d Branche si la colonne est 38 ou moins.
$2b4f-$2b50 Coordonnées sur la ligne suivante, première colonne.

$2b52       [if_less_39]
$2b52       Avance d'une colonne (la colonne 0 n'est pas utilisée par l'éditeur)
$2b53       Enregistre les nouvelles coordonnées.
$2b56       Et les sauve sur la pile.
$2b57-$2b5a B contient le caractère aux nouvelles coordonnées.
$2b5b       DE contient les nouvelles coordonnées.
$2b5c       Récupère les drapeaux de comparaison.
$2b5d       A contient le caractère lu aux coordonnées.
$2b5e       Branche si ce n'est pas la dernière ligne physique de la ligne logique.
$2b60       %CHAR
$2b60-$2b62 Branche si ce n'est pas un espace.
$2b64       [srch_char]
$2b64       Incrémente la colonne.
$2b65       Place la colonne dans A.
$2b66-$2b68 Branche si la colonne est 40 ou plus.
$2b6a-$2b6b Positionne les coordonnées deux octets plus loin, donc sur le prochain caractère.
$2b6d       %CHAR
$2b6c-$2b6f Boucle si le caractère est un espace.
$2b71       %CHAR
$2b71       Sinon, on pointe sur un caractère qui n'est pas un espace. Place un espace dans A
$2b73       Et continue vers l'acquisition de la ligne.

$2b75       [if_col_40]
$2b75-$2b7a Remet l'indicateur de ligne entrée en BASIC à 0 .
$2b7d-$2b82 Branche si le bit 7 de `(entstt)`, premier caractère de la ligne logique, est à 1.
$2b84       %CHAR
$2b84-$2b86 Branche si `(entstt)` est un espace.
$2b88       %CHAR
$2b88-$2b8a Branche si le caractère est avant `0`.
$2b8c       %CHAR
$2b8c-$2b8e Branche si le caractère est au-delà de '9'

$2b90       [spc_or_dgt]
$2b90-$2b95 Branche si la colonne du curseur actuelle est 1

$2b97       [skp_logic_l]
$2b97       Descend jusqu'après le bloc de ligne logique.
$2b9a       Renvoie avoir acquis un retour chariot

$2b9c       [if_col_1]
$2b9c       Redirige ves une insertion de ligne puis acquisition d'un retour chariot.

$2b9f       Deux octets inutilisés du au patch de la ROM 1.1

$2ba1       [not_digit]
$2ba1       Place le curseur après le bloc de ligne logique.
$2ba4-$2ba6 Émission du caractère d'effacement d'écran de la ligne du curseur jusqu'en bas de l'écran.

$2ba7       [acquired_cr]
$2ba7-$2ba9 Retour en ayant acquis un retour chariot.

$2bac       [special_acq]
            Traitement des caractères spéciaux lors de la validation d'une ligne.

            Table de correspondance :
            $ff -> $10
            $0d -> $11
            $08 -> $13
            $04 -> $18
            $1f -> $1a
            $03 -> $1c

$2bac-$2bae Branche si le caractère n'est pas $ff.
$2bb0       Sinon, transforme $ff en $10.

$2bb2       [not_ff]
$2bb2-$2bb4 Branche si le caractère n'est pas $0d.
$2bb6       Sinon, transforme $0d en $11.

$2bb8       [not_0d]
$2bb8-$2bba Branche si le caractère n'est pas $08.
$2bbc       Sinon, transforme $08 en $13.

$2bbe       [not_08]
$2bbe-$2bc0 Branche si le caractère n'est pas $04.
$2bc2       Sinon, transforme $04 en $18.

$2bc4       [not_04]
$2bc4-$2bc6 Branche si le caractère n'est pas $1f.
$2bc8       Sinon, transforme $1f en $1a.

$2bca       [not_1f]
$2bca-$2bcc Branche si le caractère n'est pas $03.
$2bce       Sinon, transforme $03 en $1c.

$2bd0       [not_03]
$2bd0       Retour de l'acquisition d'une touche.

$2bd3       [skip_block]
            Descend le curseur jusqu'à la première ligne qui ne contient pas de continuité ($84) dans la colonne 0.

            Est utilisé pour amener le curseur après une ligne logique sur plusieurs lignes physiques, après ce bloc.

$2bd3-$2bd5 Envoie d'un retour à la ligne ($03)
$2bd6       Charge les coordonnées du curseur dans HL
$2bd9       Colonne précédente.
$2bda       Récupère le caractère.
$2bdd       Boucle si le caractère est $84
$2bdf       Sinon retour.

$2be0       [ifcr]
$2be0       Récupération des coordonnées du curseur dans HL.

$2be3       [find_start_l]
            Cette partie est patchée dans la ROM 1.1 pour le traitement des lignes logiques.
$2be3       Décrémentation le numéro de colonne.
$2be4       Sauve les coordonnées ainsi modifiées.
$2be5       Lit le caractère à cet endroit.
$2be8       Restaure les coordonnées modifiées.
$2be9-$2beb Branche si le caractère trouvé est $80, le début de ligne logique.
$2bed-$2bf1 Branche si le caractère n'est pas un chiffre.
$2bf3       Boucle sur la recherche de début de ligne logique.

$2bf5       [line_start]
            Le curseur est positionné sur le caractère de continuité de ligne.
$2bf5-$2bf7 Si on n'était pas sur la colonne 0, c'était une fausse alerte et non un vrai début de ligne.
            Continue à chercher.
$2bf9       Sinon, se place sur la colonne 1 de la première ligne de la ligne logique.
$2bfa-$2bfe Branche si le mode `AUTO` n'est pas en cours.
$2c00-$2c01 Sinon, le mode `AUTO` est annulé.
$2c04       L'adresse du curseur mis à jour.
$2c07-$2c09 Émission d'un `EFFL` (effacement jusqu'à la fin de la ligne courante)
$2c0a       Et la touche acquise sera validée comme étant un retour chariot ($0d).

$2c0d       [find_cont]
            Recherche les coordonnées du début de la ligne logique.
$2c0d       Place les coordonnées modifiées du curseur sur la colonne 1.
$2c0f       [find_start]
$2c0f       Enregistre les coordonnées modifiées comme les coordonnées actuelles de ligne envoyée au BASIC.
$2c12       Sauve ces coordonnées sur la pile.
$2c13-$2c14 Lecture du caractère en colonne 0 de la ligne courante.
$2c17-$2c18 Branche si ce caractère n'est pas le marqueur de continuité de ligne logique ($84).
$2c1a       Monte les coordonnées d'une ligne.
$2c1b       Branche si la ligne est au-dessus de la ligne 0 sans traitement supplémentaire.
$2c1e       Boucle pour trouver le début de la ligne logique, ou bien le début de l'écran.

$2c20       [found_start]
            Les coordonnées du curseur dans `(retadr)` sont sur le début logique d'une ligne.

$2c20-$2c25 Branche si la commande `INPUT` n'est pas en train d'être exécutée.
$2c27-$2c2b Quelques `NOP`s pour patch de la ROM 1.1 qui annulent le traitement de `INPUT` dans la ROM 1.0
$2c2c       Récupération des coordonnées du début de ligne logique.
$2c2f       Sauve ces coordonnées sur la pile.
$2c30       Calcule dans HL la correspondance en buffer écran du BASIC.
$2c33       DE = coordonnées de début de ligne logique.

$2c34       [search_qm]
$2c34-$2c37 Branche si la colonne du curseur est 40 ou plus.
            `(retadr)` contient les coordonnées du point d'interrogation le plus à droite sur la ligne s'il y en a un.
$2c39       Une colonne vers la droite.
$2c3a       Lecture du buffer d'écran pointé par HL.
$2c3b-$2c3c Place HL deux octets plus loin (caractère suivant).
$2c3d       %CHAR
$2c3d-$2c3f Boucle si le caractère lu n'est pas un point d'interrogation.
$2c41       Les coordonnées pointent vers un point d'interrogation.
$2c45       Continue à chercher les points d'interrogation.

$2c47       [found_qm]
$2c47       %CHAR
            Considère que le caractère lu est `0`.
$2c49       Continue sur le traitement du premier caractère de l'entrée.

$2c4b       [not_input]
$2c4b       Lecture du caractère aux coordonnées curseur actuelle.

$2c4e       [record_char]
$2c4e       Enregistre le premier caractère lu de la ligne logique (ou début d'`INPUT`) dans `(entstt)`.
$2c51-$2c56 Met le drapeau `ligne entrée en BASIC` à 1 pour indiquer qu'une ligne vient d'être validée en entrée.
$2c59-$2c5d Placement des coordonnées sur le caractère en colonne précédente.
            Donc 0 pour une ligne logique, et une colonne avant l'entrée utilisateur en cas d'`INPUT`.

$2c60       [screenstart]
$2c60       La fonction sortira avec pour valeur acquise `NUL`. Le traitement a été effectué.

$2c63       [if_up]
            Traitement du déplacement vers le haut lors de l’acquisition d'une touche clavier.

            En mode listing dynamique, met à jour le listing vers la ligne précédente si elle existe.

$2c63-$2c67 Branche si le curseur n'est pas sur la ligne 0.
$2c69-$2c6e Branche si on est dans un traitement de `INPUT`, la touche est ignorée.
$2c71       Numéro de ligne en haut de l'écran lors d'une listing interactif.
$2c75       Recherche de cette ligne.
$2c78       Ligne précédente dans BC.
$2c7c-$2c7e Ignore la touche s'il n'y a pas de ligne précédente.
$2c81       Sinon, revient d'une ligne en arrière dans le listing dynamique.

$2c84       [do_up]
$2c84-$2c86 Pour les lignes supérieures à 0, ne traite pas le déplacement vers le haut et délègue à `outdo`.

$2c89       [iflinef]
$2c89-$2c8e Branche si la ligne du curseur est inférieure à 24.
$2c91-$2c96 Branche si on est dans un traitement de `INPUT`, la touche est ignorée.
$2c99       Numéro de ligne en haut de l'écran lors d'une listing interactif.
$2c9d       Se positionne sur le numéro suivant (qu'il existe ou non).
$2c9e       Recherche cette ligne.
$2ca1       Branche si une ligne avec ce numéro a été trouvée.
$2ca4       Sinon, il n'y a pas de ligne avec ce numéro, ni plus loin. La touche est ignorée.
$2ca7       [list_down]
$2ca7       Une ligne a été trouvée, mise à jour du listing dynamique.

$2caa       [do_down]
$2caa-$2cac Pour les lignes inférieures à 24, ne traite pas le déplacement vers le bas et délègue le `line feed` à `outdo`.

$2caf       [if_list]
            Traitement de la touche `LIST`
$2caf-$2cb4 Ignore la touche si on est dans un traitement de `INPUT`.
$2cb7       Place le Carry à 1 afin d'indiquer à la mise à jour du listing à l'écran qu'il faudra placer le curseur en haut de l'écran.
$2cb8       Branche vers la mise à jour du listing dynamique.

$2cba       [update_list]
            Met à jour le listing dynamique à partir de la ligne pointée par BC.

            Entrée :
            - BC pointe sur une ligne du chaînage de listing BASIC
$2cba-$2cbb BC pointe vers le numéro de ligne.
$2cbc-$2cc0 DE = numéro de la ligne.
$2cc1       Mise à jour du numéro de ligne de la première ligne du listing à l'écran.
$2cc5       Mise à 0 du Carry (pour différencier d'une arrivée depuis le traitement de la touche `LIST`.
$2cc6       HL = coordonnées du curseur.
$2cc9       Sauve les coordonnées du curseur.

$2cca       [list_key]
$2cca       Sauve le Carry sur la pile, pour la différence entre la mise à jour du listing et l'appui sur la touche `LIST`.
$2ccb-$2ccd Met à jour `(picflg)` avec les informations : pas de défilement d'écran et gestion du caractère de continuité lors des déplacements du curseur.
$2cd0       Délai de rafraîchissement de l'écran à $40, pour avoir le temps de mettre à jour tout le listing.
$2cd4       `(attcar)` à 0.
$2cd8-$2cdb Place le curseur en colonne 0, ligne 1
$2cde       Efface le buffer d'écran avec les attributs courant.
$2ce1-$2ce5 Recherche la ligne du listing à afficher en haut de l'écran.
$2ce8-$2ce9 HL pointe vers la ligne demandée.

$2cea       [list_line]
$2cea       Écrit la ligne courante à l'écran.
$2ced       Branche si le listing doit s'arrêter (fin de listing, ou bas de l'écran)
$2cef-$2cf2 Compare la ligne du curseur avec 24.
$2cf4       Prépare l'écriture du caractère de continuité.
$2cf6       Envoie un retour chariot si la ligne courante est inférieure à 24.
$2cf9       Boucle sur la ligne suivante si le curseur n'a pas atteint la ligne 24.

$2cfb       [list_end]
$2cfb       Récupère le Carry.
$2cfc       Branche si l'on vient du traitement de la touche `LIST`, afin de placer le curseur en haut de l'écran.
$2cfe       Sinon, récupère les coordonnées du curseur du début de routine.

$2d01       [cur_reset]
$2d01       Coordonnées en ligne 0, colonne 1.
$2d04       [cur_restore]
$2d04       Mise à jour des coordonnées du curseur.
$2d07       Branche sur la synchronisation avec le VDP lors de l'acquisition d'une touche.

$2d0a       [write_line]
            Écrit une ligne de listing dynamique.

            Les `REM` sont écrits en rouge.

            Une partie de cette routine est similaire à celle de l'implémentation de la commande `LIST` du BASIC.

            Entrée :
            - HL pointe vers une ligne de listing BASIC.

            Sortie :
            - Carry est à 1 si la fin du listing a été atteinte.
            - Carry est à 0 si la fin de la ligne a été atteinte, mais pas la fin du listing.

$2d0a-$2d0d BC contient l'adresse de la ligne suivante. HL pointe vers le numéro de ligne.
$2d0e-$2d10 Branche si on est en fin de chaînage (l'adresse suivante est nulle).
$2d13-$2d16 DE contient le numéro de ligne. HL pointe vers le début des données de la ligne.
$2d17       Sauve le pointeur vers les données de la ligne.
$2d18-$2d19 Imprime le numéro de la ligne.
$2d1c       %CHAR
            Prépare un espace pour l'impression.
$2d1e       Restaure le pointeur vers les données de la ligne.

$2d1f       [next_char]
$2d1f       Imprime le caractère contenu dans A.
$2d20-$2d25 Branche si le curseur a atteint le bas de l'écran.
$2d28       [line_nxt]
$2d28       A contient l'octet suivant de la ligne.
$2d29       HL pointe sur l'octet suivant de la ligne.
$2d2a-$2d2c Branche si l'octet n'est pas un marqueur de nombre entier décodé.
$2d2e-$2d36 Lecture des deux octets suivants pour placer le nombre entier dans HL.
            Le pointeur courant vers les données de la ligne est poussé sur la pile.
$2d37       Écriture du nombre décodé.
$2d3a       Restaure le pointeur vers les données de la ligne.
$2d3b       Boucle sur le prochain octet de la ligne.

$2d3d       [not_number]
$2d3d-$2d3e Branche si l'octet est nul. La fin de la ligne a été atteinte.
            Carry sera à 0 en arrivant au branchement.
$2d41       Boucle si l'octet n'est pas un token. Cela imprimera l'octet en tant que caractère.
$2d44-$2d46 C contient le numéro d'index du token.
$2d47       DE pointe vers la table des mots-clés.
$2d4a-$2d4c Branche si ce n'est pas le token `REM`
$2d4e       Sinon, passe la couleur d'écriture en rouge.
$2d52       [keyw_search]
$2d52-$2d55 Boucle jusqu'à trouver un caractère avec le bit 8 à 1 (marqueur de début de mot clé).
$2d58       Décrémente le compteur initialement index de token.
$2d59       Boucle tant que le compteur n'est pas arrivé à 0.

$2d5c       [write_keyw]
$2d5c-$2d5e Affiche le caractère du mot-clé, sans le bit de poids fort.
$2d5f-$2d64 Branche si le curseur a atteint le bas de l'écran.
$2d67       Charge l'octet suivant du nom du mot-clé.
$2d68       Incrémente le pointeur vers le nom du mot-clé.
$2d69-$2d6a Boucle tant que l'octet n'est pas un marqueur de début de mot-clé.
$2d6d       Boucle vers le traitement du prochain octet de la ligne.

$2d70       [list_stop]
$2d70       Carry à 1 pour indiquer que l'on doit arrêter le listing.

$2d71       [line_end]
$2d71       La couleur d'écriture revient en noir.

$2d76       [func_keys]
$2d76-$2d78 Branche si la touche de fonction a une valeur inférieure à $ba.
$2d7b-$2d7d Branche si la touche de fonction a une valeur supérieure ou égale à $fb.
$2d80       HL pointe vers la table des touches accélératrices (les touches "BASIC")

$2d83       [loop_accel]
$2d83       Compare avec la clé trouvée dans la table (chaque chaîne résultat est précédée par sa clé).
$2d84       Incrémente le pointeur sur la table.
$2d85       Boucle tant que la clé n'a pas été trouvée.

$2d87       [out_accel]
$2d87       Charge l'octet pointé dans la table des chaîne résultat dans A.
$2d88-$2d8a Lorsque le bit de poids fort est 1, alors la chaîne est terminée.
            Branche sur la synchronisation avec le VDP lors de l'acquisition d'une touche.
$2d8d       Sinon, l'octet lu est émis vers le buffer écran.
$2d8e       Puis le pointeur avancé dans la table.
$2d8f       Boucle pour traiter l'octet suivant.

$2d91       [ctrl_keys]
            Traitement des touches accentuées.
$2d91-$2d94 DE contient l'index de la touche de contrôle appuyée.
$2d96       HL pointe vers la table des touches de contrôles en RAM, initialisée depuis `i_contbl`. Ce sont les touches accentuées.
$2d99-$2d9a A lit l'équivalence de la touche de contrôle dans la table.
$2d9b       Cette valeur est renvoyée.

$2d9e       [accel_keys]

$2ead       [mem_move_v]
            $SECTION(bimisc),%MS_BASIC(MOVUP)
            == DEBUT DE SECTION BIMISC (BASIC INTERPRETER MISCELLANEOUS) ==
            Routine de copie de mémoire.

            La zone source se trouve entre DE et BC inclus.
            La zone de destination se termine à HL et à la même taille que la zone source.

            La copie se fait en partant de la fin, pour permettre le recouvrement de la zone si HL est supérieur à BC.

            Entrées :
            - DE est le pointeur de début de la zone source.
            - BC est le pointeur de fin de la zone source. DE < BC
            - HL est le pointeur de fin de la zone destination. BC < HL

$2ead       Vérifie qu'il reste assez de mémoire.

$2eb0       [mem_move]
$2eb0       Sauve le pointeur de fin de zone source.
$2eb1-$2eb2 BC = fin de la zone destination, HL = fin de la zone source.
$2eb3       [cpy_loop]
$2eb3       Compare HL (fin de la zone source en cours) et DE (début de la zone source)
$2eb4-$2eb5 Copie un octet de la source vers la destination.
$2eb6       Retour si le pointeur de source en cours était égal au pointeur de début de zone source. La copie est terminée.
$2eb7-$2eb8 Décrémente les pointeurs de la source et de la destination.
$2eb9       Boucle vers le prochain octet.

$2ebb       [stk_verify]
            %MS_BASIC(CHKSTK)
            Vérifie qu'il y a assez de place sur la pile pour un nombre donné de niveaux.

            Un niveau a une taille de deux octets. S'il n'y a pas la place nécessaire, provoque un message d'erreur.

            Garde toujours une marge de 96 octets dans la pile.

            Entrée :
            - C, le nombre de niveaux à tester.

$2ebb       Sauve le pointeur HL.
$2ebc       HL pointe sur la fin de la mémoire utilisée par le BASIC.
$2ebf-$2ec2 Y ajoute deux fois le nombre de niveaux.
$2ec3       Saute par dessus le `push hl` qui suit, qui est l'entrée de la routine suivante.

$2ec4       [mem_verify]
            %MS_BASIC(ENFMEM)
            Vérifie qu'il y a assez de place sur la pile à partir de HL.

            Garde toujours une marge de 96 octets dans la pile.

            (vérifier le fonctionnement du calcul)

            Entrée :
            - HL, le pointeur à vérifier

$2ec4       Sauve le pointeur HL fourni
$2ec5-$2ecc HL <- $ffa0 - HL, donc l'espace disponible entre HL et la fin de la mémoire adressable moins un espace réservé.
$2ecd       Si la soustraction est négative, alors il n'y a pas la place nécessaire entre HL et le haut de la mémoire ($FFFF).
            Branche sur une erreur.
$2ecf       Ajoute HL
$2ed0       Restaure le pointeur fourni
$2ed1       Retour si HL + SP provoque une retenue, c'est que le pointeur fourni est assez loin du haut de la mémoire. C'est ok.

$2ed2       [out_of_mem]
$2ed2-$2ed5 Message d'erreur "Out of Memory"

$2ed8       Un octet inutilisé.
            Il s'agit d'un reliquat du point d'entrée de l'instruction `NEW` dans la ROM 1.0.

$2ed9       [reset_lst]
            %MS_BASIC(CLRPTR)
            Casse le chaînage du listing en mettant à 0 le premier lien.

$2ed9       HL pointe vers le début du listing BASIC.

$2edc       [reset_lst_2]
$2edc       A = 0
$2edd       Branche vers le code patché de la ROM 1.1

$2ee0       [reset_lst_4]
$2ee0-$2ee1 Ajuste le pointeur de début des variables `(vartab)` à `(txttab)+2`.

$2ee4       [reset_vars]
$2ee4-$2ee7 HL pointe sur l'octet avant `(txttab)`.

$2ee8       [init_vars]
            %MS_BASIC(INTVAR)
$2ee8       HL est sauvé dans `(temp)`
$2eeb       HL prend la valeur de `(memsiz)` adresse la plus haute en mémoire disponible.
$2eee       `(fretop)` = `(memsiz)`
$2ef1       Z = 1, ce qui émule avec l'appel qui suit un appel à `RESTORE` sans paramètre.
$2ef2       Appel à l'instruction `RESTORE`, pour réinitialiser le pointeurs de `DATA` depuis le début du programme.
$2ef5-$2ef8 `(arytab)` = `(strend)` = `(vartab)`, ce qui invalide les variables, les tableaux et les chaînes.

$2efe       [clear_regs]
            %MS_BASIC(CLREG)
            Quelques réinitialisations.

            - Réinitialise les pointeurs de chaînes temporaires,
            - Réinitialise l'imprimante,
            - Réinitialise les boucles `FOR`.
            - Réinitialise le paramètre de fonction utilisateur.
            - Réinitialise la pile, y place 0 et l'adresse de retour.

            Sortie :
            - HL prend la valeur contenue dans `(temp)`

$2efe       Récupération de l'adresse de retour pour reconstruire la pile en fin de routine.
$2eff-$2f02 Réinitialisation de la pile (SP) à la dernière adresse RAM valide
$2f03-$2f06 Le pointeur sur la zone temporaire de descripteur est initialisé vers le buffer de construction de chaînes.
$2f09       Mise à zéro de l'état de l'imprimante.
$2f0c-$2f0e HL et A à 0
$2f0f       Mise à zéro de registre `oldtxt`, pointeur vers le dernier arrêt de programme (utilisé par `CONT`).
$2f12       Mise à zéro du registre `subflg`, utilisé pour FOR.
$2f15       Mise à zéro du nom du paramètre pour les fonctions utilisateurs.
$2f18       Met 0 sur la pile
$2f19       Remet l'adresse de retour sur la pile avant le RET

$2f1a       [do_again]
            %MS_BASIC(DOAGN)
$2f1a       HL est chargé avec la valeur de `temp`.
            Pendant `INPUT`, `hl` pointe vers le début de l'instruction `INPUT` à relancer en cas de mauvais type de donnée.

$2f1e       [inst_restore]
            %CODE,%MS_BASIC(RESTOR)
            Instruction BASIC : RESTORE

$2f1e       Sauve le pointeur vers le texte BASIC dans DE
$2f1f       HL pointe vers le début du listing BASIC.
$2f22       Pas de paramètre, restaure depuis le début du programme.
$2f24       Ramène le pointeur vers le texte BASIC dans HL.
$2f25       Récupère le numéro de ligne en paramètre dans DE.
$2f28       Sauve le pointeur vers le texte BASIC.
$2f29       Récupère le pointeur vers la ligne en paramètre de `RESTORE` dans BC.
$2f2c-$2f2d HL pointe vers la ligne désignée par le paramètre.
$2f2e       Restaure le pointeur vers le texte BASIC dans DE.
$2f2f       Si le numéro de ligne spécifié n'est pas trouvé, branche vers une erreur.

$2f32       [restore_all]
            %MS_BASIC(RESTNL)
$2f32       Recule le pointeur vers la ligne de 1 octet.
$2f33       [set_data]
            %MS_BASIC(UPDATA)
$2f33       Sauvegarde le pointeur à partir duquel la recherche de `DATA` sera faite.
$2f36       Restaure le pointeur de texte BASIC dans HL.

$2f38       [inst_stop]
            %CODE,MS_BASIC(STOP)
            Instruction BASIC : STOP

$2f38       Pas d'effet s'il y a un argument. Cela provoquera une erreur de syntaxe en cherchant l'instruction suivante.
$2f39       Prépare le drapeau pour `STOP` ($c0)
$2f3a       [inst_end]
            %CODE,MS_BASIC(PEND)
            Instruction BASIC : END

$2f3a       Pas d'effet s'il y a un argument. Cela provoquera une erreur de syntaxe en cherchant l'instruction suivante.
$2f3b       Sauve l'endroit où l'arrêt a eu lieu en cas de `STOP` ou de `END`
$2f3e       Saute par dessus le `OR` suivant.

$2f3f       [input_brk]
$2f3f       Prépare le drapeau pour `BREAK` ($ff)
$2f41       Enlève l'adresse de retour des instructions. Le programme est terminé.

$2f42       [end_of_prog]
            %MS_BASIC(ENDPRG)
            Traite la fin d'un programme

$2f42       HL contient le numéro de ligne en cours.
$2f45       Sauve la raison de l'arrêt. `STOP` et `END` ont mis A <- $c0, `BREAK` a mis A <- $ff.
$2f46-$2f49 Si la ligne courante est $ffff, le BASIC est en mode direct. Branche plus loin.
$2f4b       Sauve la dernière ligne exécutée si le BASIC est en mode indirect.
$2f4e-$2f51 Sauve le point d'arrêt vers le texte BASIC. Utilisé pour `CONT`.

$2f54       [no_line]
$2f54       Réinitialisation de l'imprimante.
$2f57       Réinitialisation du terminal et passage à la ligne.
$2f5a       Récupère AF... sans intérêt. Il s'agit d'un reliquat d'une autre version du BASIC.
$2f5b       HL pointe vers le message d'arrêt.
$2f5e       Remise dans la pile de AF... où il aurait pu y rester.
$2f5f       Chargement de la langue du système.
$2f62-$2f63 Branche si le système est en français.
$2f65       Sinon, HL pointe vers le même message en anglais.

$2f68       [break_fr]
$2f68       Récupère la raison de l'arrêt.
$2f69       Branche si la raison de l'arrêt nécessite un message.
$2f6c       Sinon, c'est un arrêt normal. Boucle sur l'affichage "Ok!".

$2f6f       [inst_cont]
            %CODE,MS_BASIC(CONT)
            Instruction BASIC : CONT
$2f6f       Récupère dans HL le dernier point d'arrêt.
$2f74       %NOT_LABEL
$2f72-$2f77 Branche sur l'erreur "Cannot continue" si le dernier point d'arrêt est 0.
$2f7a-$2f7e Sinon, place le numéro de la ligne d'arrêt dans `(curlin)`. Avec le pointeur HL sur le texte BASIC interrompu, le système est prêt à repartir.

$2f83       [myst_inst]
            %CODE
            Cette instruction, qui branche vers une instruction illégale, ne semble pas être appelée.


$2f86       [mysterious]
            %CODE
            Cette routine ne semble pas être appelée.

            Elle ne semble pas non plus avoir beaucoup de sens.

$2f86-$2f88 Prépare la demande d'un tableau.
$2f8b       Récupère un tableau tel que pointé par HL sur du texte BASIC.
$2f8e       Sauve le pointeur de texte BASIC.
$2f8f       Est-ce que cela a du sens ?
$2f92-$2f93 HL = BC
$2f94-$2f97 Recule le pointeur BC de 4 octets.

$2f98       [a_to_z]
            Vérifie que le caractère pointé par HL est entre A et Z inclus.

            Entrée :
            - HL pointe vers un caractère.

            Sortie :
            - Carry à 1 si ce n'est pas le cas.
            - Carry à 0 si c'est le cas.

            Préserve :
            - Tous les registres sauf AF.

$2f98       Lit le caractère pointé par HL dans A.

$2f99       [a_to_z_2]
            Même routine mais avec le caractère à vérifier déjà dans A.

$2f99       %CHAR
$2f99-$2f9b Retour si le caractère est avant `A`.
$2f9c       %CHAR
$2f9c       Si le caractère est `[` ou après, le Carry est à 0.
$2f9e       Complément le Carry.

$2fa0       [inst_clear]
            %CODE,MS_BASIC(CLEAR)
            Instruction BASIC : CLEAR

$2fa0       S'il n'y a pas d'argument, initialise les variables avec les valeurs courantes.
$2fa3       Récupère un premier paramètre entre 0 et 32768 dans DE.
$2fa6-$2fa7 Lit le caractère suivant.
$2fa8       Sauve le pointeur vers le texte BASIC.
$2fa9       HL contient la dernière adresse mémoire disponible.
$2fac       S'il n'y a pas de second paramètre, continue plus loin.
$2fae       Récupère le pointeur vers le texte BASIC.
$2faf       Vérifie que le caractère suivant est une virgule, ou génère une erreur de syntaxe.
$2fb0       %DATASKIP
$2fb1       Sauve le premier paramètre sur la pile.
$2fb2-$2fb5 Lit le second paramètre (de -32768 à 32767) dans DE.
$2fb8-$2fb9 Lit le caractère suivant.
$2fba       S'il n'est pas nul, c'est une erreur de syntaxe.
$2fbd       HL = première paramètre, Haut de la pile = pointeur vers le texte BASIC.
$2fbe       Le premier paramètre est dans DE, le second dans HL.

$2fbf       [clr_stored]
            %MS_BASIC(STORED)
            Arrivé ici, le premier paramètre est dans DE, le second dans HL.

            Si le second paramètre n'était pas spécifié, HL est `(memsiz)`.

$2fbf       DE = HL - DE, c'est-à-dire le pointeur vers la zone des chaînes de caractères.
            Il est étrange que ce calcul soit dans un sous-routine, elle ne semble pas utilisée ailleurs.
$2fc2       Si le résultat est négatif, alors branche vers une erreur.
$2fc5       Sauvegarde de l'adresse mémoire haute (second paramètre)

$2fc6       HL pointe vers la première adresse de variables (juste après le listing BASIC)
$2fc9       %NOT_LABEL
$2fc9-$2fcc Augmente le pointeur HL de la taille minimale pouvant être réservée (40 octets)
$2fcd       Comparaison de cette adresse avec DE, le pointeur vers la zone des chaînes de caractères.
$2fce       Si HL n'est pas inférieur à DE, c'est une erreur.
$2fd1       HL = pointeur sur la zone des chaînes de caractères.
$2fd2       Met à jour l'adresse de haut de pile `(stktop)`.
$2fd5-$2fd6 Met à jour la plus haute adresse dans `(memsiz)`.
$2fd9       Restaure le pointeur vers le texte BASIC.
$2fda       Branche l'initialisation des variables restantes.

$2fdd       [top_string]
            Routine utilisé par l'instruction `CLEAR`
            DE = HL - DE

$2fdd-$2fe2 DE = HL - DE

$2fe4       [inst_next]
            %CODE,MS_BASIC(NEXT)
            Instruction BASIC : NEXT
$2fe4       Initialise DE pour le cas où la variable d'index pour `NEXT` n'est pas spécifiée.

$2fe7       [inst_nxt_v]
$2fe7       Lit la variable index qui suit le mot clé `NEXT` s'il y en a une.
$2fea       Sauve le pointeur vers le texte BASIC dans `(temp)`
$2fed       Recherche un bloc `FOR` dans la pile.
$2ff0       Le bloc `FOR` correspondant n'a pas été trouvé. Branche vers une erreur.
$2ff3       S'il a été trouvé, on ajuste le pointeur de pile vers celui-ci.
$2ff4       Pousse l'adresse de la variable index trouvée dans le bloc `FOR` sur la pile (celle demandée, ou la première trouvée si non spécifiée).
$2ff5-$2ff6 Lit et sauve sur la pile le signe de `STEP`
$2ff7       Pointe vers l'octet suivant, qui est la valeur de `STEP`.
$2ff8       Pousse l'adresse de la variable index sur la pile.
$2ff9       Monte la valeur pointée par HL (valeur de `STEP`) dans FAC.
$2ffc       HL = pointeur vers la variable index, Haut de la pile = pointeur vers le champ `TO` du bloc `FOR`.
$2ffd       Pousse le pointeur vers la variable index sur la pile.
$2ffe       Ajoute la valeur du `STEP` et la valeur de la variable index. Le résultat est dans FAC.
$3001-$3002 Place le résultat dans la variable index.
$3005-$3006 Place la valeur de `TO` dans BCDE.
$3009       HL pointe à présent sur le champ de la ligne du bloc `FOR`. Ce pointeur est poussé sur la pile.
$300a       Comparaison de BCDE (`TO`) et FAC (la variable index)
$300d       Restaure le pointeur vers la ligne du `FOR` dans HL.
$300e       Restaure le signe de `STEP` dans B.
$300f       Compare le signe de `STEP` avec le résultat de la comparaison.
$3010       Charge les informations de ligne dans BCDE. BC = pointeur vers l'instruction suivant le `FOR`, DE = numéro de la ligne.
            HL pointe après le bloc `FOR`.
$3013       Si le signe de la comparaison et le signe de `STEP` étaient égaux, la boucle est terminée.
$3015-$3016 Sinon, place le numéro de ligne où se trouve `FOR` dans `(curlin)`.
$3019-$301a Et place le pointeur de texte BASIC sur l'instruction qui suit le `FOR`.
$301b       L'interprétation BASIC peut continuer.

$301e       [remove_for]
$301e       Ajuste la pile après le bloc `FOR` qui vient d'être lu.
$301f       Restaure le pointeur vers le texte BASIC, qui est à la fin du NEXT ou de la variable index qui vient d'être traitée.
$3023       %CHAR
$3022-$3025 Termine l'instruction si le caractère suivant n'est pas une virgule.
$3028       Sinon, lit cette virgule.
$3029       Puis appelle l’instruction `NEXT` pour la variable index suivante.

$302c       [str_hex_dec]
            %MS_BASIC(HEXTFP)
            Transforme un nombre de la forme &"xxxx" en nombre flottant.

            La fin de la routine est patchée dans la ROM 1.1 pour se reposer sur `bade_to_fac`.

            Entrée :
            - HL pointe vers le texte BASIC au niveau du '&' initial.

$302c       Pointe vers le caractère suivant.
$302d       Vérifie que le début du nombre (après le '&'), est un '"'
$302e       %DATASKIP
$302f       Initialise l'accumulateur à 0.
$3030-$3032 Compteur de chiffres maximum (4 chiffres max, la boucle djnz sort lorsque B est décrémenté à 0).
$3034       Positionnement du pointeur pour la lecture des chiffres.

$3035       [hex_fetch]
$3035       Lecture d'un chiffre hexadécimal.
$3038       Branche si ce n'était pas un chiffre hexadécimal.
$303a       DE = pointeur sur le texte BASIC, HL = accumulateur.
$303b-$303e HL = HL * 16
$303f-$3040 HL = HL + A (le chiffre tout juste lu)
$3041       DE = accumulateur, HL = pointeur sur le texte BASIC.
$3042       Il reste potentiellement des chiffres. Boucle.

$3044       [not_hexa]
$3044       %CHAR
$3044-$3046 Si le dernier caractère lu n'est pas '"', c'est une erreur de syntaxe.
$3049       Sinon, il est lu afin d'avancer HL.
$304a       Préparation de l'exposant pour un nombre entier.
$304c       Sauve le pointeur vers le texte BASIC.
$304d-$304e BADE (avec B = $98, A = 0 et DE l'accumulateur) est monté dans FAC.
$3051       Restaure le pointeur vers le texte BASIC.

$3053       Cinq octets inutilisés, reliquat du patch de la routine précédente pour la ROM 1.1

$3058       [inst_renum]
            %CODE
            Instruction BASIC : RENUM

            Les arguments pour RENUM sont, dans l'ordre :
            - La ligne de nouveau départ pour la renumérotation
            - La ligne du listing actuel à partir de laquelle commence la renumérotation
            - Le 'pas' de renumérotation.

            [ArticleAlgorithmeRenum]

$3058       BC = 10, sers pour le premier numéro des nouveaux numéro de ligne ainsi qu'au `pas`.
$305b       Pousse BC sur la pile en tant que `pas` de numérotation.
$305c-$305d DE = 0, ligne de départ par défaut pour le traitement de la numérotation.
$305e       Effectue l'opération avec les arguments par défaut (0, 10, 10) si aucun n'est précisé.
$3060       %CHAR
$3060-$3062 Branche vers le deuxième argument si le premier paramètre est ignoré.
$3064       Sauve DE.
$3065-$3069 BC = premier argument, nouveau numéro de ligne de départ.
$306a       Restaure DE, ligne de démarrage dans le listing actuel.
$306b       Branche sur l'opération s'il n'y a pas d'argument qui suit.

$306d       [renum_line]
$306d       Sinon, vérifie la présence d'une virgule.
$306e       %DATASKIP
$306f       Lit le deuxième argument dans DE.
$3072       Branche sur l'opération si c'était le dernier argument.
$3074       Retire le `pas` actuel de la pile.
$3075       Vérifie que le caractère suivant est une virgule.
$3076       %DATASKIP
$3077       Pousse le deuxième argument sur la pile.
$3078       Lecture du troisième argument.
$307b       Si l'instruction n'est pas terminée, c'est une erreur de syntaxe.
$307e-$3080 Si le troisième argument (le pas de numérotation) est nul, c'est un appel illégal.
$3083       Troisième argument dans HL.
$3084       Troisième argument en haut de la pile. HL = deuxième argument.
$3085       DE = deuxième argument. HL = pointeur vers le texte BASIC.

$3086       [do_renum]
            À l'arrivée, on a :

            - HL = pointeur vers le texte BASIC
            - BC = premier argument, nouveau numéro de ligne pour la numérotation.
            - DE = deuxième argument, numéro de ligne du listing actuel pour le début du traitement.
            - Haut de la pile = troisième argument

$3086       [do_renum]
$3086       Sauve le premier argument
$3087       Cherche une ligne qui correspond au deuxième argument.
$308a       DE = premier argument.
$308b       Pousse le premier argument sur la pile.
$308c       Pousse l'adresse de la ligne cherchée par le deuxième argument sur la pile.
$308d       Cherche la ligne indiquée par le premier argument.
$3090-$3091 HL = adresse de la ligne indiquée par le premier argument.
$3092       DE = adresse de la ligne indiquée par le deuxième argument.
$3093       Compare HL (ligne destination voulue) et DE (ligne de démarrage dans le listing)
$3094       HL = adresse de la ligne indiquée par le deuxième argument.
$3095       Si DE est supérieur à HL, l'appel est illégal.
            Cela signifie que la ligne cible de numérotation existe et que l'on veut y amener un morceau de listing plus loin.
            Si la place est libre, on aura DE et HL égaux.
            Et si HL est supérieur à DE, cela signifie que la renumérotation 'pousse' le listing vers des numéros plus grands.
$3098       DE = premier argument
$3099       BC = pas de numérotation.
$309a       AF = adresse de retour de l'instruction.
$309b       Pousse l'adresse de la ligne indiquée par le second argument sur la pile.
$309c       Pousse le premier argument sur la pile.
$309d       Démarre la vérification de renumérotation valide.

$309f       [r_check_lp]
$309f       Ajoute le 'pas' au numéro de ligne.
$30a0       Si la somme dépasse 65535, la renumérotation n'est pas valide, branche sur une erreur.
$30a3       DE = prochain nouveau numéro de ligne, HL = pointe vers la ligne.
$30a4       Sauve HL.
$30a5-$30a8 Compare DE et $fff9, plus haut numéro de ligne valide.
$30a9       Restaure HL.
$30aa       Si le numéro de ligne calculé pour la numérotation est trop haut, branche sur une erreur.

$30ad       [renum_check]
$30ad       Pousse le prochain nouveau numéro de ligne
$30ae-$30b1 DE = adresse de chaînage de la ligne à renuméroter.
$30b2       Prépare la vérification de fin de chaînage.
$30b3       HL = adresse de chaînage de la ligne à renuméroter
$30b4       Restaure le prochain nouveau numéro de ligne dans DE.
$30b5       Si le chaînage est nul, on est sur la dernière ligne du listing. Branche plus loin.
$30b7-$30ba Vérifie le chaînage pointé par HL, sans bouger HL.
$30bb       HL = nouveau numéro de ligne, DE = pointe vers la ligne.
$30bc       Si le chaînage existe, boucle.

$30be       [r_check_end]
$30be       Sauve le pas de renumérotation.
$30bf       Vérifie que toutes les références à des numéros de ligne dans le listing sont valides.
$30c2       Restaure le pas de renumérotation.
$30c3       Restaure le premier argument dans DE.
$30c4       Restaure HL qui pointe sur `(txttab)`.

$30c5       [ren_lines]
$30c5       Sauve le numéro de ligne destination (initialement le premier argument).
$30c6-$30cb Branche si le chaînage est nul, pour mettre à jour les références de lignes.
            DE contient l'adresse de chaînage.
$30cd       HL = adresse de chaînage, DE = pointeur sur le numéro de la ligne
$30ce       HL = numéro de ligne de destination, Haut de la pile = adresse de chaînage.
$30cf       DE = numéro de ligne de destination, HL = pointeur sur le numéro de la ligne.
$30d0-$30d3 Met dans le numéro de la ligne de la ligne pointée le numéro de ligne de destination.
            Autrement dit, met à jour le numéro de la ligne traitée.
$30d4-$30d6 DE = DE + BC, le numéro de ligne de destination est augmenté du pas de renumérotation.
$30d7       Restaure l'adresse de chaînage dans HL, qui pointe donc sur la ligne suivante.
$30d8       Boucle sur la renumérotation de la ligne suivante.

$30da       [renum_00]
$30da-$30dd Prépare une adresse de retour vers la boucle "Ok" précédée d'un `pop`.
$30de       Saute par dessus la suite pour arriver sur le `xor a` qui va entraîner 0 dans `(ptrfrg)`.

$30df       [renum_af]
$30df       En arrivant ici, `(ptrfrg)` sera mis à $af, pour vérifier que toutes les références à des numéros de lignes sont valides.
$30e0       A = 0
$30e1       Met `(ptrfrg)` à $af ou $00 suivant le chemin d'arrivée.
$30e4-$30e7 HL pointe un octet avant le début de listing BASIC.

$30e8       [ren_line]
$30e8       Avec HL de un octet.
$30e9-$30ec Retour si le chaînage de ligne est nul.
$30ed-$30f0 DE = numéro de la ligne
$30f1       [ren_byte]
$30f1       Lecture d'un octet du contenu de la ligne.
$30f2-$30f3 Boucle si la fin de ligne est atteinte.
$30f5       Sauve l'octet lu dans C
$30f6-$30f9 Prépare la comparaison de `(ptrfrg)` avec 0.
$30fa       Restaure l'octet lu dans A
$30fb       Branche si `(ptrfrg)` est à 0 pour remettre les références de lignes de type pointeur en numéro de ligne de type entier.
$30fd-$30ff Sinon, si l'octet n'est pas un marqueur de numéro de ligne, boucle sur le traitement l'octet suivant de la ligne.
$3101       Sinon, c'est un numéro de ligne. Sauve le numéro de la ligne courante sur la pile.
$3102-$3106 DE = numéro de ligne référencé dans les données de la ligne.
$3107       Sauve HL pointeur vers le texte BASIC.
$3108       Recherche la ligne référencée.
$310b       Pointe un octet avant les données de la ligne référencée.
$310c       A = $0d afin de mettre un marqueur de 'pointeur de ligne' dans les données de la ligne.
$310e       Branche si la ligne a été trouvée afin de remplacer le numéro de ligne par le pointeur vers la ligne.
$3110       Curseur à la ligne.
$3113-$311c HL pointe vers le texte "Ligne" en fonction de la langue du système.

$311f       [line_fr]
$311f       Sauve DE, le numéro de ligne référencée.
$3120       Émet le message "Ligne" sur la sortie actuelle.
$3123       Restaure le numéro de ligne référencée dans HL.
$3124       Émet le numéro de cette ligne à la suite.
$3127-$3130 HL pointe sur le message "non définie" en fonction de la langue du système.
$3133       [undef_fr]
$3133       Émet le message "non définie" sur la sortie actuelle.
$3136-$3139 Restaure le pointeur de texte BASIC (dans BC) et le numéro de ligne (dans HL) en les laissant sur la pile.
$313a       Émet "en ligne " + le numéro de ligne dans HL.
$313d       [ren_byt_lp]
$313d       Restaure le pointeur sur le texte BASIC dans HL.
$313e       Restaure le numéro de ligne courante dans DE.
$313f       Recule le pointeur vers le texte BASIC d'un octet.
$3140       [ren_byte_2]
$3140       Boucle sur le traitement de l'octet suivant dans la ligne.

$3142       [ref_to_line]
            On arrive ici sur `(ptrfrg)` est à 0 lors de la renumérotation.
            C'est-à-dire que les numéros de lignes ont déjà été mises à jour.
            Il s'agit à présent de mettre à jour leurs références.
$3142-$3144 Branche si l'octet n'est pas un marqueur de numéro de ligne.
$3146-$3147 Sinon, saute par dessus les deux octets suivants.
            C'est un numéro de ligne invalide, il n'est pas modifié.
$3148       Et traite l'octet suivant du contenu de la ligne.

$314a       [valid_ref]
$314a-$314c Si l'octet n'est pas un marqueur de référence de ligne valide, branche vers le prochain octet de la ligne.
$314e       Sinon, sauve DE
$314f-$3152 DE = pointeur vers la ligne référencée.
$3153-$3154 Sauve le pointeur vers les données de la ligne en cours.
$3155-$3158 Positionne HL sur le numéro de ligne de la ligne référencée.
$3159-$315b Lit le numéro de ligne de la ligne référencée dans BC.
$315c       A = $0e afin de remettre un marqueur de référence de ligne.

$315e       [update_ref]
$315e-$3161 Prépare l'adresse de retour pour traiter l'octet suivant.
$3162       Récupération de l'adresse après lecture de la dernière référence à un numéro de ligne.
$3165       Sauve ce pointeur pour préparer le contexte pour la prochaine boucle.
$3166-$316c Place dans les données de la ligne soit un numéro de ligne (si A = $0e), soit un pointeur vers une ligne dans le listing (si A = $0d).
$316d       Revient vers l'adresse placée au dessus.

$316e       [inst_auto]
            %CODE
            Instruction BASIC : AUTO
$316e       Arguments par défaut à 10.
$3171       Pousse la ligne de départ par défaut (10) dans la pile.
$3172       Branche si aucun argument n'est spécifié.
$3174       Sinon, lit le premier argument comme un numéro de ligne.
$3177       Échange AF avec son registre secondaires.
$3178-$317a Si le premier argument est 0, c'est une erreur de syntaxe.
$317d       Récupère et jette le numéro de ligne de départ par défaut actuellement sur la pile.
$317e       Pousse le premier argument (numéro de ligne de départ) sur la pile.
$317f       Restaure le registre initial AF.
$3180       Branche si la fin de l'instruction a été atteinte.
$3182       Sinon, on doit trouver une virgule.
$3183       %DATASKIP
$3184       Lit le second argument.
$3187       Échange AF avec son registre secondaires.
$3188-$318a Si le second argument est 0, c'est une erreur de syntaxe.
$318d       Restaure le registre initial AF.
$318e       Si l'instruction n'est pas terminée, c'est une erreur de syntaxe.
$3191       Sinon, place le pas de numérotation dans la variable `(autinc)`.
            Comme cette assignation se fait avant le branchement en cas de paramètre par défaut, cela signifie que le pas par défaut n'est pas 10, mais est la dernière valeur spécifiée par `AUTO`.
            La variable `(autinc)` est initialisée à 10 au démarrage. Cf. `(i_autinc)`.
$3195       [auto_end]
$3195       Récupère le numéro de ligne de départ du mode `AUTO`.
$3196       Met à jour la variable `(autlin)` avec cette valeur.
$319a-$319c Active le mode `AUTO` de l'éditeur BASIC.

$319f       [bcode_start]
$319f       Jette l'adresse de retour.
$31a0       Branche sur la boucle de l'éditeur BASIC.

$31a3       [inst_llist]
            %CODE
            Instruction BASIC : LLIST
$31a3-$31a5 Sélectionne l'imprimante comme périphérique de sortie.

$31a8       [inst_list]
            %CODE
            Instruction BASIC : LIST
$31a8       Lit les deux arguments de l'instruction `LIST` (ou `LLIST`).
$31ab       Émet le listing sur le périphérique sélectionné.
$31ae       Revient à la boucle de l'éditeur BASIC en ignorant l'adresse de retour actuelle.

$31b1       [line_pair]
            Lit deux arguments de type numéro de ligne depuis le pointeur HL sur du texte BASIC.

            La routine est patchée en ROM 1.1 pour corriger l'erreur en cas d'absence de premier argument.
            En ROM 1.0, en cas d'absence de premier argument, `(temp)` n'est pas mis à 0. Sa valeur est donc indéterminée.

            Entrée :
            - HL pointe sur le texte BASIC.

            Sorties :
            - `(temp)` contient le premier numéro de ligne trouvé.
            - `(sonsav_hi)` contient le second numéro de ligne trouvé.
            - DE pointe vers la première ligne valide dont le numéro est égal ou supérieur au premier argument (ou la première par défaut).

            Le premier numéro de ligne (trouvé) est retourné dans DE.
$31b1       Le premier argument a pour défaut 0.
$31b4-$31b5 Lit le premier caractère du texte BASIC.
$31b6       Branche si la fin d'instruction est atteinte, pas de premier argument.
$31b8       %CHAR
$31b8-$31ba Lit un numéro de ligne si le caractère suivant n'était pas une virgule. C'est le premier argument, lu dans DE.
$31bd       [no_pair_1]
$31bd       Le premier argument, qu'il soit lu ou par défaut, est placé dans '(temp)'.
$31c1       Sauve le pointeur vers le texte BASIC.
$31c2       Cherche le premier numéro de ligne valide à partir de DE.
$31c5       Restaure le pointeur vers le texte BASIC.
$31c6       Le pointeur vers le numéro de ligne trouvé est poussé sur la pile.
$31c7-$31c8 Lecture du caractère suivant.
$31c9       Branche si on a atteint la fin de l'instruction, il n'y a pas de second argument.
$31cb       %CHAR
$31cb-$31cd Si le caractère suivant n'était pas une virgule, c'est une erreur de syntaxe.
$31d0-$31d1 Sinon, récupère le deuxième argument comme un numéro de ligne.
$31d4       Si la fin de l'instruction n'a pas été atteinte, c'est une erreur de syntaxe.
$31d7-$31d9 Branche si le second argument n'est pas nul.

$31db       [no_pair_2]
$31db       Par défaut, le dernier numéro de ligne est $ffff.

$31de       [save_pair_2]
$31de       Le second argument, qu'il soit lu ou par défaut, est placé dans `(sonsav_hi)`.
$31e2       Le pointeur vers la première ligne spécifiée par les arguments est récupérée dans DE.

$31e4       [print_list]
            Routine d'affichage du listing. Appelée par `LIST`, `LLIST` ainsi que par `SAVE`.
$31e4-$31e6 Indique que le caractère de continuation devra être écrit lorsqu'une ligne logique dépassera des 40 colonnes.
$31e9       DE = pointeur vers le texte BASIC, HL = pointeur vers la ligne à émettre.

$31ea       [listing_lp]
            %MS_BASIC(LISTLP)
$31ea-$31ed BC = pointeur sur la ligne suivante.
$31ee-$31f0 La fin du listing a été atteinte (la ligne suivante est nulle), retour.
$31f1       Vérifie l'interruption de commande par l'utilisateur.
$31f4-$31f6 Branche si la touche SHIFT+RUN/STOP n'a pas été appuyée.
$31f8       Sinon, sauve le pointeur vers les données de la ligne.
$31f9       [list_bounce]
$31f9       Scan le clavier.
$31fc-$31fd Boucle tant qu'il y a de l'activité.
$31ff       [list_wait]
$31ff-$3206 Boucle tant qu'aucune touche n'a été appuyée.
$3208       Restaure le pointeur vers les données de la ligne.

$3209       [list_dec]
$3209-$320b DE = numéro de la ligne.
$320c       Sauve le pointeur vers les données de la ligne.
$320d-$3210 Comparaison avec la borne supérieur pour les numéros de lignes du listing demandé.
$3211       Restaure le pointeur vers les données de la ligne.
$3212       Inverse le résultat de comparaison.
$3213       Retour si le numéro de la ligne lue est supérieur à la borne supérieure du listing demandé.
$3214       Enregistre cette ligne comme celle vers laquelle ramènera la touche `LIST`.
$3219       Sauve le pointeur vers les données de la ligne.
$321a-$321b Émet le numéro de la ligne lue sur le périphérique sélectionné.
$321e       %CHAR
            Prépare l'émission d'un caractère d'espacement.
$3220       Restaure le pointeur vers les données de la ligne.
$3221       Sauve le pointeur vers les données de la ligne dans `(retadr)` temporairement.
$3224       Émet l'espace vers le périphérique sélectionné.
$3225       Restaure le pointeur vers les données de la ligne.
            Note : vu que `(retadr)` est écrasé juste après, pourquoi n'avoir pas laissé la valeur sur la pile ?
$3228       Sauve le pointeur vers les données de la ligne.
$322c       Évite l'émission de caractère qui suit.

$322d       [emit_char]
$322d       Émet le caractère présent dans A.
$322e       [emit_line]
$322e       Lit la donnée de la ligne en cours.
$322f       Incrémente le pointeur vers les données de la ligne.
$3230-$3232 Branche si ce n'est pas un marqueur de numéro de ligne.
$3234       %CHAR
$3234-$3236 Sinon, émet un caractère d'espacement.
$3237-$323f Charge dans HL le numéro de ligne référencé tout en préservant le pointeur vers les données sur la pile.
$3240       Émet le numéro de ligne contenu dans HL.
$3243       Restaure le pointeur vers les données de ligne.
$3244       Boucle vers l'octet suivant de la ligne.

$3246       [not_linenum]
$3246-$3247 Branche si la fin de ligne a été atteinte.
$3249       Boucle sur l'émission de caractère si celui si est strictement inférieur à 128.
$324c-$324e Sinon, calcul dans C l'index du token.
$324f       Pointe vers la table de mot clés.
$3252-$3254 Branche si ce n'est pas l'index de l'instruction `REM`.
$3256       Sinon, écrit en rouge (si l'émission se fait vers l'écran)

$325a       [find_keyw]
$325a-$325d Boucle jusqu'à trouver un octet avec le bit de poids faible à 1, marqueur de début de mot clé.
$3260       Décrémente l'index.
$3261       Boucle tant que l'index n'est pas nul, afin d'arriver sur le bon mot clé.

$3263       [emit_keyw]
$3263-$3265 Émet le caractère du mot clé, ramené à ses 7 bits de poids faible.
$3266       Lit le caractère suivant du mot clé.
$3267       Et avant le pointeur vers le mot clé.
$3268-$3269 Boucle tant que l'on reste sur le même mot clé (pas de marque de début de mot clé).
$326c       Boucle sur la suite de l'émission de la ligne.

$326e       [end_of_line]
$326e       La couleur d'écriture est remise au noir.
$3272       Émission d'un passage à la ligne suivante.
$3275       Boucle sur la suite de l'émission du listing.

$3278       [initscreen]
            %SECTION(co)
            == DEBUT DE SECTION CO (SCREEN COMMUNICATIONS) ==
            Réinitialisation du curseur et d'attributs d'affichage.

            Redéfinition de deux caractères: $20 et $7F.
            Efface l'écran, remise en colonne 1.

            Cette routine est patchée en ROM 1.1 pour ajouter la redéfinition du caractère $20.

$3278       Le bit 6 de `(cursor)` (MAT du VDP) indique l'activation du curseur.
$327c       Test du bit 0 de `(fklock)` (variable majuscules = 1 / minuscules = 0).
$3280       Le bit 4 de `(cursor)` indique que le curseur est un 'soulignement' (tiret bas).
$3284       Branche si `(fklock)` indique que l'on est en minuscules.
$3286       Changement de l'aspect du curseur pour les majuscules : curseur plein.

$328a       [lower_cur]
$328a       Réinitialisation des variables qui concernent l'écran.
$328d       Charge A avec 127 pour préparer la redéfinition de ce caractère.
$328f       Branchement sur la patch de la ROM 1.1

$3292       [initscreen2]
$3292       Redéfinition du caractère $20 étendu.
$3295       Prépare la couleur de fond pour l'enchaînement vers la routine suivante.

$3297       [init_cls]
            Efface l'écran avec la couleur de fond passée dans A.
            Fixe la couleur d'écriture pour les caractères suivants.

            Entrée :
            - A contient la valeur pour la variable `(attbak)`.

$3297       Met la valeur de A dans le registre `(attbak)`.
$329a       Efface le buffer d'écran BASIC.

$329d       [cur_home]
            Place le curseur en haut de l'écran et force un rafraîchissement d'affichage.

$329d       HL contient les coordonnées du curseur : ligne 0, colonne 1.
$32a0       Met à jour la variable position des coordonnées du curseur.
$32a3-$32a7 Force le rafraîchissement écran à l'interruption suivante.
$32ab       Et attend le prochain rafraîchissement.

$32ad       [keyb_lost]
            %CODE
            Cette routine ne semble pas être appelée.

            Elle effectue un scan du clavier avec préservation des registres (sauf F).

            Sorties :
            - Z est à 1 si le scan a renvoyé 0.

$32b7       [dec_keybrd]
            Décode le clavier et modifie la forme du curseur en fonction de la touche de verrouillage majuscules.

            La routine gère aussi la répétition des touches laissées appuyées.

            Sortie :
            - A contient le caractère appuyé ou 0.
            - Le drapeau Z correspond au contenu de A.
            - Le drapeau M est levé si la touche est une touche de fonction.

$32b7       Échange les registres avec les registres alternatifs.
$32b8       Scan le clavier
$32bb       Branche si une nouvelle touche a été appuyée.
$32bd       Sauve la touche lue dans L
$32be       Teste si  le bit 7 de `repena`. À 0, on est sur la première attente de répétition (longue), à 1, on est sur les attentes suivantes (courtes).
$32c2       Charge dans A la valeur du compteur de répétition.
$32c5       Branche si la répétition est active, pour une attente courte.
$32c8       Sinon, compare le compteur avec `$80`, attente longue.

$32cd       [short_rep]
$32cd       Compare le compteur avec $08, pour une attente courte avant la répétition de la touche.
$32cf       [long_rep]
$32cf       Branche si le compteur est inférieur à la valeur comparée. Le compteur est incrémenté à chaque interruption, qu'il y ait rafraîchissement de l'affichage ou pas.
$32d2       Une première répétition de touche a eu lieu, on bascule sur les répétition courtes.
$32d6       Récupération de la touche appuyée.

$32da       [new_key]
$32da       Une nouvelle touche vient d'être appuyée, on bascule sur une répétition longue.
$32de       [new_key_p]
$32de       La touche est validée, le compteur de répétition est mis à 0.
$32e2-$32e4 Branche si la touche appuyée n'est pas la touche de verrouillage majuscule.
$32e6-$32ea Branche si la touche de verrouillage était inactive.
$32ec       Désactive le verrouillage des majuscules.
$32f0       Affichage du curseur en souligné.

$32f6       [set_lock]
$32f6       Active le verrouillage des majuscules.
$32fa       Affichage du curseur en forme pleine.

$32fe       [lock_key]
$32fe       Demande un rafraîchissement d'écran à la prochaine interruption.

$3304       [not_caps]
$3304-$3308 Branche si le clavier n'est pas en verrouillage majuscule.
$330a-$330c Branche si le caractère lu est inférieur à $61 (début des minuscules)
$330e-$3310 Branche si le caractère lu est supérieur ou égal à $7b (après les minuscules)
$3312       Transforme une minuscule en majuscule.

$3316       [key_era_end]
$3317       [end_dec_key]
$3317       Place les drapeaux en fonction de A.
$3318       Revient sur les registres initiaux.

$331a       [sendchar_t2]
            Traite un caractère à destination de l'écran.

            Entrée :
            - A contient le caractère à traiter.

$331a       Passe sur les registres généraux annexes.
$331b       Sauve le caractère à traiter sur la pile.
$331c-$331f Place l'adresse de retour sur la pile vers la fin de la routine.
$3320-$3322 Branche si le caractère est inférieur strictement à 128.
$3324-$3326 Branche si le caractère est égal ou supérieur à 160.
$3328       A est compris entre 128 et 159. La mise à 0 du bit 7 revient à soustraire 128, ce qui amène A entre 0 et 31.
$332a       Branche plus loin.

$332c       [sdchar_bl80]
            A est inférieur strictement à 128.
$332c-$332e Branche si A est égale à 32 ou supérieur (donc entre 32 et 127 inclus). Le caractère est envoyé tel quel.
$3330-$3334 Branche si les caractères utilisateurs (modifiables en RAM du VDP) son actifs.
$3336-$333a Sinon, branche si c'est un caractère graphique (et ROM). Le caractère est envoyé tel quel.

$333c       [sdchar_spec]
            Arrivée ici si le caractère était
            - dans l'intervalle [128,160[ (ajusté en [0, 32[)
            - un caractère utilisateur de numéro inférieur strictement à 32.
            - un caractère texte ROM inférieur strictement à 32.

            Dans tous les cas, A est compris dans l'intervalle [0, 32[.
$333c       Prépare le registre DE.
$333e       Sauve AF sur la pile.
$333f-$3342 DE = A * 3 (A contient le caractère)
$3343       Pointe vers la table d'indirection.
$3346       Ajout de l'index au pointeur sur la table.
$3347       Restaure AF.
$3348       Branche sur la table de redirection pour traiter les caractères spéciaux.

$3349       [sd_a_ff]
            Re-mapping de caractères.

            Instructions partielles en cascade.

            Les 6 labels suivants chargent A avec une certaine valeur puis exécutent une série de `ld hl,xxxx` avec des valeurs inutiles.

            Pour finalement arriver sur 'sdchar_pass'
$3349       A = $ff (signe DISK)
$334c       [sd_a_0d]
$334c       A = $0d
$334f       [sd_a_08]
$334f       A = $08
$3352       [sd_a_04]
$3352       A = $04
$3355       [sd_a_1f]
$3355       A = $1f
$3358       [sd_a_03]
$3358       A = $03

$335a       [sdchar_pass]
$335a       Jette la valeur en haut de la pile.
$335b-$335e Adresse de retour pour le prochain `ret` qui termine la routine avec une demande de rafraîchissement du buffer écran et nettoyage de lapile.
$335f       Affiche le caractère présent dans A avec les attributs actuels.

$3362       [sdchar_ind]
            Suite de saut pour traitement des 31 premiers caractères.
$3362       %CODE
            CHR$(0) -> aucune action
$3365       %CODE
            CHR$(1) -> aucune action
$3368       %CODE
            CHR$(2) -> EFFC
$336b       %CODE
            CHR$(3) -> RET
$336e       %CODE
            CHR$(4) -> EFFL
$3371       %CODE
            CHR$(5) -> INSC
$3374       %CODE
            CHR$(6) -> INSL
$3377       %CODE
            CHR$(7) -> Déplacement du curseur vers la droite
$337a       %CODE
            CHR$(8) -> Déplacement du curseur vers la gauche
$337d       %CODE
            CHR$(9) -> Déplacement du curseur vers le haut
$3380       %CODE
            CHR$(10) -> Déplacement du curseur vers le bas
$3383       %CODE
            CHR$(11) -> aucune action
$3386       %CODE
            CHR$(12) -> Curseur en haut de l'écran.
$3389       %CODE
            CHR$(13) -> RET
$338c       %CODE
            CHR$(14) -> BIP
$338f       %CODE
            CHR$(15) -> Réinitialise le terminal.
$3392       %CODE
            CHR$(16) -> Transforme en $ff (caractère DISK)
$3395       %CODE
            CHR$(17) -> Transforme en $0d
$3398       %CODE
            CHR$(18) -> Envoie le caractère tel quel
$339b       %CODE
            CHR$(19) -> Transforme en $08
$339e       %CODE
            CHR$(20) -> Envoie le caractère tel quel
$33a1       %CODE
            CHR$(21) -> Envoie le caractère tel quel
$33a4       %CODE
            CHR$(22) -> Envoie le caractère tel quel
$33a7       %CODE
            CHR$(23) -> Envoie le caractère tel quel
$33aa       %CODE
            CHR$(24) -> Transforme en $04
$33ad       %CODE
            CHR$(25) -> Envoie le caractère tel quel
$33b0       %CODE
            CHR$(26) -> Transforme en $1f
$33b3       %CODE
            CHR$(27) -> Envoie le caractère tel quel
$33b6       %CODE
            CHR$(28) -> Transforme en $03
$33b9       %CODE
            CHR$(29) -> Envoie le caractère tel quel
$33bc       %CODE
            CHR$(30) -> Efface l'écran du curseur jusqu'en bas.
$33bf       %CODE
$33bf       Charge les attributs de fond utilisés par `INIT`.
$33c2       Efface l'écran.
            CHR$(31) -> Efface l'écran + Touche LIST

$33c5       [send_back]
            %CODE
$33c5-$33ca Réactive la possibilité de continuité.

$33cd       [after_send]
            %CODE
            Cette adresse est forcée dans la pile pour que le RET de l'affichage de caractère passe par là.
            Le rafraîchissement de l'écran est demandé et la pile et les registres remis en ordre.
$33cd       Demande un rafraîchissement du buffer de l'écran.
$33d1       Restaure AF
$33d2       Bascule sur les registres initiaux.

$33d4       [carreturn]
            Traitement du retour chariot (RET 13 ou RET 03)

            Commence par traiter le retour chariot, puis enchaînement sur le saut de ligne.
$33d4       Charge les coordonnées du curseur dans HL
$33d7-$33da Branche si la colonne est différente de 1.
$33dc-$33e1 Branche si la continuité n'est pas permise.
$33e3-$33e8 Si le curseur est sur la colonne 1 et que la continuité est permise, alors la colonne 0 est mise à $80 pour indiquer une fin de continuité.
            Cela se produit lorsqu'une ligne logique se termine avec le curseur en colonne 1 de la dernière ligne physique.
$33ea       Et la routine s'arrête là (pas besoin de sauter de bouger le curseur).

$33eb       [not_col_1]
$33ed       Le curseur est mis sur la colonne 1 et on enchaîne sur le saut de ligne.

$33f0       [line_down]
            Traitement de saut de ligne (après RT, par le caractère 10 pour par un déplacement droite en fin de ligne physique)

$33f0       Charge les coordonnées du curseur dans HL.
$33f3-$33f6 Branche si le curseur se situe sur une ligne strictement avant la 24ième.
$33f8-$33fd Branche si le scrolling de l'écran est désactivé.
$33ff       Fait défiler l'écran d'une ligne vers le haut.
$3402-$3404 Efface la ligne 24.
$3407       Termine la routine.

$3409       [do_line_dwn]
$3409       Le numéro de ligne est incrémenté.
$340a       Les coordonnées du curseur sont mises à jour.

$340d       [dont_do_dwn]

$340e       [line_up]
            Traitement du déplacement du curseur d'une ligne vers le haut (par le caractère 9 ou par un déplacement gauche en haut de l'écran)

$340e       Charge les coordonnées du curseur dans HL.
$3411-$3413 Branche si le curseur n'est pas sur la ligne 0.
$3415-$341a Branche si le scrolling de l'écran est désactivé.
$341c       Fait défiler l'écran d'une ligne vers le bas.
$341f-$3421 Efface la ligne 0.
$3424       Termine la routine.

$3426       [do_line_up]
$3426       Le numéro de ligne est décrémenté.
$3427       Les coordonnées du curseur sont mises à jour.
$342a       [dont_do_up]

$342b       [col_left]
            Traitement du déplacement du curseur d'une colonne vers la gauche (par le caractère 8 ou quelques retours en arrière).

$342b       Charge les coordonnées du curseur dans HL.
$342e-$3431 Branche si la colonne du curseur est inférieur strictement à 2.
            (c'est-à-dire la colonne 1, le curseur n'est pas censé se trouver sur la colonne 0).
$3433       Sinon, décrémente le numéro de la colonne.
$3434       [col_l_end]
$3434       Les coordonnées du curseur sont mises à jour.

$3438       [line_above]
$3438-$343a Retour immédiat si le curseur est en ligne 0.
$343b       Sinon, mon le curseur d'une ligne.
$343e       Puis place le curseur sur la colonne 39 (la plus à droite).
$3440       Branche vers la mise à jour des coordonnées du curseur.

$3442       [col_right]
            Traitement du déplacement du curseur d'une colonne vers la droite (par le caractère 7).

$3442       Charge les coordonnées du curseur dans HL.
$3445-$3448 Branche si le curseur est sur la colonne 39 ou plus (normalement, uniquement 39).
$344a       Sinon, incrémente le numéro de la colonne.
$344b       [col_r_end]
$344b       Les coordonnées du curseur sont mises à jour.

$344f       [line_below]
$344f-$3452 Retour immédiat si le curseur est en ligne 24.
$3453       Sinon, passe à la ligne suivante.
$3456       Puis met le curseur en colonne 1.
$3458       Branche vers la mise à jour des coordonnées du curseur.

$345a       [sd_effc]
            Traitement de EFFC (par le caractère 2).

$345a       Charge les coordonnées du curseur dans HL.
$345d-$3460 Branche si le curseur est sur la colonne 1 ou moins.
$3463       Sinon, sauve les coordonnées sur la pile
$3464       Calcule l'adresse correspondante dans le buffer d'écran BASIC.
$3467       Récupère les coordonnées du curseur dans BC.
$3468-$3469 Place l'adresse calculée dans DE
$346a-$346b Pointe sur le caractère précédant dans le buffer (deux octets par caractère).
$346c-$3471 BC = (40 - numéro de colonne) * 2
            HL = pointe vers l'adresse du buffer écran correspondant au curseur
            DE = pointe sur le caractère précédent.

$3473       [effc_loop]
$3473       Copie `(hl)` vers `(de)` sur `bc` octets.
            Autrement dit, copie le reste de la ligne d'un caractère vers la gauche.
$3475-$3476 Compare le caractère nouvellement pointé avec le caractère de continuité.
$3478-$3479 Replace HL sur la caractère qui vient d'être copié.
$347a       Branche si le caractère suivant n'est pas le caractère de continuité.
$347c-$347d Replace HL sur le caractère source de la copie.

$347e       [effc_cont]
$347e-$347f Avance de deux octets dans le buffer d'écran.
$3480       Lit le caractère pointé.
$3481-$3484 Revient de 4 octets en arrière.
$3485       Y copie le caractère.
$3486-$3489 Retour 4 octets après.
$348a-$348b DE = HL
$348c-$348d Et HL deux octets ensuite.
$348e       Compteur de BC pour une ligne complète.
$3491       Branche pour décaler la ligne suivante.

$3493       [left_col_1]
            Traite le cas où le caractère effacé à gauche du curseur sur la colonne 1 (ou moins).

            Cette partie est patchée en ROM 1.1

$3493-$3495 Retour si le curseur est sur la ligne 0.
            On ne peut pas effacer un caractère à gauche de la colonne 1 sur la ligne 0.
$3496       Sinon, décale le curseur vers la gauche (éventuellement en montant d'une ligne).
$3497       Lit le caractère pointé par les coordonnées.
$349a       Retour si ce caractère n'est pas le caractère de continuité.
$349b       Branche sur le traitement du reste de la ligne.

$349d       [if_input]
            Ce morceau profite de la place gagnée par le patch de la routine
            précédente en ROM 1.1 pour insérer un morceau de patch de l'acquisition du clavier.

$349d       Branche si le drapeau de commande INPUT était actif.
$34a0       Sinon, on remet la valeur $06 (Insertion de ligne) pour la valeur de touche appuyée.
$34a2       Puis branche vers l'émission de la touche.

$34a5       [effc_end]
$34a5       %CHAR
            Prépare un caractère espace.
$34a7-$34ab Branche si on est en mode de caractères `texte`.
$34ad       Sinon, prépare un caractère nul.
$34ae       [effc_txt]
$34ae       Place le caractère à la fin de la partie effacée.
$34af       Déplace le curseur d'une colonne vers la gauche.

$34b3       [sd_effl]
            Traitement de `EFFL` (par le caractère 4)

$34b3       Charge les coordonnées du curseur dans HL.
$34b6       Sauve les coordonnées sur la pile.
$34b7-$34b9 A = 40 - colonne (le nombre de caractère du curseur jusqu'à la colonne de droite à l'écran)
$34ba       Sauve cette valeur sur la pile
$34bb       Calcul l'adresse correspondante dans le buffer d'écran BASIC.
$34be       B = 40 - colonne
$34bf       E = `(attcar)`
$34c2       %CHAR
            Prépare un caractère espace.
$34c4-$34c6 Branche si on est en mode de caractères `texte`.
$34c8       Sinon, prépare un caractère nul.
$34c9       [effl_txt]
$34c9-$34cc Place le caractère ainsi que la valeur de `(attcar)` dans le buffer de l'écran BASIC.
$34cd       Autant de fois qu'il faut pour effacer la ligne jusqu'à la colonne de droite.

$34cf       [effl_lp]
$34cf       Récupère les coordonnées du curseur dans HL.
$34d0       Coordonnée de colonne en 0.
$34d2       Incrémente le numéro de ligne.
$34d3       Sauve ces nouvelles coordonnées sur la pile.
$34d4       Lit le caractère à l'écran.
$34d7       Restaure les coordonnées.
$34d8       Branche si le caractère en début de ligne n'est pas le caractère de continuité.
$34da       Sinon, place le numéro de ligne dans A
$34db       Sauve les coordonnées.
$34dc       Efface la ligne numéro A avec les attributs courants.
$34df       Boucle sur la ligne suivante.

$34e1       [effl_end]
$34e1       Fin de la continuité de la ligne, l'effacement est terminé.

$34e2       [sd_insc]
            Traitement de `INSC` (par le caractère 5)
$34e2       Charge les coordonnées du curseur dans HL.
$34e5       Colonne 0.

$34e7       [insc_cont]
$34e7       Ligne suivante.
$34e8       Sauve les coordonnées modifiées.
$34e9       Lecture du caractère en colonne 0. En retour, HL contient le pointeur vers le buffer d'écran BASIC.
$34ec       Ce pointeur est passé dans DE.
$34ed       Et HL récupère les coordonnées modifiées.
$34ee       La colonne 0 contenait le marqueur de continuité. Boucle.
$34f1       Récupération dans HL du pointeur vers le buffer d'écran BASIC.
            C'est la première ligne ne contenant pas de marqueur de continuité après la position du curseur.
            DE contient les coordonnées de ce même emplacement.
$34f2-$34f3 Pointe deux positions en arrière, donc sur la colonne de droite de la ligne précédente.
$34f4       Lit le caractère à cette position.
$34f5       Coordonnées du curseur sur la colonne 0 de la dernière ligne formant la ligne logique.
$34f6       Sauve ces coordonnées sur la pile.
$34f7-$34fb Branche si le mode de caractères texte est activé.
$34fd-$34fe Sinon, branche si le caractère lu est nul.
$3501       Branche si le mode activé est celui des caractères graphiques et que le caractère n'est pas nul.

$3503       [insc_txt]
$3503       %CHAR
$3503-$3505 Branche si le caractère texte de la dernière ligne du bloc logique est l'espace.
            Il n'y aura pas besoin d'insérer une nouvelle ligne.

$3508       [insc_gr]
$3508-$350b Charge les coordonnées du curseur dans HL et décrémente le numéro de ligne.
$350c       Branche sur la partie patchée de la ROM 1.1, qui reviendra juste après.

$350f       [insc_2]
            Retour après le patch de la ROM 1.1
$350f       Sauve les coordonnées modifiées du curseur (ligne précédente)
$3510-$3516 Place le curseur sur la ligne après la dernière ligne logique et émet `INSL`, afin de faire de la place pour la ligne logique.
$3519-$351c Récupère les coordonnées du curseur sur la dernière ligne du bloc logique, colonne 0.
$351e       HL pointe sur l'adresse du buffer d'écran BASIC à ces coordonnées.
$3521-$3523 Y place un marqueur de continuité.
$3524-$3525 Récupère et rétablie les coordonnées du curseur initial.
$3528       [insc_blank]
$3528       Charge les coordonnées du curseur dans HL.
$352b       Récupère les coordonnées de la première ligne logique, en colonne 0.
$352c-$352e Branche si les deux coordonnées ont les mêmes lignes.
$3531-$3532 Copie de DE vers HL.
$3533       Décrémente la ligne des coordonnées DE (la ligne traitée)
$3534       Sauve ces nouvelles coordonnées dans la pile.
$3535       HL pointe vers le buffer écran du BASIC aux coordonnées HL.
$3538-$353c Pointe 76+1 octets plus loin.
$353d-$353e Copie HL dans DE.
$353f-$3540 DE pointe 79 octets plus loin que les coordonnées précédentes dans HL.
$3541       Copie 76 octets de `(de)` vers `(hl)`
$3543-$3545 Recule HL de trois octets.
$3546       Prend l'octet pointé.
$3547-$354a Avance HL de 4 octets
$354b       Y place l'octet.
$354c       Boucle sur l'insertion d'un espace sur le reste de la ligne logique.
            Cette boucle copie chaque ligne du bloc entre la fin et le curseur vers la ligne suivante, de bas en haut.

$354f       [insc_same]
$354f       Charge les coordonnées du curseur dans HL.
$3552       Sauve les coordonnées sur la pile.
$3553       Colonne 38
$3555       HL pointe vers le buffer écran du BASIC aux coordonnées HL (en colonne 39)
$3558       Récupère les coordonnées dans BC
$3559-$355c DE pointe 2 octets plus loin que HL (donc sur la colonne 39 de la même ligne).
$355d-$3560 Branche si le curseur est en colonne 39.
$3562-$3564 Sinon, BC est le nombre d'octets entre la position du curseur et la dernière colonne (2 octets par caractère).
$3566       Copie ce nombre d'octet de `(hl)` vers `(de)` (autrement dit, créé un espace)
$3568       [insc_39]
$3568       %CHAR
            Prépare un caractère d'espacement
$356a-$356e Branche si le mode texte est activé.
$3570       Sinon, prépare un caractère nul.
$3571       [insc_txt2]
$3571       Écrit le caractère dans A avec les paramètres courant.
$3574       L'écriture a provoqué l'avancement du curseur. Il est replacé d'une colonne vers la gauche (sur une ligne logique).

$3578       [peekchar]
            Lit le caractère dans le buffer écran du BASIC aux coordonnées HL dans A.

            Entrée :
            - HL contient les coordonnées du curseur (H = ligne, L = colonne)

            Sortie :
            - A contient le caractère aux coordonnées indiquées.
            - Z est à 0 si ce caractère est le marqueur de continuité de ligne logique.
            - HL pointe vers l'adresse correspondante dans le buffer écran du BASIC.

$3578       HL pointe vers le buffer écran BASIC aux coordonnées précédemment dans HL.
$357b       Lit le caractère à cet endroit.
$357c       Le compare au caractère de continuité de ligne logique.

$357f       [sd_insl]
            Traitement de `INSL` (par le caractère 6)

            La ligne insérée est au niveau du curseur et pousse toutes les lignes du dessus vers le haut.
$357f       Charge les coordonnées du curseur dans HL.
$3582-$3584 Branche si la ligne est 0.
$3586       Sinon, coordonnées en colonne 0.
$3588       HL pointe vers le buffer écran BASIC aux coordonnées précédemment dans HL.
$358b       DE pointe sur le début de l'écran.
$358e       Carry à 0.
$358f-$3592 BC contient la différence entre le début de l'écran et le début de la ligne sur laquelle est le curseur.
$3593       HL pointe sur la ligne 1.
$3596       Copie la ligne 1 vers le début de l'écran pendant la longueur indiquée, ce qui provoque un espace au dessus du curseur.

$3598       [iinsl_0]
$3598-$359b Efface le contenu de la ligne du curseur.

$359f       [sd_effe]
            Traitement de l'effacement bas de l'écran (par le caractère 30)

            Efface toutes les lignes à partir de la ligne courante du curseur jusqu'en bas de l'écran.

$359f       A contient la ligne des coordonnées du curseur.

$35a2       [effe_lp]
$35a2       Sauve A
$35a3       Efface la ligne indiquée par A.
$35a6       Restaure A
$35a7       Incrémente A (c'est-à-dire passe à la ligne suivante).
$35a8-$35aa Boucle tant que la ligne n'est pas 25.

$35ad       [scroll_up]
            Remonte le contenu du buffer écran BASIC d'une ligne par recopie de la mémoire.

            La dernière ligne n'est pas touchée.

$35ad       HL pointe sur la ligne 1.
$35b0       DE pointe sur la ligne 0.
$35b3       BC est la taille de l'écran en octet, moins une ligne.
$35b6       Copie.

$35b9       [scroll_down]
            Descend le contenu du buffer écran BASIC d'une ligne par recopie de la mémoire.

            La première ligne n'est pas touchée.
$35b9       HL pointe sur la ligne 24
$35bc       %NOT_LABEL
            DE pointe sur la ligne 25 (c'est-à-dire juste après la fin du buffer)
$35bf       BC est la taille de l'écran en octet, moins une ligne.
$35c2       Copie.

$35c5       [reset_term]
            Réinitialise les attributs d'affichage à l'écran.

$35c5-$35ca La ligne n'est pas une ligne BASIC, et le défilement de l'écran est permis.
$35cd       Sélection des caractères en ROM.
$35d1       Couleur d'encre et fond graphique à zero, mode texte sélectionné.
$35d5-$35d9 Équivalent de `DISPLAY 10`.
$35dd       Simple hauteur de caractère (bit 7 de MAT)
$35e1       Curseur visible (bit 6 de MAT)

$35e6       [honk]
            Émet un 'bip' sonore (caractère 7).
$35e6-$35ec Paramètres du son à émettre.
$35ef       Émission du son.

$35f3       [jump_ret]
            Cette adresse est utilisée par la table de traitement des caractères pour ceux qui n'ont pas d'effet.

$35f4       [char20]
$35f4       Données pour la redéfinition du caractère $20.
            Le motif est différent dans les deux versions de la ROM.
            Ces données ne sont pas utilisées dans la ROM 1.0
            ........
            ...X....
            ..XXX...
            .XXXXX..
            XXXXXXX.
            .XXXXX..
            ..XXX...
            ...X....
            ........
            ........
$35fe       [char7f]
$35fe       Données pour la redéfinition du caractère $7f.
            ........
            ........
            ........
            ........
            ........
            ..X.X...
            ........
            ........
            ........
            ........
$3608       [zero]
$3608       Un octet inutilisé.

$3609       [str_cmp]
            %CODE,SECTION(bistrs),MS_BASIC(CMPSTR)
            == DEBUT DE SECTION BISTRS (BASIC string handler) ==
            Comparaison entre deux chaînes de caractères.

$3609       Sauve le descripteur de la première chaîne sur la pile.
$360a       Récupère le descripteur de la seconde chaîne depuis FAC.
$360d       A = longueur de la chaîne.
$360e-$3610 Se place sur l'adresse de la chaîne.
$3611-$3612 BC = adresse de la chaîne.
$3613       Restaure le descripteur de la première chaîne.
$3614       Sauve l'adresse du contenu de la seconde chaîne sur la pile.
$3615       De même que sa longueur.
$3616       Récupère le descripteur de la première chaîne pointée par DE.
$3619       Le descripteur est chargé dans BCDE.
            E contient la longueur de la chaîne chargée.
            BC pointe vers le contenu de la première chaîne.
$361c-$361d Met la longueur de la première chaîne dans D.
$361e       HL pointe sur le contenu de la seconde chaîne.

$361f       [cmp_str_lp]
$361f-$3621 Retour (avec Z à 1) si D et E sont égaux à 0.
            Les deux chaînes ont été comparées entièrement avec succès.
$3622-$3623 Réduit la longueur restante de 1.
$3625       Retour (avec Z à 0 et Carry à 1) si la longueur est devenu négative.
            La première chaîne est terminée, mais pas la seconde.
$3626-$3627 Compare E avec 0.
$3628       A = 1
$3629       Retour si la taille de la seconde chaîne a été consommée.
            Le test se fait sur Carry car ce drapeau n'est pas touché par `inc a`.
$362a       Diminue le compteur de taille restante de la première chaîne.
$362b       Diminue le compteur de taille restante de la seconde chaîne.
$362c-$3630 Boucle si les deux octets des deux chaînes sont identiques.
            Les pointeurs sur les deux chaînes ont été placés sur le caractère suivante.
$3632       Complète le Carry pour signaler la bonne différence par rapport à la dernière comparaison de caractère.
$3633       Branche vers le retour signalant une différence dans la comparaison.

$3636       [inst_str]
            %CODE,MS_BASIC(STR)

            Fonction BASIC : `STR`
$3636       Le paramètre doit être de type numérique.
$3639       Transforme le nombre en chaîne de caractère.
$363c       Créé une entrée de chaîne avec le résultat.
$363f       Récupère le descripteur de chaîne depuis FAC.
$3642-$3645 Place l'adresse de retour pour monter la chaîne vers le buffer temporaire et FAC.

$3646       [save_str]
$3646       A = longueur de la chaîne source
$3647-$3649 Sauve l'adresse du contenu de la chaîne sur la pile.
$364a       Allocation de l'espace nécessaire dans l'espace des chaînes de caractères.
$364d-$3650 BC = adresse du contenu de la chaîne source.
$3651       Création d'un descripteur temporaire de chaîne.
$3654       Sauve l'adresse de ce descripteur temporaire, sur la pile
$3655-$3656 Copie L octets de BC (source) vers DE (destination), ce qui copie la chaîne dans l'espace des chaînes de caractères.
$3659       DE pointe sur le descripteur de chaîne temporaire.
$365a       En venant de la fonction `STR()`, branche vers `to_pool`.
            Sinon, retourne vers l'allocation d'une chaîne de caractères.

$365b       [str_len_1]
            Création d'une chaîne de longueur 1.
$365b       A est la taille de chaîne de caractères demandée (1)

$365d       [ctr_ver_str]
            Allocation d'une chaîne de caractères après vérification de la mémoire disponible.

            Un descripteur de chaîne fait 4 octets de long :
            - longueur de la chaîne sur un octet
            - un octet inutilisé
            - pointeur vers les données de la chaîne, sur deux octets.

            Entrées :
            - A contient la longueur de la chaîne de caractères en octets.
            - DE pointe sur le contenu de la chaîne de caractères.

            Sortie :
            - HL pointe vers un descripteur temporaire de chaîne situé en `dsctmp`.

$3660       [crt_str_dsc]
            %MS_BASIC(CRTMST)
            Création d'un descripteur temporaire de chaîne de caractères.

            Entrées :
            - A contient la longueur de la chaîne de caractères en octets.
            - DE pointe sur le contenu de la chaîne de caractères.

            Sortie :
            - HL pointe vers un descripteur temporaire de chaîne situé en `dsctmp`.
            - DE pointe sur le contenu de la chaîne de caractères.

$3660       HL pointe vers le buffer temporaire de construction des chaînes.
$3663       Sauve cette adresse sur la pile.
$3664-$3665 Place la longueur de la chaîne de caractères dans le descripteur.

$3666       [de_in_hl]
$3666-$3669 Place DE dans les deux octets pointés par HL et HL + 1.
            Dans le cas d'une chaîne de caractères, c'est le pointeur vers son contenu.
$366a       Restaure HL.

$366c       [out_str_prc]
            %MS_BASIC(CRTST)
            Création d'une chaîne de caractères depuis la source pointée par HL dans le buffer `tempst`

            Une chaîne se termine lorsqu'elle atteint le caractère nul.
            Une chaîne a une taille de 255 caractères maximum.

            Entrée :
            - HL pointe vers les données de la chaîne de caractères, se terminant par 0.

            Sortie :
            - FAC contient l'adresse du descripteur de la chaîne.
            - HL pointe après les données de chaîne pointée par HL initialement.
            - A contient le caractère lu après les données de la chaîne.
            - `(valtyp)` est à 1.

$366c       Positionne HL un caractère avant le début de la chaîne (à cause du inc hl de la boucle qui suit)
$366d       [str_to_str]
            %MS_BASIC(QTSTR)
$366d       %CHAR
$366d-$366f '"' dans B puis D

$3670       [direct_str]
            %MS_BASIC(DTSTR)
            Un appel direct ici devra placer ses propres terminateurs dans B et D.
$3670       Sauve le pointeur actuel vers les données de la chaîne.
$3671       C est la taille de la chaîne de caractères et est initialisé à -1.

$3673       [loop_str]
$3673       Avance le pointeur vers les données de la chaîne de caractères.
$3674       A contient le caractère pointé.
$3675       Augmente la longueur totale de la chaîne.
$3676-$3677 Branche si le caractère nul a été trouvé.
$3679-$367a Branche si le caractère est le terminateur contenu dans D (guillemets par exemple).
$367c-$367d Boucle si le caractère n'est pas le terminateur contenu dans B.

$367f       [create_str]
$367f       %CHAR
$367f-$3681 Si la lecture s'est terminée par des guillemets, on les consomme.
$3684-$3685 Récupération du pointeur du début des données de la chaîne dans HL.
            Le haut de la pile contient l'adresse de fin des données de la chaîne.
$3686       DE pointe sur le début des données de la chaîne de caractères.
$3687       A est la longueur de la chaîne de caractères.
$3688       Créé un descripteur temporaire sur cette chaîne de caractères.

$368b       [cpy_to_pool]
$368b       DE pointe sur l'espace temporaire utilisé pour le descripteur.
$368e       HL pointe vers l'espace temporaire `tempst` pour le traitement de chaîne de caractères, à un emplacement libre.
$3691       Cette adresse est sauvée dans FAC.
$3694-$3696 La valeur courante est une chaîne de caractères.
$3699       Copie les 4 premiers octets de `dsctmp` vers `(hl)`.
            Autrement dit, copie la description de chaîne temporaire dans le pool de chaîne `tempst`.
$369c       Vérifie si 'de' et 'hl' sont identiques. Cela signifie que le buffer de chaîne `tempst` est plein.
$369d       Mise à jour du pointeur vers le buffer temporaire `tempst`.
$36a0       Récupère le pointeur vers la fin des données de la chaîne de caractères.
$36a1       Lecture du prochain caractère à destination de l'appelant.
$36a2       Retour s'il reste de la place dans le buffer `tempst`.
$36a3-$36a6 Sinon, c'est une erreur "String formula too complex".

$36a9       [sharp_char]
            %CODE,MS_BASIC(PRNUMS)
            Émet une chaîne de caractères sur le périphérique courant, sans le premier caractère pointé par HL.

            Entrée :
            - HL pointe un octet avant la chaîne à émettre. La chaîne se termine par un 0.

$36a9       Avance le pointeur HL de 1 octet.

$36aa       [out_str]
            %MS_BASIC(PRS)
            Émet une chaîne de caractères sur le périphérique courant.

            Entrée :
            - HL pointe un octet avant la chaîne à émettre. La chaîne se termine par un 0.

$36aa       Créé un descripteur temporaire pour la chaîne pointée par HL.

$36ad       [out_str1]
            %MS_BASIC(PRS1)
            Émet une chaîne de caractères sur le périphérique courant.

            Entrée :
            - FAC pointe vers un descripteur de chaîne de caractères.
$36ad       Lit le descripteur de chaîne courante. HL pointe sur le descripteur.
$36b0       Copie le descripteur dans BCDE.
$36b3       Prépare la boucle suivante, E étant la longueur de la chaîne de caractères.

$36b4       [prs_lp]
            %MS_BASIC(PRSLP)
$36b4       Décompte le nombre de caractères restant à émettre.
$36b5       Retour s'il n'y en a plus à émettre.
$36b6       Lit le caractères à émettre.
$36b7       Émet le caractère.
$36b8       Avance le pointeur sur l'octet suivant.
$36b9       Boucle sur l'émission de caractères.

$36bb       [alloc_stmem]
            %MS_BASIC(TESTR)
            Alloue l'espace nécessaire au stockage d'une chaîne de caractères.

            Lance le GC (Garbage Collector / Ramasse Miettes) si nécessaire.

            Z est d'abord mis à 0, et plus tard mis à 1 s'il n'y a pas assez de mémoire et que le ramasse miettes est lancé.
            Si au deuxième passage il n'y a toujours pas assez de mémoire, alors une erreur est lancée.

            Entrée :
            - A contient la longueur de la chaîne demandée.

            Sortie :
            - DE pointe vers l'espace alloué.
            - `(fretop)` est ajusté en conséquence.

            [ArticleGarbageCollect]

$36bb       Met Z à 0 pour indiquer qu'il faudra lancer le GC.
            En effet, la longueur de la chaîne n'est pas nul.
$36bc       Passe par dessus le `pop af` qui suit.

$36bd       [retry_alloc]
            %CODE
$36bd       Sauve `AF` sur la pile lors de la seconde tentative, pour garder la symétrie avec le `push af` qui suit.
$36be       Sauve l'état de Carry pour contrôler le GC.
$36bf       Charge le pointeur sur le haut de la stack (et donc juste sous la mémoire réservée pour les chaînes)
$36c2       DE contient `(stktop)`, le haut de la pile.
            La pile est située sous l'espace réservé pour les chaînes de caractères.
$36c3       HL contient `(fretop)`, la plus haute adresse mémoire disponible pour les chaînes.
$36c6-$36c8 BC est le complément à 1 de  A, la taille de la chaîne à allouer.
$36ca       Ajoute cette valeur à HL.
$36cb       Ajuste HL pour un complément à 2 de A.
            Au final, HL = `(fretop)` - A.
$36cc       Compare cette adresse avec `DE`, qui est l'adresse la plus basse possible pour le chaîne (puisque c'est le haut de la pile).
$36cd       Branche si HL est inférieur à DE, il n'y a pas assez de mémoire pour cette chaîne.
$36cf       Met à jour `(fretop)` avec le nouveau pointeur.
$36d2       HL est positionné sur la première adresse après `(fretop)`.
            C'est l'adresse allouée pour la chaîne.
$36d3       Cette adresse est placée dans DE.
$36d4       Jette le drapeau de traitement du GC.

$36d6       [out_str_mem]
$36d6       Récupère le drapeau de traitement de Garbage Collection.
$36d7-$36da Branche sur l'erreur "Out of string space" si le drapeau de traitement du GC est à 0.
            Cela signifie que la passe GC a déjà été faite et que la seconde tentative a elle aussi échouée.
$36dd       Place le drapeau Z à 1, pour indiquer qu'une première tentative d'allocation a échoué.
$36de       Sauve les drapeaux sur la pile.
$36df-$36e2 L'adresse de retour ira vers une nouvelle tentative d'allocation.

$36e3       [gc_start]
            Débute l'opération de ramasse miettes (Garbage Collection / GC).

            Le principe est de nettoyer toute donnée de chaîne non référencée par un descripteur de chaîne.

$36e3       Le traitement débute à la plus haute adresse en RAM, qui est aussi la plus haute adresse pour l'espace de chaînes de caractères.

$36e6       [str_srch]
$36e6       Mise à jour du pointeur vers la prochaine adresse disponible pour les chaînes de caractères.
$36e9-$36ec Place $0000 sur la pile.
$36ed-$36f0 Place la plus haute adresse utilisée par les variables et tableaux sur la pile.
$36f1       HL pointe vers le buffer des descripteurs de chaînes temporaires.
$36f4       [srch_temp]
$36f4       DE pointe vers le descripteur temporaire courant.
$36f8       Compare le pointeur de descripteur temporaire avec l'adresse du début du buffer des descripteurs temporaire.
$36f9       Prépare l'adresse de retour pour boucler sur la recherche dans les descripteurs temporaires.
$36fc       Le descripteur étudié n'était pas le dernier.
$36ff       Sinon, la recherche dans les descripteurs temporaire est terminée, la recherche se fait à présent dans les variables.
            HL pointe vers le début de la zone des variables.
$3702       [srch_var]
$3702       DE pointe vers le début de la zone des tableaux, donc à la fin de la zone des variables.
$3706       Compare le pointeur de variables avec le début de la zone des variables.
$3707       Branche si les deux pointeurs sont égaux : la recherche est terminée pour la zone des variables.
$3709-$370c Si le nom de la variable désigne une chaîne de caractères, le drapeau P sera à 0.
$370d       Vérifie si cette variable référence une chaîne de caractères.
$3710       Boucle sur la variable suivante.

$3712       [next_ary]
$3712       Jette le pointeur vers le nombre de dimension du tableau précédent.

$3713       [srch_ary]
            Recherche les références de chaînes dans les tableaux.

$3713       `DE` pointe sur la dernière adresse allouée pour les tableaux.
$3717       Compare avec HL qui pointe sur un début de tableau ou sur `(strend)`
$3718       La zone des tableaux est terminée.
$371b       Récupère l'identifiant du tableau dans BCDE.
            ED est l'identifiant.
            BC est la taille des données du tableau.
$371e       Récupère le type du tableau.
$371f       Sauve HL sur la pile, qui pointe vers le nombre de dimensions du tableau.
$3720       HL pointe sur le tableau suivant.
$3721-$3722 Branche si le type du tableau est numérique.
$3725       Sauve l'adresse du tableau suivant.
$3728       Récupère le pointeur vers le nombre de dimensions du tableau.
$3729-$372a BC est le nombre de dimensions du tableau.
$372c-$372e Pointe au delà des dimensions (2 octets par dimensions).
$372f       [ary_lp]
$372f       Place le pointeur dans DE.
$3730       Récupère l'adresse du tableau suivant.
$3733-$3734 Compare l'adresse actuelle dans le tableau avec celle du tableau suivant.
$3735       Ce tableau est terminé, branche sur le suivant.
$3737       Prépare l'adresse de retour vers la boucle de recherche dans le tableau actuel.
            Enchaîne pour vérifier si l'identifiant contenu dans le tableau pointe vers la donnée chaîne actuelle.

$373a       [st_pool]
$373a       Place l'adresse de retour.
$373b       Prépare le type chaîne pour la routine suivante.

$373d       [str_in_pool]
            Vérifie si le descripteur de chaîne pointé vers HL correspond à la chaîne pointée par `(freetop)`
$373d       A = longueur de la chaîne de caractères.
$373e-$3743 DE pointe sur les données de la chaîne de caractères.
$3744       Retour si la variable n'est pas de type chaîne.
            Les tableaux sont forcés au bon type car vérifiés au préalable.
            Le retour est en fait un branchement vers la boucle actuelle.
$3745-$3746 Retour si la longueur de la chaîne est 0.
$3747-$3748 Sauve HL dans BC
$3749-$374c Compare l'adresse de contenu de chaîne avec le pointeur de donnée trouvée dans le descripteur.
$374d-$374e Restaure HL depuis BC. HL pointe après le descripteur analysé.
$374f       Retour si HL est inférieur à DE, cela signifie que les données sont après `(fretop)`.
$3750-$3751 Récupère l'adresse sous l'adresse de retour, qui pointe vers `(strend)`
$3752       Compare `(strend)` avec l'adresse des données dans DE.
$3753-$3754 Remet la pile en ordre.
$3755-$3756 Récupère le pointeur après le descripteur analysé.
$3757       Retour si DE (les données) est inférieur à `(strend)`.
            Après ces deux conditions de retour, DE est situé entre `(strend)` et `(fretop)`.
$3758       Préserve l'adresse de retour dans BC
$3759-$375a Jette les deux valeurs suivantes.
$375b       Place le pointeur après la variable à nettoyer.
$375c       Place la zone des données de chaînes associée.
$375d       Replace l'adresse de retour sur la pile.

$375f       [gc_end]
$375f       Récupère le pointeur vers les données de chaîne.
$3760       Récupère le pointeur après le descripteur trouvé (ou 0).
$3761-$3763 Retour si HL est nul, il n'y a rien à faire.
$3764-$3767 Récupère le pointeur vers les données de chaîne depuis le descripteur.
$3768       Sauve le pointeur vers la partie adresse du descripteur.
$3769-$376a Revient en arrière de deux octets pour pointer sur la longueur de la chaîne.
$376b-$376c HL = longueur de la chaîne.
$376e       HL pointe vers le début des données de chaîne suivante.
$376f-$3770 DE pointe sur le début des données de la chaîne.
$3771-$3773 BC pointe sur le dernier octet de la chaîne.
$3774       HL pointe vers la première adresse disponible dans l'espace de chaîne.
$3777       Déplace la chaîne pour compacter l'espace des chaîne de caractères.
$377a       Récupère l'adresse du descripteur de la chaîne.
$377b-$377d Met à jour le descripteur avec la nouvelle adresse des données de chaîne.
$377e-$3780 HL pointe vers la valeur ajustée pour `(fretop)` qui sera mise à jour à la prochaine boucle.
$3781       Boucle vers la prochaine chaîne.

$3784       [str_concat]
            %MS_BASIC(CONCAT)
            Concatène deux chaînes de caractères.

$3784       Sauve BC sur la pile.
$3785       Sauve HL sur la pile.
$3786       Récupère le pointeur vers la chaîne actuelle.
$3789       Sauve le pointeur sur la pile et récupère le pointeur vers le texte BASIC.
$378a       Évalue la chaîne de caractères suivante.
$378d       Récupère le pointeur vers la première chaîne et place sur la pile le pointeur vers le texte BASIC.
$378e       Vérifie que la valeur évaluée est de type chaîne ou lance une erreur.
$3791       A = longueur de la première chaîne de caractères.
$3792       Sauve l'adresse de la première chaîne de caractères.
$3793-$3796 Sauve l'adresse de la seconde chaîne de caractères.
$3797       Ajoute la longueur de la seconde chaîne à la longueur de la première.
$3798-$379b Sors avec "String too long" si la somme des deux longueurs est supérieure à 255.
$379e       Alloue une chaîne de caractères de la longueur de la future chaîne de caractères.
$37a1       DE pointe vers le descripteur de la seconde chaîne.
$37a2       Récupère la chaîne pointée par DE.
$37a5       HL qui pointe sur la première chaîne est mis en haut de la pile. Récupère le descripteur de la première chaîne.
$37a6       Récupère la chaîne pointée par HL.
$37a9       Sauve le descripteur sur la première chaîne.
$37aa-$37ad DE pointe sur la zone mémoire allouée pour le résultat.
$37ae       Envoie la chaîne pointée sur la pile vers la zone des chaînes de caractères.
$37b1       Envoie la chaîne pointée sur la pile vers la zone des chaînes de caractères. Ce qui effectue la concaténation.
$37b4-$37b8 Place l'adresse de retour vers `eval_1b` sous l'adresse de retour actuelle.
$37b9       Copie le descripteur de chaîne vers le buffer temporaire et FAC.

$37bc       [to_str_area]
            Copie la chaîne désignée par le pointeur de descripteur en deuxième place dans la pile vers l'adresse pointée par DE.

$37bc-$37bd HL = pointeur sur un descripteur de chaîne extrait de la pile en deuxième position, en préservant l'adresse de retour.
$37be       A prend la longueur de la chaîne.
$37bf-$37c3 BC pointe sur les données de la chaîne.
$37c4       L prend la longueur de la chaîne.

$37c5       [copy_str]
            Copie le contenu mémoire d'une taille de L de BC vers DE.
$37c5       Prépare la boucle qui suit.

$37c6       [copy_loop]
$37c6       Décrémente le compteur du nombre d'octets restant à copier.
$37c7       Retour si la copie est terminée.
$37c8-$37c9 Copie `(de)` vers `(bc)`.
$37ca-$37cb Avance les deux pointeurs d'un octet chacun.
$37cc       Boucle sur la copie.

$37ce       [get_string]
            %MS_BASIC(GETSTR)
            Vérifie le type courant comme étant un chaîne, puis enchaîne sur la récupération de la chaîne de caractères courante.

            Entrée :
            - Suivant l'entrée, le descripteur de chaîne à récupérer est soit dans FAC, soit dans HL, soit dans DE.

            Sortie :
            - HL pointe sur le descripteur de chaîne de caractères en entrée.
            - DE pointe un caractère avant le contenu de la chaîne.

$37ce       Vérifie que le type de donnée évaluée est de type chaîne.

$37d1       [get_cur_str]
            %MS_BASIC(GSTRCU)
$37d1       Récupère le pointeur vers le descripteur de la dernière chaîne évaluée.

$37d4       [get_str_1]
$37d4       Sauve HL dans DE.

$37d5       [get_str_2]
$37d5       Récupère le descripteur de chaîne le plus récent. BC pointera sur le contenu de la chaîne.
$37d8       Récupère HL depuis DE.
$37d9       Sort si la chaîne cherchée (initialement HL) n'était pas la plus récente.
$37da       Sauve DE qui contient le descripteur de chaîne.
$37db-$37dc DE pointe sur le contenu de la chaîne.
$37dd       Pointe sur l'octet qui précède.
$37de       C contient la taille de la chaîne de caractères
$37df       Compare DE (le contenu de la chaîne) avec HL (l'adresse la plus basse de l'espace de chaîne).
$37e2-$37e3 Branche si ce n'est pas la dernière chaîne (la plus basse) de l'espace de chaîne.
$37e5       B = 0 (car A = 0), donc BC est la longueur de la chaîne de caractères.
$37e6-$37e7 Efface la chaîne de l'espace de nom par ajustement du pointeur de l'espace de chaîne.
$37ea       [gstr_end]
$37ea       Restaure le descripteur de la chaîne.

$37ec       [pop_tmp]
            Retourne dans BC le contenu de la chaîne la plus en haut (la plus récente) de la pile des descripteurs de chaîne temporaire.

            Si DE pointe sur le descripteur le plus récent, le laisse dans la pile de chaînes.
            Sinon, retire le descripteur le plus récent de la pile.

            Entrées :
            - DE pointe sur un descripteur de chaîne.

            Sortie :
            - BC pointe sur le contenu de la chaîne de caractères.

$37ec       HL pointe sur sur le haut du buffer de descripteurs de chaînes temporaires.
$37ef-$37f4 BC pointe sur les données de la chaîne décrite sur le haut du buffer.
$37f5-$37f6 Retour si ce descripteur est celui pointé par DE. On laisse le descripteur dans le buffer.
$37f7       Sinon, ajuste le pointeur pour retirer le descripteur.

$37fb       [inst_len]
            %CODE,MS_BASIC(LEN)
            Fonction BASIC : `LEN`

            En appelant la deuxième partie de la routine, on obtient le résultat dans A et D = 0.

            Sortie :
            - D est à 0
            - A est la longueur de la chaîne

$37fb-$37fe Retour de la routine pour les fonctions qui retournent le résultat dans A.

$37ff       [fetch_str]
$37ff       Récupère la chaîne courante évaluée (depuis FAC).
            Ou erreur si ce n'est pas une chaîne.
            HL pointe sur le descripteur de la chaîne.
$3802-$3803 D et A sont à 0.
$3804       Le résultat est numérique.
$3807       Récupère la longueur de la chaîne dans A.
$3808       Nettoie les drapeaux.

$380a       [inst_asc]
            %CODE,MS_BASIC(ASC)
            Fonction BASIC : `ASC`

$380a-$380d Retour de la routine pour les fonctions qui retournent le résultat dans A.

$380e       [str_to_de]
$380e       Récupère le chaîne depuis le code commun de `LEN`.
$3811       Si la chaîne de caractères est de longueur nulle, c'est une erreur.
$3814-$3818 DE pointe sur les données de la chaîne de caractères.
$3819       A est le premier caractère de la chaîne, qui sera donc renvoyé sous forme numérique.

$381b       [inst_chr]
            %CODE,MS_BASIC(CHR)
            Fonction BASIC : `CHR`

$381b       Crée une chaîne de longueur 1.
$381e       Lit le texte BASIC et le transforme en valeur numérique (dans A ainsi que dans E)
$3821-$3824 Injecte le résultat de l'évaluation dans la chaîne.

$3825       [to_pool]
$3825       Jette l'adresse de retour vers le traitement de la valeur de la fonction.
            L'évaluation d'une chaîne est transmise par FAC.
$3826       Monte le descripteur de chaîne dans le buffer temporaire et FAC.

$3829       [inst_left]
            %CODE,MS_BASIC(LEFT)
            Fonction BASIC : `LEFT`

            En arrivant dans les fonctions de traitement de chaînes à plusieurs paramètres, la pile contient :
            - la valeur du second paramètre.
            - le pointeur vers le descripteur de la chaîne en premier paramètre.

$3829       Dépile l'argument numérique de `LEFT` dans B.
$382c       A = 0
$382d       [from_right]
$382d       Récupère le pointeur vers le descripteur de la chaîne.
            Haut de la pile = pointeur vers le texte BASIC.
$382e       Copie A, l'index de début de la chaîne à extraire, dans C.
$382f       [from_mid]
$382f       Sauve le pointeur vers le descripteur de chaîne sur la pile.
$3830-$3832 Branche si la longueur de la chaîne est plus petite que la taille de la chaîne à extraire.
$3834       Sinon, copie la taille voulue dans A.
$3835       Saute par dessus le 'ld c,$00' qui suit.
$3836       [small_str]
$3836       L'index de départ est 0, car la chaîne initiale est plus petite que la chaîne à extraire.
$3838       Sauve BC sur la pile, taille de la chaîne résultante, sur la pile.
$3839       Alloue une chaîne de taille A. DE pointe sur la zone allouée.
$383c       Restaure BC. C = index de départ.
$383d       Restaure HL, le pointeur vers le descripteur de la chaîne source.
$383e-$3844 HL pointe vers les données de la chaîne de caractères source.
$3845       BC = index de départ.
$3847       Ajuste HL pour pointer sur le premier caractère à extraire.
$3848-$3849 BC pointe vers le premier caractère à extraire.
$384a       Créé un descripteur de chaîne temporaire vers DE
$384d       Copie la longueur de la chaîne dans L.
$384e       Copie la chaîne pointée par `BC` vers l'espace pointée vers `DE` sur une longueur `L`.
$3851       Restaure le pointeur vers le descripteur source dans DE.
$3852       Récupère le descripteur de chaîne temporaire.
$3855       Copie le descripteur résultat dans le buffer résultat et FAC.

$3858       [inst_right]
            %CODE,MS_BASIC(RIGHT)
            Fonction BASIC : `RIGHT`
$3858       Récupère l'argument numérique de `RIGHT`.
$385b-$385c Récupère dans DE le pointeur vers le descripteur de chaîne source en le laissant sur la pile.
$385d       A = longueur de la chaîne source.
$385e       A = index du début de la chaîne source à extraire.
$385f       Continue vers le code commun `LEFT`/`RIGHT`/`MID`.

$3861       [inst_mid]
            %CODE,MS_BASIC(MID)
            Fonction BASIC : `MID`
$3861       HL pointe vers le texte BASIC.
$3862       A = caractère suivante.
$3863       Récupère le premier argument numérique dans B, index de début de la chaîne source à extraire.
$3866-$3868 Si l'index de départ est 0, c'est une erreur.
$386b       Sauve B, l'index de départ, sur la pile.
$386c       Longueur maximale de chaîne à extraire dans E, valeur par défaut du deuxième paramètre numérique.
$386e       %CHAR
$386e-$3870 Branche si le caractère suivant est une parenthèse fermante.
$3873       Dans le cas contraire, il doit y avoir une virgule.
$3874       %CHAR
$3875       Lecture du deuxième paramètre numérique de `MID` dans E.

$3878       [mid_2_prms]
$3878       Le caractère suivante doit être une parenthèse fermante. Sinon c'est une erreur de syntaxe.
$3879       %DATASKIP
$387a       Restaure l'index de départ dans A.
$387b       HL = descripteur de la chaîne source, Haut de la pile = pointeur vers le texte BASIC.
$387c-$387f Branchement pour le prochain `ret` vers le code commun `LEFT`/`RIGHT`/`MID`.
$3880       Ajuste l'index de départ pour un départ à l'index 0.
$3881       Compare avec la longueur de la chaîne source.
$3882       Par défaut, la chaîne extraire est de taille nulle.
$3884       Ce qui est le cas si l'index de départ est plus grand que la longueur de la chaîne source.
            Dans ce cas, branche vers le code commun 'LEFT`/`RIGHT`/`MID` avec une taille nulle.
$3885       Sinon, C = index de départ de la chaîne (basé en 0)
$3886-$3887 A = (longueur source - index de départ) = longueur de la chaîne à extraire.
$3888       Compare la longueur calculée avec la longueur exprimée par le paramètre de la fonction.
$3889       Copie la longueur calculée dans B.
$388a       Branche vers le code commun si la longueur calculée est plus petite que la longueur exprimée.
$388b-$388c Sinon, branche vers le code commun avec la longueur exprimée.

$388d       [inst_val]
            %CODE,MS_BASIC(VAL)
            Fonction BASIC : `VAL`

$388d       A = longueur de la chaîne actuellement décrite par FAC.
$3890       Branche si la longueur est 0, car alors le résultat est 0.
$3893       Sauve la longueur de la chaîne dans E
$3894-$3899 HL pointe vers les données de la chaîne de caractères.
$389a       Sauve HL sur la pile.
$389b       HL pointe sur la fin de la chaîne +1 car DE = longueur de la chaîne.
$389c-$389d Remplace le caractère après la chaîne par un 0 et garde l'ancien caractère dans B.
$389e       Met la fin de chaîne sur la pile et récupère le début de la chaîne.
$389f       Sauve le caractère modifié sur la pile.
$38a0       Positionne le pointeur un octet avant le début de la chaîne pour pouvoir appeler chget.
$38a1       Récupère le premier octet de la chaîne dans A.
$38a2       Appelle la conversion de chaîne vers FAC.
$38a5       Récupère le caractère modifié.
$38a6       HL pointe vers le caractère modifié.
$38a7       Restaure le caractère modifié.

$38a9       [lf_rt_arg]
            Récupère dans B l'argument numérique de `LEFT` et `RIGHT`
$38a9       HL pointe vers le texte BASIC.
$38aa       Vérifie que la suite est une parenthèse fermante, sinon, c'est une erreur de syntaxe.
$38ab       %DATASKIP

$38ac       [mid_arg]
            Récupère dans B le deuxième argument pour `MID`.

$38ac-$38ae Récupère l’argument depuis la pile en préservant l'adresse de retour.
$38af       Met l'argument dans B.

$38b1       [inst_fre]
            %CODE,MS_BASIC(FRE)
            Instruction BASIC : `FRE`

            Si l'argument est numérique, la place restante calculée est celle qui reste pour les variables, tableaux et fonctions.

            Si l'argument est une chaîne, la place restante calculée est celle qui reste pour le contenu des chaînes de caractères.

$38b1-$38b4 DE contient l'adresse `(strend)`
$38b5-$38b8 HL contient l'adresse de la pile.
$38b9-$38bd Branche si l'argument est numérique sur le calcul de la différence (HL - DE).
$38c0       Récupère le descripteur de la chaîne courante depuis FAC.
$38c3       Lance le ramasse miette.
$38c6       HL contient `(fretop)`, la plus haute mémoire accessible par le BASIC.
$38ca       DE contient `(stktop)`, l'adresse la plus haute de la pile (donc le bas de la pile).
$38cd       Branche sur le calcul de la différence (HL - DE).

$38d0       [dim_cont]
            %CODE,SECTION(biptrg)
            == DEBUT DE SECTION BIPTRG (BASIC pointer get routines) ==
            L'appel est induit par le push en $38d8, lors de l'exécution de l'instruction `DIM`.

$38d0-$38d2 Le texte BASIC a atteint un caractères nul. Retour de la routine.
$38d3       Sinon, le caractère doit être une virgule, sinon, c'est une erreur.
$38d4       %DATASKIP

$38d5       [inst_dim]
            %CODE,MS_BASIC(DIM)
            Instruction BASIC : DIM

            La structure d'un tableau (stocké à partir de `(arytab)`) est le suivant :
            - identifiant du tableau (2 octets),
            - taille des données allouées pour le tableau (dimensions comprises) (2 octets),
            - nombre de dimensions (1 octet),
            - paires d'octets suivantes : taille de chaque dimension,
            - puis la zone d'allocation de données (4 octets pour chaque valeur).
$38d5-$38d8 `DIM` s'appuie sur la récupération/initialisation d'un nom de variable, mais avec une adresse de retour forcée pour permettre le dimensionnement de plusieurs tableaux avec la même instruction.
$38d9       A = $af et passe par dessus le `xor a` qui suit.
            Ce qui fait qu'en passant par `DIM`, `(dimflg)` sera initialisé avec $af.
            En arrivant directement dans la routine suivante, `(dimflg)` sera initialisé avec $00.

$38da       [getvar]
            Cherche le nom de variable pointée par le texte BASIC.

            Ce nom de variable peut référencer une variable numérique, alphanumérique, un tableau ou une fonction.

            Un pointeur sur l'objet nommé est retourné par la routine après avoir été initialisé s'il ne l'était pas déjà.

            Les noms sont stockés sur deux caractères.

            - Si le type de la variable est numérique, alors les deux caractères sont sur 7 bits avec les bits de poids fort à 0.
            - Si le type de la variable est alphanumérique, alors le second caractère a son bit de poids fort à 1.
            - Si le type de la variable est une fonction, alors le premier caractère a son bit de poids fort à 1.

            La valeur est stockée sur les quatre octets qui suivent.

            - Si le type de la variable est numérique, les 4 octets indiquent la valeur.
            - Si le type de la variable est alphanumérique, le premier octet est la longueur de la chaîne, le second n'est pas utilisé, les deux derniers pointent vers les données de la chaîne.
            - Si le type de la variable est une fonction, les deux premiers octets pointent vers le texte BASIC de la fonction, les deux octets suivants forment l'identifiant de la variable locale.

            Entrée:
            - HL pointe sur le texte BASIC au niveau du nom.

            Sorties:
            - DE pointe sur la valeur de la variable correspondant au nom en entrée pour une variable simple, ou la valeur indexée dans un tableau, ou le descripteur de la fonction.
            - BC, en cas de recherche explicite d'un tableau (`(subflg) à 1), pointe sur le nombre de dimensions du tableau (début des données). Dans ce cas, DE contient la taille du tableau.
            - HL pointe sur le texte BASIC à la suite du référencement de la variable (incluant l'indice du tableau).

$38da       En arrivant ici, `(dimflg)` aura pour valeur 0.
$38db       Initialisation de `(dimflg)`. En venant de `DIM`, avec $af, sinon avec $00.
$38de       C est le premier caractère du nom de la variable.

$38df       [get_id]
$38df-$38e2 Si le nom de variable ne commence par par une lettre majuscule entre A et Z, c'est une erreur de syntaxe.
            Note : tout ce qui a été lu par le BASIC, hors chaîne de caractère entre guillemets, a préalablement été passé en majuscules.
$38e5-$38e7 `(valtyp)` désigne une valeur numérique par défaut. Initialise aussi `B` à 0, qui désigne le second caractère du nom de la variable.
$38ea       Lit le caractère suivant.
$38eb       Branche si le caractère lu est un chiffre.
$38ed-$38f0 Branche si le caractère lu n'est pas entre A et Z. Le nom de la variable est nécessairement terminé.

$38f2       [id_num]
$38f2       Sauve le second caractère de la variable dans B.
$38f3       [id_trail_lp]
$38f3-$38f4 Continue la lecture du nom de la variable tant que l'on trouve des chiffres.
$38f6-$38f9 Continue la lecture du nom de la variable tant que l'on trouve des lettres.

$38fb       [id_end]
$38fb       %CHAR
$38fb-$38fd On branche si le caractère suivant n'est pas '$'. Le nom désigne une valeur numérique.
$38ff-$3900 Sinon, la variable est de type chaîne de caractères.
$3903-$3905 Ajoute $80 à B, deuxième caractère du nom, afin d'indiquer son type chaîne de caractères.
$3906       Lecture du caractère suivant le signe '$'.

$3907       [var_is_num]
$3907       `(subflg)` est à 1 si un nom de tableau est cherché. Supérieur à 1 lorsque l'on vient d'un `FOR` ou d'une fonction.
            $80 lors d'une évaluation de fonction par exemple.
$390a-$390b Branche si `(subflg)` est à 1. On recherche un nom de tableau.
$390e       Branche si `(subflg)` est à supérieur à 1. Les tableaux sont interdits pour `FOR` et les fonctions.
$3912       %CHAR
$3911-$3914 Branche si le caractère suivant est une parenthèse ouvrante.

$3917       [var_no_ary]
$3917-$3918 Le cas est celui d'une variable simple ou d'une fonction (pas un tableau).
$391b       Sauve le pointeur vers le texte BASIC.
$391c-$391d Copie le nom de la variable dans DE.
$391e-$3921 Compare le nom du paramètre d'une fonction (HL) avec le nom cherché (DE).
            Si on n'est pas dans une fonction, `(prmnam)` est égal à $00.
$3922       DE pointe vers la valeur de paramètre.
$3925       Branche à la fin de la routine si le paramètre de la fonction est référencé.
            Le branchement restaure le pointeur vers le texte BASIC.
$3928-$392c Sinon, HL = `(vartab)` et DE = `(arytab)`.
            Les deux registres délimitent la mémoire contenant les noms de variables.

$392f       [next_var]
$392f-$3930 Branche si HL, qui pointe sur la prochaine variable, a atteint DE. Toutes les variables ont été vérifiées.
$3933-$3934 Comparaison du premier caractère de la variable avec le premier caractère de la variable pointée par HL.
$3935       Incrémente HL avant le saut potentiel
$3936       Branche si les caractères sont différents. HL ne pointe pas sur la variable cherchée.
$3939-$393a Comparaison des premiers caractères de la variable cherchée et de la variable pointée.
$393b       [var_diff]
$393b       Incrémente pour la deuxième fois HL, qui pointe après l'identifiant.
$393c       Branche si les premiers caractères étaient identiques La variable a été trouvée.
$393f-$3942 Sinon, HL est avancé de 4 octets pour pointer vers la variable suivante.
$3943       Boucle vers la variable suivante pointée par HL.

$3946       [no_var_yet]
$3946       HL pointe vers le texte BASIC.
$3947       HL est l'adresse de retour de la routine, Haut de la Pile est le pointeur vers le texte BASIC.
$3948       Sauve DE, qui contient `(arytab)`.
$3949-$394c Compare l'adresse de retour récupérée avec `from_eval`.
$394d       Restaure DE, qui contient `(arytab)`.
$394e       Branche si l'appel à cette routine a été fait par `str_to_var`, c'est-à-dire depuis la routine d'évaluation d'expression. La résultat sera nul.
            Dans le cas contraire, c'est une assignation, il faut créer une nouvelle entrée pour cette nouvelle variable.
$3951       Remise en place de l'adresse de retour et HL pointe sur le texte BASIC.
$3952       Sauve HL, le pointeur de texte BASIC sur la pile.
$3953       Sauve BC, qui contient le nom de la variable.
$3954       Taille d'une entrée de variables : 2 octets pour son nom et 4 octets pour son contenu.
$3957       HL pointe sur la fin de la zone des tableaux en mémoire.
$395a       HL est sauvé sur la pile.
$395b       Calcule la nouvelle fin de la zone des tableaux en mémoire.
$395c       Récupère l'actuelle fin de la zone des tableaux dans HL.
$395d       Sauve la nouvelle fin de la zone des tableaux sur la pile.
$395e       Copie [DE,BC], c'est-à-dire [`(arytab)`,`(strend)`] vers [`(arytab)`+6,`(strend)`+6], après vérification de mémoire disponible pour l'opération.
            Cela laisse 6 octets de libre à la fin de la zone des variables.
$3961       Restaure la nouvelle valeur de `(strend)`.
$3962       Cette valeur est mise à jour dans la variable `(strend)`.
            Autrement dit : `(strend)` <- `(strend)` + 6
$3965-$3967 Mise à jour de `(arytab)` selon le même calcul.

$396a       [clear_mem]
$396a-$396e Mise à zéro de la partie entre l'ancien `(arytab)` (DE) et le nouveau (HL), c'est-à-dire l'espace libérée pour la nouvelle variable.
$3970       DE récupère le nom de la variable depuis la pile.
$3971-$3974 Écriture du nom de la variable dans les deux premiers octets de la variable. HL pointe sur la valeur, actuellement nulle.

$3975       [var_found]
$3975       DE pointe sur la mémoire après le nom de la variable, c'est-à-dire sur sa valeur.
$3976       HL pointe sur le texte BASIC.

$3978       [ret_null]
$3978-$397e Arrivé ici, A est à 0. La résultat monté dans FAC est donc une valeur qui est à la fois 0 en numérique et la chaîne vide en alphanumérique.
$3981       HL pointe vers le texte BASIC.

$3983       [subscript]
$3983       Sauve le pointeur vers le texte BASIC.
$3984-$3987 HL = pointeur vers le texte BASIC, Haut de la pile : `(dimflg)` et `(valtyp)`.
$3988       D = A = 0. A compte les dimensions.
$3989       [loop_dim]
$3989       Sauve le numéro de la dimension.
$398a       Sauve le nom de la variable (et donc du tableau).
$398b       Lit un entier sur 16 bits dans DE.
$398e       Restaure le nom de la variable.
$398f       Restaure le numéro de la dimension.
$3990       Taille/Index du tableau dans HL.
$3991-$3992 Place la taille/index sous `(dimflg)/(valtyp)`
$3993       HL pointe sur le texte BASIC, DE contient `(dimflg)/(valtyp)`.
$3994       Augmente le numéro de la dimension.
$3995       Et place le compte dans D.
$3997       %CHAR
$3996-$3999 Boucle si la taille est suivie par une virgule.
$399c       Sinon, le caractère suivant doit être une parenthèse fermante.
$399d       %DATASKIP
$399e       Sauve HL, pointeur sur le texte BASIC, temporairement.
$39a1-$39a2 Remise en place de la valeur `(dimflg)/(valtyp)` venant de la pile.
            Cette valeur n'a pas été modifiée depuis qu'elle a été lue. Cette instruction est étrange.
$39a5-$39a7 D est le nombre de dimensions, E est à 0, le tout poussé sur la pile.
$39a8       Saute par dessus les deux `push` qui suivent.

$39a9       [aryvar]
$39a9       Sauve le pointeur sur le texte BASIC.
$39aa       Sauve A = 0 et Z à 1, pour indiquer la recherche de l'adresse d'un tableau.
$39ab       HL pointe sur le début de la zone mémoire des tableaux.
$39ae       Saute par dessus le 'add' qui suit.

$39af       [dim_search]
$39af       HL pointe vers le tableau suivant.
$39b0-$39b5 Branche si HL a atteint la fin de la zone mémoire des tableaux.
$39b7       Sinon, lit le premier caractère du nom du tableau dans A.
$39b8       HL pointe vers le deuxième caractère du nom du tableau.
$39b9-$39ba Branche si les premiers caractères du tableau pointé et du nom recherché sont différents.
$39bc-$39bd Comparaison des seconds caractères des noms pour préparer le test plus loin.

$39be       [dim_neq]
$39be-$39c2 Lecture vers DE de la taille mémoire du contenu du tableau.
$39c3       Boucle vers le prochain tableau en mémoire si le nom cherché et le nom pointé sont différents.
$39c5       Sinon, A récupère l'action voulue (création ou accès).
$39c8-$39c9 Branche vers une erreur de redimensionnement si `(dimflg)` est différent de zéro (création de tableau).
$39cc       Sinon, c'est un accès. A prend le nombre de dimensions indiqués par le texte BASIC.
$39cd-$39ce BC pointe vers les dimensions du tableau trouvé.
$39cf       Branche si le nombre de dimension était 0 (recherche d'une adresse de tableau)
$39d2-$39d3 Branche si les dimensions sont égales.

$39d6       [out_range]
$39d6-$39d9 Les dimensions ne sont pas identiques, sort avec l'erreur "Subscript out of range".

$39dc       [ary_at_end]
            %MS_BASIC(CREARY)
            Le nom du tableau n'a pas été trouvé.

            Entrées :
            - HL est `(strend)`, pointeur vers le début de la mémoire inutilisée du BASIC.
            - BC est le nom de la variable/tableau

$39dc       %NOT_LABEL
            DE est initialisé à 4, qui est la taille d'un élément de tableau.
$39df       Récupère la dimension dans A.
$39e0       Branche vers une erreur si le tableau a zéro dimension.
$39e3-$39e6 Inscrit le nom de la variable/tableau dans les deux premiers octets de l'entrée pointée.
$39e7       Place le nombre de dimensions dans C.
$39e8       Vérifie qu'il y a assez de place sur la pile pour 2 * le nombre de dimensions.
$39eb-$39ec HL Pointe vers le nombre de dimensions.
$39ed       Sauve ce pointeur.
$39f0       Inscrit le nombre de dimensions du tableau dans le descripteur de ce tableau.
$39f1       HL pointe sur l'emplacement des données de la première dimension.
$39f2-$39f5 Carry à 0 pour une évaluation, Carry à 1 pour une création avec `DIM`.
$39f6       A contient le nombre de dimensions du tableau.

$39f7       [multi_dim]
            %MS_BASIC(CRARLP)
$39f7       BC = 11, la taille par défaut d'un tableau (DIM A(10) créé 11 emplacements).
$39fa       Branche si le tableau est évalué. Il est alors créé avec la taille par défaut.
$39fc       Sinon, BC contient la taille de la dimension demandée pour la création.
$39fd       En BASIC, la taille d'un tableau est d'une unité plus grande que celle spécifiée (à cause de l'indice 0).
            Ce BASIC n'a pas l'option pour démarrer les indices à 1.

$39fe       [default_dim]
            %MS_BASIC(DEFSIZ)
$39fe-$3a02 Inscrit la taille de la dimension actuelle.
            Sauvegarde le nombre de dimensions restantes et drapeaux sur la pile.
$3a03       Sauvegarde de HL qui pointe vers le début des entrées du tableau.
$3a04-$3a07 Calcule la taille nécessaire pour les données de cette dimension et la place dans DE.
            Cela devient donc la taille d'une entrée pour la dimension suivante, s'il en reste.
$3a08       Récupère le pointeur sur les données du tableau.
$3a09       Récupère le nombre de dimensions restantes et les drapeaux.
$3a0a       Décrémente le nombre de dimensions restantes.
$3a0b       Boucle s'il reste des dimensions.
$3a0d       Sauve les drapeaux (Carry qui désigne l'évaluation ou la création). A est forcément 0.
$3a0e-$3a0f BC récupère la taille totale nécessaire pour les données du tableau.
$3a10       HL contient la taille à réserver, DE contient le pointeur vers les données du tableau.
$3a11       Après l'addition, HL contient le pointeur de fin du contenu du tableau.
$3a12       Si HL a débordé, alors il n'y avait plus de mémoire (dépassement de la plus haute mémoire adressable).
$3a15       Sinon, vérification par rapport à la mémoire installée.
$3a18       S'il y a assez de mémoire, `(strend)` est mis à jour.
            Les tableaux ne peuvent pas être redimensionnés.

$3a1b       [dim_nullify]
            %MS_BASIC(ZERARY)
$3a1b       HL pointe sur le dernier octet des données du tableau.
$3a1c-$3a1f Mise à zéro du contenu du tableau en ramenant HL vers DE, pointeur vers le début du contenu du tableau.
$3a21       Incrémente la taille nécessaire pour les données du tableau.
$3a22       D = A = 0
$3a23       Restaure le pointeur vers le début des données du tableau au niveau du nombre de dimensions.
$3a26       DE est le nombre de dimensions du tableau.
$3a27       HL = nombre de dimensions du tableau, DE = pointeur vers le tableau.
$3a28-$3a29 HL <- 2 * (nombre de dimension) + BC (espace pour les données + 1)
$3a2a       DE = taille totale nécessaire pour les données de toutes les dimensions, y compris les tailles de ces dimensions.
            HL = pointeur vers le tableau.
$3a2b-$3a30 Inscription dans l'entrée du tableau de la taille nécessaire pour les données.
            Cette taille ne prend pas en compte le nom du tableau ni la taille elle-même.
$3a31       Récupération du drapeau Carry (évaluation/création).
$3a32       En cas de création (Carry à 1), branche vers la fin de la routine.
            Sinon, il s'agit d'un accès au tableau (allocation par défaut lors d'un accès à un tableau non défini).

$3a34       [dim_access]
            %MS_BASIC(FINDEL)
$3a34-$3a35 BC = A = 0
$3a36       A est le nombre de dimensions du tableau.
$3a37       HL pointe sur la première dimension du tableau.
$3a38       Saute par dessus le `pop hl` qui suit.

$3a39       [dimension_l]
$3a39       Récupère dans HL le pointeur vers la taille de la dimension courante.
$3a3a-$3a3d DE est la taille du tableau pour la dimension actuelle.
$3a3e       HL = index, Haut de la pile = pointeur vers les données du tableau.
$3a3f       Sauve les dimensions restantes.
$3a40       Compare l'index et la taille de la dimension.
$3a41       Branche vers une erreur si l'index demandé est au delà de la taille du tableau pour cette dimension.
$3a44       Sauve l'index sur la pile.
$3a45       Multiplie BC (numéro d'index accédé à la dimension précédente, 0 au premier passage) et DE (taille de la dimension actuelle) pour donner HL.
$3a48       Récupère dans DE l'index accédé pour la dimension en cours.
$3a49       L'ajoute à HL pour donner l'index intermédiaire pour la dimension actuelle.
$3a4a       Récupère le nombre de dimensions dans A.
$3a4b       Décrémente le nombre de dimensions restantes.
$3a4c-$3a4d Copie l'index intermédiaire dans BC pour l'itération suivante.
$3a4e       Boucle s'il reste des dimensions à parcourir.
$3a50-$3a51 Multiplie l'index final par 4, car chaque entrée du tableau prend 4 octets.
$3a52       Récupération dans BC du pointeur des données du tableau.
$3a53-$3a54 DE pointe vers l'adresse finale de la donnée dans le tableau.

$3a55       [end_dim]
            %MS_BASIC(ENDDIM)
$3a55       Restaure le pointeur vers le texte BASIC.

$3a59       [k7_advance2]
            %SECTION(caset)
            Fait avancer la k7 pour sauter l'amorce. Rien n'est écrit, ni lu.
            Elle est appelée depuis `k7_advance`.

            == DEBUT DE SECTION CASET (Low level cassette handler) ==

$3a59-$3a5b Allume le moteur du lecteur de k7.
$3a5d       Désactive les interruptions.

$3a5e       [loop3A5E]
$3a5e       Sauve le compteur B.
$3a5f       BC = 0
$3a62       [loop3A62]
$3a62-$3a64 Attente de 20 + 20 + 5 états.
$3a65       Décrémente la partie C de BC.
$3a66       Boucle 256 fois (sur C)
$3a68       Boucle 256 fois (sur B), pour un total de 65536.
$3a6a       Récupère le compteur global.
$3a6b       Et boucle sur celui-ci (mis à 3 au début).

$3a6d       [wait_stp_k7]
            Attend le temps de compter jusqu'à 65535 puis éteint le moteur de la K7.

$3a6d-$3a6e Sauve AF et BC sur la pile
$3a6f       BC à 0
$3a72       [loop_on_bc]
$3a72-$3a75 Boucle jusqu'à ce que BC soit égal à 0.
$3a77-$3a78 Restaure AF et BC depuis la pile
$3a79       [stop_k7]
$3a79       Sauvegarde AF
$3a7a-$3a7c Passe le registre de k7 à 0 (moteur éteint, pas de lecture)
$3a7e       Restaure AF
$3a7f       Permet l'IRQ

$3a81       [save_sync]
            Écrit sur la k7 la partie synchronisation.

            Il s'agit d'une séquence d'alternances 1/0 courts (cycles high/low) dont le nombre dépend de `(handler)` et de A.

            Entrée :
            - A à $00 multiplie `(handler)` par 256 (cas de l'amorce initiale pour SAVE et de l'amorce d'en-être pour CSAVE).
            - A à $ff multiplie `(handler)` par 1024 (cas de l'amorce du contenu pour un CSAVE).

$3a81       Place les drapeaux en fonction de A.
$3a82       Sauve les drapeaux sur la pile.
$3a83-$3a85 Allume le moteur du lecteur k7.
$3a8a       [sync_loop]
$3a87-$3a8d Boucle d'attente le temps que HL boucle de $0000 à $0000
$3a8f       Restaure les drapeaux.
$3a90       [send_ones]
$3a90       La valeur de `(handler)` vient des paramètres initialisés dans `k7_set_prms`.
$3a93       Si le drapeau était à Z, on branche.
$3a95-$3a96 Si Z n'était pas à 1 (dans A initialement pas à 0), A est multiplié par 4.
$3a97       [not_mult]
$3a97       La valeur est ensuite stockée dans B
$3a98       Et C est mis à $00 pour former BC comme un compteur qui commence à :
            - `handler * 1024` si `A` en entrée était $ff
            - `handler * 256` si `A` en entrée était $00
$3a9a       Désactivation des interruptions.
$3a9b       [send_one_lp]
$3a9e       Attente de 29 états T
$3aa1-$3aa4 Boucle tant que BC n'atteint pas 0.
$3aa6       Pour terminer, branche sur la vérification de BREAK, d'anti copie et de reset des touches. Profitera du `ret` de la routine.

$3aa9       [k7write]
$3aa9       Charge les périodes d'écriture du son.
$3aac       Sauve le caractère à envoyer.
$3aad-$3ab0 Réduction de la période dans L de $0e
$3ab1       Envoie un premier cycle long (0) sur la k7.
$3ab4       Restaure le caractère à envoyer
$3ab5       8 bits à traiter.
$3ab7       [byte_to_k7]
$3ab7       Bit de poids fort de l'octet dans Carry
$3ab8       Appel si le Carry est à 1
$3abb       Appel si le Carry est à 0
$3abe       Boucle sur les 8 bits.
$3ac0-$3ac3 Envoie de deux "1" sur la k7 pour terminer l'octet.
$3ac6       Retour de la fonction en passant par le test d'interruption de commande.

$3ac9       [s0_to_k7]
            Envoie sur la k7 un cycle décrivant un '0'
$3ac9       Charge les périodes longues pour décrire un '0'.
$3acc       Envoie sur la k7
$3acf       [wait_29]
$3acf       L'entrée ici sert de petite attente (18 T du `call` + 11 T du `ret`, donnent 29 états T)

$3ad0       [s1_to_k7]
            Envoie sur la k7 un double cycle décrivant un '1'.
$3ad0       Envoie un premier cycle court pour un '1'
$3ad3-$3ad8 Attente de 11 * 2 (ex) + 5 * 4 (nop) états T.
$3ad9       Envoie un second cycle court pour terminer le '1'

$3add       [k7_send_h1]
            Envoie un cycle court sur la sortie k7.

            Doublé, cela code un '1', la routine envoie donc une moitié du code complet.

$3add       Met la valeur du timing de cycle 1 (HIGH) dans HL
$3ae0       [k7_send_hl]
$3ae0       Sauve AF
$3ae1       [k7_1_loop_h]
$3ae1       Boucle sur L
$3ae2       Tant que L n'atteint pas 0
$3ae5-$3ae7 Signal `haut` et `moteur en route` sur la sortie k7.
$3ae9       [k7_1_loop_l]
$3ae9       Boucle sur H
$3aea       Tant que H n'atteint pas 0
$3aed-$3aef Signal `bas` et `moteur en route` sur la sortie k7.
$3af1       Restaure AF

$3af3       [calibrate]
            Calibre la lecture de la cassette.

            Lit le « temps » nécessaire à un cycle 1/0.

            La routine est un succès si elle peut lire 1111 fois un cycle 1/0 dont le temps reste assez stable.

            La stabilité est jugée par un écart qui ne doit par dépasser un compte de 4.

$3af3-$3af5 Démarre le moteur du lecteur k7 (si la prise remote est branchée).
$3af7       Désactive l'IRQ

$3af8       [cal_retry]
$3af8       Compteur à $457 (1111)
$3afb       [cal_adjust]
$3afb       Mise dans D de la valeur précédente du compteur de cycle 1/0.
            La valeur de D à la première itération n'a pas d'importance.
$3afc       Lit un cycle 1/0
$3aff       Si le Carry est levé, l'interruption de la commande a été demandée, retour immédiat.
$3b00       Compteur de cycle 1/0 dans A
$3b01-$3b03 Boucle si le compteur est supérieur à 222
$3b05-$3b07 Boucle si le compteur est inférieur à 5
$3b09-$3b0a Le compteur est dans ses bornes. Branche plus loin si A était supérieur à D, la valeur précédente. A contient la différence entre la nouvelle et l'ancienne valeur.
$3b0c-$3b0d Complément à 2 de A, pour prendre sa valeur opposée.

$3b0e       [cycle_abs]
$3b0e       A contient la valeur absolue de la différence entre les deux précédent compteur de cycle 1/0
$3b10       Boucle si cette différence est de 4 ou plus avec le compteur HL réinitialisé.
$3b12       Décrémente HL
$3b13-$3b15 Boucle si HL n'est pas nul pour lire une nouvelle valeur.
$3b17       Force HL à 0. Qui est déjà à $0000...
$3b1a-$3b1b B et D à 0 aussi

$3b1c       [read_256]
$3b1c       Lecture d'un cycle 1/0
$3b1f       Retour si l'interruption de la commande a été demandé.
$3b20       Accumule dans HL les temps de cycle successivement lus.
$3b21-$3b22 Boucle 256 fois (D initialement à 0)
$3b25-$3b28 Valeur d'ajustement à l'accumulation des temps de lectures (= 1530).
$3b29       A contient la moyenne du compteur de 256 lectures de cycle 1/0 (à l'ajout de 5 prêt)
$3b2a-$3b2b Moyenne divisée par 2
$3b2d       Et mise dans D
$3b2e       Double l'accumulateur de toutes les durées de lecture.
$3b2f       A contient deux fois la moyenne du compteur de 256 lectures.
$3b30       Différence entre 2 fois la moyenne et la moitié de la moyenne.
$3b31       Sauvegarde de la différence dans D
$3b32       Soustraction de 5 à la différence (ajoutée précédemment à la somme)
$3b34       Enregistrement de la différence entre la moitié et le double de la moyenne.
            C'est la longueur de la phase haute de cycle 1/0.
$3b37-$3b38 Doublement de la différence
$3b39       Initialise B pour calculer A / 3.
$3b3b       [lim_div_3]
$3b3b       Réduit A de 3.
$3b3d       Incrémente B (`inc` ne touche pas Carry)
$3b3e       Boucle tant que A est positif.
$3b40-$3b41 A prend le résultat de la division - 3.
$3b43       Ce qui donne la taille de la fenêtre.
$3b46       Met Carry à 0, car Carry indique une demande d'interruption de commande.

$3b48       [k7_read_byt]
            Lecture d'un octet de donnée depuis la k7

            Sortie :
            - A, le résultat de l'octet lu.
            - Carry à 1 en cas d'interruption de commande ou d'erreur.

$3b48       Lit la valeur du calibrage `lowlim`
$3b4b       Et la place dans D
$3b4c       [wait_1]
$3b4c-$3b4f Sort si une demande d'interruption de commande a été demandée, avec un petit délai.
$3b50       Lecture de la k7 (donnée sur le bit 7)
$3b52       Récupération de la donnée dans Carry
$3b53       Boucle si la donnée lue est 0.
$3b55       [wait_0]
$3b55-$3b58 Sort si une demande d'interruption de commande a été demandée, avec un petit délai.
$3b59       Lecture de la k7 (donnée sur le bit 7)
$3b5b       Récupération de la donnée dans Carry
$3b5c       Boucle si la donnée lue est 1.
$3b5e       On est maintenant calé juste après un premier cycle 0/1.
$3b60       Lecture d'un demi cycle à 0, avec calcul de la période.
$3b63       [half_cycle]
$3b63       B prend la période de la lecture de 0.
$3b64       Lecture d'un demi cycle à 1, avec calcul de la période.
$3b67       Retour si demande d'interruption de commande.
$3b68-$3b69 Ajout du total des deux périodes.
$3b6a       Si la somme dépasse 255 (en cas d'échec de lecture), nouvelle tentative. À chaque fois, la somme calculée est celle des deux demi-périodes du cycle lues.
$3b6c-$3b6d Nouvelle tentative si la période du cycle complet est plus petite que `(lowlim)` actuellement dans D.
$3b6f       L compte les 8 bits à lire.

$3b71       [rd_nxt_byte]
$3b71       Lecture pendant la durée d'une fenêtre.
$3b74-$3b77 Retour s'il y a eu 4 changements de signal ou plus pendant la période avec le Carry à 1.
$3b78-$3b7a Si le nombre de changements est inférieur strictement à 2, le Carry est à 0, sinon (donc pour 2 ou 3 changements), le Carry est à 1.
            Normalement, on s'attend à avoir 3 changements (bit à 1) ou 1 changement (bit à 0). Le Carry porte donc la valeur du bit.
$3b7b       Construction progressive de l'octet lu par rotation et valeur lue en bit 7.
$3b7d       Copie la valeur de C dans A... Mais ceux-ci sont déjà égaux et non modifiés depuis l'appel à `read_window`.
$3b7e-$3b7f En cas d'un nombre de changement paire (0 ou 2), on attent le prochain changement pour se recaler sur 1 ou 3.
$3b82       Puis attente d'un nouveau changement de signal. Ce qui fait qu'on a toujours un nombre de changements pair (2 ou 4)
$3b85-$3b86 Boucle 8 fois.
$3b89       Vérifie l'interruption de commande.
$3b8c       Résultat de l'octet lu de l'opération dans A.

$3b8e       [read_window]
            Lecture de cycles 0/1 limités dans le temps par la valeur de calibrage `winwid`.

            Entrée :
            - E bit 7, la donnée sur laquelle la routine commence

            Sortie :
            - A et C, à la fin de la période, le nombre de changements de signal
            - E contient le dernier signal lu.

$3b8e-$3b91 Lecture dans B de `winwid` longueur de la fenêtre calibrée précédemment.
$3b92       C initialisé à 0.
$3b94       [window_loop]
$3b94       Lecture de la k7 (donnée dans le bit 7)
$3b96-$3b97 Branche plus loin si la donnée correspond au contenu du bit 7 de E.
$3b9a-$3b9c Inverse la valeur de E
$3b9d       Incrémente le compteur C
$3b9e       Boucle autant de fois que B, la valeur de `winwid`.
$3ba0       Place le compteur C dans A.

$3ba2       [still_same]
$3ba2-$3ba5 Attente similaire dans les deux branches du test.
$3ba6       Boucle autant de fois que B, la valeur de `winwid`.
$3ba8       Place le compteur C dans A.

$3baa       [wait_chnge_b]
            Appel de `wait_change` avec une vérification d'interruption de commande.

$3baa-$3bad Retour si une interruption de commande à été demandée.

$3bae       [wait_change]
            Renvoie une valeur d'attente du changement de valeur de lecture depuis la k7.

            Entrée :
            - E, la valeur actuelle de la k7, et donc celle qu'on attend de voir changer.

            Sortie :
            - C, le compteur d'attente, 255 max
            - E, la valeur complémentée si trouvée, ou initiale si pas trouvée

$3bae       Initialise le compteur à 0
$3bb0       [same_value]
$3bb0       Incrémente le compteur
$3bb1       Au bout de 256 itérations, branche à la fin.
$3bb3       Lit la valeur de l'entrée son/k7 (sur le bit 7)
$3bb5       Ou exclusif avec la lecture précédente inversée
$3bb6       Boucle tant que la valeur lue et la valeur actuelle (dans E) sont les même.
$3bb9-$3bbb La valeur vient de changer, E est complémenté à 1.
$3bbc       Lors du retour, C est le timing d'attente avant d'avoir reçu l'autre valeur en lecture.

$3bbd       [wait_timout]
$3bbd       Ramène C à $ff

$3bbf       [read_cycle]
            Lit depuis la k7 un cycle 1/0 et renvoie dans C le temps total.

            La routine commence par attendre le passage au signal haut.

            Sortie :
            - C, compteur total pour le cycle 0/1, ou 255 en cas d'échec.

$3bbf       Vérifie si une interruption de commande a été demandée (avec un petit délai)
$3bc2       Retour si oui.
$3bc3       Lecture de l'entrée son/k7
$3bc5       Décalage à gauche (l'entrée k7 est sur le bit 7)
$3bc6       Boucle tant que le signal d'entrée est à haut, afin de se caler sur une valeur basse.
$3bc8       On est actuellement sur une valeur basse.
$3bca       Attente jusqu'à la fin de la valeur basse.
$3bcd       Attente jusqu'à la fin de la valeur haute.

$3bd0       [outdo_impl]
            $SECTION(bio)
            == DEBUT DE SECTION BIO (BASIC input/ouput controller) ==
            Émission d'un caractère vers le périphérique sélectionné.

            Entrée :
            - A est le caractère à émettre.

$3bd0       Appel au hook d'émission de caractère.
$3bd3       Sauve AF sur la pile.
$3bd4-$3bd8 Branche vers l'émission vers l'écran (A = 0)
$3bda-$3bdb Branche vers l'émission vers l'imprimante (A = 1)
$3bdd       Restaure AF
$3bde       Branche vers l'émission vers la k7 (A = 255)
            Véritablement, toute valeur de `(prtflg)` autre que 0 et 1 amène sur la k7 en fonctionnement normal.

$3be1       [sendchar_pt]
            Émission d'un caractère vers l'imprimante.

            Entrée :
            - Haut de la pile contient AF, avec A qui est le caractère à émettre.

$3be1       A est le type de l'imprimante.
$3be4-$3be6 Branche vers une imprimante définie par l'utilisateur (A = 255)
$3be8-$3be9 Récupère le caractère à émettre dans A en préservant la pile.
$3bea-$3bec Branche si ce n'est pas le caractère de tabulation horizontale.
$3bee       [prt_htab]
$3bee-$3bf0 Émet (récursivement) un caractère d'espacement.
$3bf1-$3bf6 Jusqu'à arriver sur un colonne multiple de 7.
$3bf8       Jette le caractère sur la pile.

$3bfa       [prt_not_tab]
$3bfa-$3bfc Si A est le retour chariot, la soustraction va mettre A à 0 ce qui, avec le branchement, amènera le chariot de l'imprimante en colonne 0.
$3bfe       Les autres caractères inférieurs à 13 passent à la suite.
$3c00-$3c02 Ainsi que tous les caractères strictement inférieurs à 32 (c'est-à-dire les caractères ASCII de contrôle).
$3c04-$3c09 En colonne 132, émet un retour chariot avant de continuer.
$3c0c       Avance d'une colonne.
$3c0d       [set_prt_col]
$3c0d       Met à jour la colonne de l'imprimante (telle que vue par l'ordinateur).

$3c10       [no_prt_ctrl]
$3c10       Récupère le caractère à émettre.
$3c11       Continue sur l'émission du caractère vers l'imprimante.

$3c14       [resetprt]
            Fonction: Mise à zéro de l'état de l'imprimante
$3c14-$3c16 Sélectionne l'imprimante pour l'émission de caractère.
$3c19-$3c20 Récupère l'était `user on/off` et le met à 0 ('user on').
$3c23       Branche si l'état était 'user off'.
$3c25       Sinon, récupère le numéro de colonne de l'imprimante dans A.
$3c28       Met à jour le drapeau Z pour préparer le test qui suit.

$3c29       [rst_prt_0]
$3c29       Émet un retour chariot si l'état précédent était 'user off', ou si la colonne de l'imprimante n'était pas 0.
$3c2c-$3c31 Réinitialise les états d'affichage, sauf l'était de curseur en fin de page.
$3c34-$3c35 Sélectionne le terminal comme périphérique de sortie.
$3c38       Mise à zéro de l'état de l'imprimante.

$3c3c       [sendchar_te]
            Émet un caractère vers l'écran.
$3c3c       Récupère dans A le caractère à afficher.
$3c3d       Branche vers la suite.

$3c40       [cursor_x0]
            %MS_BASIC(STTLIN)
            Remet le terminal en état. Puis, si le curseur n'était pas en
            première colonne, fait un saut à la ligne à l'écran.

$3c40       Réinitialise l'écran.
$3c43-$3c47 Retour si le curseur était en colonne 1.
$3c48       Sinon, saut à la ligne.

$3c4a       [nul_at_end]
            Met un caractère nul à la fin de la chaîne précédent le pointeur HL actuel, en ignorant les espaces de fin de ligne.

            Entrée :
            - HL pointe à la fin d'un ligne BASIC qui vient d'être acquise.

            Sortie :
            - HL pointe un octet avant le buffer de travail `buf`.

$3c4a-$3c4e Recale le pointeur HL sur le dernier caractère non espace ($20) avant le retour chariot ($0d).
$3c50       HL pointe donc à présent juste après le dernier caractère de la ligne à traiter.

$3c51       [hl_on_buf]
$3c51-$3c52 Met un caractère nul à la fin de la ligne.
$3c53       Et fait pointer HL un octet avant le début du buffer de travail `buf`.

$3c57       [crdo]
            Envoi d'un retour chariot sur le périphérique de sortie actuel.

$3c57       Appel le `hook` de retour chariot.
$3c5a-$3c5e Branche si la sortie de caractère se fait sur l'écran.
$3c60-$3c61 Branche si la sortie de caractère n'est pas l'imprimante (donc la k7)

$3c63       [crdo_prt]
            Retour à la ligne sur l'imprimante.

$3c63-$3c65 Envoi d'un retour chariot (`carriage return`) à l'imprimante.
$3c66-$3c68 Envoi d'un saut de ligne (`line feed`) à l'imprimante.
$3c69-$3c6a Mise à zéro de la colonne logique de l'imprimante.
            Il n'y a aucun test de la véracité de l'état. On considère que l'opération a réussi.

$3c6e       [crdo_k7]
            Retour à la ligne vers la k7.
$3c6e-$3c70 Envoi d'un retour chariot (`carriage return`) à l'imprimante.

$3c72       [crdo_term]
            Retour à la ligne sur l'écran.
$3c72-$3c74 Envoie le caractère de retour à la ligne (non ASCII, spécifique VG5000).
$3c75       A = 0

$3c77       [chk_break]
            Vérifie la séquence d'interruption utilisateur puis continue sur l'instruction `STOP`.

            L'instruction `STOP` commence par 'ret nz', qui fera donc un `RET` s'il n'y a pas eu de demande d'interruption, et qui exécutera la routine de `STOP` dans le cas contraire.
$3c77       Vérifie la demande d'interruption utilisateur.
$3c7a       Enchaîne sur la routine `STOP`.

$3c7d       [break_delay]
            Vérifie si SHIFT + RUN-STOP est appuyée (interruption de commande).
            Avec un délai préalable.

            Si oui, le Carry est positionné à 1 au retour.

$3c7d-$3c7e Perd un peu de temps (2 fois 20 états T)

$3c7f       [break_impl]
            Vérifie si SHIFT + RUN-STOP est appuyée (interruption de commande).

            Si oui, le Carry est positionné à 1 au retour.
$3c7f-$3c83 Retour immédiat si RUN-STOP n'est pas appuyée.
$3c84-$3c88 Retour immédiat si SHIFT n'est pas appuyée.
$3c89-$3c8d Retour immédiat si la boucle BASIC n'est pas en route. (pas certain du traitement de allflg)
$3c8e       Met la valeur $f2 dans la dernière touche scannée.
$3c92       Réinitialisation du drapeau de répétition des touches.
$3c96       Réinitialisation du compteur de répétition des touches.
$3c9a       Set Carry, pour signaler que l'interruption de commande a été demandée.

$3c9c       [print_prt]
            Affiche l'invite d'acquisition "? " pour l'instruction `INPUT`.

            Puis continue sur l'acquisition des données.

            MS_BASIC=PROMPT
$3c9c       %CHAR
$3c9c-$3c9e Émet '?' sur le périphérique de sortie.
$3c9f       %CHAR
$3c9f-$3ca1 Émet ' ' sur le périphérique de sortie.

$3ca2       [get_line]
            %MS_BASIC(GETLIN)
            Récupération d'une ligne d'instruction entrée au BASIC
            Entre à chaque nouvelle invite. Sort lorsque la touche CR est appuyée.

            Sortie :
            - Le buffer `buf` contient les données lues.

$3ca2       Appel au hook d'entrée de ligne.
$3ca5       HL pointe vers le buffer de travail
$3ca8       [get_line2]
$3cab-$3cac Branche si le périphérique d'entrée actuel est le clavier.
$3cae       Sinon, l'entrée est autre chose qu'un clavier. Pour la ROM de base, c'est la k7, via la routine de chargement de `LOAD`.
            L'adresse à lire est dans `(high)` et l'octet lu sera en retour dans A. Le drapeau Z est à 1 si l'octet lu était le marqueur de fin de buffer, $03 et dans ce cas, A est à 0.
$3cb1       Branche si un octet a été lu depuis le buffer.
$3cb3       Sinon, la fin du buffer a été atteinte, et on branche pour finaliser la ligne entrée.

$3cb5       [keyloop]
            Traitement du moniteur pour une entrée par le clavier.
$3cb5       Traitement de l'appui d'une touche, qui est éventuellement traitée.
$3cb8-$3cb9 L'acquisition de touche a deux sorties possibles.
            Si A est à 0, alors une touche a été acquise mais ne demande pas de traitement particulier (ou a déjà été traitée).
            Si A est différent de 0, alors c'est qu'une boucle a été initiée et que l'acquisition de touche va envoyer chacun des caractères de la ligne validée pour décodage.
$3cbb-$3cbe Retour à la boucle de traitement si la touche STOP n'a pas été appuyée
$3cc0       La combinaison d'interruption de commande (SHIFT+STOP) a été détectée. Carry est à 1 et on termine l'acquisition des touches. Le retour se fait en $22b1

$3cc1       [decodebasic]
            Traitement d'une ligne BASIC validée.

$3cc1-$3cc3 Branche si le dernier caractère acquis était un retour chariot.
$3cc5-$3cc7 Sinon, place le caractère dans le buffer de travail BASIC en effaçant le bit de poids fort.
$3cc8-$3ccb Vérifie que le pointeur dans le buffer de travail n'a pas atteint la fin du buffer.
$3ccc       Branche vers la suite.

$3ccf       [hl_incbuf]
$3ccf       Incrémente le pointeur dans le buffer de travail.
$3cd0       Et continue vers l'acquisition de la ligne BASIC.

$3cd2       [print_char]
            %SECTION(biprtr)
            Émet le caractère vers l'imprimante.

$3cd2-$3cd5 Sauve les registres sur la pile.
$3cd6-$3cdb Appelle la bascule 'on/off' si la touche PRT du clavier a été appuyée.
$3cde-$3ce3 Branche si l'imprimante a déjà été initialisée.
$3ce5       Appelle l'initialisation de l'imprimante.

$3ce8       [alrdy_init]
$3ce8       Attends que l'imprimante soit prête.
$3ceb       Branche si le caractère ne doit pas être envoyé (utilisateur 'off')
$3ced-$3cee Récupère le caractère à envoyer en laissant la pile en état.
$3cef       Modifie le caractère en fonction de la table de traduction de l'imprimante.
$3cf2-$3cf6 Envoie le caractère à l'imprimante en désactivant les interruptions.
$3cf7       [skip_prt]
$3cf7-$3cfa Restaure les registres.


$3cfc       [prt_init]
            Initialise l'imprimante.

$3cfc-$3cfe Indique que l'imprimante a été initialisée.
            Le drapeau doit être à 1 avant l’initialisation elle-même car l'appel va être récursif.
$3d01       Sauve la valeur de `(prtstt)` sur la pile.
$3d02       HL pointe sur la chaîne d'initialisation de l'imprimante.

$3d05       [send_init]
$3d05-$3d0b Envoie sur l'imprimante tous les caractères de la chaîne d'initialisation jusqu'à trouver le premier caractère nul.
            Par défaut, l'initialisation est $00, et s'arrête donc immédiatement.
$3d0d       Restaure dans A la valeur de `(prtstt)`

$3d0f       [prt_status]
            Lit l'état de l'imprimante et émet une erreur si celle-ci n'est pas prête.

$3d0f-$3d10 Retour si la bascule 'user on/off' est sur 'off' (= 1). Le caractère n'est pas envoyé.
$3d11-$3d14 Met à jour `(prtstt)` en passant à 0 les 4 bits de poids faibles.
            Le bit 0 est busy, qui passe donc à 0.

$3d17       [prt_wait]
$3d17       HL = 7000, pour préparer la boucle d'attente.

$3d1a       [loop_7000]
$3d1a       Lit le status de l'imprimante.
$3d1c-$3d1e Retour si le bit 2 de l'état de l'imprimante est 0.
$3d1f       Décrémente le compteur d'attente longue.
$3d20       A = 0

$3d21       [loop_256]
$3d21-$3d23 Boucle 256 fois.
$3d25-$3d27 Boucle 7000 fois.
$3d29-$3d2a Sélectionne l'écran comme périphérique de sortie.
$3d2d       Prépare la boucle des 5 'bips'

$3d2f       [bip_5]
$3d2f-$3d32 Émet 5 'bips'
$3d34-$3d37 Drapeau 'busy' à 0.
$3d39-$3d3d Branche si le bit 0 des drapeaux utilisateur est à 1.
            Cela signifie que l'on ne veut pas voir les messages à l'écran.
$3d3f-$3d48 Prépare la chaîne 'Imprimante pas prête' dans la langue du système.
$3d4b       [prt_not_rdy]
$3d4b       Affiche la chaîne d'erreur.

$3d4e       [skip_nrdy]
$3d4e-$3d50 Re-bascule sur l'imprimante comme périphérique de sortie.

$3d53       [wait_key]
$3d53-$3d57 Attend l'appui d'une touche.
$3d59-$3d5b Attend et rafraîchis l'état de l'imprimante si la touche appuyée n'est pas `PRT`.
            Sinon, continue avec la bascule de l'état utilisateur.

$3d5d       [user_on_off]
$3d5d-$3d62 Attend que la touche `PRT` soit relâchée.
$3d64-$3d6a Inverse le statut 'user on/off', contrôlé par la touche `PRT`.
$3d6b       Le statut est poussé dans le Carry.

$3d6d       [trans_char]
$3d6d       Sauve AF.
$3d6e-$3d72 Branche si l'imprimante est de type MSX (= 0).
$3d74       HL pointe vers la table de caractères de l'imprimante.
$3d77-$3d79 Branche si le pointeur est nul.
$3d7b-$3d81 Ajoute le numéro du caractère à imprimer à la table.
$3d82       A est le caractère traduit pour l'imprimante.
$3d83       Qui est poussé sur la pile.

$3d84       [raw_print]
$3d84       Récupère le caractère potentiellement traduit dans A.

$3d86       [send_prt]
            Émet le caractère présent dans A vers l'imprimante.
$3d86       Place le caractère sur le port $11.
$3d88-$3d8e Émet brièvement un cycle 0/1 sur le port $10.

$3d91       [reset_lst_3]
            Annule le mode `AUTO` et coupe le premier lien du listing BASIC.

            Partie patchée par rapport à la ROM 1.0
$3d91       0 dans `(autflg)` pour annuler le mode `AUTO`.
$3d94-$3d96 Met le premier lien du listing BASIC à 0.
$3d97       Continue vers le code non patché.

$3d9a       [auto]
            Traitement du mode AUTO actif.

            Cette partie est patchée par rapport à la ROM 1.0.
            La ROM 1.1 ajoute l'affichage d'un signe si la ligne contient déjà quelque chose.

            Entrée :
            - HL contient l'ancien numéro de ligne

$3d9a       Sauve HL sur la pile.
$3d9b       Affiche HL sur le périphérique de sortie.
$3d9e       Récupération du numéro de ligne dans DE
$3d9f       Recherche de la ligne
$3da2       Branche si la ligne n'a pas été trouvée (affichera un espace avant de continuer sur la boucle du moniteur BASIC)
$3da5-$3da7 Sinon, affiche le caractère $a0 pour indiquer qu'il y a déjà du contenu. Puis continue aussi sur la boucle du moniteur BASIC.

$3daa       [auto_patch]
            Partie patchée en ROM 1.1 avec l'amélioration de la commande `AUTO` en ajoutant la vérification du numéro de ligne maximum.

$3daa       Branche si le calcul de la nouvelle ligne a provoqué un dépassement de capacité. `AUTO` est terminé.
$3dac-$3db1 Compare le numéro de ligne avec $fff9 (65529, plus haut numéro de ligne valide)
$3db2       Branche si le numéro de ligne courant (dans HL) est égal ou supérieur à 65529.
$3db4       Sinon, la nouvelle ligne de `AUTO` est validée et enregistrée.
$3db7       Branchement vers la suite du patch

$3db9       [stop_auto]
$3db9-$3dba Annule le mode `AUTO`.

$3dbd       [auto_patch2]
$3dbd       Retour à la suite de la routine. Fin du patch pour `AUTO`.

$3dc0       [initscreen1]
            Patch de la routine d’initialisation de l'écran pour la ROM 1.1.

            Ce patch ajoute la redéfinition du caractère $20.
            Seul le caractère $7f est redéfini dans la ROM 1.0.

$3dc0       Pointe vers les données de redéfinition du caractère $7f étendu.
$3dc3       Redéfini le caractère.
$3dc6-$3dc8 Prépare la redéfinition du caractère $20 étendu.
$3dcb       Branche sur la suite de la routine après le patch.

$3dce       [inst_new]
            %CODE,MS_BASIC(NEW)
            Instruction BASIC : NEW

            Efface le listing courant.

            S'il n'y a pas de paramètre, on branche directement vers le reset de la mémoire.
            S'il y a un paramètre et que c'est un numéro de ligne, on efface à partir de ce numéro de ligne.

            La routine est entièrement déplacée par rapport à la ROM 1.0.
            En ROM 1.0, l'instruction se trouve en `$2ed8`.
            La table d'instruction a été patchée en ce sens.
            La version ROM 1.1 ajoute la possibilité d'un `NEW` avec un numéro de ligne.

$3dce       Branche vers l'effacement du chaînage à partir de la première ligne si l'instruction n'est suivi par aucun argument.
$3dd1       Sinon, récupère un numéro de ligne.
$3dd4       Retour s'il reste encore des caractères après le numéro de ligne, cela provoquera une erreur de syntaxe.
$3dd5-$3dd8 Place l'adresse de retour comme la boucle du moniteur BASIC.
$3dd9       Cherche la ligne spécifiée par l'argument.
$3ddc-$3ddd Copie le pointeur vers la ligne trouvée dans HL
$3dde       Branche vers l'effacement du chaînage du listing à partir de cette ligne.

$3de1       [decodenext]
            Code patché de la ROM 1.1 pour la routine `decodebasic`.

            Le patch consiste a un meilleur traitement lorsque le buffer d'acquisition de la ligne est rempli.

$3de1       Si HL pointe avant la fin du buffer de travail, le pointeur est incrémenté puis la routine l'acquisition continue.
$3de3       Si HL n'est pas égal, c'est qu'il est supérieur à la fin du buffer de travail, l’acquisition continue sans toucher à HL.
$3de6-$3de8 Sinon, HL vient d'atteindre la fin du buffer de travail, un 'bip' est émit. Puis enchaîne sur l'incrémentation du pointeur et la suite de l'acquisition.

$3de9       [ind_inchl]
$3de9       Saut intermédiaire pour aller incrémenter HL et poursuivre l'acquisition de la ligne BASIC.

$3dec       [prompt_1]
            Code patché de la ROM 1.1 pour la routine d'`INPUT`.

$3dec-$3df1 Signal le fait que l'on est dans une instruction `INPUT` (bit 5 de `picflg`)
$3df4       Affiche le curseur.
$3df8       Branche sur la suite de l'initialisation de l'invite d'acquisition.

$3dfb       [acq_key_4]
            Suite du traitement de l'entrée de caractère.
            On arrive ici que la boucle de BASIC soit active ou non.

            Il s'agit ici de code patché pour la ROM 1.1
$3dfb-$3dfd Branche si la touche appuyée n'est pas Insertion de ligne (touche INSL, valeur non ASCII)
$3dff-$3e02 Test du drapeau de commande INPUT actif

$3e07       [acq_key_6]
$3e07       Trampoline pour le `jr` conditionnel de `acq_key_5`

            Pourquoi ne pas avoir utilisé un `jp nz,acq_key_7' ?

$3e0a       [acq_key_5]
$3e0a-$3e0c Branche si la touche appuyée n'est pas Effacement de l'écran (touche EFFE, valeur non ASCII)
$3e0e       Sinon, branche sur le traitement de la touche `EFFE`.

$3e11       [insert_n_cr]
            Patch de la ROM 1.1 pour traiter le cas `INPUT`.
$3e11-$3e16 Branche si on n'est pas dans un `INPUT`
$3e19-$3e1b Sinon, émet une insertion de ligne.
$3e1c       Puis valide la ligne.

$3e1f       [insc_patch]
            Traitement de la touche `INSC` patché.

            Il s'agit ici de code patché pour la ROM 1.1 afin de traiter le cas `INPUT`.
$3e1f       Branche si le numéro de ligne du curseur est négatif. Le curseur était sur la ligne 0.
$3e22-$3e27 Branche si on est dans une commande `INPUT`.
$3e2a       Sinon, continue avec la routine de traitement `INSC`.

$3e2d       [acq_key_2]
            Suite du traitement de l'entrée de caractère.

            Il s'agit ici de code patché pour la ROM 1.1 afin de traiter le cas `INPUT`.

$3e2d       Branche si la touche appuyée est Entrée.
$3e30       Sauve AF
$3e31-$3e35 Branche si la boucle BASIC n'est pas active (octet de protection), pour éviter de traiter certaines touches d'édition de LISTING (haut, bas, LIST).
$3e37       Restaure AF

$3e3b       [skip_ctrl_k]
$3e3b       Restaure AF
$3e3c       Évite le traitement des touches d'édition.

$3e3f       [end_of_rom]
$4000       [screen]
$47d0       [inthk]
$47d3       [calhk]
            Tremplin pour la commande `CALL` qui y place l'opcode `call`/$c3
$47d4       [calhk_addr]
            Adresse pour le tremplin `calhk`.
$47d6       [sonhk]
$47d9       [plyhk]
$47dc       [rsthk]
$47df       [prthk]
$47e2       [outhk]
$47e5       [crdhk]
$47e8       [inlhk]
$47eb       [inphk]
$47ee       [nmihk]
$47ef       [nmihk_addr]
$47f1       [inst_lpen]
            %CODE
$47f4       [inst_disk]
            %CODE
$47f7       [inst_modem]
            %CODE
$47fa       [intdiv]
            Début de la zone de données graphiques pour la communication avec le EF9345
$47fb       [intact]
$47fc       [intrat]
$47fd       [cursor]
$47fe       [fklock]
$47ff       [crchar]
            valeur scannée du clavier la plus récente
$4800       [reptim]
$4801       [repena]
$4802       [attcar]
$4803       [attbak]
$4804       [extenf]
$4805       [xcursor]
$4806       [ycursor]
$4807       [prelin]
$4809       [homeln]
$480b       [retadr]
            Coordonnées de la prochaine ligne à interpréter
$480d       [entstt]
            programme ($82) ou direct ($80)
$480e       [sonsav_hi]
$480f       [sonsav_lo]
$4810       [ft]
            Table de fichier
$4811       [ft_filename]
$4817       [ft_version]
$4818       [ft_st_line]
$4819       [ft_st_line1]
$481d       [ft_protect]
$481e       [ft_sum_pos]
$4820       [ft_addr]
$4822       [ft_data_len]
$4824       [ft_sumchk]
$4825       [ft_sumchk1]
$4826       [low]
$4828       [high]
$482a       [handler]
$482c       [ft_sumchkr]
$482e       [lowlim]
$482f       [winwid]
$4830       [ramlow]
$4833       [inst_usr]
            %CODE
$4836       [fdivc]
$4837       [fdivc_1]
$483b       [fdivc_2]
$483f       [fdivc_3]
$4842       [fdivc_4]
$4844       [rnd_seed_0]
$4845       [rnd_seed_1]
$4846       [rnd_seed_2]
$4867       [rnd_gen]
$486e       [lptpos]
$486f       [prtflg]
            sélectionne la sortie des caractères (0=Terminal, 1=printer, ff=k7)
$4870       [getflg]
            Entrée des caractères sur clavier (0) ou cassette (255)
$4871       [picflg]
$4872       [cascom]
$4873       [rawprt]
$4874       [prtstt]
            État de l'imprimante
$4875       [prtcom]
$4876       [prtint]
$4878       [prtxlt]
$487a       [contbl]
$4884       [autflg]
            État courant de la commande AUTO
$4885       [autlin]
            Ligne courante de la commande AUTO
$4887       [autinc]
            Incrément du mode AUTO
$4889       [allflg]
            Exécution de la boucle BASIC (0 to execute BASIC control loop)
$488a       [linlen]
$488b       [clmlst]
$488c       [curlin]
            Ligne courante du BASIC
$488e       [txttab]
$4890       [frgglg]
            Messages en anglais (1) ou français (0)
$4891       [kbdtbl]
            Table de transcription du clavier
$4893       [tmpsav]
            Tempo actuel pour le générateur de son.
$4894       [octsav]
            Octave actuel pour le générateur de son.
$4895       [stktop]
            Adresse de départ (maximale) pour la pile. Initialisée tout en haut de la RAM.
$4897       [bufmin]
            Zone précédent la zone de tokenisation. Mis dans HL après avoir mis NUL en fin de chaîne à traiter.
$4898       [buf]
            Buffer d'entrée pour le BASIC
$4918       [endbuf_pre]
            Juste avant la fin du buffer
$4919       [endbuf]
            Fin du buffer
$491a       [dimflg]
$491b       [valtyp]
            (0 = numeric, 1=string)
$491c       [dores]
            Drapeau de suppression de la tokenisation
$491d       [contxt]
$491f       [memsiz]
            Plus haute mémoire disponible
$4921       [temppt]
$4923       [tempst]
$499b       [dsctmp]
$499d       [dsctmp2]
$49c3       [fretop]
$49c5       [temp3]
$49c7       [temp8]
$49c9       [endfor]
$49cb       [datlin]
$49cd       [subflg]
$49ce       [flginp]
$49cf       [temp]
$49d1       [ptrfrg]
$49d2       [temp2]
$49d4       [oldlin]
$49d6       [oldtxt]
$49d8       [vartab]
$49da       [arytab]
$49dc       [strend]
$49de       [datptr]
$49e0       [prmnam]
$49e2       [prmval]
$49e4       [prmval_2]
$49e6       [fac_lsb]
$49e8       [fac_msb]
$49e9       [fac_exp]
$49ea       [fac_sgn]
$49eb       [fbuffr]
$49f8       [fmltt1]
$49f8       Valeur temporaire pour la multiplication (`fp_bcde_mul`)
$49f9       [fmltt2]
$49f9       Valeur temporaire pour la multiplication (`fp_bcde_mul`)
$49fb       [end_vars]
            Adresse juste après la dernière des variables système.
$e1c1       [jumpE1C1]
