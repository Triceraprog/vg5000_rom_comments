$0000       [reset]
            %CODE,SECTION(in)
            Tout commence par un saut à l'adresse $1000.

            C'est aussi `RST 0`.

            Le Z80 réserve le bas de la mémoire aux branchements de type `RST`.
            Il est donc standard que `RST 0`, le reset, branche vers une
            adresse plus loin pour la phase démarrage du système.

            Cette adresse est variable d'une machine à l'autre. Sur VG5000µ, c'est
            $1000.

            == DEBUT DE SECTION IN (bas niveau et interruptions) ==

$0003       ???
$0004       [num_ver]
$0004       %NTS
            Numéro de la version de la ROM

$0008       [chkchr]
            %CODE
            Vérifie que le caractère pointé par HL est égal au caractère qui suit exactement
            l'instruction `RST $8`/`RST 1` appelante.
            
            Si ce n'est pas le cas, affiche un message d'erreur de syntaxe BASIC.

$0008       Enregistre le caractère pointé par HL
$0009       Échange le contenu sur le haut de la pile (l'adresse de retour de RST) et HL
$000a       Compare le contenu de l'adresse de retour et la valeur sauvée dans A
$000b       Incrémente HL afin que l'adresse de retour saute le caractère suivant l'instruction appelante
$000c       Remet la nouvelle adresse de retour en place sur la pile
$000d       Si les deux caractères comparés étaient différent, saute en stx_err_prt ; sinon, passe dans chget

$0010       [chget]
            %CODE,MS_BASIC(GETCH)
            Incrémente HL et met le caractères pointé par le nouveau HL dans A.

            Appelé par `RST $10`/`RST 2`

            Retour:
            - A = code caractère
            - Carry = 1 si c'est un chiffre, 0 sinon
            - Z = 1 si c'est une fin de ligne (A était égal à 0) ou si le caractère était ':' (fin d'instruction)
$0010-$0011 A prend la valeur pointée par HL incrémenté de 1
$0012       %CHAR
            ':' est le premier caractère après '9'
$0014       Ce n'est pas un chiffre (ni zéro), retour immédiat.

$0018       [outdo]
            %CODE
            Envoi d'un caractère sur le périphérique sélectionné par `prtflg`.

            Appel par `RST $18`/`RST 3`.

            Entrée :
            - le caractère à envoyer est dans A.

$0018       L'implémentation de `outdo` est plus loin.

$001b       [setext]
            %CODE
            Redéfinition d'un caractère programmable de la mémoire vidéo.

            Entrées :
            - A[6:0] contient le caractère à changer (sur 7 bits).
            - A[7] contient la nature de la palette (0 == Texte, 1 == Graphique)
            - HL pointe sur le buffer de 10 octets avec les valeurs de caractère.

            [ArticleSetExtCommandsAndMemoryLayout]

$001b       L'implémentation de `setext` est plus loin.
$001e       ---

$0020       [dcompr]
            %CODE
            Comparaison de HL et DE.

            Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
            Aucun des deux registres n'est modifié.

            Appel par `RST $20`/`RST 4`.

            Entrée :
            - HL et DE, les deux registres à comparer.
            
            Sortie :
            - A est modifié
            - Carry est à 1 si DE est supérieur à HL.
            - Z est à 1 si les deux registres sont égaux.

$0020-$0024 Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
            Aucun des deux registres n'est modifié.

$0026       ---

$0028       [getsign]
            %CODE
            Détermine le signe du nombre dans l'accumulateur flottant.

            Appel par `RST $28`/`RST 5`.

            Retour:
            - A retourne $FF (négatif), $00 (nul) ou $01 (positif).
            - Préserve HL
$0028-$002b Si l'exposant est à 0, alors le nombre est nul.
$002c       Saute si l'exposant est 0.
$002f       Sinon sort avec 0 dans A.

$0030       [usrrst]
            %CODE
            Cette entrée de `RST` est réservée pour l'utilisateur.

            Appel par `RST $30`/`RST 6`.

            [ArticleRST6]

$0030       Saut vers le trampoline, initialement contenant `RET`.

$0033       [warmgo]
            %CODE
            Indirection pour le redémarrage à chaud.

$0033       Saute vers l'implémentation du démarrage à chaud.
$0036       Semble ne servir à rien.

$0038       [irq]
            %CODE
            Traitement de l'interruption (IRQ) du Z80.

            Le Z80 fonctionne en mode 1. Dans ce mode, un signal IRQ provoque, après
            traitement de l'instruction en cours, un branchement à cette adresse.

            Sur le VG5000µ, cette interruption est levée par le signal VBLANK (???)
            de l'affichage, provoqué par l'EF9345.

            Un vecteur est disponible pour installer une routine d'utilisateur qui
            sera appelée lors du traitement de l'IRQ.

            Appel par `RST $38`/`RST 7`. ???

            [ArticleUserIRQ]

$0038       Appel au vecteur utilisateur.
$003b       Sauve AF.
$003c       Décrémente le compteur de temporisation d'affichage
$003f       Si le compteur n'est pas nul, on évite le rafraichissement.
$0042-$0045 Chargement de la valeur de référence du compteur de rafraichissement.
$0048-$004c Test puis mise à zéro du bit 0 du flag d'affichage.
$0050       Si le flag d'affichage était à zéro, on évite le rafraichissement.
$0053-$0055 Début du rafraichissement de l'affichage, avec sauvegarde
            de registres.
$0056       Envoi à EF9345 de commandes (à décoder)
$0058       ---
$005a       ---
$005c       ---
$005e       ---
$0060       ---
$0062       ---
$0065       ---

$0066       [nmi]
            %CODE
            Interruption non masquable.

            L'interruption est provoquée par l'appui sur la touche Delta, qui est branchée
            sur l'interruption du processeur (via ???)

            L'interruption branche immédiatement vers un vecteur qui, par défaut, branche à
            son tour vers `test_reset`. Cette routine par défaut vérifie l'appuie sur la
            touche CTRL. Si c'est le cas, un redémarrage à chaud aura lieu. Sinon, il ne
            se passe rien de plus.

            [ArticleUserNMI]

$0069       [lang_to_eng]
            %CODE
            Met le système en anglais.

            Le seul accès semble être via la valeur que prend temporairemet `nmihk` pendant le démarrage.
$0069-$006b Messages en anglais.
$006e-$0071 Table de transcription du clavier en anglais.
$0074       Retour d'interruption NMI.

$0076       ---

$0080       [retfun]
            %CODE
            Fin de fonction d'utilisateur.

            Doit être appelé à la fin d'une fonction utilisateur afin de placer le contenu de A comme
            résultat de la fonction.

            Entrées : 
            - A contient la valeur de retour de la fonction
            - HL pointe sur le texte BASIC
$0080       Saut vers l'implémentation.

$0083       [deint]
            %CODE
            Place l'accumulateur flottant en tant qu'entier dans DE.

            Peut être appelé par une fonction utilisateur afin de récupérer le contenu de
            l'accumulateur flottant en tant qu'entier, dans DE. Si ce n'est pas possible,
            une erreur BASIC est provoquée.

            Entrées :
            - HL pointe généralement sur le texte BASIC (mais ne sert pas et est préservé).
            
            Sortie :
            - DE contient la valeur de l'accumulateur flottant, sous forme entière.
$0083       Saut vers l'implémentation.

$0086       [getbyt]
            %CODE
            Évalue l'expression BASIC pointée par HL et renvoie son résultat dans A.

            Le résultat de l'expression doit être numérique et tenir sur 8 bits.
            Dans le cas contraire, une erreur BASIC sera levée.

            Entrées :
            - HL pointe sur le texte BASIC.

            Sortie :
            - DE contient l'évaluation de l'expression, sous forme entière.
            - HL est avancé après l'expression.
$0086       Saut vers l'implémentation.

$0089       [frmnum]
            %CODE
            Évalue l'expression BASIC pointée par HL et renvoie son résultat dans FAC.

            Si l'expression n'est pas numérique, une erreur BASIC sera levée.
            
            Cette opération peut être enchaînée avec un appel à `deint` pour récupérer le
            résultat sous forme d'entier 16 bits dans DE.

            Entrées :
            - HL pointe sur le texte BASIC.

            Sortie :
            - FAC contient l'évaluation de l'expression.
            - HL est avancé après l'expression.
$0089       Saut vers l'implémentation.
$008c       [beep]
            %CODE
            Produit un son.

            Entrées :
            - DE contient la durée du son.
            - (sonsav_hi) contient le temps de la période haute du son.
            - (sonsav_lo) contient le temps de la période basse du son.

            [ArticleBeep]
$008c       Saut vers l'implémentation.

$008f       [play]
            %CODE
            Joue une séquence sonore codée par une chaîne de caractères selon le format de la commande
            BASIC `PLAY`.

            Entrées :
            - BC pointe vers la chaîne de commande.
            - E contient la taille de la chaîne de commande en octets.

            [ArticleVDP]
$008f       Saut vers l'implémentation.

$0092       [putahl]
            %CODE
            Place une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            La position est spécifiée.

            Le BASIC n'utilise pas cette commande et passe par une mémoire intermédiaire.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC et AF

            [ArticleVDP]
$0092       Saut vers l'implémentation.

$0095       [putici]
            %CODE
            Place une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            Le caractère est placé à la position courante du curseur.

            Le BASIC n'utilise pas cette commande et passe par une mémoire intermédiaire.

            Entrées :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC et AF

            [ArticleVDP]
$0095       Saut vers l'implémentation.

$0098       [getahl]
            %CODE
            Lit une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            La position est spécifiée.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            Sorties :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC DE, et AF

            [ArticleVDP]
$0098       Saut vers l'implémentation.

$009b       [getici]
            %CODE
            Lit une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            Le caractère est lu depuis la position courante du curseur.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            Sorties :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC DE, et AF

            [ArticleVDP]
$009b       Saut vers l'implémentation.

$009e       [cls]
            %CODE
            Efface la mémoire tampon de l'écran.

            L'effacement se fait en effçant la première selon la procédure `cll` qui suit, puis
            en recopiant son contenu dans le reste de la mémoire tampon.

            Entrées :
            - (attbak) contient la couleur de fond.
            - (attcar) contient les attributs de caractères.

            [ArticleScreenBuffer]
$009e       Saut vers l'implémentation.

$00a1       [cll]
            %CODE
            Efface une ligne donnée de la mémoire tampon de l'écran.

            L'effacement se fait en plaçant en début de ligne un caractère de délimitation dont les paramètres
            se trouvent en (attbak). Puis en remplissant la ligne avec $20 (espace ASCII) en mode
            texte, ou $00 en mode graphique, avec un attribut, selon la directive (attcar).

            Entrées :
            - A contient le numéro de la ligne.
            - (attbak) contient la couleur de fond.
            - (attcar) contient les attributs de caractères.

            [ArticleScreenBuffer]
$00a1       Saut vers l'implémentation.

$00a4       [wait]
            %CODE
            Attente que le VDP soit prêt.

            Modifie :
            - AF

            [ArticleVDP]
$00a4       Saut vers l'implémentation.

$00a7       [fndadr]
            %CODE
            Calcule de l'adresse dans le tampon vidéo de coordonnées.

            Entrées :
            - H contient le numéro de la ligne (Y)
            - L contient le numéro de la colonne (X)
            Sortie :
            - HL contient l'adresse correspondante dans le tampon vidéo

            [ArticleScreenBuffer]
$00a7       Saut vers l'implémentation.

$00aa       [kbscan]
            %CODE
            Renvoi le numéro de la touche clavier appuyée, ou 0.

            Effectue un scan du clavier sur le moment.

            Sortie :
            - A contient le caractère ASCII produit par la touche appuyée, ou bien 0.
            - Le Carry Flag indique si la lue touche a changé depuis le dernier appel (0) ou est restée identique (1).

            [ArticleKeyboard]
$00aa       Saut vers l'implémentation.

$00ad       [regst]
            %CODE
            Envoie au VDP une liste de paires (registres, valeur).

            Le premier élément de la liste est le nombre de paires de la table.
            Suivent les paires sous forme de deux octets, le premier contenant l'adresse de selection de registre et le deuxième la valeur à transmettre.

            Entrées :
            - HL pointe vers la table des valeurs.

            Modifie :
            - HL, BC, AF
            [ArticleVDP]
$00ad       Saut vers l'implémentation.

$00b0       [stkv]
            %CODE
            Vérification de l'axe vertical pour les déplacements.

            L'axe vertical est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.
            
            Sortie :
            - A = 0, aucune action selon l'axe vertical.
            - A = 1, action vers le bas.
            - A = 255, action vers le haut.

            Modifie :
            - AF, B

            [ArticleActions]
$00b0       Saut vers l'implémentation.

$00b3       [stkh]
            %CODE
            Vérification de l'axe horizontal pour les déplacements.

            L'axe horizontal est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.
            
            Sortie :
            - A = 0, aucune action selon l'axe horizontal.
            - A = 1, action vers la droite.
            - A = 255, action vers la gauche.

            Modifie :
            - AF, B

            [ArticleActions]
$00b3       Saut vers l'implémentation.

$00b6       [stka]
            %CODE
            Vérification du bouton d'action.

            Le bouton d'action est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour la barre espace du clavier.
            
            Sortie :
            - A = 0, aucune action.
            - A = 1, bouton actif.

            Modifie :
            - AF, B

            [ArticleActions]
$00b6       Saut vers l'implémentation.

$00b9       [break]
            %CODE
            Vérification de la séquence `break` (shift + stop appuyés au clavier).

            Sortie :
            - A = 1 si `stop` n'était pas pressé
            - A = 4 si `stop` était pressé, mais pas `shift`.
            - A = 0 si `stop` et `shift` étaient pressés, le Carry est à mis à 1.
$00b9       Saut vers l'implémentation.

$00bc       [disp_refrsh]
            Rafraichissement de l'état de l'affichage sur l'EF9345 en fonction
            du contenu de la mémoire vidéo en RAM ($4000)

            Le séquence commence avant le branchement à la fin de `irq:`.
$00bc       ---
$00bf       Séquence EF9345 à décoder
$00c1       ---
$00c3       ---
$00c5       ---
$00c7       ---
$00c9       ---
$00ca       ---
$00cc       ---
$00ce       ---
$00d0       ---
$00d1       ---
$00d3       ---
$00d6       ---
$00d8       ---
$00da       ---
$00dc       ---
$00de       ---
$00e0       [r_line0_lp]
$00e2       ---
$00e4       ---
$00e6       ---
$00e8       ---
$00ea       ---
$00ec       Boucle sur les 80 octets de la première ligne
$00ee       ---
$00f0       ---
$00f2       ---
$00f4       ---
$00f6       ---
$00f8       ---
$00fa       ---
$00fb       ---
$00fd       24 lignes
$00ff       [r_line_loop]
$0101       ---
$0103       ---
$0105       [jump0105]
$0107       ---
$0108       ---
$010b       ---
$010d       ---
$010f       ---
$0111       [loop0111]
$0113       ---
$0115       [jump0115]
$0117       ---
$0118       ---
$011b       ---
$011d       ---
$011f       ---
$0121       ---
$0123       ---
$0125       ---
$0127       ---
$0129       ---
$012b       ---
$012d       [jump012D]
$012f       ---
$0130       ---
$0133       ---
$0135       ---
$0137       ---
$0139       ---
$013b       ---
$013c       ---
$013e       ---
$0142       ---
$0144       ---
$0147       ---
$0148       ---
$0149       ---
$014b       ---
$014d       ---
$014e       [skip014E]
$0150       ---
$0152       ---
$0154       ---
$0156       ---
$0158       ---
$015a       ---
$015c       ---
$015e       ---
$0160       ---
$0162       ---
$0164       ---
$0166       ---
$0168       [jump0168]
$016a       ---
$016b       ---
$016e       ---
$0170       ---
$0172       ---
$0174       ---
$0176       ---
$0178       ---
$017a       ---
$017e       ---
$0181       ---
$0183       [skip0183]
$0184       ---
$0185       ---
$0186       [skip_dsplay]
$0186       Incrémente le compteur de répétition des touches.
$0189       ---
$018a       ---
$018b       ---

$018c       [putahl_impl]
            Implémentation de `putahl:`.
$018c       ---
$018e       ---
$0190       ---
$0192       Place le curseur sur le ligne H
$0194       ---
$0196       ---
$0198       Place le curseur sur le colonne L

$019a       [putici_impl]
            Implémentation de `putici:`.
$019a       ---
$019d       ---
$019f       ---
$01a1       [put_wait1]
$01a3       ---
$01a4       ---
$01a7       ---
$01a9       ---
$01ab       ---
$01ad       ---
$01af       ---
$01b1       [put_wait2]
$01b3       ---
$01b4       ---
$01b7       ---
$01b9       ---
$01bb       ---
$01bd       ---
$01bf       ---
$01c1       ---
$01c3       ---

$01c4       [getahl_impl]
            Implémentation de `getahl:`.
$01c4       ---
$01c6       ---
$01c8       ---
$01ca       ---
$01cc       ---
$01ce       ---
$01d0       ---

$01d2       [getici_impl]
            Implémentation de `getici:`.
$01d2       ---
$01d5       ---
$01d7       ---
$01d9       ---
$01db       ---
$01dd       ---
$01df       [get_wait1]
$01e1       ---
$01e2       ---
$01e5       ---
$01e7       ---
$01e9       ---
$01eb       ---
$01ed       ---
$01ef       [get_wait2]
$01f1       ---
$01f2       ---
$01f5       ---
$01f7       ---
$01f9       ---
$01fb       ---
$01fc       [delim_wrt]
            Inscrit un délimiteur à l'écran avec les attributs courants et avance le curseur.

            Peut provoquer un défilement de l'écran.

$01fc       Récupère la valeur de `extenf`, qui indique l'utilisation des caractères ROM ou RAM.
$01ff       Récupère les coordonnées actuelles du curseur.
$0202       Sauve les coordonnées du curseur.
$0203       Sauve la valeur de `extenf`.
$0204       Calcul de l'adresse écran en RAM pour la position du curseur dans HL.
$0207       Restaure la valeur de `extenf`.
$0208       Met cette valeur dans le premier octet de la paire caractère/attribut dans la zone de l'écran.
$0209       Récupère la valeur de `attcar`, qui contient les attributs de caractère courant.
$020c       Avance le pointeur de l'écran.
$020d       Met dans le second octet de la paire caractère/attribut les attributs de couleurs.
$020e       Avance le pointeur de l'écran.
$020f       Sauve le pointeur de l'écran dans DE.
$0210-$0213 Désactive la continuation de ligne (expliquer le fonctionnement de la continuation ailleurs ???)
$0215       Récupère les coordonnées du curseur.
$0216-$0219 Branche si la colonne est inférieure à 39
$021b       Sinon ramène le curseur à la colonne 0.
$021d       Incrémente la ligne du curseur.
$021e-$0221 Branche si la ligne est inférieur à 25.
$0223       Sinon réduit la ligne de 1.
$0224-$0229 Indique dans le registre `picflg` que le curseur à atteint le bas de l'écran.
$022c-$022e Branche si le défilement n'est pas permis.
$0230       Sauve les coordonnées.
$0231       Provoque un défilement de l'écran de 1 ligne vers le haut.
$0234-$0236 Efface la ligne 24.
$0239       Restaure les coordonnées.
$023a       Demande un rafraichissement de l'écran à la prochaine interruption.
$023e       Charge DE avec l'adresse du premier octet de la dernière ligne de l'écran.
$0241       [line_ok]
$0241-$0246 Branche si le caractère de continuation n'est pas requis par le registre.
$0248-$024a Réactive la continuation.
$024d-$024f Inscrit le caractère de continuation ($84) au début de la dernière ligne.
$0250       [delim_end]
$0250       Incrémente le numéro de colonne.
$0251       Replace les nouvelles coordonnées dans le registre.

$0255       [cls_impl]
            Efface l'écran avec la couleur de fond passée dans A.

            Entrée :
            - A contient la valeur pour le registre `attbak`.

            Normalement appelé par `cls`

$0255       A = 0
$0256       Efface la première ligne du buffer d'écran avec la valeur `0`.
$0259-$0262 Copie le contenue de la première ligne dans le reste du buffer écran.

$0265       [cli_impl]
            Implémentation de `cli:`.
$0265       ---
$0267       ---
$0268       ---
$026b       Écriture de $80 à la première position de la ligne
$026d       Récupération des attributs par défaut
$0270       ---
$0271       Écriture dans la position suivante des attributs par défaut
$0272       ---
$0275       ---
$0276       if bit(C,7) == 1 then A = 0 else A = $20
            Le bit 7 de C étant à 1 pour un caractère graphique, 0 pour texte
$0278       ---
$027a       ---
$027c       ---
$027d       [cli_default]
            Boucle pour écrire dans les positions suivantes de la ligne alternativement A et C.
            Donc un espace pour le mode texte et 0 pour le mode graphique, suivi des attributs
$027f       [cli_loop]
$0280       ---
$0281       ---
$0282       ---
$0283       ---
$0285       ---

$0286       [wait_impl]
            Implémentation de `wait:`.
$0286       ---
$0288       ---
$028a       [wait_loop]
$028c       ---
$028d       ---
$0290       ---

$0291       [fndadr_impl]
            Implémentation de `fndadr`.

            Effectue le calcul $4000 + (80 * y) + (2 * x).

            Normalement appelé par `fndadr`.

$0291       C contient x
$0292       L contient y
$0293-$0297 HL = L * 8 (c'est-à-dire y * 8)
$0298-$0299 DE = HL = y * 8
$029a-$029c HL = 32 * y + 8 * y = 40 * y
$029d       HL = 80 * y
$029e       C contient x
$02a0-$02a1 HL = 80 * y + 2 * x
$02a2-$02a5 HL = $4000 + 80 * y + 2 * x

$02a7       [kbscan_impl]
            Implémentation de `kbscan:`.

            Les touches sont branchées sur une matrice de 8 lignes de 8 colonnes.

            La première étape est de trouver la premier ligne contenant une touche appuyée,
            puis dans cette ligne, trouver laquelle des 8 touches est appuyée.

            À partir de la ligne et de la colonne, un index est calculé et cet index sert
            à lire la valeur de la touche dans une table.

            Il y a trois tables consécutives.
            - Table standard
            - Table avec `shift` appuyée.
            - Table avec `control` appuyée.

            Ces tables sont en RAM et remplies à l'initialisation en fonction de la langue
            du sytème.

            Sortie :
            - A contient le caractère ASCII produit par la touche appuyée, ou bien 0.
            - Le Carry Flag indique si la lue touche a changé depuis le dernier appel (0) ou est restée identique (1).

$02a7       Prépare C avec le premier port à scanner ($87) et B avec le nombre de ports (7).
$02aa       [kb_row_loop]
            lecture de l'entrée
$02ac-$02ad La ligne est à l'état haut lorsque la touche n'est pas pressée.
            En prenant son complément, un résultat à 0 signifie qu'aucune touche de la rangée n'est pressée.
$02ae       Branche si une touche est pressée sur cette ligne.
$02b0       Vise le port précédent.
$02b1       Boucle sur le nombre de ports (7).
$02b3       Quel est le port ici ???
$02b5       ---
$02b6       Masque avec b10111011 de la dernière ligne lue.
$02b8       [key_pressed]
$02b8       Branche si aucune touche n'est pressée.
$02ba       ---
$02bc       [col_count]
$02bc-$02bf Cherche la 'colonne' de la touche appuyée et décalant
            vers la gauche A jusqu'à ce que Carry passe à 1, tout
            en comptant depuis 7 à rebours.
$02c1       [col_exit]
$02c1       Place dans A la colonne de la touche pressée.
$02c2       A=2 * colonne
$02c3       A=4 * colonne
$02c4       A=8 * colonne
$02c5       A=(8 * colonne) + (port de la ligne) ($80 à $87)
$02c6       A=(8 * colonne) + (port de la ligne - $80) (0 à 7)
            Cela donne l'index dans la table de décodage.
$02c8       ---
$02ca       Lecture du rang 0 dans B pour vérifier l'appui sur `shift` et `control`.
$02cc-$02cf Préparation de la table de décodage dans HL et du potentiel décalage.
$02d2       Vérification de la touche `shift` appuyée.
$02d4       Branchement si `shift` n'est pas appuyée.
$02d6       Déplacement du pointeur vers la table de décodage avec `shift` appuyée.
$02d7       Si `shift` est appuyée, `control` est ignorée.
$02d9       [key_noshift]
$02d9       Vérification de la touche `control` appuyée.
$02db       Branchement si la touche `control` n'est pas appuyée.
$02dd-$02de Ajoute $80 (2 * $40) à l'adresse de la table de décodage.
$02df       [key_noctrl]
$02df-$02e0 L'index de la table, dans A, est copié dans DE.
$02e2       L'index est ajouté au pointeur de la table.
$02e3       La valeur de la table est lue dans A.
$02e4       [key_changed]
$02e4       Comparaison avec la valeur précédente lue au clavier.
$02e7       Set Carry flag
$02e8       Branche si la nouvelle touche pressée est identique à la précédente.
$02ea       Sinon, on enregistre la nouvelle valeur
$02ed       Et le Carry flag est enlevé
$02ee       [kbscan_exit]

$02ef       [regst_impl]
            Implémentation de `regst:`.
$02ef       Lecture dans B de la longueur (nombre de paires) de la table.
$02f0       Place HL sur l'octet suivant de la séquence.
$02f1       [regst_loop]
$02f4-$02dc Utilisation de `outi` pour enoyer les paires vers le VDP.
            À chaque tour de boucle, le premier octet est envoyé vers le port `$8f`
            et le second vers le port `$cf`. Chaque envoie est précédé d'une attente
            d'état `prêt` du VDP.

$02ff       [add_half]
            %SECTION(f4i),MSBASIC(ROUND)
            Ajoute `0.5` à FAC (l'accumulateur flottant).

            Est utilisé pour faire un arrondi à l'entier le plus proche.

            == DEBUT DE SECTION F4I (mathématiques flottantes) ==

$0302       [fp_add_hl]
            %MS_BASIC(ADDPHL)
            Addition flottante : (HL) + FAC

            Entrées :
            - FAC
            - Le nombre flottant pointé par HL.

            Sortie :
            - FAC contient le résultat.
$0302       Charge les quatre octetcs pointés par HL dans BCDE.
$0305       Branche vers l'addition entre BCDE et FAC.
$0307       [fp_sub_hl]
            %MS_BASIC(SUBPHL)
            Soustraction flottante : (HL) - FAC

            Entrées :
            - FAC
            - Le nombre flottant pointé par HL.

            Sortie :
            - FAC contient le résultat.

            La suite se décode comme :
            - call     hl_to_bcde ; (cd e0 05)
            - ld       hl,$d1c1   ; (21 c1 d1)
            La deuxième instructon saute par dessus les deux `pop` pour arriver directement sur
            l'inversion de signe de `fp_bcde_sub`.

$030b       [fp_stck_sub]
            %CODE,MS_BASIC(PSUB)
            Appelé via la table des priorités lors de l'évaluation d'une expression.
            Soustrait FAC du contenu de la pile, placé dans BCDE.
$030b-$030c Récupère le nombre flottante depuis la pile puis continue
            sur l'inversion de signe et l'ajout de BCDE à FAC.

$030d       [fp_bcde_sub]
            %MS_BASIC(SUBBCDE)
            Inverse le contenu de FAC puis y ajoute BCDE.
            Ce qui revient à faire BCDE - FAC.

$0310       [fp_bcde_add]
            %MS_BASIC(FPADD)
            Appelé via la table des priorités lors de l'évaluation d'une expression.
            Ajoute le contenu de BCDE et de FAC.
$0310-$0312 Si l'exposant de BCDE est 0, il n'y a rien à ajouter, on ne touche pas à FAC et on sort.
$0313-$0317 Si l'exposant dans FAC est 0, alors on copie BCDE dans FAC et c'est terminé
$031a-$031b Si l'exposant de BCDE (B) est plus petit que celui de FAC (A), on garde comme ça. Sinon, on les échange.
$031d-$031e Oppose la différence entre les expostants (complément à 2)
$031f       Sauve DE...
$0320       Le temps de mettre FAC sur la pile
$0323       ... et restaure DE
$0324       Copie BCDE dans FAC
$0327-$0328 Et récupère BCDE (l'ancien FAC) depuis la pile.
$0329       [no_swap]
            Ici, BCDE contient le plus petit des nombres. A contient la différence (positive) entre les deux exposants.
$0328-$032b Si la différence est de plus de 25. BCDE est négligeable face à FAC, on a terminé.
$032c       Sauve AF
$032d       Extrait les signes de FAC et BCDE, A bit 7 à 1 si les signes sont opposés, 0 si identiques.
$0330       Sauve le résultat du signe dans H
$0331       Et récupère AF
$0332       Déplace la mantisse à droite (division) d'un nombre de position égal à A
$0335-$0336 Test le résultat de signe
$0337       Pointe sur la mantisse
$033a       Branche si les signes étaient différents. Dans ce cas, on doit faire une soustraction.
$033d       Ajoute les mantisses de FAC et BCDE
$0340       Pas d'overflow, on passe à l'arrondi du résultat (et sa normalisation)
$0342       Sinon, il faut augmenter...
$0343       .. l'exposant de 1
$0344       Si l'exposant a dépassé sa limite (boucle sur zéro), branche sur une erreur de dépassement de capacité.
$0347-$0349 Sinon, il faut corriger la mantisse avec un décalage de 1 (L) vers la droite
$034c       Puis on passe à l'arrondi

$034e       [min_bcde]
            FAC - CDEB -> BCDE. Si un overflow (underflow) est provoqué, le nombre est complémenté à 2 à la fin. Puis fallback dans la normalisation.
$0350       B ici contient le résultat du shift à droite le moins signifiant. Le nombre est sous forme CDEB
$035c       [pos_norm]
            Met le nombre en positif potentiellement avant de normer et compacter.
$035c       Si Carry est à 1, fait le complément à 2 de CDEB.

$035f       [bcde_norm]
            Lors de la normalisation, BCDE n'a pas le format normal. B n'est pas l'exposant, mais le poids le plus faible de la mantisse.

            C'est donc une mantisse sous forme CDEB qui est traitée. L'exposant est celui de FAC.
$035f-$0360 L et H sont les plus petits signifiants de la mantisse, qui est sous la forme CDHL (l'exposant est dans FAC)
$0361       A = 0, va servir de compteur

$0362       [rot_loop]
            La partie ci-dessous prend C, D, H, L, A comme un buffer en decalage vers la gauche
            (octet par octet). A est un compteur (sauvé temporairement dans B pendant la rotation) auquel
            on soustrait 8 à chaque fois, jusqu'à attendre $e0 (ce qui fait 4 fois avec A = 0 au début)
$0362       Sauvegarde du compteur dans B
$0363       Récupère le MSB de la mantisse dans A
$0364       Si A est différent de 0, c'est que C (la partie la plus haute de la mantisse) était non nul
$0365       Si A (dont l'octet le plus haut) est 0, on peut faire le décalage d'un octet complet. Sinon, bit par bit
$0367       On décale...
$0368       ... CDHL
$0369       ... vers
$036a       ... DHLA (et A est égal à 0 ici). On embarque L (l'exposant) dans le shift, pour tester au passage s'il était nul.
$036b       Récupération temporaire dans A du compteur
$036c-$036e Soustrait 8 du compteur, puisque l'on vient de décaler de 8, et comparaison avec -24-8.
$0370       Arrêt si le compteur est arrivé à 32. On a shifté de 32 bits au max, le résultat est donc 0. Sinon, on continue le shift
$0372       [clear_fac]
$0372       On met 0 dans le FAC
$0373       [a_to_exp]
$0376       Charge A dans l'exposant de FAC.
$0377       [normal]
$0378-$0379 Vérifie s'il y a des bits dans DHL (les LSBs de la mantisse).
$037a       Si oui, il faut les traiter avec les routines complète
$037c       Sinon, on ne traite que C pour trouver le premier bit de poids fort. Routine optimisée
$037d       [bit_find]
$037d-$037f Diminue B jusqu'à trouver le premier bit à 1 dans A (qui vient de C). B est le résultat du nombre de shift de 8 effectué précédemment, en soustraction de $00.
$0381       Bit à 1 trouvé. On remet B un cran avant.
$0382       On remet aussi le nombre au cran d'avant (remettre le CY dans le nombre)
$0383       C (MSB de la mantisse) est normalisé (avec 1 en msb)
$0386       [norm_full]
$0386       Compte un bit de shift
$0387       Décale HL à gauche de 1
$0388-$038a Shift D de 1 en récupérant le Carry de HL
$038b-$038d Shift C de 1 en récupérant le Carry de D
$038e       [norm_bit]
$038e       Il reste quelque chose, on continu la normalisation
$0391       [norm_nxt]
$0391       Le compteur de shift est mis dans A. CDHL est normalisé.
$0392-$0393 Reconstruction de CDEB contenant la mantisse
$0394-$0395 On n'a rien shifté, on passe à l'arrondi
$0397-$039a Modification de l'exposant avec le compteur de décalage (B est négatif en complément à 2).
$039b       Remise en place de l'exposant ajusté.
$039c       Le décalage est trop grand, on n'a plus de précision, le résultat est 0
$039e       L'exposant est 0, le résultat est donc 0 (dans d'autres versions, un RET Z est fait ici)
$03a0       [round]
$03a0       Récupère la plus petite partie de la mantisse
$03a1       [round0]
$03a4       Vérifie si la plus petite partie de la mantisse a son msb à 1
$03a5       Dans ce cas, on arrondi vers le haut.
$03a8       Récupération dans B de l'exposant
$03a9-$03aa Récupération dans A du résultat de signe
$03ab       Récupération du bit de signe (seul le msb compte)
$03ad       Place le bit de signe (le msb de C est forcément à 1, donc un XOR fonctionne si 1 signifie + ?)
$03ae       Remet en place le MSB + Signe de la mantisse
$03af       Place le résultat dans FAC
$03b2       [round_up]
$03b2       Incrément la partie basse de la mantisse
$03b3       Si on n'a pas fait d'overflow (retour à zero), c'est ok, on revient
$03b4       Sinon, on augmente la partie suivante
$03b5       On vérifie encore
$03b6       Si on doit toujours arrondir, on arrondie la partie suivante
$03b7       Dernière chance
$03b8       Tout a été arrondi, on reset C
$03ba       Et on incrémente l'exposant
$03bb       Retour si tout va bien. Mais si l'exposant a bouclé sur 0
$03bc       Alors c'est que le nombre est trop grand, on lance l'erreur.

$03bf       [add_bcde]
            Ajoute les mantisses de FAC (plus exactemet, de ce qui est pointé par HL) et CDE.
            
            Le résultat est dans CDE, et Carry à 1 si dépassement de capacité.
            FAC n'est pas modifié.

$03bf-$03ca HL pointe sur la mantisse de FAC. Y ajoute la mantisse CDE.

            Les exposants des deux nombres doivent être identiques pour que cela ait du sens.
            Si la mantisse provoque un dépassement de capacité, le Carry sera à 1 en sortie.

$03cb       [cpl_2]
            Complément à 2 de la mantisse sous forme CDEB.
$03cb-$03cd Inverse le bit de signe temporaire.

$03df       [scale]
            %MS_BASIC(SCALE)
            Décalage vers la gauche de la mantisse CDEB d'un nombre donné par A.

            Le décalage se fait d'abord par groupe de 8 bits tant que c'est possible, puis continue bit à bit.
            
$03df       Initialise B à 0. B contiendra les bits les moins significatifs de la mantisse.
$03e1       [shiftr_8]
$03e1-$03ea Décale la mantisse de 8 bits (un registre complet) vers la droite.
$03ec       [end_256]
$03ec       La denière soustractiona a fait passer A négatif, on y ajoute 8+1.
$03ee       Sauvegarde de l'exposant restant dans A
$03ef-$03f2 S'il y a des bits à 1 dans le bas de la mantisse (DEB), on passe sur la méthode complète (plus lente) de shift vers la droite L fois.
$03f4       Sinon, on s'occupe uniquement de la partie haute de la mantisse (C)
$03f5       [msb_shift]
$03f5       Décrémentation du nombre de décalage restant (la boucle commence par le test, ce qui explique le 8+1 ajouté à A).
$03f6       Traitement terminé, routine terminée.
$03f7       Décalage à droite.
$03f8       Résultat dans C.
$03f9       Si le décalage a fait sortir un bit à 1, branchement vers la méthode complète.
$03fb       Le décalage n'a pas fait sortir de bit à 1, on continue avec le décalage de C uniquement.

$03fd       [fp_shift_r]
            %MS_BASIC(SHRLP)
            Décalage vers la droite L fois de la mantisse CDEB.
            Méthode complète.
            
$03fd       A prend 0. Et Carry est à 0 (important pour initialiser le décalage à droite)
$03fe       Décrémentation du nombre de décalage restant (la boucle commence par le test, ce qui explique le 8+1 ajouté à A).
$03ff       Traitement terminé, routine terminée.
$0400       Début du décalage du groupe CDEB vers la droite de 1.

$0401       [shft_right]
$0401-$0402 Décalage d'un bit vers la droite de CDEB, partie C.
$0403       [shift_rgt_2]
$0403-$0405 Décalage d'un bit vers la droite de CDEB, partie D.
$0406-$0408 Décalage d'un bit vers la droite de CDEB, partie E.
$0409-$040B Décalage d'un bit vers la droite de CDEB, partie B.
$040e       [unity]
$0412       [logtab]
$0412       Longueur du tableau.
$0413       [logtab_0]
$0413       4.811474800109863
$0417       [logtab_1]
$0417       6.105852127075195
$041b       [logtab_2]
$041b       -8.86266040802002
$041f       [logtab_3]
$041f       -2.054666757583618
$0423       [logtab2]
$0423       Longueur du tableau.
$0424       [logtab2_0]
$0424       1.0
$0428       [logtab2_1]
$0428       6.427842140197754
$042c       [logtab2_2]
$042c       4.545170783996582
$0430       [logtab2_3]
$0430       0.3535534143447876
$0434       [inst_log]
            %CODE
$0434-$0426 Branche sur une erreur si l'argument, dans FAC, est négatif ou nul.       
$0439       Appel le calcul du log.
$043c-$043f BCDE = ln(2)
$0442       Multiplie le résultat par ln(2)
$0444       [log]
$0444       L'argument de l'instruction log est ramenée dans BCDE.
$0447-$0449 Initialise l'exposant de FAC avec $80 (c'est-à-dire exposant 0)
$044c       Opération sur l'exposant de FAC pour en retirer la valeur entière, qui sera utilisée plus loin.
            Note : le bit 7 de l'exposant, inversé, se retrouvera dans le bit de signe du nombre monté dans FAC (???)
$044d       Sauvegarde de AF
$044e       Pousse FAC (l'argument du `log` avec son exposant à `$80`) sur la pile.
$0451       Fait pointer HL vers la table de facteurs pour `log`.
$0454       Calcule le polynome avec les facteurs de `logtab`.
$0457-$0458 Récupère l'argument dans BCHL (car DE va être utilisé)
$0459       Pousse le résultat du polynome sur la pile.
$045c       Reconstitue BCDE, argument du `log`.
$045d       Monte BCDE dans FAC.
$0460-$0463 Calcule le second polynome avec les facteurs de `logtab2`.
$0466-$0467 Récupère BCDE, l'argument du `log`.
$0468       Division de l'argument dans BCDE par le polynome.
$046b       Récupération de l'opération sur l'exposant de FAC (inversion du bit 7).
$046c       Résultat de la division dans la pile.
$046f       Placement du nombre dans A dans FAC (qui était la valeur de l'exposant)
$0472-$0473 Récupération du résultat du calcul qui avait été mis sur la pile.
$0474       Ajout avec FAC.
$0477       Saute les deux `pop` suivant pour aller vers la multiplication.

$0478       [fp_stk_mul]
            %CODE
            Appelé via la table des priorités

            Multiplication du nombre flottant sur la pile avec FAC.
$0478-$0479 Récupération du nombre flottant sur la pile dans BCDE.

$047a       [fp_bcde_mul]
            Multiplication flottante

            Multiplication de BCDE et de FAC.
$047a       Récupère le signe de FAC.
$047b       Retourne immédiatement si c'est 0.
$047c-$047e Ajoute les exposants de FAC et BCDE
$0481-$0482 Sauve le MSB de BCDE dans le premier buffer de travail.
$0485-$0486 Sauve le reste de BCDE dans le second buffer de travail.
            Ces deux buffers servent à garder l'argument de la multiplication.
$0489-$048d BCDE = 0
$048e-$0491 Place l'adresse de retour sur la pile vers la normalisation de BCDE.
$0492       Charge l'adresse de la multiplication sur 8 bits
$0495-$0496 Et la place sur la pile comme deux adresses de retour.
            Ainsi, les trois prochains RET provoqueront deux appels à `mul_8b` puis un appel à `bcde_norm`.
$0497       HL pointe vers le LSB de FAC.
$049a       [mul_8b]
$049a       Début de la multiplication sur 8 bits. Récupération de la partie FAC du nombre.
$049b       Et déplacement de HL vers l'octet suivant.
$049c-$049d Branchement si cette partie est nulle.
$049f       Sauvegarde de HL, qui pointe vers l'octet suivant de FAC.
$04a0       Compteur de 8 bits pour la multiplication partielle par A.
$04a2       [mul_8b_loop]
$04a2       Récupération du bit de poids faible dans le Carry.
$04a3       Sauvegarde du multiplicateur dans A
$04a4       Copie du MSB de BCDE dans A.
$04a5       Branche si le bit du multiplicateur était à zéro : pas d'addition.
$04a7       Sauvegarde de l'octet du multiplicateur et du compteur de bits.
$04a8       Récupération des deux octets bas de l'accumulateur pour la multiplication.
$04ab       Addition de cette partie basse avec la partie basse de BCDE (l'accumulateur de résultat)
$04ac       Le résultat devient le nouveau DE.
$04ad       Restauration de H (multiplicateur) et L (compteur de bits)
$04ae-$04b1 Addition des deux MSB (argument et accumulateur) en tenant compte de la retenue des parties basses.
$04b2       [no_add]
$04b2       
$04b2-$04bc Décalage du résultat vers la droite de CDEB.
            Dans l'opération, les bits les plus faibles de la mantisse peuvent être perdus.
$04bd       Test si le décalage a amené un bit en position 5 de B (l'octet de récupération de la précision).
$04bf       Branche si ça n'est pas le cas.
$04c1-$04c4 Sinon, place un bit en position 6 de B, pour faire un arrondi vers le haut.
$04c5       [no_lost]
$04c5       Décrémente le compteur de bits
$04c6       Ramène l'octet de multiplicateur dans A
$04c7       Boucle s'il reste des bits à traiter
$04c9       [pop_hl_ret]
$04c9       Restaure l'adresse de l'octet de FAC à traiter.
$04ca       Ce RET va rappeler deux fois la multiplication puis la normalisation de BCDE (cf. le commentaire plus haut)
$04cb       [byte_shift]
$04cc-$04ce Décalage d'un octet complet de l'accumulateur CDEB.
$04cf       Voir les commentaires ci-dessus sur l'effet de RET dans cette routine de multiplication.

$04d0       [fp_div_10]
            Division de FP par 10
            
            MS_BASIC=DIV10
$04d0       Place FAC sur la pile
$04d3-$04d6 Monte le nombre "10" dans BCDE
$04d9       Monte BCDE dans FAC

$04dc       [fp_stk_div]
            Appelé via la table des priorités

            Division du nombre flottant sur la pile par FAC.
$04dc-$04dd Extrait BCDE depuis la pile.
$04de       [fp_bcde_div]
            Division du nombre BCDE par FAC.
$04df-$04e2 Branche vers une erreur de division par zéro si FAC est nul.
$04e4-$04e7 Soustrait les exposants des deux nombres (celui de BCDE par celui de FAC)
$04e8       Ajoute 1 à l'exposant
$04eb       Si boucle sur zéro, branche vers un dépassement de capacité.
$04ec       Ajoute 1 à l'exposant à nouveau
$04ef       Et vérifie à nouveau un dépassement de capacité.
$04f0       Fait pointer HL sur le MSB de FAC.
$04f1       Charge le MSB de FAC dans A.
$04f4       Et le sauve dans la mémoire de travail de la division.
$04f5-$04f6 Fait de même pour l'octet du milieu de FAC
$04f9-$04fb Et enfin pour l'octet le moins signifiant.
$04fe       Charge le MSB de BCDE dans B.
$04ff       Sauve la partie basse de BCDE dans HL.
$0500-$0503 CDE = 0. Contiendra le quotient de la division.
$0504       Dépassement/VLSB
$0507       [fp_div_loop]
$0507       Sauve la partie basse du dividende
$0508       Sauve la partie haute (B) du dividende.
$0509       Prend le LSB du dividende
$050a       Soustrait le diviseur (injecté dans la routine) du dividende (LHB).
            La routine de division, copiée en RAM au démarrage, est la suivante :

                div_subr:    sub      a,$00 ; LSB
                             ld       l,a
                             ld       a,h
                             sbc      a,$00 ; Middle
                             ld       h,a
                             ld       a,b
                             sbc      a,$00 ; MSB
                             ld       b,a
                             ld       a,$00 ; VLSB
                             ret

$050d       Continue la soustraction en accumulant les dépassements dans `fdivc_4`
$050f       Complémente le Carry
$0510       Branche si le diviseur était plus grand que le dividende.
$0512       Sinon, sauve le compteur de dépassement.
$0515-$0516 Supprime le diviseur de la pile.
$0517       Met le Carry à 1
$0518       Saute par dessus les deux `pop` suivant
$0519       [restore_div]
$0519-$051a Restaure le diviseur depuis la pile.
$051b       Prend le MSB du quotient.
$051c       Incrémente
$051d       Décrémente
$051e       Amène le Carry vers le bit 7 et le bit 0 vers le Carry.
$051f       Branche si le résultat est positive.
$0522       Rotation dans l'autre sens pour restaurer A.
$0523       Récupération du nombre de dépassements.
$0526       Rotation vers la droite.
$0527       Masque avec $c0
$0529       Sauve AF
$052a-$052d Branche si L = H = B = 0, c'est-à-dire qu'il n'y a plus rien à diviser.
$052f       Sinon, A = $20
$0531       [div_end]
$0531       Restaure HL (qui était AF)
$0532       Prépare les drapeaux pour l'arrondi.
$0533       Branche vers l'arrondie.
$0536       [div_2]
$0536       Pour initialiser un flag ???
$0537-$0539 Décale E vers la gauche
$053a-$053c Décale D vers la gauche (avec le bit sorti de E)
$053d-$053f Décale C vers la gauche (avec le bit sorti de D)
$0540       Double HL
$0541-$0543 Décale B vers la gauche (avec le bit sorti du doublement de HL)
$0544-$0548 Décale `fdivc_4` vers la gauche (avec le bit sorti du doublement de B)
$054b-$054e Saute si C, D ou E contiennent encore des bits à 1 (la division continue)
$0550       Sauve HL
$0551       Pointe vers l'exposant de FAC.
$0554       Décrémente l'exposant
$0555       Restaure HL
$0556       Si l'exposant est non nul, on boucle vers la suite de la division.
$0558       Sinon, on a perdu toute précision, FAC passe à zéro et la division est terminée.
$055b       [add_exp]
            %MS_BASIC(ADDEXP)
            Ajoute ou soustrait l'exposant de BCDE à celui de FAC.

            Entrée :
            - L = 0, ajoute
            - L = $FF, soustrait

$055b-$055d Branche si l'exposant du dividende est zéro.
$055f       Place l'argument (ajoute ou soustrait) dans A.
$0560       HL pointe vers l'exposant de FAC.
$0563       Si l'argument était L = 0, ne fait rien, si L = FF, complément à 1 de l'exposant.
$0564       Ajoute les deux exposants.
$0565       Résultat des exposants dans BCDE.
$0566       Récupération de Carry dans le bit de poids fort de A
$0567       Détection du dépassement de capacité de l'addition précédente.
$0568       Copie l'exposant dans A.
$0569       Branche en cas de possible dépassement de capacité.
$056c       Normalise l'exposant autour de 128.
$056e       Et le place dans FAC.
$056f       Branche si l'exposant est zéro.
$0572       Sinon, extrait le bit de signe.
$0575       Place le nouvel exposant.
$0576       Fait pointer HL juste avant l'exposant (MSB de FAC)
$0578       [truc]
            %CODE
$0578       [ovrflw_tst1]
$0578       Chercher le signe de FAC.
$0578       Prend son opposé
$0578       Nettoie la pile
$057b       [ovrflw_tst2]
$057b       Vérifie si la valeur est nulle (l'exposant ou le signe)
$057c       [exp_no_add]
$057c       Retire l'adresse de retour de la pile.
$057d       Si le résultat est positif, le résultat est zéro, on branche vers FAC = 0
$0580       Sinon, c'est un dépassement de capacité, on branche vers l'erreur.

$0583       [fp_x_10]
            Multiplication de FAC par 10
            
            MS_BASIC=MLSP10
$0583       Récupère FAC dans BCDE
$0586-$0588 Si BCDE est nul, retour immédiat (il suffit de vérifier l'exposant B)
$0589       En ajoutant 2 à l'exposant, on multiplie le nombre par 4
$058b       Sortie si Overflow avec le message d'erreur
$058e       Sinon, on remet l'exposant en place dans BCDE
$058f       Ce nombre x4 est ajouté à FAC, pour un résultat de x5
$0592-$0595 Incrémente directement l'exposant dans FAC, pour obtenir x10.
$0596       Retour si on n'a pas fait passer l'exposant à zéro, cela s'est bien passé.
$0597       Sinon, c'est un dépassement de capacité.

$059a       [getsign_2]
$059d       Saute le `cpl` qui suit
$059e       [ret_cmp]
$059e       %CODE
            Prend le complément de A.
$059f       Rotation à gauche via Carry, qui contient donc le bit de poids fort de A.
$05a0       [flag_diff]
$05a0       Soustraction de A avec A avec retenu.
$05a1       Saute si la rotation avait débordée dans la retenue.
$05a2       Sinon, augmente A de 1 (autrement, dit A = 1 puisque la soustraction avait donné 0)
            Au final, le bit de poids fort de A est transformé en -1 (si bit à 0) ou 1 (si bit à 1)
$05a4       [inst_sgn]
            %CODE,MS_BASIC(SGN)
            Fonction BASIC `SGN()`.

            Place dans FAC le nombre entier dépendant du signe initial de FAC (-1, 0 ou 1).

$05a5       [a_to_fac]
            Place le contenu de A en tant qu'entier sur 8 bit vers FAC.
$05a5-$05a7 BCDE est préparé avec les valeurs $80,xx,$00,$00. A prendra la place de xx.
$05aa       [bade_to_fac]
            Place BADE sous format de nombre flottant dans FAC.
$05aa       Appelé depuis le traitement d'auto ($072e), A = 0, B = $98, DE = numéro de ligne ???
$05ad       Place la partie manquante de BCDE.
$05ae       Place l'exposant dans FAC.
$05af       Initialise B comme VLSB, à 0, pour donner CDEB.
$05b1       Pointe HL vers le bit de signe de FAC.
$05b2       Bit de signe à 1 (ce qui signifie positif, ce bit étant inversé par rapport à la forme normalisée BCDE)
$05b4       Place le bit de signe réel de A dans Carry
$05b5       Puis normalise.

$05b8       [inst_abs]
            %CODE,MS_BASIC(ABS)
            Fonction BASIC `ABS()`.

            Place dans FAC la valeur absolue de FAC.
$05b8       Prend le signe de FAC
$05b9       Retour immédiat si le signe est positif
$05ba       [inv_sign]
            Change le signe de FAC par son opposé
$05ba-$05bd Prend le MSB de FAC, dont le bit de poids fort est le bit de signe.
$05be       Inverse le bit de poids fort.
$05c0       Replace MSB avec le nouveau bit de signe.

$05c2       [fac_to_stck]
            Place le contenu de FAC sur la pile.

            Modifie :
            - DE
$05c2       Préserve HL.            
$05c3       Récupère les deux premiers octets de FAC.
$05c6       Les place sur la pile.
$05c7       Restaure l'adresse de retour.
$05c8       Récupère les deux octets suivants de FAC.
$05cb       Les place sur la pile.
$05cc       Restaure l'adresse de retour.
$05cd       Restaure HL

$05cf       [hl_to_fac]
$05cf       La valeur numérique pointée par HL est extraite dans BCDE.

$05d2       [bcde_to_fac]
            Place BCDE dans FAC.
            
            Préserve HL et BCDE.
$05d2       Échange DE et HL pour préserver HL et récupérer la partie basse du nombre
$05d3       Place la partie basse du nombre dans le début de FAC.
$05d6-$05d7 Charge HL avec BC, la partie haute du nombre et son exposant.
$05d8       Les place dans la seconde partie de FAC.
$05db       Restaure HL et DE.

$05dd       [fac_to_bcde]
            Extrait le contenu de FAC vers BCDE
$05dd       HL pointe vers le début de FAC.

$05e0       [hl_to_bcde]
            %MS_BASIC(LOADFP)
            Charge BCDE avec le nombre pointé par HL.
$05e0-$05e6 Place le contenu de FAC octet par octet dans BCDE
$05e7       [inc_hl]
$05e8       Incrémente une dernière fois HL.

$05e9       [fac_to_hl]
            Copie le contenu FAC vers ce que pointe HL.
$05e9       Fait pointer DE sur FAC

$05ec       [cpy_detohl_4]
            Copie le contenu des 4 premiers octets pointés par DE vers ce que pointe HL.
$05ec       Initialise le compteur de boucle à 4.
$05ee       [cpy_4_loop]
$05ee       Récupère l'octet pointé par DE
$05ef       Le copie vers ce que pointe HL
$05f0       Incrémente DE
$05f1       Incrémente HL
$05f2       Boucle selon le compteur B

$05f5       [ext_sign]
            Extrait le signe de BCDE et FAC et place 1 à la place.
            Sauve le signe de FAC dans l'octet de signe.

            Condition: BCDE est plus petit que FAC.

            Sortie :
            - Bit 7 de A à 1 si les signes de BCDE sont identiques, ou 0 si non.
            - HL pointe sur l'octet de signe
$05f5       Fait pointer HL vers le MSB de FAC
$05f8       Copie MSB vers A
$05f9       Rotation à gauche, ce qui place le btit de signe de FAC dans Carry et dans le bit 0 de A.
$05fa       Met le Carry à 1.
$05fb       Puis rotation à droite. Le MSB à donc son bit de poids fort à 1 et Carry contient le bit de signe initial.
$05fc       Replace le MSB de FAC, avec le 1 implicite de la mantisse explicité.
$05fd       Inverse le Carry (positif devient 1, négatif devient 0)
$05fe       Met le Carry dans le bit 7 de A, par rotation.
$05ff-$0600 Place HL après l'exposant, sur l'octet contenant le signe.
$0601       Place l'octet de signe.
$0602-$0607 Effectue la même opération avec BCE.
$0608       XOR entre les deux bits de signe (celui de BCDE et de FAC). BCDE non opposé, FAC opposé.
            Le bit 7 de A est donc à 1 si les deux nombres étaient de même signe, 0 sinon.

$060a       [cmp_num]
            %MS_BASIC(CMPNUM)
            Compare les nombres BCDE et FAC (-1 si FAC < BCDE, 0 si FAC = BCDE, 1 si FAC > BCDE)
$060a-$060c Si BCDE est nul, revient à calculer le signe de FAC.
$060f-$0612 Place sur la pile l'adresse de retour qui sera donc appelée au prochain RET.
$0613       Prend le signe de FAC.
$0614       Prend le MSB de BCDE (avec son signe)
$0615       Si FAC est nul, termine ici (et donc appelle ret_cmp qui transforme le bit de signe de BCDE en résultat -1/1)
$0616       Fait pointer HL sur le MSB de FAC.
$0619       Combine les deux signes (seul le bit 7 est important ici). Si les deux signes sont identiques, alors le bit 7 est à 0, sinon, il est à 1 et le drapeau M est à 1.
$061a       Remet le MSB de BCDE dans A
$061b       Termine si les signes étaient différents (le résultat est donc fonction du signe de BCDE)
$061c       Les nombres sont de même signe, on appel la comparaison générique.
$061f       Amène le Carry dans le bit 7.
$0620       Le combine avec le bit de signe de BCDE
$0621       Branche sur le calcul du résultat.
$0622       [cmp_fp]
            Compare les nombres flottants BCDE et FAC de même signe.

            Préserve BCDE et FAC.
$0622       HL pointait sur MSB à l'appel, on le décal vers l'octet de signe de FAC
$0623       Charge l'exposant de BCDE dans A.
$0624       Compare les exposants.
$0625       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$0626       HL pointe à nouveau sur MSB
$0627-$0628 Compare les deux MSB.
$0629       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$062a       HL pointe sur l'octet du milieu de FAC
$062b-$062c Compare les deux octets du milieu.
$062d       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$062e       HL pointe sur le LSB de FAC.
$062f-$0630 Compare les deux LSB.
$0631       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$0632       Arrivé ici, les deux nombres sont identiques, on retire de la pile l'adresse de retour vers `cmp_num`
$0633       Puis on retire l'adresse de retour qui branche vers `ret_cmp`.
$0634       Termine la comparaison avec A = 0.

$0635       [fp_to_int]
            %MS_BASIC(FPINT)
            Transforme un nombre flottant en décalant la mantisse jusqu'à ne garder que la partie entière.

            Entrées :
            - A contient l'exposant du nombre.
            - HL pointe sur FAC
$0635-$0638 Initialise B, C, D et E avec l'exposant.
$0639-$063a Si l'exposant est nul, retourne immédiatemet (avec BCDE à zéro par la méme occasion)
$063b       Sauvegarde de HL qui pointe sur FAC
$063c       BCDE prend la valeur de FAC.
$063f       Sortie des signes des nombres et mise en place des 1 de mantisse explicite.
$0642       Effectue à nouveau le XOR présent en fin de `ext_sign` pour retrouver le signe de BCDE (et FAC, qui sont identiques)
$0643       Met l'octet de signe dans H
$0644       Décrémente BCDE si le nombre est négatif.
$0647       Exposant maximal significatif pour un entier ($80 + 24)
$0649       Exposant maximum - exposant du nombre donne le nombre de bits de décalage.
$064a       Effectue le décalage de A bits. Après l'appel, on a donc le nombre sous forme entière 24 bits dans CDE.
$064d       Récupération du signe (en tant que bit de signe normal, non inversé)
$064e       Place le signe dans Carry.
$064f       Si le signe était 1 (donc négatif), appel l'arrondi vers le haut.
$0652       L'exposant de BCDE est mis à 0.
$0654       Si le nombre est négatif, prend son complément à 2.
$0657       Restaure HL

$0659       [dec_bcde]
            Soustrait 1 de BCDE

            Modifie :
            - A
$065d       Continue si la soustraction de 1 de DE nécessite une soustraction de DE.

$0660       [inst_int]
            %CODE,MS_BASIC(INT)
            Fonction BASIC `INT()`.
$0660       Faite pointer HL vers l'exposant de FAC.
$0663       Charge l'exposant dans A.
$0664       Comparaison avec l'exposant maximal intéressant pour une partie décimale ($80 + 24). Au delà, on est assuré que le nombre est un entier.
$0666       Il semble que l'appel par la fonction 'exp' ait besoin du LSB de FAC ???
$0669       Si le nombre est déjà un entier, on retourne immédiatement.
$066a       Prend à nouveau l'exposant.
$066b       Transforme FAC en nombre entier dans CDE.
$066e       Puisque le nombre entier est complètement à droite de la mantisse, l'exposant est à $98. Le nombre se fera normaliser par la suite.
$0670-$0671 Mise sur la pile de l'octet le plus bas du nombre entier résultat (pour 'exp' probablement encore ???)
$0672       Octet de poids fort de l'entier dans A.
$0673       Récupération du signe dans Carry
$0674       Normalisation du nombre.
$0677       Récupération de l'entier sur 8 bits dans A.

$0679       [dim_compute]
            %MS_BASIC(MLDEBC)
            Calcule l'index pour accéder à une entrée d'un tableau.

            La fonction sert aussi pour calculer l'espace nécessaire pour le tableau complet.
            Si l'index est trop grand, provoque une erreur BASIC d'Index hors des limites.

            Entrées :
            - BC contient l'index dans le tableau (ou dimension totale)
            - DE contient la taille d'une entrée pour cette dimension (4 octets pour la première dimension)

            Retour :
            - HL contient le pointeur vers l'emplacement mémoire (ou la taille). C'est BC * DE.
            - DE contient 0
            - BC est conservé
$0679       HL est initialisé à 0. Accumulateur pour la multiplication.
$067c-$067e Si BC == 0, retour immédiat.
$067f       Multiplication sur 16 bits.
$0681       [dim_loop]
$0681       Double HL (décalage vers la gauche)
$0682       Si dépasse la capacité, branche sur une erreur.
$0685-$0687 Double DE
$0688       Pas de Carry signifie que le bit de poids fort était 0, donc pas d'addition.
$068a       Sinon, ajout de BC à HL.
$068b       En cas de dépassement de capacité, branche sur une erreur.
$068e       [dim_no_add]
$068f       Boucle sur A (16 fois, pour les 16 bits)

$0692       [str_to_num]
            %MS_BASIC(ASCTFP)
            Transforme le texte pointé par HL en nombre dans l'accumulateur flottant FAC.

            Entrée :
            - HL pointe sur le buffer contenant la chaine à transformer.

            Sortie :
            - Nombre dans FAC

$0692       %CHAR
            Cas hexa (commence par `&`)
$0694       Branchement vers le décodage hexadécimal.
$0697       %CHAR
            Nombre négatif.
$0699       Sauvegarde des flags de la comparaison avec '-'
$069a       Branche si '-'
$069c       %CHAR
            Nombre positif spécifié
$069e       Branche si '+'
$06a0       Positionne HL un caractère avant dans les autres cas, car chget avance d'un avant la lecture.
$06a1       [skip_sign]
$06a1       Initialise l'exposant de FAC à 0. Effet de bord, A = 0
$06a4       Nombre de chiffres après le point (la virgule) (B = 0)
$06a5       Signe de l'exposant (D = 0)
$06a6       Puissance de 10 (E = 0)
$06a7       Met A à FF
$06a8       Met C à FF, drapeau pour situer le parsing avant ou après le point.
$06a9       [prse_flt_lp]
$06a9       Lecture du caractère suivant
$06aa       Cas d'un chiffre
$06ac-$06ae %CHAR
            Cas du caractère `.`
$06b0-$06b2 %CHAR
            Cas du caractère `e`
$06b4-$06b6 %CHAR
            Cas du caractère pas `E`
$06b8       [case_exp]
$06b8       Lit le caractère suivant.
$06b9       Récupére le signe de l'exposant.
$06bc       [exp_loop]
$06bc       Lecture d'un caractère de l'exposant.
$06bd       C'est un chiffre, on l'ajoute à l'exposant
$06bf       Ce n'est pas un chiffre, on vérifie le signe de l'exposant
$06c0       Saut s'il était positif, on a fini
$06c2-$06c4 S'il était négatif, on inverse la valeur dans E (l'exposant)
$06c5       Le drapeau de passage de point est augmenté pour s'assurer qu'on ne bouclera plus dans le parsing. La chaine est terminée.
$06c6       [case_dot]
$06c6       Le drapeau du passage du point est incrémenté (pour le premier point, passe de FF à 00)
$06c7       Le drapeau vient de passer à 0, on entame donc une nouvelle partie du nombre.
$06c9       [exp_end]
$06c9       Que ce soit avec un deuxième point ou la fin de l'exposant, le parsing du nombre est terminé. Il faut le finaliser. On sauve le pointeur du buffer de texte.
$06ca-$06cb Soustrait le nombre de chiffre après la virgule de l'exposant. A contient donc l'exposant corrigé pour qu'il n'y ait pas de nombre après la virgule.
$06cc       [adj_loop]
$06cc       Si ce nombre est positif, on multiplie le nombre par autant de fois 10.
$06cf       Si ce nombre est positif, on a terminé (le drapeau ici est forcément positif si l'appel précédent a été fait)
$06d2       Met sur la pile le nombre de divisions par 10 à faire.
$06d3       Division par 10 du nombre
$06d6       Récupération de A
$06d7       Que l'on augmente
$06d8       [adjust_loop]
$06d8       Boucle autant de fois que nécessaire.
$06da       Restaure le pointeur vers le buffer de texte.
$06db       Restaure le test de la présence de '-' en début de nombre.
$06dc       S'il y avait un signe négatif, alors on inverse le signe de FAC.
$06df       Récupère le pointeur de buffer de texte dans HL.

$06e1       [adj_x_10]
            Multiplie FAC par 10 et décrémente A (si A est supérieur à 1)
$06e1       Si A était 0, retour immédiat
$06e2       [fac_x_10]
$06e2-$06e7 Multiplie FAC par 10 et décrémente A.

$06e9       [case_digit]
            Traitement d'un chiffre en ASCII dans A pour l'ajouter à FAC.

            B le nombre de chiffres après la virgule
            C est FF avant la virgule, 0 après (ou dans l'exposant)
            D est l'exposant
            E la puissance de 10

            HL pointe sur le buffer de texte

            Carry est à 1 car `chget` a récupéré un chiffre.

$06e9       Sauve l'exposant et la puissance de 10.
$06ea       D prend le caractère ASCII à traiter.
$06eb-$06ed Après la virgule, le compteur de chiffres décimaux est incrémenté (Carry = 1, C = 0)
$06ee-$06f0 Sauvegarde des registres
$06f1       Multiplie FAC par 10.
$06f4       Récupération de la valeur du caractère (depuis DE)
$06f5       %CHAR
            Transformation du chiffre en ASCII vers sa valeur numérique.
$06f7       Ajoute A à FAC
$06fa-$06fc Restaure les registres
$06fd       Continue la lecture.

$06ff       [add_a]
            Ajoute le nombre entier A à FAC
$06ff       Pousse FAC sur la pile
$0702       Monte A dans FAC
$0705       [fp_stk_add]
            MS_BASIC(PADD)
            Ajoute le nombre flottant sur la pile à FAC.

            Appelé a travers la table des priorités
$0705-$0706 Récupère le nombre depuis la pile dans BCDE
$0707       Ajoute BCDE à FAC.

$070a       [add_to_exp]
            %MS_BASIC(EDIGIT)
            Ajoute le caractère ASCII dans A à l'exposant du nombre analysé.

            E la puissance de 10 du nombre analysé.

            HL pointe sur le buffer de texte

            Prend l'exposant actuel E et le multiplie par 10, ajoute le caractère de (HL) et en soustrait '0'
            Puis va chercher un autre chiffre pour l'exposant
$070a       Exposant dans A.
$070b-$070e Multiplie par 10
$070f       Ajoute le caractère pointé
$0710       %CHAR
            Et le transforme en sa valeur numerique.
$0712       Sauve le résultat dans E
$0713       Continue l'analyse de l'exposant.

$0715       [out_in]
            %MS_BASIC(LINEIN)
            Affiche le texte " en " (ou " in ", suivant la langue), suivi du numéro de ligne présent dans HL

            L'affichage se fait via `out_str` et donc dépend du périphérique selectionné.
$0715       Sauve HL
$0716       Pointe vers les messages en français.
$0719       Récupère la langue configurée.
$071c-$071d Branche si c'est zéro (français)
$071f       Sinon pointe vers les messages en anglais.
$0722       [out_in_fr]
$0722       Affiche le message.
$0725       Restaure HL

$0726       [out_number]
            Affiche un nombre contenu dans HL sur le périphérique selectionné.
$0726-$0729 Met sur la pile une adresse de retour vers `sharp_char`.
$072a       Envoie HL (l'argument) vers DE.
$072b       A = 0
$072c       B = $98 ($80 + 24), l'exposant pour nombre entier.
$072e       Monte le nombre dans FAC, préparé avec le nombre entier correspondant à ce qui était dans HL.

$0731       [fout]
            Construit la représentation ASCII contenu de FAC dans le buffer `fbuffr`.
$0731       HL pointe vers le buffer de travail (de 13 caractères de long)
$0734       Sauve le pointeur
$0735       Prend le signe de FAC
$0736       %CHAR
            Place un espace dans le buffer de travail.
$0738       Branche si le nombre est positif.
$073b       %CHAR
            Remplace l'espace par le signe moins.
$073d       [pos_sign]
$073d       Pointe sur le caractère suivant du buffer.
$073e       %CHAR
            Place un '0' dans le buffer.
$0740       Branche si le nombre à afficher est nul.
$0743       Sauve le pointeur de travail
$0744       Branche si FAC est négatif.
$0747       A = 0, le nombre de divisions par 0 qui vont être faites pour ramener la partie entière sur une zone affichable (6 chiffres)
$0748       Sauve AF
$0749       Vérifie si le nombre est inférieur à 999999.
            La suite de la routine cherche quel est le facteur multiplicatif de 10 pour que le nombre soit un entier de 6 chiffres.
            Ceci afin de trouver quelle est la partie significative affichable.
$074c       [six_digit]
$074c-$074f %CODE
            BCDE = 99999.9
$0752       Compare BCDE et FAC
$0755-$0756 Le nombre est plus grand que 99999.9, on a la partie affichable.
$0759       Récupération du compteur
$075a       Multiplication du nombre par 10 (la routine décrémente aussi A)
$075d       Sauvegarde du compteur
$075e       Boucle pour obtenir les 6 chiffres
$0760       [fout_big]
            Appelé lorsque FAC est trop grand pour être affiché en entier.
$0760       Divise FAC par 10
$0763-$0765 Augmente le compteur qui est sur la pile.
$0766       Vérifie à nouveau si le nombre est sous la bourne affichable.
            Ce `call` est une recursion terminale. Lorsque le nombre aura été assez divisé, le dernier `jp (hl)` reviendra à l'instruction suivante.
$0769       [is_in_range]
$0769       Arrivé ici, la partie entière de FAC est sur 6 chiffres.
            Le compteur sur la pile contient l'inverse la puissance de 10 qu'il a fallu appliquer.
            Ajoute 0.5 à FAC pour arrondire.
$076c       Que contient A ???
$076d       Ramène FAC dans un entier dans BCDE
$0770       Remonte BCDE dans FAC
$0773       Initialise des bornes
$0776       Ramène le compteur du nombre de multiplcations/divisions par 10 ayant été faites
$0777       Y ajoute la borne C (6)
$0778       +1
$0779       Branche vers l'ecriture en 'E' si A + 6 + 1 < 0, donc si on a fait 8 multiplications par 10, ou plus (nombre strictement inférieur à 0.01)
$077c       Compare avec 8
$077e       Branche si A + 6 + 1 >= 8, donc si on a fait 1 division ou plus (nombre strictement supérieur à 999999)
$0780       A est à présent égal à l'inverse des puissances de 10 faites + 8.
$0781       Place ce nombre dans B (à la place du $03)
$0782       Place $02 dans A.
$0784       [form_ready]
$0784-$0785 Décrémente A deux fois.
$0786       Restaure le pointeur vers le buffer de travail.
$0787       Sauve AF. S'il n'y a pas besoin de nottation 'E', A est à 0 et Z est à 1.
            Sinon, A contient la valeur de l'exposant.
$0788       Pointe sur le tableau des puissances de 10
$078b       Décrémente B, le nombre de chiffre avant la virgule.
$078c       Branche s'il reste des chiffres à afficher avant la virgule + 1.
$078e       %CHAR
            Sinon, place un point dans le buffer de travail.
$0790       Avance dans le buffer de travail.
$0791       %CHAR
            Prépare un zéro
$0793       Avance dans le buffer de travail.
$0794       [out_digit]
$0794       Décrémente le nombre de chiffres avant la virgule.
$0795       %CHAR
            Place un point dans le buffer de travail.
$0797       S'il n'y a plus de chiffre à afficher sur la partie entière, avance dans le buffer.
$079a-$079c Sauvegarde les registres (B = chiffres avant le point, HL = buffer de travail, DE = table des puissances de 10)
$079d       Ramène FAC vers BCDE
$07a0       Restaure le pointeur vers la table des puissances de 10.
$07a1       %CHAR
            '/' est ('0' - 1)
$07a3       [try_digit]
$07a3       Incrémente B
$07a4       LSB de BCDE
$07a5       Y soustrait le LSB dans la table des puissances
$07a6       Sauve le résutat
$07a7-$07aa Fait de même avec l'octet central (en tenant compte de la retenue)
$07ab-$07ae Puis avec le MSB (en tenant compte de la retenue)
$07af-$07b0 Revient au début de l'entrée courante dans la table des puissances de 10.
$07b1       La soustraction a réussi, on essai une nouvelle fois avec la même puissance de 10.
$07b3       La dernière soustraction a fait passer le nombre dans CDE négatif. On l'annule.
$07b6       L'addition précédente a amené HL sur le dernier octet de la puissance de 10, un octet plus loin pointe vers la puissance de 10 suivante.
$07b7       Le reste du nombre est remonté vers FAC.
$07ba       Le pointeur vers la table de puissances repasse dans DE
$07bb       Récupération du buffer de travail.
$07bc       Placement du chiffre en ASCII dans le buffer de travail.
$07bd       Pointe vers l'emplacement suivante du buffer.
$07be       Restaure le compte de chiffres avant la virgule (B) et total (C)
$07bf       Décrémente le compteur des puissances
$07c0       Boucle s'il en reste.
$07c2       Un chiffre avant la virgule de moins à afficher.
$07c3       Branche La partie avant la virgule est terminée, les 6 chiffres étaient de la partie entière.
$07c5       [strip_0]
$07c5-$07c9 Revient en arrière pour ignorer les '0' à droite de la partie décimale.
$07c7       %CHAR
$07cb       %CHAR
            Vérifie s'il y a un point.
$07cd       Si ce n'est pas le cas, remet la fin du buffer de travail un octet plus loin (conserve le chiffre)
$07d0       [fout_exp]
$07d0       Récupère AF pour savoir s'il y a besoin de la notation 'E'
$07d1       Branche si pas besoin.
$07d3       %CHAR
            Inscrit 'E' dans le buffer
$07d5       Avance dans le buffer.
$07d6       %CHAR
            Inscrit '+' dans le bufer
$07d8       Branche plus loin si l'exposant est positif.
$07db       %CHAR
            Remplace le '+' par un '-'
$07dd-$07de Complémente à 2 le registre A (prend l'opposé de la valeur de l'exposant)
$07df       [exp_pos]
            %CHAR
$07df       Initialise B avec '0' - 1, sur le même principe que précédemment
$07e1       [fout_e_loop]
$07e1       Passe au caractère ASCII suivant.
$07e2       Soustrait 10 de l'exposant
$07e4       Boucle tant que le résultat est positif
$07e6       Annule la dernière soustraction augmenté de $30 ('0' en ASCII), pour préparer l'affichage des unités.
$07e8       Avance dans le bufer de travail.
$07e9       Inscrit les dizaines.
$07ea       [out_zero]
$07ea       Avance dans le buffer de travail.
$07eb       Inscrit les unités
$07ec       Avance dans le buffer de travail.
$07ed       [fout_no_exp]
$07ed       C est nul à ce niveau là, ce qui permet de terminer la chaîne.
$07ee       Restaure HL à l'adresse initiale, c'est-à-dire le début du buffer de travail.

$07f0       [in_range]
            Vérifie que FAC est inférieur ou égal à 999999.
$07f3-$07f6 BCDE = 999999.
$07f6       Compare BCDE et FAC.
$07f9       Prépare le ŕesultat.
$07fa       Récupère l'adresse de retour
$07fb       Branche si le nombre est trop grand
$07fe       `ret` simulé.

$07ff       [fp_half]
$07ff       Contient le nombre `0.5` flottant.
$0806       [powers_5]
$0806       100000
$0809       [powers_4]
$0809       10000
$080c       [powers_3]
$080c       1000
$080f       [powers_2]
$080f       100
$0812       [powers_1]
$0812       10
$0815       [powers_0]
$0815       1
$0818       [neg_fac]
            Stock un appel à l'inversion de signe au prochain `ret` de l'appelant.
$0818       Adresse de la routine qui sera appelée
$081b       Récupère l'adresse de retour dans HL et stock l'adresse de la routine sur la pile.
$081c       `ret` simulé.

$081d       [inst_sqr]
            %CODE,MS_BASIC(SQR)
            Fonction BASIC `SQR()`.

            Calcul la racine carrée de FAC.
$081d       Met FAC sur la pile
$0820-$0823 Mais 0.5 dans FAC. Ce qui prépare à l'exponentiation qui suit.
$0826       [fp_bcde_pow]
            %MS_BASIC(POWER)
            Calcul la puissance FAC du nombre flottant sur la pile.
$0826-$0827 Récupère le nombre sur la pile dans BCDE.
$0828       Prend le signe de FAC (ne s'intéresse qu'aux drapeaux, puisque A est écrasé juste après)
$0829       A prend l'exposant de BCDE.
$082a       Si la puissance est 0, branche vers l'instruction `EXP`. (??? pour donner 1)
$082c       Branche si la puissance est positive.
$082f-$0830 Erreur si on tente de prendre une puissance négative de 0.
$0833       [pos_pow]
$0833-$0834 Si le nombre est nul avec une puissance positive, alors le résultat est zéro, que l'on construit à partir de A mis dans l'exposant de FAC.
$0837-$0838 Sauve le nombre sur la pile.
$0839       MSB de BCDE dans A.
$083a       Garde le bit de signe, met tout le reste à 1.
$083c       Met la puissance dans BCDE
$083f       Branche si le nombre de base est positif
$0842       Sauve le résultat du OR précédent.
$0843       Charge l'exposant de la puissance dans A.
$0846       La compare avec $99 (= $80 + 31)
$0848       Branche si l'exposant de la puissance est 32 ou plus.
$084a       Sinon, dépile le signe de la base
$084b       Et continue le calcul plus loin.
$084d       [big_power]
$084d       Dépile le signe de la base
$084e-$084f Pousse la puissance sur la pile
$0850       Prend la valeur entière de la puissance
$0853-$0854 Récupère la puissance dans BCDE
$0855       Sauve AF, A contient le MSB de la base (pourquoi ???)
$0856       Compare la puissance et sa valeur entière
$0859-$085a Récupère A sans toucher aux drapeaux
$085b       Récupère un drapeau dans A (résultat de la comparaison ???)
$085c       [pos_base]
$085c-$0861 Montre le nombre dans la pile dans FAC
$0864       En fonction de la comparaison, prend l'opposé dans FAC (??? perdu le fil...)
$0867       En fonction de la comparaison, inverse le signe de FAC (??? perdu le fil...)
$086a-$086b Sauve la puissance dans la pile
$086c       Prend le `log` de FAC (la base)
$086f-$0870 Restaure la puissance
$0871       Multiplie FAC et BCDE (log(base) * power)
            Le fait d'enchaîner sur `inst_exp` va donner exp(log(base) * power),
            c'est-à-dire base * exp(power).
            ??? Il faut reprendre quelles sont les calculs, car tel quel, il manque des choses.
$0874       [inst_exp]
            %CODE
            Fonction BASIC `EXP()`

            Retourne l'exponentielle de FAC.
$0874-$0877 BCDE = 1/ln(2)
$087a       Multiplie FAC par 1/ln(2)
$087d       Prend l'exposant de FAC
$0880       Compare avec $80 + 8.
$0882       Branche si plus grand : overflow
$0884       Compare avec $80 - 24
$0886       Branche si plus petit : le résultat est 1.
$0888       Amène FAC sur la pile
$088b       Prend la partie entière de FAC
$088e       Ajoute $81 au LSB en entier. On sait que le nombre entier tient forcément sur 8 bits grâve aux bornes d'exposants précédents.
$0890-$0891 Récupère le nombre en argument.
$0892       Si l'ajout précédent a donné zéro, c'est que l'exposant était $79, on branche sur overflow.
$0894       En on sauve le résultat.
$0895       Soustrait BCDE (l'exposant) de FAC (l'exposant en entier)
$0898       Pointe sur la table utilisée pour l'exponentiation.
$089b       Appelle le calcul du polynome.
$089e       Récupère l'exposant 
$089f       DE = 0
$08a2       C = 0, pour former BCDE avec une mantisse nulle et B l'exposant.
$08a3       Multiplie BCDE et FAC.
$08a6       [exp_too_big]
$08a6       Met FAC sur la pile
$08a9       [exp_big2]
$08a9       Prend l'exposant
$08ac       Test l'exposant
$08ad       Si l'exposant est positive, alors c'est un overflow
$08b0-$08b1 Restaure la pile
$08b2       Le résultat est 0
$08b5       [over_redir]
$08b5       Trampoline vers l'erreur de dépassement de capacité.

$08b8       [fac_to_1]
            Assigne 1 à FAC.
$08b8-$08bb BCDE = 1.0
$08be       Monte BCDE dans FAC.

$08c1       [exptab]
$08c1       Taille de la table utilisée par l'exponentielle.
$08c2       [exptab_0]
$08c2       0.0002074557705782354
$08c6       [exptab_1]
$08c6       0.0012710057199001312
$08ca       [exptab_2]
$08ca       0.00965065136551857
$08ce       [exptab_3]
$08ce       0.055496565997600555
$08d2       [exptab_4]
$08d2       0.2402271330356598
$08d6       [exptab_5]
$08d6       0.6931471824645996
$08da       [exptab_6]
$08da       1.0

$08de       [sum_series]
            %MS_BASIC(SUMSER)
            Prépare la somme polynomiale pour `sin` et `cos`.

            Met le paramètre (FAC) au carré et programme une multiplication par le paramètre à la sortie du calcul du polynome.
$08de       Pousse FAC dans la pile.
$08e1-$08e4 Insère une opération de multiplication 'pile * FAC' au prochain `ret`.
$08e5       Sauve HL
$08e6       Met FAC dans BCDE
$08e9       Met FAC au carré
$08ec       Restaure HL
$08ed       [sum_ser_1]
            Effectue une somme polynomiale.

            Avec 4 coefficients, on a :
            c1.x^4 + c2.x^3 + c3.x + c4
$08ed       Pousse FAC sur la pile.
$08f0       Récupère le nombre de coefficients.
$08f1       Pointe vers le premier coefficient.
$08f2-$08f2 Charge le premier coefficient dans FAC. HL est avancé vers le coefficient suivant.
$08f5       Saute par dessus le `pop af` pour arriver sur le `pop bc`.
$08f6       [sum_ser_lp]
$08f6       Restaure AF.
$08f7-$08f8 Lit BCDE depuis la pile. Contient toujours l'argument initial.
$08f9       Décrémente le nombre de facteurs restants.
$08fa       Retourne si le nombre restant est de 0.
$08fb-$08fc Place BCDE sur la pile.
$08fd-$08fe Sauve les autres registres (HL pointe sur le coefficient suivant de la table, A est le compteur de coefficients).
$08ff       Multiplie BCDE (l'argument) et FAC (l'accumulateur de résultat)
$0902       Retrouve le pointeur sur les coefficients.
$0903       Charge le nombre suivant de la table dans BCDE. HL pointe sur le nombre qui suit.
$0906       Sauve le pointeur sur la table.
$0907       Ajoute le nombre à FAC.
$090a       Restaure le pointeur vers la table.
$090b       Et boucle

$090d       [inst_rnd]
            %CODE
$090e       Pointe vers la seed (pourquoi cette instruction n'est pas dans reseed !!!)
$0911       Si l'argument est négatif, reseed
$0914       Point vers le dernier nombre généré
$0917       Déplacement vers l'accumulateur flottant
$091a       Pointe vers la seed à nouveau
$091d       Retour si l'argument est 0, on renvoit le dernier nombre généré (qui est dans le FAC)
$091e       On ajoute la seed avec le contenu de A (qui est à 1 car le sign est positif)
$091f       ... uniquement les 3 premiers bits (0 à 7)
$0921       Pourquoi ???
$0923       On sauve la seed
$0924       Avance dans la table des coefficients
$0925-$0927 Offset dans la table des coefficients (seed * 4, B étant à zéro)
$0928       On pointe vers la table des coefficients
$0929       Charge le coefficient en tant que FP dans BCDE
$092c       Multiplication du nombre en FAC avec le coefficient
$092f       Prend l'autre seed
$0932       L'incrémente...
$0933       Limite entre 0 et 3
$0935       Prépare B pour l'`adc` (addition avec retenue) qui suit.
$0937       Compare la seed à 1
$0939       Si A était zéro, alors Carry est à 1 et donc A passe à 1.
$093a       On sauve la seed
$093d       4 octets avant rnd_add
$0940-$0942 Index dans la table des additions
$0943       Pointe sur l'entrée de la table
$0944       Addition du contenu de la table avec FAC

$0947       [afterreseed]
$0947       Récupération de FAC dans BCDE
$094a       A récupère le poids faible de la mantisse
$094b       Met le poids fort de la mantisse dans le poids faible
$094c       Modifie des bits de A
$094e       Met le résultat en haut de la mantisse
$094f       HL pointe sur fac_1 (signe résultant). On y met $80 pour positif.
$0951       HL pointe sur l'exposant
$0952       Que l'on récupère dans B (étrange... on avait déjà récupéré dans BCDE)
$0953       On fixe l'exposant à $80 (donc puissance 0)
$0955-$0958 Incrémentation de la troisième seed
$0959       Récupération de sa valeur
$095a       Modulo 171
$095c       Branchement sauf si le modulo passe par zéro
$095e-$0961 Dans ce cas, on bouge un peu la mantisse
$0962       [rnd_cnt]
$0962       Normalisation
$0965-$0968 Copie FAC dans (HL), donc dans le dernier numéro généré.
$096b       [reseed]
            Réinitialisation du générateur aléatoire.
$096c-$096f Place A dans les trois octets du nombre précédemment généré.
$0970       Puis continue avec le prochain nombre généré.
$0972       [rnd_add]
            Table utilisée par le générateur aléatoire.
$0972       environ 4.626181748790259e-08
$0976       [rnd_add_1]
$0976       environ -6.841145960834183e-08
$097a       [rnd_add_2]
$097a       environ 5.723364893128746e-08

$097e       [inst_cos]
            %CODE,MS_BASIC(COS)
            Fonction BASIC `COS()`

            Place le cosinus de FAC dans FAC.
$097e       Pointe vers la valeur PI/2
$0981       Ajoute PI/2 à FAC, car cos(x) = sin(x + pi/2)
$0984       [inst_sin]
            %CODE,MS_BASIC(SIN)
            Fonction BASIC `SIN()`

            Place le sinus de FAC dans FAC.
$0987       Prends l'exposant de FAC.
$0989       Le compare avec $77 ($80 - 9)
$098a       Retourne avec FAC non touché si l'exposant est petit.
            En effet, pour des petits nombres, x est une approximation de sin(x)
$098d       Récupèration du MSB dans A.
$098e       Branche plus loin si c'est un nombre positif
$0991       Comme sin(-a) = -sin(a), on rend le paramètre positif.
$0993       On remote le MSB dans FAC
$0996-$0999 En retour de fonction, `ret` branchera vers la routine qui prendra l'opposée de FAC.
$099a       [sin_pos]
$099a-$099d Presque pi/20... ???
$09a0       ... multiplié au paramètre (l'angle)
$09a3       Le résultat est sauvé sur la pile.
$09a6       Et on prend la valeur entière de FAC.
$09a9-$09aa On récupère le résultat de la multiplication dans BCDE
$09ab       Afin d'en obtenir la partie décimale.
$09ae-$09b1 BCDE = 0.25
$09b4       Comparaison de 0.25 et le résultat dans FAC.
$09b7       Si FAC est inférieur à 0.25, on branche plus loin.
$09ba-$09bd BCDE = -0.25
$09c0       Ajout de -0.25 à FAC
$09c3-$09c6 BCDE = -0.5
$09c9       Ajout de -0.5 à FAC. Pour un total de -.75
$09cc       Récupère le signe de FAC
$09cd       S'il est positif (le nombre entre 0 et 1 était donc supérieur à 0.75), inverse le signe.
$09d0-$09d3 BCDE = 0.25
$09d6       Ajout de 0.25 à FAC
$09d9       Inverse le signe
$09dc       [min_quarter]
$09dc       Prend le MSB de FAC
$09df       Le test
$09e0       Et pousse le résultat dans la pile.
$09e1       S'il est positif, branche plus loin
$09e4       Sinon, inverse le signe.
$09e6       Et remonte la nouvelle valeur dans FAC.
$09e9       [sin_pos_2]
$09e9       Pointe vers la table des coefficients pour le sinus.
$09ec       Calcul du polynome.
$09ef       Récupère le signe du MSB initial.
$09f0       S'il était positif, on s'arrête là.
$09f1-$09f6 Sinon, on inverse le signe.
$09f9       Ici, si l'angle était initialement négatif, un appel à `inv_sign` est effectué.
$09fa       [half_pi]
$09fa       PI/2
$09fe       [quarter]
$09fe       0.25
$0a02       [sintab]
$0a02       Taille de la table pour le sinus
$0a03       [sintab_0]
$0a03       Environ : 39.71091842651367
$0a07       [sintab_1]
$0a07       Environ : -76.57498931884766
$0a0b       [sintab_2]
$0a0b       Environ : 81.60223388671875
$0a0f       [sintab_3]
$0a0f       Environ : -41.341678619384766
$0a13       [sintab_4]
$0a13       Environ : 6.2831854820251465
$0a17       [inst_tan]
            %CODE,MS_BASIC(TAN)
            Fonction BASIC `TAN()`

            Place la tangeante de FAC dans FAC par calcul du sinus, du cosinus, puis de la division du premier par le second.
$0a17       Pousse FAC sur la pile
$0a1a       Calcule le sinus de FAC.
$0a1d-$0a1e Récupèration de l'angle initial dans BCHL
$0a1f       Pousse le sinus sur la pile
$0a22       Echange HL et DE pour reconstituer BCDE
$0a23       Monte BCDE dans FAC
$0a26       Calcule son cosinus.
$0a29       Divise sinus (sur la pile) par cosinus (dans FAC).
$0a2c       [inst_atn]
            %CODE,MS_BASIC(ATN)
            Fonction BASIC `ATN()`

            Place l'arctangeante de FAC dans FAC.
$0a2c       Récupère le signe de FAC
$0a2d-$0a30 Si le nombre est négatif, on prend l'opposé de son signe ainsi que du signe de son exposant (-1/x)
$0a33       Récupère le MSB de FAC
$0a36       Comparaison avec $80 ($80 + 1)
$0a38       Branche si le nombre est inférieur à 1.
$0a3a-$0a3e BCDE = 1
$0a3f       Calcule 1/x
$0a42-$0a45 Après le calcul, `ret` branchera sur une soustration de l'angle par ce que pointera HL
$0a46       [atn_1]
$0a46       Pointe HL sur la table des coefficients pour `atn`.
$0a49       Calcule le polynome.
$0a4c       Fait pointer HL sur pi/2, pour le cas où `ret` branche vers la soustraction.
$0a4f       Retour, ou branchement sur la soustraction.

$0a50       [atantab]
$0a50       Taille de la table pour atan
$0a51       [atantab_0]
$0a51       1/17
$0a55       [atantab_1]
$0a55       -1/15
$0a59       [atantab_2]
$0a59       1/13
$0a5d       [atantab_3]
$0a5d       -1/11
$0a61       [atantab_4]
$0a61       1/9
$0a65       [atantab_5]
$0a65       -1/7
$0a69       [atantab_6]
$0a69       1/5
$0a6d       [atantab_7]
$0a6d       -1/3
$0a71       [atantab_8]
$0a71       1/1

$0a75       [inst_play]
            %CODE,SECTION(gr)
            Commande BASIC `PLAY`

            Joue une séquence de notes dans un langage spécialisé contenu dans la chaîne de caractères en paramètre.

            Comme le rafraichissement de l'écran est désactivé pendant PLAY, une note dans le manuel indique qu'il
            faut provoquer un rafraichissement avant l'appel à PLAY pour être a jour de l'affichage, en appelant
            `DISPLAY`.

            == DEBUT DE SECTION GR (manipulations graphiques et sonores) ==

$0a75       Appel du `hook` de PLAY.
$0a78       Désactivation du rafraichissement.
$0a7c       Lecture de l'expression en paramètre.
$0a7f       Sauve le pointeur.
$0a80       Récupère le pointeur vers le descripteur de chaine résultante.
$0a83       BCDE contient les informations de chaine. BC = pointeur vers les données, E = nombre de caractères.
$0a86       Augmente de 1 le nombre de caractères.

$0a87       [play_impl]
            Joue une séquence sonore

            Entrées :
            - BC = Pointeur vers la séquence ASCII
            - E = taille du buffer
            - Le pointeur vers le texte BASIC a été poussé sur la pile.
$0a87       Vérifie si l'utilisateur demande d'arrêter le programme.
$0a8a       Lecture du caractère suivant de la chaine.
$0a8b       Pointe vers le caractère suivant.
$0a8c       Réduit le nombre de caractères restant.
$0a8d       Branche si le buffer est épuisé.
$0a90       %CHAR
$0a90-$0a92 Branche si le caractère est ','
$0a94       %CHAR
$0a94-$0a96 Branche si le caractère est '|'
$0a98       %CHAR
$0a98-$0a9a Branche si le caractère est ' '
$0a9c       %CHAR
$0a9c-$0a9e Erreur de syntaxe si le caractère est inférieur à 'A'
$0aa1       Passe les caractères en majuscules.
$0aa3       %CHAR
$0aa3-$0aa5 Branche si le caractère est 'O'
$0aa8       %CHAR
$0aa8-$0aaa Branche si le caractère est 'R'
$0aad       %CHAR
$0aad-$0aaf Branche si le caractère est 'T'
$0ab2       %CHAR
$0ab2-$0ab4 Erreur de syntaxe si le caractère est supérieur ou égal à 'H'
$0ab7       %CHAR
            Soustraction par 'A' pour avoir la hauteur de la note.
$0ab9-$0aba hauteur = (A * 2) + 1
$0abb       Sauve la hauteur dans D
$0abc       Lit le caractère suivant.
$0abd       %CHAR
$0abd-$0abf Branche plus loin si ce n'est pas un '+'
$0ac1       Si c'est un '+', incrémente le pointeur vers la chaine de commandes.
$0ac2       Augmente la hauteur de 1
$0ac3       Réduit le nombre de caractères restant.
$0ac4       [not_sharp]
$0ac4       %CHAR
$0ac4-$0ac6 Branche plus loin si le caractère suivant la note n'est pas '-'
$0ac8       Incrémente le pointeur vers la chaine de commandes.
$0ac9       Réduire la hauteur de 1.
$0aca       Réduit le nombre de caractères restant.
$0acb       [not_flat]
            Récupère l'information sur l'octave.
$0ace       Ajoute la note à l'octave.
$0acf       Sauve le résultat dans D.
$0ad0       Récupère le paramètre de longueur de note dans HL
$0ad3       Sauve la valeur sur la pile
$0ad4       DE ayant été préservé, ramène la hauteur de note dans A.
$0ad5       Passe sur les registres alternatifs de BC, DE, HL
$0ad6-$0ad7 DE = hauteur de la note
$0ad9       HL pointe sur la table des sons
$0adc-$0ade Chaque entrée dans la table comprends 3 octets.
$0adf       C prend le premier des octets
$0ae0-$0ae1 B prend le second des octets
$0ae2       Sauve la valeur dans `sonsav_hi`
$0ae6-$0ae7 A prend le troisième octet de l'entrée
$0ae8       Récupère la longueur de la note depuis la pile dans DE
$0ae9       Multiplie la longueur par le troisième paramètre de la note.
$0aec       Met le Carry à zéro, essentiellement.
$0aed-$0aef Divise DE par deux.
$0af1       Met le Carry à zéro.
$0af2-$0af4 Divise DE par deux.
$0af6       Met le Carry à zéro.
$0af7-$0af9 Divise DE par deux.
$0afb       Récupère le `tempo` actuel.
$0afe       Multiplie DE (premier paramètre du son divisé par 8) par A (le tempo). Résultat dans DE.
$0b01       Met le Carry à zéro.
$0b02-$0b04 Divise DE par deux.
$0b06       Met le Carry à zéro.
$0b07-$0b09 Divise DE par deux.
$0b0b       Émet le son.
$0b0e       Boucle vers la prochaine définition de note.

$0b11       [play_exit]
$0b11       Restauration du HL initial, pointeur sur le texte BASIC.
$0b12-$0b16 Provoque un rafraichissement 3 IRQ plus tard.

$0b1b       [octave]
            Décodage de la commande 'O' dans une instruction PLAY, indiquant un changement d'octave.

            Pour cela, décode un nombre entre 1 et 4 inclus, le multiplie par 14 et sauve le résultat dans `tmpsav`.
$0b1b       Lecture du caractère suivant.
$0b1c       Incrémente le pointeur sur le buffer de commandes.
$0b1d       Réduit le nombre de caractères restants.
$0b1e       S'il n'y en a plus, génère une erreur d'argument manquant.
$0b21       %CHAR
$0b26       %CHAR
$0b21-$0b28 Branche sur une erreur de syntaxe si l'argument n'est pas entre '1' et '4'.
$0b2b       %CHAR
            Soustrait '1' à l'argument pour en obtenir sa valeur numérique.
$0b2d-$0b32 Multiplie l'octave par 14.
$0b33       Sauve la valeur d'octave courante.
$0b36       Boucle sur la prochaine commande.

$0b39       [tempo]
            Décodage de la commande 'T' dans une instruction PLAY, indiquant un changement de tempo.

            Pour cela, décode un nombre de 1 à 3 chiffres décimaux, le divise par 4 et y ajoute 1 puis sauve le résultat dans `tmpsav`.
$0b39       Lit le premier caractères du paramètre.
$0b3a       %CHAR
            En soustrait '0' pour obtenir la valeur numérique.
$0b3c       Branche sur une erreur de syntaxe si la valeur est trop basse.
$0b3f-$0b41 Fait de même si la valeur est trop haute (plus de 9)
$0b44       Charge la valeur dans L
$0b45-$0b46 Caractère suivant
$0b47       S'arrête si la chaine de commandes est épuisée.
$0b4a       %CHAR
$0b49-$0b50 Lit le prochain chiffre ou arrête le décodage.
$0b52       Sauvegarde la nouvelle valeur dans H
$0b53-$0b58 Multiplie A par 10
$0b59       Y ajoute le nouveau chiffre.
$0b5a       Met le résultat dans L.
$0b5b-$0b5d Caractère suivant.
$0b5f-$0b66 Lit le prochain chiffre ou arrête le décodage.
$0b68-$0b70 Multiplie à nouveau L par 10 et ajoute le nouveau chiffre.
$0b71-$0b72 Pointe sur le caractère suivant de la chaine de commandes.
$0b73       [tempo_done]
$0b73       La valeur décodée est dans L, elle passe dans A.
$0b74       Passe le Carry à 0.
$0b75       Divise la valeur par 2.
$0b76       Passe le Carry à 0.
$0b77       Divise la valeur par 2.
$0b78       Augmente la valeur de 1
$0b79       Sauve la valeur de tempo calculée.
$0b7c       Boucle sur la prochaine commande.

$0b7f       [play_pause]
            Décodage de la commande 'R' dans une instruction PLAY, indiquant une pause (une respiration).
$0b7f       Décodage de la longueur de la respiration.
$0b82       Sauvegarde de la valeur
$0b83       Échange les registres par les registres secondaires.
$0b84       Récupère la longueur de la note dans DE
$0b85       Charge la valeur du tempo.
$0b88       Multiplie le tempo par la longueur de la respiration.
$0b8b       [pause_lp_1]
$0b8b       Décrémente la longueur de la pause
$0b8c       Initialise un compteur pour la seconde boucle
$0b8e       [pause_lp_2]
$0b8e       Attente
$0b8f       Boucle sur B. 1 + 3 Cycle M par boucle, 4 + 13 États T par boucle. Sauf pour la dernière, 1 + 2 / 4 + 8. Total: 767 Cycles / 3259 États. Environ 814.74 ns
$0b91-$0b93 Boucle si DE n'est pas nul (2 * 4 + 10 États T)
$0b95       Revient sur les registres initiaux.
$0b96       Boucle sur la commande suivante.

$0b99       [note_length]
            Récupere un potentiel nombre décimal de deux chiffres maximum dans le buffer fourni à 'play` et en retourne la valeur dans HL.

            Préserve DE.

$0b99       %NOT_LABEL
            Valeur par défaut de HL
$0b9c       Caractère dans le buffer de commande.
$0b9d       %CHAR
            Soustrait '0'
$0b9f       Retourne immédiatement si inférieur à 0 (et donc, sort avec HL = $0010)
$0ba0       Compare avec 10.
$0ba2       Retourne si le caractère était supérieur à '9'
$0ba3       Charge la première valeur dans L
$0ba4       et H contient 0.
$0ba6       Pointe vers le caractère suivant.
$0ba7       Réduit le nombre de caractères restant.
$0ba8       Si la chaine est épuisée, retourne.
$0baa       %CHAR
$0ba9-$0baf Même traitement pour le nouveau caractère.
$0bb0       Sauve DE
$0bb1       Double HL
$0bb2-$0bb3 Transfert HL dans DE
$0bb4-$0bb6 Multiplie HL par 10.
$0bb7-$0bb8 Charge la valeur des unités dans DE
$0bba       Ajoute HL et DE
$0bbb       Restaure DE
$0bbc       Pointe vers le caractère suivant.
$0bbd       Réduit le nombre de caractères restant.

$0bbf       [sound_data]
            14 notes sur 4 octaves = 56 notes
            56 notes * 3 octets = 168 octets

            Les deux premiers octets de chaque note est sauvé dans `sonsav`, il s'agit des périodes qui forment les deux phases du son.
            Le troisième octet est un facteur multiplicatif pour obtenir la longeur de la note.

$0c6a       [inst_sound]
            %CODE
$0c6a       Appel le `hook` pour l'instruction SOUND.
$0c6d       Récupère le premier paramètre.
$0c70-$0c71 Branche si le premier paramètre n'est pas 0.
$0c73       Sinon, le paramètre est forcé à 1
$0c74       [snd_val_ok]
$0c74       Passage sur les registres alternatifs.
$0c75-$0c76 DE prend la valeur du premier paramètre.
$0c78-$0c79 Période du son = 256 - A
$0c7a       Cette valeur est mise dans C
$0c7b       Bascule sur les registres primaires.
$0c7c       Vérification de la présence d'une virgule
$0c7d       %DATASKIP
$0c7e       Récupère le deuxième paramètre.
$0c81       Bascule sur les registre alternatifs.
$0c82       Multiplie DE (le premier paramètre) par A (le second paramètre)
$0c87       [de_div_16]
$0c85-$0c8c Divise DE par 16
$0c8e       Et l'incrémente.
$0c8f       Bascule sur les registres primaires.
$0c91       %CHAR
$0c90-$0c95 Vérifie la présence du troisième paramètre, optionnel.
            Branche s'il n'existe pas, avec la valeur par défaut A = 0.
$0c97-$0c98 Sinon, récupération dans A du troisième paramètre
$0c9b       [no_cycle]
$0c9b       Bascule sur les registres secondaires.
$0c9c       Sauvegarde du troisième paramètre
$0c9d-$0c9e Première période = période du son + cycle
$0ca1       Récupère le troisième paramètre dans H
$0ca2-$0ca4 Deuxième période = période du son - troisième paramètre

$0ca7       [snd_emit]
            Émet un son

            Entrées :
            - sonsav_hi et sonsav_lo indiquent les périodes des deux phases du son
            - DE contient la durée du son

            [ArticleBeep]
$0ca7       Désactive les interruptions.
$0ca8       [snd_dur_lp]
$0ca8       Boucle sur la durée du son. Pousse HL
$0ca9       Et récupère. Semble être là pour le timing, HL étant écrasé ensuite.
$0caa       Met A à 0
$0cac       Récupère la valeur des deux périodes.
$0caf       [snd_low]
$0caf       Attente de 69 états
$0cb2       Décrémente le nombre de première période.
$0cb3       Boucle tant qu'il est différent de zéro.
$0cb6-$0cb8 Mise à état haut de la sortie son (bit 3 de $af à 1)
$0cba       Décrémente la durée totale du son
$0cbb-$0cbe Attente totale de 58 états.
$0cc1       [snd_high]
$0cc1       Attente de 69 états.
$0cc4       Décrémente la valeur de la seconde période.
$0cc5       Boucle tant que le nombre est différent de zéro.
$0cc8-$0cca Mise à état bas de la sortie son (bit 3 de $af à 1)
$0ccc-$0cce Boucle si DE n'est pas nul.
$0cd1       Réactivate les interruptions
$0cd2       Bascule sur les registres alternatifs.

$0cd4       [de_mul_a]
            Multiplication de DE par A, avec le résultat dans DE.

            Entrées :
            - A, le multiplicateur
            - DE, le registre à multiplier

            Sortie :
            - DE, le résultat de DE multiplié par A
            - HL contient le DE initial multiplié par 256, par effet de bord.

            Préserve :
            - A

            Sortie : HL = DE << 8 (autrement dit, H <- E) ; DE = DE * A ; A inchangé
$0cd4       Multiplication sur 8 bits
$0cd6       Accumulateur à 0
$0cd9       [next_bit]
$0cd9       Rotation à droite avec le bit de poids faible dans Carry
$0cda       Si le bit était 0, pas d'addition à effectuer.
$0cdc       Sinon, ajout de DE dans HL
$0cdd       [dont_add]
$0cdd       Passe le Carry à 0
$0cde-$0ce0 Multiplication de DE par 2 (décalage de DE de 1 vers la gauche)
$0ce2       Traite le bit suivant.
$0ce4       Récupère le résultat dans DE

$0ce6       [wait_69s]
            Attente de 69 states (états T), incluant le `call`.
$0ce6       19 states
$0ce7       19 states
$0ce8       [wait_31s]
$0ce8       4 states
$0ce9       [wait_27s]
$0ce9       10 states (+ `call` 17 states)
$0cea       [some_data]
$0cea       ??? (en code, `dec b`, `reti`)

$0ced       [inst_sete]
            %CODE
            Commandes BASIC `SETET` et `SETEG`

            L'interpréteur branche ici pour la commande `SETE` qui n'est pas une vraie commande.
            La routine se charge de déterminer à partir du caractère suivant de quelle commande il s'agit.

            En effet, les deux commandes sont similaires, on peut considérer que `E` ou `G` est le premier argument
            de la commande.

$0ced-$0cee Récupère dans A le caractère pointé par HL et incrémente HL, pointeur vers le texte BASIC.
$0cef       Paramètre par défaut dans B si la commande est `SETET`
$0cf1       %CHAR
$0cf1-$0cf3 Branche si la commande est `SETET`
$0cf5       Paramètre dans B si la commande est `SETEG`
$0cf7       %CHAR
$0cf7-$0cf9 Si le caractère paramètre n'est pas 'G'. branche vers une erreur de syntaxe.
$0cfc       [setet]
$0cfc       Sauve l'argument B dans la pile (C n'est pas utilisé).
$0cfd       Désactive le rafraichissement de l'écran.
$0d01       Récupère le premier argument sous forme d'octet dans A.
$0d04-$0d06 Ce paramètre doit être au minimum 32, branche vers une erreur si ce n'est pas le cas.
$0d09       Met le bit 7 du paramètre à 1.
$0d0b       Transfert le paramètre dans E
$0d0c       Prépare la commande pour le VDP.
$0d0e       Bascule sur AF alternatif.
$0d0f       Envoie la commande $22 avec le premier paramètre modifié au VDP.
$0d12-$0d13 Récupère puis remet sur la pile l'argument préparé suivant si on est dans `SETET` ou `SETEG`.
$0d14       Inverse le bit 7 de A (ce qui inverse les $c0 et $40)
$0d16-$0d19 Envoie la commande $21 avec la valeur déduite de la commande utilisée. (VDP : R1 = mode)
$0d1c-$0d20 Envoie la commande $20 avec l'argument $03 au VDP (VDP : R0 = 3, c'est-à-dire KRG+Ince)
$0d23       Prépare la commande $24 pour le VDP
$0d25-$0d27 Bascule de registre AF alternatif le temps de récupèrer le premier argument (numéro de caractère) dans E
$0d28       On récupère dans A le numéro de caractère.
$0d29-$0d2b On ne garde du paramètre que les bits de 2 à 7 (dans les bits 0 à 5)
$0d2d-$0d2e Envoie la commande $24 avec comme paramètre ce nombre modifié (VDP : R4 = (caractère >> 2) & $1f)
$0d31       Préparation de la commande $25 pour le VDP
$0d33       Bascule sur AF initial.
$0d34       On garde les 2 bits de poids faible de l'argument.
$0d36       Récupèration du type de commande depuis la pile (dans B)
$0d37-$0d38 Préparation de l'argument pour la commande comme l'union du type de commande (B) et des 2 bits de poids faibles.
$0d39       Envoi de la commande $25 avec cet argument au VDP (VDP : R5 = (A & $03 | mode)
$0d3c-$0d40 Envoi de la commande $20 avec l'argument $34 au VDP (VDP : R0 = OCT Write AP NoInce, écrit R1 en mémoire désignée par R4 R5)
$0d43       Vérifie la présence d'une virgule dans le buffer texte du BASIC.
$0d44       %DATASKIP
$0d45       Vérifie la présence d'un début de chaîne de caractères.
$0d46       %DATASKIP
$0d47       Décrémente le pointeur vers le texte BASIC pour préparer le décodage de la valeur hexadécimale.
$0d48       Il y a 10 valeurs de lignes a décoder.
$0d4a       [set_rd_data]
$0d4a       Récupère une valeur hexadécimale codée en ASCII vers A.
$0d4d       Sauve le compteur de lignes.
$0d4e       8 bits à traiter
$0d50       [invert_byte]
$0d50       Met le bit de poids fort dans Carry
$0d51       Met le Carry dans le bit de poids fort de C avec rotation.
$0d53       Boucle sur les 8 bits
$0d55       Met dans A le résultat, qui est la valeur initiale « mirroir » (le bit 7 est à présent le bit 0)
$0d56       Récupère le compteur de ligne.
$0d57-$0d5a Envoi de la commande $29 avec l'argument de la ligne au VDP (VDP : R1 = A + Execute)
$0d5d       Attent que le VDP soit prêt.
$0d60-$0d62 Envoi de la commande $25 au VDP (VDP : lecture de R5).
$0d64       Lecture de la réponse.
$0d66-$0d6b Envoi de la commande $25 avec l'argument retourné augmenté de 4 (VDP : R5 = R5 + 4)
$0d6e       Boucle sur la lecture de la ligne suivante.
$0d72       %CHAR
$0d70-$0d76 Lecture des guillemets de fin optionnels.
$0d77       [sete_end]
$0d77       Réactivation du rafraichissement de l'écran.

$0d7c       [send_to_vdp]
            Envoi d'une commande au Video Display Processor (EF9345)

            La commande est envoyée sur le port $8F.
            La donnée associée est envoyée sur le port $CF

            Entrée :
            - D est la commande à envoyer
            - E son argument

            Modifie :
            - C

            [ArticleVDP]
$0d7c       Préparation du port de sortie pour la commande
$0d7e       Envoi de la commande
$0d80       Préparation du port de sortie pour la donnée
$0d82       Envoie de la donnée

$0d85       [setext_impl]
            Redéfinition d'un caractère


            Entrées :
            - A[6:0] contient le caractère à changer (sur 7 bits).
            - A[7] contient la nature de la palette (0 == Texte, 1 == Graphique)
            - HL pointe sur le buffer de 10 octets avec les valeurs de caractère.

            Normalement appelé depuis `setext`.

$0d85-$0d8b Si le bit 7 de A est à 0, alors B prend $C0 (mode texte), sinon B prend $40 (mode graphique)
$0d8d       [setext_gr]
$0d8d       Sauve le paramètre B qui vient d'être choisi.
$0d8e       Désactivation du rafraichissement de l'affichage.
$0d92       Bit 7 de A, le caractère à modifier, passe à 1.
$0d94       L'arguement est mis dans E.
$0d95       Préparation de la commande pour le VDP
$0d97       Bascule sur le registre AF alternatif.
$0d98       Envoi la commande $22 au VDP, avec en argument le numéro de caractère modifié (VDP : R2 = caractère).
$0d9b       Récupération de la valeur de B, le choix du mode graphique ou texte, dans A.
$0d9c       Remise du contenu de BC sur la pile.
$0d9d       Inversion du bit 7 de A, ce qui inverse les valeurs $c0 et $40 choisies au début.
$0d9f-$0da2 Envoi la commande $21 au VDP avec le choix texte/graphique (VDP : R1 = mode).
$0da5-$0da9 Envoi al commande $20 au VDP avec l'argument $03 (VDP : R0 = 3, c'est-à-dire KRG+Inc).
$0dac       Prépare la commande $24 pour le VDP
$0dae       Récupération, à travers E, de la valeur de A en entrée de fonction (avec les trois lignes suivantes)
$0daf-$0db1 Bascule de registre AF alternatif le temps de récupèrer le premier argument (numéro de caractère) dans E
$0db2-$0db4 On récupère dans A le numéro de caractère. On ne garde du paramètre que les bits de 2 à 7 (dans les bits 0 à 5)
$0db6-$0db7 Envoie la commande $24 avec comme paramètre ce nombre modifié (VDP : R4 = (caractère >> 2) & $1f).
$0dba       Préparation de la commande $25
$0dbc       Bascule sur AF initial.
$0dbd       On garde les 2 bits de poids faible de l'argument.
$0dbf       Récupèration du type de commande depuis la pile (dans B)
$0dc0       Préparation de l'argument pour la commande comme l'union du type de commande (B) et des 2 bits de poids faibles.
$0dc1-$0dc2 Envoie de la commande $25 avec cet argument au VDP (VDP : R5 = (A & $03) | mode)
$0dc5-$0dc9 Envoi de la commande $20 au VDP avec l'argument $34 (R0 = OCT Write AP NoInc, écrit R1 en mémoire désignée par R4 R5)
$0dcc       10 lignes de pixels à transférer.
$0dce       [setext_read]
$0dce       Récupère la valeur suivante de la redéfinition de caractère.
$0dcf       Pointe HL vers la valeur suivante
$0dd0       Sauve sur la pile le compteur de lignes (B)
$0dd1       Prépare la boucle interne, 8 bits à traiter.
$0dd3       [setext_inv]
$0dd3-$0dd8 Inverse (mirroir) bit à bit la définition lue dans A.
$0dd9       Récupère le compte de lignes dans B
$0dda-$0ddd Envoi de la commande $29 au VDP avec en argument la description « mirroir » (VDP : R1 = A + Execute)
$0de0       Attente que le VDP soit prêt
$0de3-$0de7 Envoi de la commande $25 au VDP pour lecture de donnée. (VDP : lecture de R5).
$0de9-$0dee Envoi de la commande $25 au VDP avec la valeure lue augmentée de 4 (VDP : R5 = R5 + 4).
$0df1       Boucle sur la ligne suivante
$0df3       Réactivation de l'affichage

$0df8       [inst_tx]
            %CODE
            Commande BASIC `TX`.

            Initialise le mode texte.

            Les registres touchés sont les registres en RAM, ils sont pris en compte par les commandes BASIC, pas
            directement envoyés au VDP>
$0df8-$0dfa Sélection des caractères en ROM du VDP.
$0dfd       [char_switch]
$0dfd       Sauvegarde la valeur de A, qui contient le paramètre mis par les différentes routines pour `TX`, `ET` , `GR`, `EG` (1 pour graphique, 0 pour texte)
$0dfe       Mis à 1 les 3 bits de poids faibles, ce qui signifie que la couleur d'affichage est b111.
$0e00       Place la valeur dans le registre `attcar`.
$0e03       Récupère la valeur de A initiale et les drapeaux lors de l'appel de la routine.
$0e04       Si Z était à 1, cela signifie qu'il n'y avait pas de paramètre (vérifier ???). Retour immédiat.
$0e05       Récupère le premier paramètre dans A, entier 8 bits qui contient la couleur d'écriture sur 3 bits.
$0e08       Sauve la valeur
$0e09       N'en garde que les 3 bits de poids faible.
$0e0b       Sauve la valeur dans D.
$0e0c       Prend la valeur du registre `attcar`.
$0e0f       En garde les 5 bits de poids forts.
$0e11       Fait l'union avec la valeur du paramètre.
$0e12       Replace la nouvelle valeur dans `attcar`.
$0e15       Restaure la valeur des drapeaux après `getbyt_impl`. Z est à 1 si on était en fin de ligne.
$0e16       Dans ce cas, retour immédiat.
$0e17       Sinon, il doit y avoir une virgule.
$0e18       %DATASKIP
$0e19       Récupère le second paramètre dans A, entier 8 bits qui contient l'état des caractères sur 3 bits
            pour le texte, ou bien la couleur du fond pour le mode graphique.
$0e1c       Sauve la valeur et les drapeaux.
$0e1d-$0e22 Garde les 3 bits de poids faible et les déplace de 4 bits vers la gauche.
$0e23-$0e26 Met à jour `attcar` (double hauteur, double largeur et inverse vidéo / couleur de fond)
$0e29-$0e2a Retour immédiat si la commande est terminée.
$0e2b       Sinon, il doit y avoir une virgule.
$0e2c       %DATASKIP
$0e2d       Récupère le troisième paramètre dans A, entier 8 bits qui contient le clignotement sur 1 bit.
$0e30-$0e31 Retour immédiat si la valeur est 0.
$0e32       Sinon, on passe directement le bit 3 de `attcar` à 1.

$0e37       [inst_gr]
            %CODE
            Commande BASIC `GR`.

            Initialise le mode graphique.

            Utilise la routine générique avec les paramètres :
            - caractères en ROM
            - mode graphique
$0e37       Indique que les caractères sont à prendre en ROM
$0e3b       Sélectionne le mode graphique

$0e40       [inst_et]
            %CODE
            Commande BASIC `ET`.

            Initialise le mode texte étendu (texte spécial).

            Utilise la routine générique avec les paramètres :
            - caractères en RAM
            - mode texte
$0e44       Indique que les caractères sont à prendre en RAM du VDP
$0e40       Sélectionne le mode texte.

$0e49       [inst_eg]
            %CODE
            Commande BASIC `EG`.

            Initialise le mode graphique étendu (graphie spécial).

            Utilise la routine générique avec les paramètres :
            - caractères en RAM
            - mode graphique
$0e49       Indique que les caractères sont à prendre en RAM du VDP
$0e4b       Sélectionne le mode graphique.

$0e51       [inst_init]
            %CODE
            Commande BASIC `INIT`.

            Initialise la couleur de l'écran, et l'efface.

$0e51       Initialise `attcar` à 0 (couleur 0, pas de clignotement, pas de double hauteur/largeur, couleurs non inversées)
$0e55       Sauve le pointeur de texte BASIC.
$0e56       Prépare un paramètre $e6 par défaut pour `attbak`.
$0e58       S'il n'y a pas de paramètre, branche à la fin de la routine.
$0e5a       Restaure le pointeur de texte BASIC.
$0e5b       Lit le premier paramètre (couleur de fond)
$0e5e       Branche si c'était le dernier paramètre.
$0e60       Sauve le résultat
$0e61       Le caractère suivant doit être une virgule
$0e62       %DATASKIP
$0e63       Lecture du second paramètre (couleur de bord)
$0e66       Prend les 3 bits de poids faibles.
$0e68       Les sauve dans B.
$0e69       Prend la valeur actuel du registre `cursor`.
$0e6c       En garde les 5 bits de poids forts.
$0e6e       Union avec le paramètre de couleur de bord.
$0e6f       Sauvegarde de la couleur de fond dans le registre `cursor`.
$0e72       Restaure AF, résultat du premier paramètre.
$0e73       [init_color]
$0e73       Sauve le pointeur de texte BASIC.
$0e74       Garde les 3 bits de poids faible du premier paramètre (couleur de fond)
$0e76       Sauve le résultat dans L
$0e77-$0e7a Décale la couleur de 4 vers la gauche, pour la positionner dans la couleur de fond graphique.
$0e7b       Ajoute la couleur de fond texte.
$0e7c       Le bit 7 de `attbak` doit être à 1. (??? pourquoi ?)
$0e7e       [init_end]
$0e7e       Efface l'écran avec la nouvelle couleur de fond.
$0e81       Restaure le pointer de texte BASIC.

$0e83       [inst_cursor]
            %CODE
            Commandes BASIC `CURSORX` et `CURSORY`

            L'interpréteur branche ici pour la commande `CURSOR` qui n'est pas une vraie commande.
            La routine se charge de déterminer à partir du caractère suivant de quelle commande il s'agit.

            En effet, les deux commandes sont similaires, on peut considérer que `X` ou `Y` est le premier argument
            de la commande.

$0e85       %CHAR
$0e83-$0e87 Branche si le caractère suivant est un 'Y'
$0e89       %CHAR
$0e89-$0e8b Si ce n'est pas 'X' non plus, provoque une erreur de syntaxe.
$0e8e       Récupère l'argument dans A en tant qu'entier sur 8 bits.
$0e91-$0e95 La valeur maximale pour la colonne est 39.
$0e97       [set_curx]
$0e97       Met le numéro de colonne passé en argument dans la variable système.

$0e9b       [cursory]
$0e9b       Récupère l'argument dans A en tant qu'entier sur 8 bits.
$0e9e-$0ea2 La valeur maximale pour la ligne est 24.

$0ea4       [set_cury]
$0ea4       Met le numéro de ligne passé en argument dans la variable système.

$0ea8       [inst_scroll]
            %CODE
            Commande BASIC `SCROLL`

            Cette commande permet le défilement de l'écran.
            Inverse de la commande `PAGE`.
$0ea8-$0ead Met à 0 le bit 7 du registre `picflg`.

$0eb1       [inst_page]
            %CODE
            Commande BASIC `PAGE`

            Cette commande empêche le défilement de l'écran.
            Inverse de la commande `SCROLL`.

$0eb1-$0eb6 Met à 1 le bit 7 du registre `picflg`.

$0eba       [inst_stickx]
            %CODE
            Fonction BASIC `STICKX()`

            Renvoie la valeur gauche (255)/repos (0)/droite (1) des commandes de joystick ou au clavier.

$0eba       Tranforme la valeur dans FAC en entier dans A.
$0ebd       Appelle la routine système.
$0ec0       Branche sur le retour de fonction avec le résultat dans A.

$0ec3       [stkh_impl]
            Vérification de l'axe horizontal pour les déplacements.

            L'axe horizontal est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.
            
            Sortie :
            - A = 0, aucune action selon l'axe horizontal.
            - A = 1, action vers la droite.
            - A = 255, action vers la gauche.

            Modifie :
            - AF, B

            Normalement appelé depuis `stkh`.
$0ec3       Prépare la valeur de retour.
$0ec5       Restreint le paramètre d'entrée entre 0 et 3.
$0ec7       Branche pour le cas 0.
$0ec9-$0eca Branche pour le cas 1.
$0ecc-$0ece Lecture de la flêche vers le gauche du clavier
$0ed0       Branchement si la touche n'était pas appuyée (une touche appuyée est mise à 0)
$0ed2       La touche gauche à été appuyée, B passe à -1/255
$0ed3       [stkv_nol_k]
$0ed3       Lecture de la flêche vers le droite du clavier
$0ed5       Branche vers la partie finale commune.

$0ed7       [stkh_joy0]
$0ed7-$0ed9 Lecture du joystick 0 vers la gauche.
$0edb       Branche si le joystick n'était pas vers la gauche.
$0edd       Le joystick était vers la gauche, B passe à -1/255.
$0ede       [stkh_nol_0]
$0ede       Lecture du joystick 0 vers la droite.
$0ee0       Branche vers la partie finale commune.

$0ee2       [stkh_joy1]
$0ee2-$0ee4 Lecture du joystick 1 vers la gauche.
$0ee6       Branche si le joystick n'était pas vers la gauche.
$0ee8       Le joystick était vers la gauche, B passe à -1/255.
$0ee9       [stkh_nol_1]
$0ee9       Lecture du joystick 1 vers la droite.

$0eeb       [stk_end]
$0eeb       Branche à la fin de la fonction si la détection vers la droite n'a rien donné.
$0eed       Sinon, incrémente B, ce qui ramène B à 0 si les deux directions étaient valides, sinon, l'amène à 1.

$0eee       [stk_exit]
$0eee       Place le résultat dans A.

$0ef0       [inst_sticky]
            %CODE
            Fonction BASIC `STICKY()`

            Renvoie la valeur bas (1)/repos (0)/haut (255) des commandes de joystick ou au clavier.

$0ef0       Tranforme la valeur dans FAC en entier dans A.
$0ef3       Appelle la routine système.
$0ef6       Branche sur le retour de fonction avec le résultat dans A.

$0ef9       [stkv_impl]
            Vérification de l'axe vertical pour les déplacements.

            L'axe vertical est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.
            
            Sortie :
            - A = 0, aucune action selon l'axe vertical.
            - A = 1, action vers le bas.
            - A = 255, action vers le haut.

            Modifie :
            - AF, B

            Normalement appelé depuis `stkv`.

$0ef9       Prépare la valeur de retour.
$0edb       Restreint le paramètre d'entrée entre 0 et 3.
$0edf       Branche pour le cas 0.
$0eff-$0f00 Branche pour le cas 1.
$0f02-$0f04 Lecture de la flêche vers le haut du clavier
$0f06       Branchement si la touche n'était pas appuyée (une touche appuyée est mise à 0)
$0f08       La touche haute à été appuyée, B passe à -1/255
$0f09       [stkv_noup_k]
$0f0b       Lecture de la flêche vers le bas du clavier
$0d0d       Branche vers la partie finale commune.

$0f0f       [stkv_joy0]
$0f0f-$0f11 Lecture du joystick 0 vers la haut.
$0f12       Branche si le joystick n'était pas vers la haut.
$0f15       Le joystick était vers la haut, B passe à -1/255.
$0f16       [stkv_noup_0]
$0f16       Lecture du joystick 0 vers le bas.
$0f18       Branche vers la partie finale commune.

$0f1a       [stkv_joy1]
$0f1a-$0f1c Lecture du joystick 1 vers la haut.
$0f1e       Branche si le joystick n'était pas vers la haut.
$0f20       Le joystick était vers la haut, B passe à -1/255.
$0f21       [stkv_noup_1]
$0f23       Lecture du joystick 1 vers le bas.

$0f25       [inst_action]
            %CODE
            Fonction BASIC `ACTION()`

            Renvoie la valeur du bouton d'action appuyé (1) ou repos (0) des commandes de joystick ou au clavier.

$0f25       Tranforme la valeur dans FAC en entier dans A.
$0f28       Appelle la routine système.
$0f2b       Branche sur le retour de fonction avec le résultat dans A.

$0f2e       [stka_impl]
            Vérification du bouton d'action.

            Le bouton d'action est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. 0 pour le joystick gauche, 1 pour le joystick droit, 2 pour la barre espace du clavier.
            
            Sortie :
            - A = 0, aucune action.
            - A = 1, bouton actif.

            Modifie :
            - AF, B

            Normalement appelé depuis `stka`.

$0ef9       
$0edb       
$0edf       
$0eff-$0f00 
$0f02-$0f04 Lecture de la flêche vers le haut du clavier

$0f2e       Prépare la valeur de retour.
$0f30       Restreint le paramètre d'entrée entre 0 et 3.
$0f32       Branche pour le cas 0.
$0f34-$0f35 Branche pour le cas 1.
$0f38-$0f3a Vérification de l'appuie de la touche ESPACE
$0f3c       Branche vers la partie finale commune.
$0f3e       [stka_joy0]
$0f3e       Vérification de l'appuie sur la bouton action du joystick 0
$0f40       Complément à 1.
$0f41       Masque sur le bits 4 et 5.
$0f43-$0f46 Décalage pour amener le résultat sur les bits 0 et 1
$0f47       Résultat assu dans B (pourquoi ???)

$0f49       [inst_key]
            %CODE
            Fonction BASIC `KEY()`.

            Retourne la valeur ASCII correspondant au caractère de la touche enfoncée.

$0f49       Préserve HL
$0f4a       Scan le clavier
$0f4d       Restaure HL
$0f4e       Essentiellement, met le flag Z à 1 si aucune touche n'a été détectée.
$0f4f       Retour de fonction avec la valeur dans A.

$0f52       [inst_delim]
            %CODE
            Commande BASIC `DELIM`.

            Écrit un délimiteur avec des attributs spécifiques.
            Provoque un rafraichissement de l'écran.

$0f52       Récupère la valeur de `attcar`
$0f55       La sauve sur la pile
$0f56-$0f58 Sauve 0 sur la pile.
$0f59       Prend le premier argument de la commande.
$0f5c       Limité entre 0 et 7 (4 bits de poids faible).
$0f5e       Récupère 0 dans D.
$0f5f       Compare l'argument à 0.
$0f60       Pousse le résultat sur la pile.
$0f61       Vérifie la présence d'une virgule.
$0f62       %DATASKIP
$0f63       Prend le second argument de la commande.
$0f66       Limité entre 0 et 7.
$0f68-$0f6b Décale le résultat de 4 vers la gauche.
$0f6c       Récupère le premier argument dans D
$0f6d       Union des deux arguments (les deux couleurs)
$0f6e       Le bit 7 de `attcar` est toujours 1
$0f70       Place les nouvelles couleurs dans `attcar`.
$0f73       Vérifie la présence d'une virgule.
$0f74       %DATASKIP
$0f75       Prend le troisième argument de la commande.
$0f78       Test le bit 0 de l'argument.
$0f7a       Prépare le résultat si l'argument est 0, $80.
$0f7c       Branche si l'argument est 0 (plus généralement, pair)
$0f7e       Si l'argument est 1 (plus généralement, impair), le résultat est $84
$0f80       [delim_norm]
$0f80       Préserve HL
$0f81       Affiche le délimiteur
$0f84       Restaure HL
$0f85       Récupère la valeur initiale de `attcar`
$0f86       Et la restaure.
$0f89       Demande un rafraichissement de l'écran.

$0f8e       [inst_screen]
            %CODE
            Commence BASIC `SCREEN`

            Contrairement à ce que le manuel indique, l'appel de la commande a un effet, celui
            de forcer un rafraichissement de l'écran.
            
$0f8e-$0f92 Force l'affichage et met le compteur de rafraichissement à 1
$0f96       Attend la prochaine interruption qui provoquera un rafraichissement

$0f98       [inst_display]
            %CODE
            Commande BASIC `DISPLAY`

            Indique la période de rafraichissement de l'écran et provoque un rafraichissement de l'écran à la prochaine
            interruption.
            
$0f9a       Valeur par défaut pour DISPLAY, 32
$0f9a       Branche si DISPLAY a été appelé sans argument.
$0f9c       Récupère l'argument de la commande dans A.
$0f9f       [display_def]
$0f9f       Inscrit la valeur de la période dans le registre `intrat`, utilisé par l'IRQ pour décider de quand rafraichir l'écran.
$0fa2       Branche sur l'inscrution SCREEN, qui provoque un rafraichissement à la prochaine interruption.

$0fa4       [inst_store]
            %CODE
            Commande BASIC `STORE`

            Contrairement à ce que le manuel indique, l'appel de la commande a un effet, celui
            de faire prendre la plus grande période possible pour un rafraichissement d'écran, et de
            retarder le prochain du maximum (256 interruptions).

$0fa4       Met à 0 la période d'affichage qui est la plus grande possible, car le compteur est toujours décrémenté avant de tester s'il est à zéro.
$0fa8       Met le compteur d'interruption actuel à 0.

$0fad       [inst_call]
            %CODE
            Commence BASIC `CALL`

            Évalue l'argument, en prend la partie entière, puis utilise le vecteur `calhk` comme tremplin pour appeler l'adresse obtenue.
$0fad       Evalue l'expression numérique qui suit la commande.
$0fb0       En prend la partie entière dans DE.
$0fb3       $C3 est l'opcode pour `call`.
$0fb5       Place l'opcode dans `calhk`
$0fb8       Place l'adresse à la suite
$0fbc       Branche vers le tremplin.

$0fbf       [str_to_hex]
            Décode une valeur hexadécimale formée par deux caractères ASCII pointés par HL.

            Entrée :
            - HL pointe sur le caractère précédent la première valeur

            Sortie :
            - A contient la valeur

$0fbf       Décode la valeur hexadécimale pointée par HL.
$0fc2       Branche sur une erreur de syntaxe si le décodage a échoué.
$0fc5-$0fc9 Multiplie le résultat par 16 et le place dans C.
$0fca       Décode la seconde valeur hexadécimale.
$0fcd       Branche sur une erreur de syntaxe si le décodage a échoué.
$0fd0       Complète l'octet.

$0fd2       [get_hex]
            Lecture d'un chiffre hexadécimal depuis HL.

            Entrée :
            - HL pointe un octet avant le caractère (la routine l'avance, comme toutes les routines de lecture de caractère)

            Sortie :
            - Carry est à 1 si le caractère n'était pas un chiffre hexadécimal
            - Carry est à 0 si le caractère était un chiffre hexadécimal
            - Dans ce cas, A contient la valeur du chiffre.
            
$0fd2-$0fd3 Acquisition du caractère.
$0fd4       %CHAR
$0fd4-$0fd6 Branche si le caractère est inférieur à '0' en ASCII.
$0fd8       Comparaison avec ':' (juste après '9')
$0fd8       %CHAR
$0fd8-$0fda Branche si le caractère est inférieur à ':', il est entre '0' et '9' inclus.
$0fdc       Si le caractère est alphabétique, il est à présent forcé à sa version majuscule.
$0fde       %CHAR
$0fde-$0fe0 Branche si le caractère est inférieur à 'A' en ASCII
$0fe2       %CHAR
$0fe2-$0fe4 Branche si le caractère est supérieur ou égal à 'G'.
$0fe7       Soustrait $37 à A pour obtenir la valeur ('A' - $37 donne $0A)
$0fe9       [valid_hex]
$0fe9       Si le caractère était entre '0' et '9', ne garde que la partie basse, ce qui transforme le caractère en sa valeur numérique.

$0fec       [invalid_hex]
$0fec       Le caractère n'était pas un chiffre hexadécimal. Le Carry est mis à 1.

$0fee       Padding de fin de section. Ces octets ne sont pas utilisés.

$1000       [start]
            %SECTION(biinit)
            C'est ici que commence l'intialisation complète de la machine.
            La première étape est de recopier le contenu de la ROM dans
            l'espace RAM adressable. Adressable ne signifie pas que de la RAM
            est effectivement branchée. Cela ne pose pas de problème au
            niveau hardware du VG5000 d'envoyer une demande d'écriture.
            
            Le contenu de la mémoire est ensuite lu et comparé à la ROM.
            Tant que c'est identique, c'est qu'il y a quelque chose de branché
            qui répond correctement. Dès que c'est différent, c'est qu'on est
            sorti de la zone de la mémoire inscriptible disponible.
            
            La dernière adresse valide est stockée dans $4895 (`stktop`) et
            dans SP, le registre pointeur de pile (Stack Pointer)
            
            On remarquera que si une ROM répond avec un contenu identique à
            la ROM à une adresse multiple de 16ko, l'initialisation va
            penser que c'est de la RAM accessible.

            == DEBUT DE SECTION BIINIT (BASIC INITIALISATION) ==

$1000       Désactivation de l'IRQ.
$1001-$100a Copie de la ROM en boucle sur toute la mémoire addressable.
$100c-$100d Transfert de HL (qui vaut $c000) vers BC. DE vaut $0000 suite à `ldir`.
$100e       HL pointe sur la première adresse RAM.
$1011       [check_mem]
$1011       Lecture de l'octet pointé par HL
$1012       Comparaison de A et (HL), incrémentation de HL, décrémentation de BC
$1014       DE pointe sur l'octet suivant
$1015       Branche si le deux octets comparés étaient différent.
$1017       Sinon, on boucle selon le compteur BC.

$101a       L'instruction partielle suivante ne sert à rien d'autre qu'à gagner un peu
            d'espace lorsque BC == 0 et que la boucle est terminée.
            Le contenu de A est écrasé un peu plus loin.
$101a       %DATASKIP
$101a       Cet octet semble inutilisé. ???

$101b       [mem_differs]
            Après avoir initialisé le pointeur de pile, la seconde
            étape de l'initialisation consiste à remplir les vecteurs
            utilisateur par des instructions spécifiques. Ces vecteurs, situés
            en RAM, permettent d'intervenir lors de certaines opérations avec
            du code écrit par l'utilisateur et donc de modifier le comportement
            du système.

            [ArticleHooks]

$101b       HL pointe sur la dernière adresse valide.
$101c       SP prend aussi cette valeur
$101d       Ainsi que le registre `stktop`

$1020       A est initialisé avec l'opcode pour `ret`
$1022       HL pointe vers le premier hook, `inthk`
$1025       Sur une longueur amenant jusqu'à `inphk` compris.
$1027       [hk_ini_lop]
$1027       Place un `ret` à l'adresse pointée par HL
$1028       Avance HL
$1029       Boucle sur la longueur de B. Tous les hooks sont initialisés avec des `ret`.
$102b       A est initialisé avec l'opcode pour `jp`
$102d-$1033 Place un `jp` dans les adresse d'exécution des commandes BASIC `LPEN`, `DISK` et `MODEM`.

            Ces adresses sont aussi appelées respectivement `lpnhk`, `dskhk` et `modhk`.

            Ces instructions sont en RAM, ce qui permet de les router initialement vers une routine
            affichant une erreur, puis de les router vers les vraies commandes lorsque le
            périphérique est pris en charge.
$1036       Adresse de la routine affichant une erreur de périphérique non présent.
$1039-$103f Place cette adresse après tous les `jp` des trois instructions précédentes.
$1042-$1048 Étrangement, le hook de l'interruption non masquable, lors du boot, est branchée vers
            une routine qui passe le système en anglais.

$104b       IX prend la valeur $47FA qui est la base de la zone de données graphiques.

            Attention, la valeur de IX doit rester constante. Le système considère que IX
            est en tout temps égal à $47FA et référence certaines variables par index par rapport à IX.

            Si IX doit changer, il faut veiller à désactiver l'IRQ (ou faire en sorte d'en sortir juste
            après le hook `inthk`) et ne rien appeler qui concerne l'affichage sans avoir restauré IX.
            
            Cette troisième phase initialise le processeur graphique EF9345. Pour commencer,
            une séquence est envoyée au périphérique, puis quelques variables en RAM sont
            initialisées.
            
            La séquence, envoyée par `regst`, est détaillée au label correspondant.

$104f       HL pointe sut la séquence à envoyer au VDP.
$1052       Envoie la séquence au VDP.
$1055       Initialisation du registre `intdiv`, compteur d'interruptions à 5.
$1059       Initialisation du registre `intact`, permission de rafraichissement à faux.
$105d       Initialisation du registre `fklock` : utilisation des majuscules à vrai.
$1061       Passage du Z80 en Mode 1.

$1063       Réactivation de l'IRQ.
$1064-$1067 Numéro de départ d'un listing avec la touche HOME (???)
$106a       Initialisation du registre `cursor` (couleur du pourtout et aspect du curseur ???)
$106e       Réinitialisation des paramètres de l'écran
$1071-$107a Recopie une série de valeurs en RAM pour initialiser des registres à partir de `ramlow`.

            Cela comprend entre autre le squelette de la routine de division de nombres flottants ou
            encore les valeurs initiales du générateur de nombres aléatoires.

            Le dernier registre initialisé est `octsav`.

$107c-$107f Envoi 0 sur le port $EF, censé être non utilisé (à vérifier ???) et sur $AF, pour la son/k7.
$1081-$1084 Modification de l'adresse du hook "nmihk" pour brancher vers `test_reset` qui traite le redémarrage utilisateur (Ctrl+Delta)
$1087       Initialise les registres BASIC et l'imprimante.
$108a       Retour à la ligne.
$108d       Marque la fin du buffer de travail du BASIC.
$1090       Initialise le début de la RAM (??? juste avant txttab initial ???)

$1093       Calcul des bornes de pile, memsize et place disponible
$1096       HL pointe deux octets avant SP.
$1097-$109b Branche vers une erreur de mémoire si HL est inférieur à $03e8 (comment serait-ce possible ???)
$109e       DE = -50
$10a1       `memsiz` prend la valeur de HL (deux octets avec `(stktop)`)
$10a4       Soustrait 50 de HL
$10a5       Le haut de la pile `(stktop)` est placé 50 octets avant `memsiz`, pour laisse la place pour les chaînes.
$10a8       Efface et réinitialise les variales internes BASIC.
$10ab       Récupération du haut de la pile
$10ae-$10b1 HL pointe sur `(stktop)` - 17.
$10b2-$10ba Calcul la différence entre le haut de la pile moins 17 et le début de la RAM utilisable.
$10bb       Cette taille disponible est poussée dans la pile.

$10bc       
$10bc       Texte en double hauteur, double largeur.
$10c0-$10cc Affichage du texte de démarrage. "VG5000"
$10cf       Retour en simple hauteur, simple largeur.
$10d3-$10df Affichage du numéro de version.
$10e2       La taille utilisateur disponible est récupérée.
$10e3       Affiche la taille mémoire utilisateur disponible.
$10e6-$10ef Sélectionne le message "octets disponibles" en français ou anglais.
$10f2       [disp_fr]
$10f2       Affiche le message
$10f5       DE contient le marqueur d'extention ROM
$10f8-$10fb Place une adresse de retour sur la pile pour le prochaine `ret z`
$10fc       Initialise le pointeur à 0.
$10ff       %NOT_LABEL
$10ff       Initialise le pas d'avancement du pointeur.
$1102       [no_rom_ext]
$1102-$1103 Ajoute BC ($2000) à HL
$1105-$1107 Retourne si HL est égal à 0, c'est-à-dire quand tous les multiples de $2000 ont été vérifiées.
            Provoquera un retour à $113f.
$1108       Sauve HL
$1109-$110c HL = (HL)
$110d       Compare avec DE, le marqueur indiquant qu'une ROM est présente.
$110e       Restaure HL, pointeur vers les multiples de $2000
$110f       Boucle si une ROM n'a pas été détectée.
$1111-$1112 Un marqueur de ROM a été détecté, HL est positionné deux octets plus loin.
$1113-$1116 HL = (HL)
$1117       Branchement à l'adresse indiquée par la ROM. Un `ret` renverra vers `after_check`.

$1118       [test_reset]
            %CODE
            Gestion de l'interruption non masquable (NMI) via le vecteur `nmihk`.

            Teste si CTRL est appuyé et si oui, effectue un reboot à chaud.

            Plus exactement, pendant le boot, le vecteur est à `jp $0069`, puis à la fin du boot `jp $1118`

            [ArticleNMI]
$1118       Sauve AF
$1119-$111b Vérifie la touche CTRL
$111d       Si appuyé, branche vers le reboot à chaud.
$111f       Sinon, restaure AF.

$1122       [warm_boot]
            Reset à chaud.
$1122       Le haut de la pile pointe vers la fin du buffer de travail BASIC.
$1125-$1126 Sortie son à 0.
$1128       L'entrée des programmes se fait par le clavier (et non par la cassette)
$112b-$112c Mise à 1 du port $10 ???
$112e       Activation de l'IRQ
$112f-$1132 La première ligne avec la touche HOME (???) est 1.
$1135       Initialisation du registre `cursor` (expliquer la valeur ???)
$1139       Initialisation de l'écran
$113c       Initialisation des registres (dont la pile)
$113f       [after_check]
$113f-$1142 Joue la mélodie de démarrage.
$1145       Boucle sur l'invite utilisateur.

$1148       [vg5000_txt]
$1163       [version_txt]
$116d       [start_music]

$1179       [init_ef_seq]
            Séquence d'intialisation de l'EF9345 au démarrage.

            $28,$81 -> Écriture de quelque chose dans le TGS
            $29,$00 -> TGS = 0 (625 lignes, non entrelacé, no-input-resync, output VSync+HSync, Service Row = 0, 40 Char
            $20,$82,$29,$6e -> MAT = $6e (Marge = B+G, Insert Marge, Curseur plein/flash, Curseur affiché, simple hauteur
            $20,$83,$29,$f7 -> PAT = $f7 (Ligne 0 'ON', Bulk haut et bas activé, pas de conceal, Insert mode : Active Area, Flash ON, Format court pour le 40 Char
            $20,$84,$29,$13 -> DOR = $13 (Block G0=3, Block G1=1<<1, Block Q=0<<3)
            $20,$87,$29,$08 -> ROR = $08 (Z=0, Y=8)
            $26,$08,$27,$00,$28,$02 -> R6=$08, R7=$00, KRG sans incrémentation avec MP=$0800 (data R1, R2 = $08, ??)

            ??? mieux détailler la séquence.

$1194       [initvalues]
$119a       [div_subr]
            %CODE
$119a-$11a7 Cette routine fait partie des valeurs montées en RAM au démarrage.
            Elle contient la soustraction du dividende par le diviseur.
            Les valeurs sont injectées à la place des $00 par la routine de
            division.

$11f9       [keybfr_0]
            %SECTION(txtfil)

            == DEBUT DE SECTION TXTFIL (messages textuels) ==
$1201       [keybfr_1]
$1209       [keybfr_2]
$1211       [keybfr_3]
$1219       [keybfr_4]
$1221       [keybfr_5]
$1229       [keybfr_6]
$1231       [keybfr_7]
$1239       [keybfr_s0]
$1241       [keybfr_s1]
$1249       [keybfr_s2]
$1251       [keybfr_s3]
$1259       [keybfr_s4]
$1261       [keybfr_s5]
$1269       [keybfr_s6]
$1271       [keybfr_s7]
$1279       [keysfr_c0]
$1281       [keysfr_c1]
$1289       [keysfr_c2]
$1291       [keysfr_c3]
$1299       [keysfr_c4]
$12a1       [keysfr_c5]
$12a9       [keysfr_c6]
$12b1       [keysfr_c7]
$12b9       [keybeng_0]
$12c1       [keybeng_1]
$12c9       [keybeng_2]
$12d1       [keybeng_3]
$12d9       [keybeng_4]
$12e1       [keybeng_5]
$12e9       [keybeng_6]
$12f1       [keybeng_7]
$12f9       [keybeng_s0]
$1301       [keybeng_s1]
$1309       [keybeng_s2]
$1311       [keybeng_s3]
$1319       [keybeng_s4]
$1321       [keybeng_s5]
$1329       [keybeng_s6]
$1331       [keybeng_s7]
$1339       [keyseng_c0]
$1341       [keyseng_c1]
$1349       [keyseng_c2]
$1351       [keyseng_c3]
$1359       [keyseng_c4]
$1361       [keyseng_c5]
$1369       [keyseng_c6]
$1371       [keyseng_c7]
$1379       [errors_fr]
$13ef       [out_mem_fr]
$153f       [errors_eng]
$159e       [out_mem_eng]
$16c6       [txt_fre_fr]
$16db       [txt_fre_en]
$170f       [txt_igno_fr]
$172d       [txt_igno_en]
$173c       [txt_redo_fr]
$1752       [txt_redo_en]
$1763       [txt_arret]
$176a       [txt_break]
$1771       [txt_in_fr]
$1776       [txt_in_en]
$177b       [txt_foun_en]
$1782       [txt_skip_en]
$1788       [txt_abrt_en]
$17af       [txt_diff_en]
$17e0       [txt_abrt_fr]
$17a4       [txt_bad_en]
$17d1       [txt_foun_fr]
$17d9       [txt_skip_fr]
$1814       [txt_diff_fr]
$1802       [txt_bad_fr]

$1945       [inst_save]
            %CODE,SECTION(bicset)
            Commande BASIC `SAVE`

            Sauvegarde du listing BASIC en ASCII.
            Attention, la routine efface tout le contenu mémoire à la fin.

            == DEBUT DE SECTION BICSET (gestion haut niveau de la cassette) ==
$1945       Lit le paramètre de vitesse et initialise les valeurs correspondantes.
$1948       Récupère les paramètres de lignes de début et fin (optionnels)
$194b       Sauve le pointeur de texte BASIC
$194c       Sauve le premier numéro de ligne de la paire.
$194d       Initialise les paramètres d'enregistrement pour la cassette.
$1950       DE contient le numéro de première ligne à sauver.
$1951-$1954 Place $0000 dans `retadr`, numéro de ligne BASIC à décoder
$1957-$1959 La sortie de caractère se fait sur K7
$195c-$1961 Met $82 en premier octet de la zone des variables qui va servir de buffer de travail.
$1962       Pointe sur l'octet suivant de la zone des variables.
$1963       Met HL dans ($4810 + $10) (`ft` + $10) (adresse de départ dans le descripteur de K7)
$1966       Met $82 dans ($4810 + $14) (`ft` + $14) (premier octet de la somme de contrôle).
$1969       Envoie le listing vers le buffer de travail.
$196c-$196e Envoie $b3 vers le buffer de travail de la k7.
$1971       Récupère le contenu de (ft + $14) (premier octet de la somme de contrôle).
$1974       ???
$1977       ???
$197a       Restaure le pointeur du texte BASIC.
$197b       Réinitialise la mémoire du programme. Le programme est effacé.

$197e       [inst_load]
            %CODE
            Commande BASIC `SAVE`

            Charge un listing qui a été sauvé en ASCII.
            Le listing chargé est mélangé à celui existant.

$197e       Lecture de la paire de ligne à charger.
$1981-$1986 Annule les drapeaux d'erreurs qui auraient pu être levés précédemment.
$1989       Coupe l'insertion vidéo
$198c-$198e Couleur de la marge à 5 (??? préciser quelle est la couleur)
$1991       Calibre la k7 en lisant l'amorce du fichier.
$1994       Branche si interruption ou erreur.
$1996       Lecture de la k7 avec préservation des registres.
$1999       Branche si interruption ou erreur.
$199b       Compare l'octet lu à $82 qui est le marqueur d'une sauvegarde ASCII via `SAVE`.
$199d       Lève le Carry
$199e       Branche si A était différent de $82
$19a0       Enregistre l'octet dans `(low)`
$19a3       Lecture du contenu du fichier ASCII.
$19a6       [load_end]
$19a6       Si Carry à 1, affiche le message d'abandon et boucle sur l'invite du BASIC.
$19a9-$19ad Lecture d'une donné, le dernier octet, en préservant aussi AF. Ce dernier octet n'est pas utilisé et permet de se caller à la fin des données avant d'éteindre le moteur.
$19ae       Extinction de la k7 et restauration de la couleur de marge.
$19b1       Branche plus loin si le chargement s'est bien déroulé.
$19b3-$19c2 Affiche le message Sortie de mémoire dans la bonne langue.
$19bf       [load_nok]
$19c5       [load_ok]
$19c5       Charge la variable des états de k7 
$19c8-$19ca Branche plus loin s'il n'y a aucune erreur inscrite.
$19cc-$19cf Affiche "Mauvais fichier"
$19d2       [load_nerr]
$19d2-$19d5 Affiche le message "Pause..."
$19d8-$19d9 Annule la commande AUTO
$19dc-$19dd Met $ff dans `getflg` indiquant que l'entrée se fait par k7 (???)
$19e0       Revient à l'interpréteur BASIC.

$19e3       [pause_msg]
$19ed       [inst_csave]
$19ed       %CODE,CHAR
$19ed-$19ef Branchement pour "CSAVEM"
$19f1       %CHAR
$19f1-$19f3 Branchement pour "CSAVES"
$19f5-$19f7 Branchement pour "CSAVE*". Comme la multiplication est tokenisé, c'est le numéro du token qui est comparé et non le caractère `*`.
$19f9       %CHAR
$19f9-$19fb Branchement pour "CSAVEX"
$19fd       %CHAR
$19fd-$19ff Branchement pour "CSAVEL"
$1a02       Du coup, ça doit être "CSAVE"
$1a03       [csave_prm]
$1a03       Déplacement au caractère suivant lorsque l'on vient d'un "SAVE" suivi d'un caractère paramètre.
$1a05       %CHAR
            Place un espace dans le type de fichier en cas de "CSAVE" sans caractère paramètre.
$1a07       Met le type de fichier contenu dans A dans le descripteur de type de fichier.
$1a0a       Récupère et initialise le paramètre de vitesse d'écriture.
$1a0d       Récupère et envoie le nom de fichier vers le description de fichier.
$1a10       Initialise le reste de la description de fichier.
$1a13       Sauvegarde HL
$1a14       Calcul le sumcheck et écrit la description de fichier K7.
$1a17       Branche en cas d'erreur ou d'interruption de commande.
$1a19       Écrit le contenu du fichier sur la K7.
$1a1d       [stp_or_abrt]
$1a1d       Sauvegarde HL
$1a1e       [csave_skip]
$1a21       Branche s'il n'y a pas eu d'erreur ni d'interruption de commande.
$1a23-$1a26 Inscrit l'erreur "ABORT" dans la variable `cascom`
$1a28       Pointe sur le message d'erreur en français.
$1a2b-$1a2f Branche si le système est en francais.
$1a31       Sinon pointe vers le message d'erreur en anglais.
$1a34       [print_abort]
$1a34       Écrit le message d'erreur.
$1a37       [csave_ok]
$1a37       Restaure HL le pointeur vers le buffer de texte BASIC.

$1a39       [inst_cload]
            %CODE
$1a39       Compare le caractère paramètre avec le token pour '*'
$1a3b       Sauve le caractère paramètre potention dans la version du descripteur de fichier.
$1a3e       Branche si le caractère n'était pas '*'
$1a40       Si c'était '*', alors avance d'un caractère dans le buffer de texte BASIC.
$1a41       [not_star]
$1a41       Place le caractère paramètre potentiel dans le type de fichier du descripteur de fichier.
$1a44       %CHAR
$1a44-$1a46 Branche pour la commande `CLOADA`, qui charge un programme sans effacer l'existant.
$1a48-$1a4a Branche pour la commande `CLOAD?` qui compare la version sur bande et celle en mémoire.
$1a4c       Les cas `CLOAD` et `CLOAD*`

$1a4d       [cload_a]
$1a4d       Avance d'un octet dans le buffer de texte BASIC.
$1a4e       Efface A

$1a50       [cload_vrfy]
$1a50       Complémente A, ce qui donne $FF, car A est à 0 depuis la soustraction qui a causé le branchement ici.
$1a51       Avance d'un octet dans le buffer de texte BASIC.
$1a52       Ce qui donne A = $FF et Carry à 1 pour `CLOAD?`, A = $00 et Carry à 0 dans les autres cas. (??? non... à vérifier)
$1a54       On pousse sur la pile A ainsi que les drapeaux de la comparaison avec $01 ???
$1a55-$1a5a Efface les erreurs systèmes k7 de la variable `cascom`
$1a5d       Copie le paramètre potentiel nom de fichier dans le descripteur de fichier.
$1a60       Lit le potentiel second paramètre.
$1a63       Éteint la marge de l'écran.

$1a66       [read_file]
$1a66-$1a68 Change la couleur de la marge (??? quelle couleur)
$1a6b       Calibre la vitesse de lecture.
$1a6e       Branche en cas d'erreur ou d'interruption de commande.
$1a70       Lit le début du descripteur de fichier en décalé.
$1a73       Branche en cas d'erreur ou d'interruption de commande.
$1a75       Pointe vers ce qui actuellement contient le nom de fichier chargé depuis la k7, à cause du chargement décalé.
$1a78       Compare le nom de fichier trouvé avec celui dans le descripteur de fichier.
$1a7b       Branche si les deux noms correspondent (comme la correspondance se fait sur le nombre de caractère du paramètre de `CLOAD`, un nom vide est toujours un succès.
$1a7d-$1a86 Charge dans HL l'adresse du texte "Skip: " dans la bonne langue.
$1a89       [out_skip]
$1a89       Affiche le message "Skip: " si l'utilisateur ne l'a pas désactivé.
$1a8c-$1a8e Change la couleur de la marge (??? quelle couleur)
$1a91       Lance une nouvelle calibration
$1a94       Branche en cas d'erreur ou d'interruption de commande.

$1a96       [sync_silenc]
$1a96       Cherche 10 octets à 0 ???

$1a98       [read_zero]
$1a98       Lit un octet depuis la k7
$1a9b       Branche en cas d'erreur ou d'interruption de commande.
$1a9d-$1a9e Boucle si l'octet lu n'est pas 0.
$1aa0       Lit 10 octets nuls.
$1aa2       Lit le fichier suivant.

$1aa4       [file_found]
$1aa4-$1aad Pointe vers le message de fichier trouvé dans la bonne langue.
$1ab0       [out_found]
$1ab0       Affiche le message si l'utilisateur ne l'a pas désactivé.
$1ab3-$1ab5 Change la couleur de la marge (??? quelle couleur)
$1ab8       Premier caractère du descripteur de fichier lu, qui contient donc le type de fichier.
$1abb       %CHAR
$1abb-$1abd Branche si le type n'est pas ' ' (caractère espace)
$1ac2       %CHAR
$1abf-$1ac4 Branche si la commande utilisée est `CLOADA`
$1ac6       Récupère le résultat de la détection d'un `CLOAD?`
$1ac7       Utilise FAC pour sauver A temporairement.
$1aca       Si le Carry est à 1, casse la première chaîne du programme en mémoire.
$1acd       Restaure la valeur de A.
$1ad0       Compare A avec 1...
$1ad2       ... et pousse le résultat dans la pile.
$1ad3       [keep_prog]
$1ad3       Détermine l'adresse mémoire de destination du chargement, dans HL.
$1ad6       Récupère le résultat de la comparaison précédente.
$1ad7       Lecture ou vérification des données depuis la k7.
$1ada       Termine l'opération de chargement.

$1adb       [cload_end]
$1adb       Restaure DE
$1adc       Arrête le moteur k7.
$1adf       Pointe HL vers la variable du contrôle et erreurs de k7.
$1ae2       Branche en cas d'erreur de lecture ou d'interruption de commande.
$1ae4       Branche en cas de mémoire pleine.
$1ae6-$1ae7 Place les drapeaux en fonction du contenu de C (qui contient quoi ???)
$1ae8       Charge le contenu de `cascom` dans A
$1ae9       Branche si C était égal à zéro.
$1aeb-$1aed Branche si `cascom` a signalé une erreur.

$1aef       [ok_clear]
            Affiche le message d'invite "Ok!" et réinitialise le chaînage (???) et les variables.
$1aef-$1af2 Affiche la chaîne "Ok!"

$1af8       [mem_out_k7]
            Indique une erreur de fichier trop grand dans `cascom` et affiche une erreur de dépassement de mémoire (vraiment celui-là ???)
$1af8       Signale l'erreur de fichier trop grand dans `cascom`
$1afa-$1afc Affiche l'erreur "Out of Memory"

$1aff       [abort_n_ok]
            Indique une erreur d'abandon dans `cascom` et affiche l'erreur correspondante dans la bonne langue.
$1aff       Signale l'erreur d'abandon dans `cascom`
$1b01-$1b0d Pointe vers le texte d'erreur dans la bonne langue et branche vers l'affichage de l'erreur avant de boucler dans le moniteur BASIC.

$1b0f       [out_k7_err]
$1b0f       %CHAR

$1b0f-$1b11 Branche si ce n'était pas un cas d'erreur de vérification.
$1b13-$1b1f Prépare l'affichage du message d'erreur de vérification dans la bonne langue.
$1b21       [out_bad_fle]
$1b24       [print_n_ok]
$1b27       Continue vers la boucle BASIC.

$1b2a       [bad_file]
            Charge le message "Mauvais fichier" dans la bonne langue.

            Sortie :
            - HL pointe sur le texte dans la bonne langue.

$1b36       [load_adjust]
            ???

$1b36-$1b38 Branche si l'utilisateur a activé le mode `return if error`.
$1b3a-$1b3c Branche s'il y a une erreur système.

$1b3e       [ret_if_err]
$1b3e       A prend le type de fichier lu.
$1b41       %CHAR
$1b41-$1b43 Branche si le type de fichier lu est `M`.
$1b45       %CHAR
$1b47       Branche si le type de fichier lu n'est pas ` `.
$1b49       Charge `cascom` dans A.
$1b4a-$1b4c Branche s'il y a une erreur signalée.
$1b4e       Construit le chaînage du listing BASIC chargé.
$1b51       À la fin du chaînage, HL pointe à la fin du listing, qui devient donc l'adresse pour les variables, mis dans `(vartab)`.

$1b54       [mem_adjust]
            ???
$1b54       État de l'exécution BASIC
$1b57-$1b58 Branche si `(allflg)` est différent de 0, ce qui signifie que le moniteur BASIC ne doit pas tourner (??? pas sur, ça a l'air de servir comme variable temporaire pendant le chargement)
$1b5a       Pointe vers le buffer de travail.
$1b5d-$1b5f Branche si le premier octet du buffer de travail est nul (mais que contient-il ?)
$1b61       %CHAR
$1b61-$1b63 Branche si le premier octet du buffer de travail est `0`.
$1b65       Branche dans les autres cas (??? lesquels).

$1b67       [run_or_end]
$1b67       Lecture du descripteur de fichier en décalé, donc numéro de ligne de départ (en ASCII)
$1b6a-$1b6c Branche si le premier octet n'est pas nul, il y a un numéro de ligne auquel démarrer.

$1b6e       [end_rd_file]
$1b71       %CHAR
$1b6e-$1b73 Branche si le type de fichier lu est `M` (placement de HL de `(contxt)` et retour).
$1b75       Branche vers le moniteur BASIC.

$1b78       [run_k7_at]
            La routine recopie le numéro de ligne de départ du BASIC et met le système dans un état où l'instruction `RUN` suivi d'un numéro de ligne aurait été entré.

            Entrées :
            - HL pointe vers un buffer temporaire pour y placer l'argument pour `RUN`.
            - DE pointe vers le buffer source contenant le numéro de ligne BASIC.

$1b78       Sauve HL
$1b79       5 octets à copier.
$1b7b       [cp_line_nb]
$1b7b-$1b7f Copie des 5 octets du descripteur de fichier vers le buffer pointé par HL (un buffer temporaire)
$1b81       Restaure HL.
$1b82       [k7_run]
$1b82       Décrémente A pour quelles valeurs ???
$1b83       Branche sur l'instruction RUN.

$1b86       [hl_contxt]
$1b86       HL contient l'adresse dans `(contxt)`, (probablement la variable ou le tableau lu ???)


$1b8a       [get_bauds]
            Récupère le paramètre optionnel de vitesse sur les opérations K7, et place le flag correspondant dans `cascom`.
$1b8a       Replace le pointeur de texte sur le caractère précédent
$1b8b       Afin de récupérer le caractère.
$1b8c       Retourne tout de suite s'il n'y a rien.
$1b8d       %CHAR
$1b8d-$1b8f Retourne s'il n'y a pas une `(`
$1b90       Sinon, récupére le caractère suivant.
$1b91       S'il n'y a rien, c'est une erreur de syntaxe
$1b94       %CHAR
$1b94-$1b96 Saute si le paramètre est 1
$1b98       %CHAR
$1b98-$1b9a Si ce n'est pas 2, c'est un appel illégal.
$1b9d       [valid_bauds]
$1b9d       Met dans D l'argument entre parenthèses (qui est la vitesse d'enregistrement)
$1b9e-$1b9f Si la commande s'arrête là, c'est une erreur de syntaxe.
$1ba2       Vérifie que le caractère suivant est ')' ou c'est aussi une erreur de syntaxe.
            Caractère ')'
$1ba3       %DATASKIP
$1ba4       Sauve HL
$1ba5-$1ba8 Met le flag de vitesse de la cassette à 0 (1200 bauds)
$1baa-$1bab Test le bit de poids faible de l'argument ('1' ou '2' en ASCII, soit $31 ou $32).
$1bad       Saute s'il n'est pas nul, c'est-à-dire si l'argument était '1'.
$1baf       Sinon, passe le flag de vitesse à 1, pour '2400 bauds'
$1bb1       [bauds_keep]
$1bb1       Restaure HL


$1bb3       [buf_to_name]
            Amorce le remplissage du nom de fichier par le contenu pointé par HL.
$1bb3-$1bb4 Le nom de fichier est une chaîne de caractères vide.
$1bb7       Placement sur l'octet précédent du buffer.
$1bb8       Lecture du premier octet.
$1bb9       Retour si la ligne est terminée (pas de nom de fichier en paramètre)

$1bba       [name_to_ft]
            Place le nom de fichier en paramètre d'une commande dans FT.
$1bba       Lit l'expression de alphanumérique. Au retour, DE pointe vers l'adresse de la chaine, et C contient sa longueur.
$1bbd       Sauve le pointer de texte BASIC.
$1bbe       La longueur de la chaine est mise dans B.
$1bbf       6 caractères maximum.
$1bc1       HL pointe vers le nom de fichier du descripteur de fichier.

$1bc4       [cpy_name_lp]
$1bc4-$1bc7 Copie le caractère pointé par DE vers le buffer pointé par HL et incrémente les deux pointeurs.
$1bc8       Décrémente le compter.
$1bc9       Si le compteur tombe à zéro, on sort de la boucle (6 caractères maximum pour le nom de fichier)
$1bcb       Boucle sur la taille de la chaîne, qui s'arrêtera si B est inférieur à 6.
$1bcd       Si on s'est arrêté avant 6 caractères, place un $00 de terminaison de chaîne.
$1bcf       [cp_name_end]
$1bcf       Restaure le pointeur vers le buffer de texte BASIC.

$1bd1       [read_ft]
            Se synchronise sur les 10 premiers octets de l'en-tête, puis charge le descripteur de fichier.

            Ce chargement se fait de manière incomplète et en décalé. Il s'agit en effet de conserver les
            informations déjà présentes dans le descripteur pour identifier le fichier.

$1bd1       En attente de 10 fois l'octet d'en-tête.

$1bd3       [rd_ft_head]
$1bd3       Lit un octet depuis la k7
$1bd6       Retourne en cas de problème ou d'interruption de commande
$1bd7-$1bd9 Boucle tant que $d3 n'est pas lu depuis la k7.
$1bdb       Boucle 10 fois
$1bdd       Charge dans HL l'adresse du premier numéro de ligne dans le descripteur de fichier.
$1be0       Lit $16 (22) octets.

$1be2       [read_ft_pl]
$1be2       Lit un octet depuis la k7.
$1be5       Retourne en cas de problème ou d'interruption de commande
$1be6-$1be7 Remplit le descripteur de fichier avec les octets lus.
$1be8       Boucle sur les 22 octets.

$1beb       [cmp_filenam]
            Compare le nom de fichier du descripteur de fichier avec les 6 premiers caractères pointés par HL.

            La comparaison s'arrête dès la fin du nom du descripteur de fichier.

            Retour:
            - Z à 1 si la le nom dans le descripteur de fichier est indentique au début du nom pointé par HL.
            - Z à 0 sinon.

$1beb       BC pointe vers le nom de fichier du descripteur de fichier.
$1bee       Comparaison de 6 caractères.

$1bf0       [cmp_bytes]
$1bf0-$1bf2 Retour dès que BC pointe vers un octet nul.
$1bf3-$1bf4 Compare les deux octets pointés par BC et HL respectivement.
$1bf5-$1bf6 Avance les deux pointeurs.
$1bf7       Retour si les deux octets sont différents.
$1bf8       Décrémente le compteur de caractères.
$1bf9       Boucle 6 fois.

$1bfc       [out_k7_msg]
            Affiche le message k7 pointé par HL suivi par le nom de fichier lu depuis la k7.

            Si le bit 0 de `cascom` est à 1, n'affiche que le retour chariot, et n'affiche pas le message.

$1bfc-$1bfd Préserve DE et AF
$1bfe-$1c01 Vérifie si l'utilisateur veut supprimer l'affichage des messages k7.
$1c03       Branche si ce n'est pas le cas (bit 0 à 1)
$1c05       Affiche la chaîne pointée par HL.
$1c08       Pointe vers l'actuel nom de fichier chargé depuis la k7.
$1c0b       6 caractères maximum à afficher
$1c0d       [out_filenam]
$1c0d-$1c0f Branche si on a atteint la fin du nom, plus court que 6 caractères.
$1c11       HL pointe un caractère plus loin.
$1c12       Affichage du caractère.
$1c13       Boucle 6 fois maximum.

$1c15       [end_k7_msg]
$1c15       Affiche un retour chariot (même si les messages ne sont pas affichés)
$1c18-$1c1f Provoque un rafraichissement de l'écran, fin que le message soit visible.
$1c20       [skip_k7_msg]
$1c20-$1c21 Restaure AF et DE

$1c23       [mk_chain_k7]
            Construit le chaînage du listing BASIC lu depuis la k7.

            Sortie :
            - HL pointe vers le premier emplacement libre après le listing BASIC.

$1c23       Charge `(txttab)`, le début du programme en BASIC, dans DE
$1c27       [next_line]
$1c27-$1c28 HL = DE
$1c29-$1c2d Retour immédiat à la fin du chaînage du programme BASIC (le pointeur vers la ligne suivante est à 0).

$1c2e       [skip_16b]
$1c2e-$1c2f Passe sur le numéro de ligne.

$1c30       [read_byte]
$1c30       Lit le premier caractère ou token de la ligne BASIC.
$1c31       Et déplace le pointeur de lecture un octet plus loin.
$1c32-$1c34 Branche si le token est le marqueur de nombre sur 16 bits, afin de passer par dessus ces deux octets.
$1c36-$1c37 Branche si le caractère ou le token n'est pas nul.
$1c39       On est arrivé à la fin de la ligne. En échangeant HL et DE, DE contient le pointeur après la fin de ligne, et HL le pointeur sur le début de la ligne.
$1c3a-$1c3c Écrit dans l'adresse de chaînage de la ligne courante l'adresse de la ligne suivante.
$1c3d       Cherche la ligne suivante.

$1c3f       [k7_advance]
$1c3f       Incrémente HL, pointeur vers le texte BASIC.
$1c40       Initialise le compteur B à 3.
$1c42       C'est un patch de la ROM 1.0, branche plus loin (??? vérifier)

$1c45       [init_ft]
            Initialise le descripteur de fichier

            Les champs effacés sont :
            - numéro de version
            - numéro de ligne de départ
            - octet de protection
            - position de checksum (??? vérifier comment est utilisée cette information)

            Les champs initialisés sont :
            - octet de protection avec la valeur de `(allflg)`
            - addresse de départ
            - longueur du fichier

$1c45       Sauve HL
$1c46       HL pointe le numéro de version du descripteur de fichier.
$1c49       A = 0
$1c4a       Efface 9 octets.
$1c4c       [zero_ft]
$1c4c-$1c4d Met l'octet pointé à 0.
$1c4e       Fin de la boucle d'effacement
$1c50       Récupère l'octet de protection actuel.
$1c53       Et le place à sa position dans FT
$1c56       Récupère le type du fichier depuis FT
$1c59       %CHAR
$1c59-$1c5b Branche si le type n'est pas ' '
$1c5d       Traitement du type ' ' (CSAVE simple)
$1c60       Récupération dans HL de (txttab) (début du listing BASIC)
$1c63       Sauve HL contenant `(txttab)` vers DE.
$1c64       Récupération dans HL de (vartab) (début des variables, et aussi fin + 1 du listing BASIC)
$1c67       Préparation de la soustraction en effaçant la Carry
$1c68       Soustraction des deux pointeurs pour avoir la taille de la zone BASIC
$1c6a       [wrt_k7_len]
$1c6a       Écriture de la taille du fichier dans le descripteur de fichier.
$1c6d       Branche vers la récupération optionnelle du numéro de ligne.

$1c6f       [ft_type_4d]
$1c6f       %CHAR
$1c71       Branchement si le type de fichier n'est pas 'M' ($4d).
$1c73       Traitement du type $4d (CSAVEM). Récupération du pointeur de parsing.
$1c74       Vérification de la présence d'une virgule ou erreur de syntaxe
$1c75       %DATASKIP
$1c76       Évaluation du paramètre numérique (S = adresse du premier octet à stocker)
$1c79       Valeur entière dans DE
$1c7c       Placement de l'adresse de départ dans FT+16 (adresse de départ)
$1c80       Vérification de la présence d'une virgule ou erreur de syntaxe
$1c81       %DATASKIP
$1c82       Évaluation du paramètre numérique (T = longueur à stocker)
$1c85       Valeur entière dans DE
$1c88       Sauvegarde du pointeur de parsing
$1c89       Placement de la longueur dans HL
$1c8a       Et branchement sur la suite identique à CSAVE (pour l'écriture de la longueur et le paramètre optionnel I)
$1c8c       [ft_type_53]
            Traitement du type de fichier $53 (sauvegarde de l'écran)
$1c8c       %CHAR
$1c8e       Branchement si le type n'est pas 'S' ($53)
$1c90-$1c93 L'adresse de départ est celle de l'écran
$1c96       %NOT_LABEL
            HL prend la taille de l'écran.
$1c99       [wrt_k7_len2]
$1c99       Place HL dans la taille du fichier du descripteur de fichier.
$1c9c       Termine la commande d'initialisation du descripteur de fichier.

$1c9e       [ft_type_bb]
            Traitement de CSAVE*
$1c9f       Récupère le pointeur de parsing.
$1ca1       Branchement si le type n'est pas $bb (qui est le token de '*')
$1ca3       Récupération des informations de tableau
$1ca6       Sauvegarde du pointeur de parsing
$1ca7       Sauvegarde de l'adresse du tableau dans l'adresse de départ de FT
$1cab       Placement de la longueur (DE) dans HL
$1cac       Mutualisation d'écriture de longueur sans autre paramètre.

$1cae       [ft_type_58]
            Traitement de CSAVEX
$1cae       Lecture de l'expression chaine de caractère
$1cb1       Placement de l'adresse de début de chaîne
$1cb5       Placement de la longueur de la chaîne.

$1cba       [k7_line_prm]
            Récupération du paramètre optionnel de numéro de ligne
$1cba       Récupére le pointeur vers le texte BASIC
$1cbb-$1cbc Lit le caractère pointé.
$1cbd       S'il n'y a pas de paramètre optionnel, on a terminé.
$1cbe       Sinon, il doit y avoir une virgule ou bien c'est une erreur de syntaxe.
$1cbf       %DATASKIP
$1cc0       DE pointe sur le numéro de la première ligne BASIC du descripteur de fichier.
$1cc3       Récupération des 5 prochains octets directement (il n'y a pas de traduction en entier pour ce paramètre, il est sauvé directement en ASCII)
$1cc5       [prm_i_loop]
$1cc5       Sauvegarde du pointeur de parsing
$1cc6       [ft_end]
$1cc6       Récupération du pointeur de parsing
$1cc7       Si on a terminé le parsing, on sort de la fonction
$1cc8       Si le caractère n'était pas un chiffre, c'est une erreur de syntaxe.
$1ccb       Copie du chiffre (en caractère) vers FT
$1ccc       DE pointe sur le caractère suivant dans FT
$1ccd       Lecture du prochain caractère sur la ligne à parser.
$1cce       Il reste des caractères à parser.
$1cd0       La limite de 5 chiffres à été atteinte, on sort.

$1cd1       [cload_prm_2]
            Lecture du second paramètre de `CLOAD`.

            Soit une virgule suivi d'un numéro de ligne.
            Soit un nom de variable (chaîne ou tableau).

            Sorties:
            - A = 0 s'il y a un paramètre numéro de ligne, ou pas de paramètre.
            - A = -1 s'il y a un paramètre de type alphanumérique
            - A = 1 s'il y a un paramètre de type tableau
            - Le numéro de version du descripteur du fichier est égal à A
            - DE contient l'adresse de la variable ou du tableau
            - `(contxt)` contient le pointeur vers le buffer de texte BASIC.


$1cd1-$1cd2 A et C à 0.
$1cd3-$1cd4 Lecture d'un caractère depuis le buffer de texte BASIC.
$1cd5       Fait pointer DE vers `buf`, le buffer temporaire de traitement BASIC.
$1cd8       Y place le caractère lu.
$1cd9       Branche si la chaîne est terminée (pas de paramètre supplémentaire)
$1cdb       %CHAR
$1cdb-$1cdd Branche si le caractère lu n'est pas une virgule (pour les cas où le deuxième argument est un nom de variable)
$1cdf       Lit 5 caractères maximum.

$1ce1       [prm_i_lp2]
$1ce1       Lecture d'un caractère.
$1ce2       Branche si la chaîne est terminée.
$1ce4       Branche vers une erreur de syntaxe si le caractère n'était pas numérique.
$1ce7       Écrit le chiffre vers le descripteur de fichier qui pointe vers le buffer temporaire `buf`
$1ce8       Et avance le pointeur
$1ce9       Boucle selon le compteur B, 5 chiffres maximum.

$1ceb       [prm_end]
$1ceb       Sauve HL, qui pointe sur le buffer de texte BASIC, dans `(contxt)` ???
$1cee-$1cef Met dans la version du descripteur de fichier -1 s'il y a un paramètre alphanumérique, 1 s'il y a un paramètre tableau et 0 sinon.

$1cf3       [r_varname]
$1cf3       Sauve HL, pointeur vers le buffer de texte BASIC, sur la pile.
$1cf4       Et l'incrémente.
$1cf5       Lecture du caractère, qui est le second du paramètre.
$1cf6       %CHAR
$1cf6-$1cf8 Branche si le marqueur de variable alphanumérique est trouvé.
$1cfa-$1cfb Sinon, lit le caractère suivant.
$1cfc       %CHAR
            Et le compare avec le marqueur de variable alphanumérique.
$1cfe       [varname_end]
$1cfe       Restaure le pointeur sur le buffer de texte BASIC initial.
$1cff       Et le sauve à nouveau.
$1d00       Sauvegarde de BC.
$1d01       Branche si un marqueur de variable alphanumérique n'a pas été trouvé. Il s'agit d'un nom de tableau.
$1d03-$1d08 La commande était `CLOAD*`, il s'agit donc d'un tableau alphanumérique.
$1d0a       Il s'agit du nom d'une variable alphanumérique, elle est évaluée, ce qui provoquera le chargement de son adresse dans DE et sa longueur dans BC (avec B à 0)
$1d0d       Restauration de BC.
$1d0e       C est diminué de 1 pour le mettre à $FF.
$1d0f       [pophl_end]
$1d0f       Récupération du pointeur vers le buffer de texte BASIC.
$1d10       Termine la commande.

$1d12       [arry_name]
$1d12       Charge le nom du tableau. Le pointeur sera dans DE.
$1d15       Restauration de BC.
$1d16       Incrémente C pour le mettre à 1.
$1d17       Termine la commande.

$1d19       [load_addres]
            Place dans HL l'adresse à laquelle les données doivent être chargées depuis la K7.

            Sortie :
            - HL pointeur vers la zone de données à écrire.

$1d19       A prend le type de fichier lu depuis la k7
$1d1c       %CHAR
$1d1c-$1d1e Branche s'il est différent d'un espace
$1d23       %CHAR
$1d20-$1d25 C'est un programme en BASIC. Branche si la commande utilisée n'est pas `CLOADA`
$1d27-$1d2b `CLOADA`, le chargement se fera vers deux octets avant `(vartab)`, c'est-à-dire à la suite du programme BASIC actuellement en mémoire.

$1d2d       [txttab_hl]
$1d2d       `CLOAD`, le chargement se fera vers `(txttab)`, c'est-à-dire à la place du programme BASIC actuellement en mémoire.

$1d31       [bin_format]
            %CHAR
$1d31-$1d33 Branche si le type n'est pas `M`
$1d35       Format de 'CSAVEM`, binaire, le chargement se fera vers l'adresse dans `(high)` (??? comment est-elle arrivée là ?)

$1d39       [scr_format]
            %CHAR
$1d39-$1d3b Branche si le type n'est pas `S`
$1d3d       Format de `CSAVES`, le chargement se fera vers le buffer de l'écran.

$1d41       [var_or_ary]
$1d41       Chargement d'une variable ou d'un tableau, HL pointe vers le decripteur de la variable.
$1d44-$1d46 Branche si ce n'est pas le format `CSAVE*`
$1d48-$1d4c Branche si le format dans le descripteur de fichier n'était pas 1, on charge une variable.
$1d4e       Va chercher le tableau à charger.
$1d51       Sauve BC
$1d52       [verify_mem]
$1d52       Sauvegarde HL temporairement dans `(contxt)`
$1d55       Récupération dans HL du nombre d'octets à charger depuis le descripteur de fichier lu.
$1d58       Compare le contenu de `handler` et DE, l'adresse du tableau.
$1d59       BC récupère le nombre d'octets à charger depuis la pile.
$1d5a-$1d5b Retour si Carry est à 1 ou Z est à 1
$1d5c       Restaure HL.
$1d5f       Arrête la K7
$1d62       Branche vers le message d'erreur de dépasement de capacité.

$1d65       [var_format]
$1d65-$1d69 Vérifie que le format de fichier est bien $FF
$1d6b       Lit une expression alphanumérique.
$1d6e       Sauve l'adresse du résultat.
$1d6f       Sauve DE
$1d70       BC dans DE
$1d71       Continue sur le code commun variable et tableau.

$1d73       [wrg_format]
$1d73       Arrête la K7.
$1d76       Branche sur une erreur d'opération illégale.

$1d79       [fetch_dim]
            Récupère le pointeur et la longueur vers un tableau DIM.
            Utilisé par les routines de k7.

            Entrée :
            - HL pointe vers le texte BASIC

            Sorties :
            - DE pointe sur la zone mémoire contenant le descripteur du tableau (???)
            - HL pointe vers le texte BASIC avec le descripteur de tableau

$1d79 -$1d7b Mise à 1 de subflg pour demander la recherche d'un tableau
$1d7e       Recherche de la variable
$1d81       "Appel illégal" si le tableau n'a pas été trouvé
$1d84       Remise à 0 de subflg (???)

$1d88       [rd_str_expr]
            Évalue une expression de type chaîne de caractères.

            Entrée :
            - HL pointe vers le texte BASIC

            Sorties :
            - DE pointe vers l'adresse du descripteur de chaîne.
            - C contient la longueur de la chaîne.
$1d88       Évaluation de l'expression
$1d8b       Sauve HL
$1d8c       DE pointe sur l'adresse de la chaine évaluée, C contient la longueur et A le premier caractère. HL pointe sur le deuxième octet de l'adresse de la chaîne dans son decripteur.
$1d8f-$1d91 Recalage de HL pour pointer vers la taille de la chaîne dans son descripteur.
$1d92-$1d94 Taille de la chaîne dans BC.
$1d95       Restauration de HL, pointeur vers le texte BASIC.

$1d97       [sd_char_k7]
            Envoie vers le buffer d'écriture de la k7 un octet ASCII sur 7 bits.
            Utilisé par `SAVE` à travers `outdo` ainsi qu'en direct pour envoyer l'octet de terminaison.

            ??? À vérifier, cela copie des morceaux de (txttab) ???

            Entrée :
            - A contient le caractère à écrire. Seuls les 7 bits de poids faible sont pris en compte.
            - (ft_addr) contient l'adresse de destination pour le caractère.

$1d97       Met le bit de poids fort de A à 1.
$1d99       Sauve HL
$1d9a       HL pointe vers la zone à sauver déclarée dans le descripteur de fichier.
$1d9d       Place l'octet à écrire à cette adresse.
$1d9e       Pointe sur l'octet suivant
$1d9f-$1da1 Branche si l'octet était $83 (marqueur de fin de listing)
$1da3-$1da4 Sélectionne l'écran comme périphérique de sortie.
$1da7       Vérifie la mémoire restante entre HL et la pile.
$1daa-$1dac Sélectionne la k7 comme périphérique de sortie.
$1daf       Sauve DE
$1db0       Récupère l'adresse de la ligne exécutée en BASIC dans DE.
$1db4-$1db6 Branche si la ligne actuellement exécutée en BASIC est 0 (donc, mode direct).
$1db8       Efface les drapeaux pour la soustraction qui suit.
$1db9       HL contient la différence de mémoire entre la ligne exécutée et le buffer de travail pour la sauvegarde.
$1dbb       Sauve cette valeur sur la pile.
$1dbc-$1dbf Place l'adresse de la ligne exécutée en BASIC comme étant la première du listing BASIC.
$1dc2       Place HL (début de listing) dans DE, HL prend la valeur de la ligne exécutée du BASIC.
$1dc3       Récupère la différence calculée dans BC.
$1dc4       Copie un bloc d'octets de (HL) vers (DE) de taille BC.
$1dc6       Sauve DE, l'adresse de destination.
$1dc7       Différence entre les adresses de destination et de source.
$1dc9       Sauve cette différence dans DE.
$1dca       Récupère l'adresse de la zone des variables dans HL (??? qu'est-ce que ça signifie exactement ?)
$1dcd       Soustrait la différence précédente de l'adresse de la zone des variables.
$1dcf       Et déclare cette adresse comme la nouvelle zone des variables.
$1dd2       Récupère dans HL l'adresse de destination.
$1dd3       [sd_direct]
$1dd3       Restaure le DE initial.
$1dd4       [sd_char_end]
$1dd4       Sauve HL dans `(ft_addr)`, pointeur vers le prochain caractère à traiter.
$1dd7       Se replace sur le dernier caractère ayant été traité.
$1dd8-$1ddd Met à jour la somme de controle par XOR successifs des octets écrits.
$1dde       Restaure HL.


$1de0       [save_asc_k7]
            Écrit le buffer initialement rempli par `SAVE` sur la k7.

$1de0       Récupère le pointeur sur la fin de la zone de travail.
$1de3       Y place A, la somme de contrôle.
$1de4       Avance HL, pointeur vers le buffer de travail contenant les données à écrire.
$1de5       Met (vartab) dans DE
$1de9       Met A à 0, mais surtout passe le Carry à 0.
$1dea       Différence entre HL, pointeur vers la fin du buffer de travail, et DE, le début.
$1dec       Ce qui donne la taille du buffer, que l'on pousse sur la pile.
$1ded       A = $FF pour le paramètre de l'appel suivant.
$1dee       Démarre la k7 et envoie l'entête de synchronisation.
$1df1       Récupère la taille du buffer.
$1df2       Retour en cas d'erreur.
$1df3       [write_byte]
$1df3       Lecture d'un caractère du buffer dans A.
$1df4       Pointe dans le buffer un octet plus loin.
$1df5       Décrémente la taille du buffer restante.
$1df6       Écrit l'octet sur la k7
$1df9       Retour en cas d'erreur.
$1dfa-$1dfc Boucle s'il reste des octets à envoyer.
$1dfe       A = $FF
$1dff       Envoie le signal de synchronisation de fin.

$1e02       [load_ascii]
            Charge depuis la k7 un programme en ASCII

$1e02       HL pointe sur le début de la zone des variables.
$1e05-$1e08 Puis 20 caractères plus loin.
$1e09       Enregistre le résultat dans `high`
$1e0c-$1e0d HL dans DE
$1e0e       Pointe DE un octet plus loin. DE pointe sur le début de ligne. HL va avancer pour remplir le buffer.
$1e0f       BC à 0 (B était déjà à 0)
$1e11       [read_part]
$1e11       Dernier octet lu sur 7 bits. Lors de l'écriture, le format ASCII met le bit 7 à 1 sur tous les octets.
$1e13       Placé dans la zone pointée par HL
$1e14-$1e16 Branche si la valeur est 3, marqueur de fin du listing ($83 sur la k7)
$1e18-$1e1d Change la couleur de la marge.
$1e20       Envoi le changement de couleur au VDP (??? juste comme ça ? D'où vient la commande ?)
$1e22-$1e25 Branche s'il n'y a plus de mémoire (Carry est à 0)
$1e27       Sinon pointe un octet plus loin
$1e28       Lit un octet
$1e2b       Retour si interruption ou erreur.
$1e2c       Sauvegarde AF, A contient l'octet lu.
$1e2d-$1e2f Branche si ce n'était pas $8d
$1e31-$1e32 Sauvegarde HL (pointeur du buffer) et DE (début de la ligne) sur la pile
$1e33       Ramène DE, qui pointe vers le début de ligne, dans HL.
$1e34       Décodage d'un numéro de ligne.
$1e37-$1e38 Le résultat, dans DE, est mis dans BC
$1e39       Rétablie la valeure lue de A.
$1e3b       Restaure DE, quite pointe un octet avec le nouveau début de ligne.
$1e3c       [xor_sumchk]
$1e3c-$1e40 Ou exclusif de A avec le caractère pointé dans le buffer pour calculer le sumcheck.
$1e41       Restaure HL
$1e42       Restaure AF
$1e43       Boucle vers la prochaine partie à lire.
$1e45       [vrfy_lines]
$1e45-$1e47 Branche si BC, le numéro de la ligne courante, est 0
$1e49       Préserve HL
$1e4a       A à 0
$1e4b       Charge le dernier numéro de ligne de l'interval.
$1e4e-$1e50 Branche si la ligne est supérieure à la dernière ligne.
$1e52       Charge le premier numéro de ligne de l'interval.
$1e55-$1e59 Branche si le numéro de ligne courant est supérieur au premier numéro de l'interval.
$1e5b       [ignore_line]
$1e5b       Tout ce calcul est pour le moment mysterieux ???
$1e5c       [commit_line]
$1e5c-$1e5d Suivant le chemin d'arrivée, la ligne précédente est avancée au pointeur du buffer (la ligne est donc gardée) ou bien le pointeur actuel et remis en début de ligne (la ligne est donc ignorée, car elle sera écrasée).
$1e5e       BC, le numéro de ligne courant, à 0
$1e61       [pre_sumchk]
$1e61       Restaure AF
$1e62       [end_verify]
$1e62       Préserve AF
$1e63       Préserve HL

$1e66       [keep_line]
$1e66       Restaure HL
$1e67       Échange DE et HL (ligne précédente et pointeur actuel)

$1e6a       [one_more]
$1e6a       Lecture d'un octet
$1e6d       Branche si ni erreur ni interruption.
$1e6f       Interruption ou erreur, retour.

$1e70       [check_sum]
$1e70       Lecture d'un octet
$1e73       Retour si interruption ou erreur
$1e74       Préserve HL
$1e75-$1e78 Soustrait le caractère lu de celui dans `low`
$1e79       Signal une erreur de somme de contrôle si le résultat n'est pas 0.
$1e7c       Restaure HL
$1e7d-$1e80 Branche s'il n'y a plus de mémoire
$1e82       A à 0 et donc Z est levé.

$1e84       [chk_no_mem]
$1e84       Echange DE et HL
$1e85-$1e87 Place $03 dans le caractère pointé par HL (qui est ???)

$1e89       [fetch_next]
            Récupère un octet lu avec `LOAD` depuis l'adresse stockée en `(high)`.
            Provoque le basculement vers le périphérique clavier à la fin du buffer.

            Entrée :
            - L'adresse à lire est dans `(high)`

            Sortie :
            - A contient l'octet lu si ce n'était pas le marqueur de fin. Drapeau Z à 0.
            - A contient 0 si l'octet lu était le marqueur de fin. Drapeau Z à 1.

$1e89-$1e8f A contient le prochain octet lu et l'adresse dans `(high)` est incrémentée.
$1e93-$1e95 Retour si la valeur lue n'est pas le marqueur de fin de listing.
$1e96-$1e97 Replace le périphérique d'entrée sur le clavier
$1e9a       Réinitialise le moniteur après avoir affiché "Ok!"

$1e9d       [k7_1200]
$1e9d       Paramètre K7 pour 1200 bauds

$1ea2       [k7_2400]
$1ea2       Paramètre K7 pour 2400 bauds

$1ea7       [k7_set_prms]
            Remet le flag 'abort' à 0.
            Si le flag de suppression L/H/H n'est pas mis, alors recopie les informations de cycles de la K7 vers les paramètres actuels.
$1ea7-$1eaa Met le flag 'abort' de `cascom` à 0.
$1eac-$1ead Test le flag de supression des informations de vitesse K7
$1eaf       Et sort de la routine s'il est mis
$1eb0-$1eb6 Prépare la copie des 5 octets de paramétrage de la K7
$1eb9-$1ebb Saute si le flag de vitesse de K7 est à 1200 bauds
$1ebd       Sinon, pointe vers les 5 octets suivants pour la vitesse à 2400 bauds.
$1ebe       [k7_params]
$1ebe       Copie les paramètres de vitesse de la K7

$1ec1       [k7_wr_data]
            Calcule le sumcheck des données puis Synchronise la K7, y écrit l'entête (D3) puis le contenu de FT.

$1ec1       Monte les timings en RAM
$1ec4       DE = adresse de démarrage des données
$1ec8       BC = taille des données à écrire
$1ecc-$1ece HL = 0

$1ecf       [k7_sum_lp]
$1ecf       Récupération de l'octet de donnée pointé par DE.
$1ed0-$1ed1 Ajoute la valeur de A à L (L += A)
$1ed2       A = 0, sans toucher aux flags
$1ed4-$1ed5 Ajout de la retenue éventuelle à H. Ce qui donne au final : HL += A
$1ed6       Octet suivant
$1ed7       Et taille diminuée de 1
$1ed8-$1eda Boucle tant que BC est différent de 0, afin de calculer le sumcheck sur l'intégralité des données.
$1edc       Écriture de la somme de contrôle (`sumcheck`) dans le descripteur de fichier.
$1edf       A = $ff
$1ee0       Synchronisation de la K7
$1ee3       Retour en cas d'erreur ou d'interruption de commande.
$1ee4       Compteur à 10.
$1ee6       [k7_head_lp]
$1ee6-$1ee8 Écrit $d3 sur la k7.
$1eeb       Retour en cas d'erreur ou d'interruption de commande.
$1eec       Boucle 10 fois.
$1eee       Compteur à 22 taille du descripteur de fichier.
$1ef0       HL pointe vers le descripteur de fichier.

$1ef3       [k7_ft_lp]
$1ef3       Récupère l'octet courant du descripteur de fichier.
$1ef4       Pointe sur l'octet suivant.
$1ef5       Écrit l'octet sur la k7.
$1ef8       Retour en cas d'erreur ou d'interruption de commande.
$1ef9       Boucle 22 fois.


$1efc       [k7_write_pl]
            Synchronise la K7, y écrit l'entête (D6) puis le contenu des données.
$1efc       A = 0
$1efd       Synchronisation de la k7.
$1f00       Retour en cas d'erreur ou d'interruption de commande.
$1f01       Compteur à 10.

$1f03       [k7_split_lp]
$1f03-$1f05 Écrit $d6 sur la K7.
$1f08       Retour en cas d'erreur ou d'interruption de commande.
$1f09       Boucle 10 fois.
$1f0b       DE = Adresse de démarrage des données.
$1f0f       BC = Taille des données à écrire.
$1f13       [payload_wrt]
$1f13       Récupèration de l'octet de données à écrire.
$1f14       Pointe vers l'octet suivant
$1f15       Décrémente la longueur des données restantes.
$1f16       Écrit l'octet sur la k7.
$1f19       Retour en cas d'erreur ou d'interruption de commande.
$1f1a-$1f1c Continue tant que la taille (BC) restante est non nulle.
$1f1e       Compteur à 10.
$1f20       [zero_wrt]
$1f20-$1f21 Écrit 0 sur la k7.
$1f24       Retour en cas d'erreur ou d'interruption de commande.
$1f25       Boucle 10 fois.

$1f28       [read_contnt]
            Charge les données du fichier sur la K7 vers la zone mémoire pointée par HL.

            (ou vérifie ???)

            Entrée :
            - HL contient l'adresse mémoire où charger les données chargées.
            - A est à 0 si on effectue un chargement, et à $FF si on effectue une vérification de fichier.

$1f28       Sauve HL, l'adresse de destination.
$1f29       Sauve AF, le paramètre de vérification. ???
$1f2a       Calibre la lecture.
$1f2d       Retour (avec nettoyage de la pile) en cas d'erreur ou d'interruption de commande.
$1f30       Charge l'indicateur de protection dans le descripteur de fichier lu (qui est toujours décalé)
$1f33-$1f37 Ajuste la possibilité d'exécuter le moniteur BASIC (si `allflg` est à 1, on ne reviendra pas sur l'invite de commande du BASIC)
$1f38-$1f39 Récupère le paramètre de vérification (???) et l'adresse de destination.
$1f3a       Copie A, le masque de comparaison ou lecture, dans D
$1f3b       [read_ct]
$1f3b       Initialise la lecture de 10 octets d'entete.
$1f3d       [rd_ct_head]
$1f3d       Lecture d'un octet
$1f40       Retour en cas d'erreur ou d'interruption de commande.
$1f41-$1f43 Boucle tant que l'octet lu n'est pas `$d6`
$1f45       Lecture de 10 octets `$d6`
$1f47       Récupération du nombre d'octets à lire depuis la k7 (valeur du descripteur de fichier chargé)
$1f4b       [read_ct_pl]
$1f4b       Lecture d'un octet depuis la k7.
$1f4e       Retour en cas d'erreur ou d'interruption de commande.
$1f4f       Place l'octet lu dans E
$1f50       Sauve HL
$1f51-$1f5b Ajoute la valeur de l'octet lu au calcul du `sumcheck`.
$1f5e       Restaure HL, qui pointe vers la mémoire à remplir
$1f5f       Récupère l'octet qui vient d'être lu
$1f60-$1f62 En faisant la soustraction de l'octet lu et de l'octet présent en mémoire,
            masque par le selecteur de vérification ou chargement, on branche en cas de chargement ou, en cas de vérification, si l'octet
            chargé et l'octet en mémoire sont identiques.
$1f64-$1f69 Sinon, il y a une erreur de vérification, qui est indiqué dans la variable `cascom`.
$1f6c       L'octet ne sera pas écrit en mémoire, et on continue
$1f6d       [byte_ok]
$1f6d       L'octet lu est écrit en mémoire.
$1f6e-$1f76 Changement direct de la couleur de marge.
$1f7b       %CHAR
$1f78-$1f7d Branche si le type de fichier lu n'est pas ' '.
$1f7f       Vérifie qu'il reste de la mémoire.
$1f82       Ou retourne immédiatement dans le cas contraire.

$1f83       [read_ct_cnt]
$1f83       Pointe vers l'octet suivant.
$1f84       Décrémente le nombre d'octets à charger.
$1f85-$1f87 Boucle s'il reste des octets à charger.
$1f89       Récupère dans C le sélecteur de chargement ou vérification.
$1f8a       Sauve HL
$1f8b       Charge la somme de contrôle calculée dans HL.
$1f8e       Charge dans DE la somme de contrôle lue depuis la k7.
$1f92       Compare les deux `sumcheck`.
$1f93       Restaure HL

$1f94       [sumchk_err]
$1f94       Retour si Z est levé.
$1f95-$1f98 Sinon, signal l'erreur de somme de contrôle dans la variable `cascom`
$1f9a       Et passe A à 0.

$1f9c       [check_mem_2]
            Vérifie qu'il reste assez de mémoire.

            Sortie :
            - A à $ff s'il n'y a plus assez de mémoire.
            - Carry est à 1 s'il reste de la place

            Choisir un meilleur label pour ici ou pour l'affiche de `check_mem` ???
$1f9c       Préserve HL
$1f9d-$1fa4 HL = $ffa0 - HL (afin de garder une pile minimale de $60). Mais si on n'a pas 64ko de RAM ???
$1fa5       Branche s'il y a eu retenue, et donc que HL est supérieur à la limie.
$1fa7       On obtient l'adresse de la pile plus la différence entre HL et le haut de la mémoire, afin de placer Carry.
$1fa8       Restaure HL
$1fa9       Retour si la pile augmentée de la place restante dépasse. Il y a encore de la place.
$1faa       Préserve HL (pour être cohérent avant la fin de la routine)
$1fab       [out_of_mem2]
            Choisir un meilleur label pour ici ou pour l'affiche de `out_of_mem` ???
$1fab       Restaure HL
$1fac-$1fad Valeur de retour de A à $ff

$1faf       [k7write_reg]
            Appel l'écriture sur la K7 en préservant les registres.
$1faf-$1fb1 Sauve les registres sur la pile
$1fb2       Appel à l'écriture
$1fb6       [pop_dehlret]
$1fb5-$1fb7 Restauration des registres.

$1fb9       [k7_read_reg]
            Appel la lecture de la K7 en préservant les registres.

$1fb9-$1fbb Sauve les registres sur la pile
$1fbc       Appel à la lecture
$1fbf-$1fc1 Restauration des registres.

$1fc3       [end_k7_marg]
            Arrête la lecture de la k7, y compris le moteur, et restaure la couleur de la marge d'affichage.

$1fc3       Arrête la lecture de la k7
$1fc6-$1fc9 Restaure `cursor`

$1fcd       [margin_off]
$1fcd-$1fd0 Sauvegarde la valeur de `cursor` dans une variable temporaire inutilisé de la multiplication.
$1fd3       Met le bit 6 de `cursor` à 0. Coupe l'affichage du curseur.
$1fd7-$1fdc Force un rafraichissement du VDP.

$1fde       [margin_col]
            Modifie la couleur de la marge de l'écran.

            Commande directe au VDP.

            Envoi au VDP :
            - $28 / $82
            - $29 / `cursor` (MAT) & $f8 | E

            Préciser les commandes $28 et $29 ???
$1fde-$1fe4 Envoi de la commande $28 avec le paramètre $82 au VDP
$1fe6-$1ff0 Envoi de la commande $29 avec la variable `cursor` privée de la partie « couleur de la marge », remplacée par la couleur dans le registre E.

$1ff3       [stka_joy1]
$1ff3       Vérification de l'appuie sur la bouton action du joystick 0
$1ff5       Complément à 1.
$1ff6       Masque sur le bits 4 et 5.
$1ff8-$0ffb Décalage pour amener le résultat sur les bits 0 et 1
$1ffc       Résultat aussi dans B (pourquoi ???)

$1ffe       Padding de fin de section. Indiqués dans le Technical Bulletin comme deux octets libres.

$2000       [instr_table]
            $SECTION(bintrp)

            == DEBUT DE SECTION BINTRP (BASIC INTERPRETER) ==
$2064       [funct_table]
$209d       [prekeywords]
$209e       [keywords]
$21fd       [keywstop]
$21fe       [prio_table]
$2213       [null_str]
$2214       [ok_str]
$2219       [back_stack]
            Appelé par `NEXT`, ???

            Appelé par `RETURN`, dépile tous les blocs `FOR` jusqu'à trouver un bloc différent (probablement `GOSUB`).

            Retour :
            - HL pointe un octet après le début du bloc non `FOR` trouvé.
            - A contient le premier octet du bloc non `FOR` trouvé.

$2219       %NOT_LABEL
$2219-$221c HL = SP + 4, pour passer au-dessus des deux adresses de retour empilées (celle qui correspond au `call` ici, et celle de l'instruction)
$221d       [for_lookup]
            Cherche le bon bloc `FOR` dans la pile.

            Dans cette version du BASIC, il faut absoluement spécifier une adresse.
            Le code qui permet à DE d'être nul, trouvable dans d'autres versions de ce BASIC, n'est pas présent.

            Entrée :
            - DE contient le pointeur vers la variable d'index que l'on cherche.
            - HL pointe dans le pile au niveau d'un bloc `FOR` ou `GOSUB` potentiel.

            Sortie :
            - HL pointe vers le bloc `FOR` correspondant, dans la pile. (??? vers le step ?)
            - Drapeau Z à 1 si le bloc a été trouvé, 0 sinon.
            - BC est à $000d si le bloc a été trouvé.

$221d       Recupère le marqueur du bloc pointé par HL
$221e       Et pointe un octet plus loin.
$221f-$2221 Retourne si le marqueur n'est pas celui de l'instruction `FOR`.
$2222-$2225 BC = adresse de la variable associée pour `FOR`.
$2226       Sauve HL, pointeur vers le bloc `FOR` en cours d'analyse.
$2227-$2228 HL prend l'adresse du compteur pour `FOR`.
$2229       Compare HL avec l'index paramètre dans DE.
$222a       Prépare le déplacement du pointeur dans la pile en cas d'échec de comparaison.
$222d       Récupère le pointeur vers le bloc `FOR` en cours d'analyse, qui pointe sur le signe du `STEP`.
$222e       Retour si l'adresse de l'index recherché correspond.
$222f       Sinon, déplacement du pointeur d'analyse plus loin dans la pile.
            Les débuts de blocs sont séparés de 16 octets, desquels on retranche les 3 octets déjà traités, reste 13.
$2230       Boucle sur la recherche.

$2232       [str_err_dat]
            Copie le numéro de ligne trouvée dans `(datlin)` vers `(curlin)` puis affiche une erreur de syntaxe.

$2238       [stx_err_prt]
            Affiche une erreur "Erreur de syntaxe".

$223b       [divbyzero]
            Affiche une erreur "Division par Zéro".

$223e       [missfor]
            Affiche une erreur "NEXT sans FOR"

$2241       [redim]
            Affiche une erreur "Tableau redimensionné"

$2244       [undeffn]
            Affiche une erreur "Fonction utilisateur non définie"

$2247       [overflow]
            Affiche une erreur "Dépassement de capacité"

$224a       [missing_op]
            Affiche une erreur "Opérande manquante"

$224d       [wrong_op]
            Affiche une erreur "Opérande mal adaptée"

$2250       [no_device]
            %CODE
            Affiche une erreur "Device not supported"
            Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.

$2252       [error_out]
            Affiche un message d'erreur BASIC

            L'erreur est cherchée dans la table des messages correspondant à la langue.
            L'erreur n'est pas récupérable, elle enchaîne sur l'invite de commande BASIC.

            Entrée :
            - E contient le numéro de l'erreur
$2252       Reinitialisation.
$2255       Curseur à la ligne.
$2258       Pointe sur la table des erreurs en français.
$225b-$225f Branche si le système est en français.
$2261       Sinon, pointe vers la table des erreurs en anglais.
$2264       [err_msg_fr]
$2264-$2266 Ajoute 2 à l'erreur et prends le multiple de 2 inférieur
$2268-$226b Branche si E est inférieur à $2b
$226d       Sinon fixe l'erreur à $2a (autrement dit, E est maximum $2a)
$226f       [err_loop]
$226f       Prend l'octet pointé par HL.
$2270       Pointe un octet plus loin.
$2271-$2272 Boucle si l'octet n'est pas à 0.
$2274-$2275 E est décrémenté de 2.
$2276       Boucle tant que E n'est pas tombé à 0.

$2278       [disp_break]
            Lorsqu'arrive directement ici, c'est pour afficher un arrêt d'exécution en ligne (curlin)
            
            MS_BASIC=ERRIN
$2278       Affiche le message d'erreur pointé par HL
$227b       Charge dans HL le numéro de ligne courante.
$227e-$2282 Si le numéro de ligne est 65534, cela provoque un reboot.
$2285-$2288 Branche si le numéro de ligne n'était pas $ffff
$228b       Évite le `pop bc` pour aller directement sur la boucle du moniteur BASIC.

$228c       [nok_loop]
            MS_BASIC=POPNOK
$228c       Enlève l'adresse présent dans la pile avant de continuer vers la boucle du moniteur BASIC.

$228d       [ok_loop]
            Boucle "Ok!" puis entrée dans le moniteur BASIC.
            
            MS_BASIC=PRNTOK
$228d       Réinitialise l'imprimante.
$2290       Met le curseur en début de ligne.
$2293-$2296 Affiche "Ok!"

$2299       [monitorloop]
            MS_BASIC=GETCMD
$2299-$229c Met la ligne courante du BASIC à -1 ($ffff), c'est-à-dire, par de ligne courante
$229f-$22a3 Branche si `(autflg)` est à 0, `AUTO` n'est pas actif.
$22a5       Ligne courante du mode AUTO dans HL
$22a8       Patch par rapport à la ROM 1.0, branche plus loin. (???)

$22ab       [out_space]
            Suivant si la ligne a déjà du contenu ou pas, le mode de numérotation automatique
            du mode `AUTO` arrivera sur `out_space` ou `out_loop`, puis continuera sur la boucle du moniteur.

$22ab       Affiche le caractère espace puis continue dans la boucle BASIC.

$22ad       [out_loop]
$22ad       Affiche le caractère qui est dans A puis continue dans la boucle BASIC. Le caractère est soit $20 soit $a0.

$22ae       [stoploop]
            Boucle de traitement du BASIC
$22ae       Acquisition d'une ligne de commande BASIC.
$22b1       Lorsque l'acquisition sort avec Carry à 1, une annulation a été demandée. On boucle alors sur l'acquisition d'une nouvelle ligne.

$22b3       Lorsqu'on arrive ici, la touche Entrée a été appuyée, la ligne est donc validée.
            HL pointe sur l'adresse précédente le buffer qui a été rempli par l'acqusition des touches, et qui se termine par un $00.

            Pour une entrée normale, le buffer est `(buf)`, existe-t-il un autre cas ? (avec `LOAD` ???)
$22b4-$22b5 Afin de tester si A est égal à zéro sans toucher au Carry, utilise une paire `INC`/`DEC` qui touche à Z mais pas à Carry.
$22b6       Le premier caractère entrée était $00, ce qui signifie que la ligne est vide, on boucle sur la moniteur.
$22b8       Sauve le drapeau Carry.
$22b9-$22bd Si `(allflg)` est différent de 0, la machine reboot. C'est le cas avec les programmes "protégés", dont l'interruption d'exécution provoque le reset de la machine.
$22c0       Tentative de lecture de numéro de ligne depuis le buffer pointé par HL
$22c3       DE, aui contient soit un numéro de ligne, soit 0, est sauvé sur la pile.
$22c4       Appelle la tokenisation de la ligne.
$22c7       A = 0, donc B = 0.
$22c8       Récupération du numéro de ligne dans DE
$22c9       Récupération des drapeaux. Le Carry est celui de `chget` et donc est à 1 si la ligne commence par un nomnbre.
$22ca       Branche si la ligne ne commençait pas par un nombre, c'est-à-dire pas par un numéro de ligne.
$22cd       Sauve le numéro de ligne.
$22ce       Sauve la taille du buffer résultat tokenisé.
$22cf       Sauve l'adresse du buffer résultat (HL pointe un octet avant le premier octet du buffer).
$22d0-$22d3 Augmente le numéro de ligne gérée par la commande `AUTO`. HL contient le numéro numéro de ligne.
$22d4       Branche sur le code patché pour la ROM 1.1

$22d7       [line_record]
$22d7       Récupération de l'adresse du buffer résultat.
$22d8       Lecture du prochain caractère du buffer résultat.
$22d9-$22da Préparation et sauvegarde du test de caractère nul.
$22db       Recherche du numéro de ligne (depuis DE)
$22de       Branche si le numéro de ligne a été trouvé.
$22e0-$22e1 Sinon, récupère le résultat du test de caractère nul précédent ainsi que le caractère lu, en gardant la valeur sur la pile.
$22e2       Retourne au moniteur si le buffer était vide (mais pourquoi avoir testé le numéro de ligne entre temps ???)
$22e5       Pourquoi refaire un "or a,a" ici ??? Il y a besoin que Carry soit à 0, mais il devrait l'être à cause de $22d9

$22e6       [prev_found]
$22e6       BC contient l'adresse de la ligne trouvée si elle l'a été, ou de la ligne suivante sinon.
            Cette adresse est sauvée dans la pile.
$22e7       Branche si le numéro de ligne n'a pas été trouvé.
$22e9       DE prend l'adresse suivante de la ligne trouvée.
$22ea       HL pointe vers la zone des variables.

$22ed       [erase_line]
$22ed-$22f0 Copie un octet de la ligne suivante vers la ligne cherchée
$22f1-$22f2 Boucle jusqu'à ce que DE atteigne HL. Autrement dit, la ligne courante est effacée par recopie de tout ce qui la suit à partir de son emplacement.
            Au passage, les pointeurs de chaînages à partir de cette ligne deviennent invalides.
$22f4-$22f6 Ajustement de la nouvelle valeur de `(vartab)` comme étant la dernière adresse recopiée dans le bloc précédent.

$22f9       [prev_nfound]
$22f9       Récupération dans DE de l'adresse initiale de la ligne trouvée (entre temps effacée) ou de la suivante si elle n'avait pas été trouvée.
$22fa       Récupération du résultat du test du token sauvé en $22e1 (fait en $22d9)
$22fb       Branche si la ligne est vide après le numéro de ligne.
$22fd       HL pointe sur l'adresse des variables
$2300       Récupération dans HL de la taille de la tokenisation
$2301       Récupération dans BC de l'adresse des variables `(vartab)`
$2302       HL contient la nouvelle valeur pour `(vartab)`.
$2303       Sauve cette valeur.
$2304       Déplacement du bloc de texte vers le haut de la mémoire pour faire la place nécessaire à la ligne qui arrive.
            La routine vérifie aussi qu'il y a assez de place en mémoire pour ça et génère une erreur BASIC dans le cas contraire.
$2307-$2308 Récupération et mise à jour de `(vartab)`. Fait uniquement si le déplacement mémoire a réussi.
$230b       Récupération dans HL de l'adresse de la ligne
$230c       Mise en place d'une valeur dans la première partie de l'adresse de chaînage.
            Nécessaire pour éviter que la reconstruction du chaînage ne confonde ce pointeur avec la fin du listing.
$230d       DE récupère le numéro de la nouvelle ligne.
$230e-$230f Déplace le pointeur vers l'emplacement du numéro de ligne.
$2310-$2313 Placement du numéro de ligne. HL pointe sur le début du contenu de la ligne (qui n'est pas encore là).
$2314       Sauvegarde du pointeur sur la ligne dans DE.
$2315       HL pointe sur le buffer de résultat de tokenisation.

$2318       [cpy_line]
$2318       Récupère l'octet source dans A.
$2319       Copie un octet de (HL) vers (DE), incrémente les deux et décrémente BC (qui n'est pas utilisé)
$231b-$231d Branche pour le cas normal de copie de caractère.
$231f-$2321 Copie des deux octets composant les entiers 16 bits décodés.
$2323       Boucle sur la copie du contenu de la nouvelle ligne.

$2325       [cpy_not_num]
$2325-$2326 Continue la copie tant que le caractère n'est pas nul. En sortie de boucle, la ligne a été insérée dans la partie texte.

$2328       [line_empty]
            Arrive ici si la ligne était vide (et donc a été effacée) ou a été transférée au bon endroit.
$2328       Réinitialise les pointeurs des zones mémoires du BASIC.
$232b       HL pointe sur (txttab)
$232c       DE pointe sur (txttab)
$232d       [make_chain]
$232d-$232e HL et DE pointent au même endroit, le début des données d'une ligne.
$232f-$2332 Si le pointeur vers la ligne suivante est nul, le chaînage est terminé.
            C'est la raison pour laquelle une valeur non nulle a été temporairement donnée au premier octet du pointeur.
$2335       HL pointe sur le numéro de ligne

$2336       [sk_2_bytes]
$2336-$2337 Avance de 2 octets.
            Soit pour le numéro de ligne et se positionner sur le premier octet du contenu de la ligne.
            Soit ensuite pour les nombre entiers sur 16 bits pré-encodés.

$2338       [adv_1byte]
$2338-$2339 Lecture d'un octet des données de la ligne.
$233a-$233c Si c'est le marqueur de nombre entier sur 16 bits, boucle pour passer avant de deux octets supplémentaires.
$233e-$233f Si l'octet n'est pas n'est pas nul, boucle pour avancer d'un octet.
$2341       Sinon, c'est la fin de la ligne. On ramène dans HL le pointeur de la ligne précédente.
$2342-$2344 Le pointeur vers la ligne suivante, à présent dans DE, est placé dans le pointeur de chaînage de la ligne précédente (HL).
$2345       Poursuite du chaînage.

$2347       [line_search]
            Cherche une ligne BASIC désignée par DE.

            Entrée :
            - DE contient le numéro de la ligne BASIC à chercher.

            Sorties :
            - `(prelin)` contient le pointeur vers la ligne précédente à celle recherchée ou 0 s'il n'existe pas de ligne précédente.
            - Carry à 1 si la ligne a été trouvée, 0 dans le cas contraire.
            - BC pointe vers les données de la ligne cherchée. Sur les données de la ligne qui a dépassé sinon.
            - HL pointe vers les données de la ligne suivante si la ligne est trouvée. Contient le numéro de ligne qui a dépassé sinon.
            - DE contient toujours le numéro de la ligne BASIC à chercher.
            - Si la fin du listing a été atteinte, alors BC et HL pointent sur le pointeur final.

            En sortie, si Carry Flag est levé, alors HL contient le pointeur vers la ligne de BASIC trouvée.
            Si Carry Flag est reset, alors la ligne n'a pas été trouvée. BC contient le pointeur vers la ligne de numéro inférieur à celui cherché. HL contient la ligne suivante à celle pointée par BC.
            (prelin) contient toujours le pointeur vers la ligne cherchée précédemment.
            
            MS_BASIC=SRCHLN
$2347       Initialise BC à 0.
$234a       HL pointe vers la première adresse du listing BASIC.

$234d       [search_lp]
$234d       Met à jour la  dernière ligne trouvée.
$2351-$2352 BC = HL, pointeur vers un début de données d'une ligne.
$2353-$2357 Retour immédiat si le pointeur de chaînage est nul. On est arrivé en fin de listing.
            HL pointe toujours vers le début des données d'une ligne.
$2358-$2359 HL pointe à présent sur le numéro de ligne BASIC.
$235a-$235d Lecture du numéro de ligne dans HL.
$235e       Comparaison de HL (numéro de ligne pointée) et DE (numéro de ligne recherchée)
$235f-$2360 HL pointe à nouveau en début de données de la ligne.
$2361-$2364 Lecture dans HL du pointeur de chaînage. HL pointe donc vers les données de la ligne suivante.
$2365       Inverse la retenue. Si Z est à 1, alors C était à 0, il est donc passé à 1, indiquant que la ligne a été trouvée.
$2366       Retour immédiat si la ligne considérée était celle cherchée.
$2367       Inverse la retenue et la remet donc à l'état du test HL/DE précédent.
$2368       Retour immédiat si HL > DE dans le test de ligne. On a dépassé le numéro de la ligne cherchée, elle ne sera donc pas trouvée.
$2369       Boucle pour étudier la ligne suivante.

$236b       [tokenize]
            Effectue la tokenisation du buffer pointé par HL.

            Le résultat est construit dans la zone de travail `buf`.

            Entrée :
            - HL pointe vers le contenu à traiter

            Sortie :
            - HL pointe un octet avec le buffer résultat
            - DE pointe à la fin du buffer résultat
            - C contient la taille du buffer résultat
            - A est égal à 0
            
            MS_BASIC=CRUNCH
$236b-$236c Mise à 0 de (`dores)` pour signaler la tokenisation. À 1, le drapeau indique un mode « direct » (ou littéral).
$236f       Taille initial du buffer de sortie (pourquoi 5 ???)
$2371       DE pointe sur le buffer de tokenisation
$2374       [analyze]
$2374       Récupération dans A du caractère à traiter
$2375       %CHAR
$2375-$2377 Branche si c'est un espace
$237a       Copie du caractère à traiter dans B.
$237b       %CHAR
$237b-$237d Branche si ce sont des guillemets.
$2380-$2381 Branche si c'est le caractère nul.
$2384-$2387 Préparation du test de drapeau de tokenisation
$2388       A est à nouveau le caractère à l'étude
$2389       Branche si on se trouve en mode littéral (non tokenisé)
$238c       %CHAR
$238c-$2390 Branche si le caractère est '?', avec A contenant la valeur du token pour `PRINT`.
$2393       A est à nouveau le caractère à l'étude
$2394-$2398 Branche si le caractère est '…', avec A contenant la valeur du token pour `DISK`.
$239b       A est à nouveau le caractère à l'étude
$239c       %CHAR
$239c-$239e Branche si le caractère est inférieur à '0'.
$23a0       %CHAR
$23a0-$23a2 Branche si le caractère est inférieur à '<'. Les chiffres et les caractères ':' et ';' sont traités comme des littéraux.
$23a5       [special_chr]
            À cet endroit, A contient un caractère hors chiffre ni ':; "?…\0'.
$23a5       Sauve le pointeur vers le buffer de travail sur la pile.
$23a6       DE pointe un octet avant le début du tableau des mots clés du BASIC.
$23a9       Sauve le compteur C, initialement égal à 5, sur la pile.
$23aa-$23ad Place sur la pile l'adresse qui sera utilisée par `ret` si le mot-clé n'a pas été trouvé.
$23ae       B initialisé à `$7F`. B sera incrémenté à chaque mot-clé essayé, et sera le numéro de token associé. Le premier token a donc pour numéro $80.
$23b0       A est à nouveau le caractère à l'étude
$23b1       %CHAR
$23b5       %CHAR
$23b1-$23bb Transforme les lettres minuscules en majuscules directement dans le buffer d'entrée.
$23bc       [not_lower]
$23bc       C contient le caractère à traiter
$23bd       HL pointe vers le tableau de mots-clés. DE vers le buffer d'entrée.
$23be       [next_keyw]
$23be       Avance le pointeur vers le tableau de mots-clés.
$23bf-$23c0 Boucle jusqu'au premier caractère du tableau avec un bit de poids fort à 1. Cela est le marqueur d'un nouveau mot-clé.
$23c3       Augmente l'index du mot-clé actuellement pointé.
$23c4-$23c5 A contient le premier caractère de la table des mots-clé, sur 7 bits, ce qui enlève le marqueur de premier caractère.
$23c7       Si le caractère est nul, alors la fin du tableau des mots-clé est atteinte, on sort.
            La sortie se fait vers l'adresse poussée précédemment sur la pile : `not_a_tk`.
$23c8-$23c9 Branche si le caractère pointéà traiter et celui du mot-clé sont différents. On cherche le mot-clé suivant dans le tableau.
$23cb       Le pointeur vers le tableau de mots-clés retourne dans DE.
            HL contient à nouveau l'adresse du buffer en traitement.
$23cc       Sauvegarde de HL.
$23cd       [cmp_kw]
$23cd       Avance le pointeur de mot-clé vers le caractère suivant.
$23ce       Place le caractère suivant dans A
$23cf-$23d0 Branche si on atteint un nouveau marqueur de mot clé. Cela signifie que le mot-clé a été trouvé.
$23d3       Place dans C le caractère courant du mot-clé.
$23d4       Place dans A le numéro de token trouvé.
$23d5-$23d7 Branche si le mot-clé actuel est `GOSUB`
$23d9-$23db Branche si le mot-clé actuel est `GOTO`
$23dd       [goto_or_sub]
$23dd       Lecture du caractère suivant du buffer d'entrée.
            Il faut se rappeler que la routine 'saute' les espaces.
$23de       Annule un déplacement de HL effectué par la lecture précédente.
            Cela a pour effet de sauter par dessus les espaces éventuels, permettant l'écriture `GO TO` ou `GO SUB`.
$23df       [no_space]
$23df-$23e0 Lecture d'un nouveau caractère depuis le buffer d'entrée.
$23e1       %CHAR
$23e1-$23e3 Branche si le caractère est inférieur à 'a'.
$23e5       Sinon, passage du caractère en majuscule.
            Il n'y a pas de vérification de caractère supérieur à 'z'. En effet, le tableau de mots-clés ne contient de toute façon que des caractères alphabétiques.
$23e7       [not_low]
$23e7-$23e8 Les caractères du buffer d'entrée et du mot-clé courant sont identiques, la comparaison continue.
$23ea-$23eb Le mot-clé ne correspond pas, on essaie le mot clé suivant après avoir récupéré le pointeur vers la chaîne à traiter depuis son début de mot.

$23ed       [kw_found]
$23ed       Sauvegarde dans C du numéro de token.
$23ee       L'adresse du début de mot sur la pile est nettoyée.
$23ef       L'adresse de retour en cas d'échec de recherche est dépilée.
$23f0       A prends le numéro de token (pourquoi ne pas avoir fait directement LD A,B à ce niveau ???)
$23f1-$23f3 Branche si le token est $88 (`GOTO`)
$23f5-$23f7 Branche si le token est $8c (`GOSUB`)
$23f9-$23fb Branche si le token est $8b (`RESTORE`)
$23fd-$23ff Branche si le token n'est pas $b6 (`THEN`)
$2401       [test_number]
            Vérifie s'il y a un paramètre nombre derrière l'instruction
$2401       Sauve HL, pointeur vers le buffer d'entrée.
$2402       Lit le caractère dans le buffer d'entrée.
$2403       Restaure à nouveau HL, qui pointe au début de la partie à vérifier.
$2404       Si Carry est à 0, le caractère n'était pas un nombre, il n'y a pas donc pas de paramètre numérique.
$2406       Sauvegarde de HL, pointer vers le buffer d'entrée, dans DE.
$2407       Récupération dans Y du compteur C initialement mis à 5.
$2409       Récupération dans HL du pointeur vers le buffer en entrée.

$240a       [dec_number]
$240a       Le token est placé dans le buffer de travail lors de la première arrivé. Ensuite, c'est la virgule de séparation préparée plus loin qui sera copiée.
$240b       DE pointe sur l'octet suivant du buffer d'entrée.
$240c       Et on sauve DE sur la pile.
$240d       Utilisation des registres secondaires.
$240e       Récupération dans HL du buffer d'entrée
$240f       Remise sur la pile de l'adresse du buffer d'entrée.
$2410       Tentative de récupération d'un numéro de ligne depuis le buffer d'entrée HL.
$2413-$2415 Branche si le numéro de ligne est invalide (à 0).
$2417       Nettoyage de la pile en enlevant l'adresse du buffer d'entrée.
$2418       Octet bas du numéro de ligne dans A (exx n'echange pas AF, on garde donc une partie de numéro de ligne, voir plus loin)
$2419-$241a Mise dans la pile dans l'adresse de décodage ajustée à l'octet avant la dernière lecture de numéro de ligne.
$241b       On repasse aux registres initiaux.
$241c       On récupère dans DE le buffer d'entrée.
$241d       HL, qui pointe vers le buffer de travail, est incrémenté.
$241e       $0e est placé dans le buffer de travail comme marqueur de nombre entier sur 16 bits pré-décodé.
$2420-$2421 Placement de la première partie du numéro de ligne
$2422       Avancement dans le buffer de travail.
$2423-$2426 Récupération dans C de la seconde partie du numéro de ligne
$2427-$242b La taille du buffer de travail est augmentée de 3 (pour le token, le marqueur et la première partie du nombre)
$242d       [miss_line]
$242d       Comparaison de DE, buffer d'entrée, et de HL, buffer de travail.
$242e       DE doit toujours être plus loin que HL. Sinon, branche vers l'erreur Opérande manquante. pourquoi ???
$2431       HL contient le buffer en entrée, DE le buffer de travail.
$2432       Sauvegarde du buffer d'entrée.
$2433       Lecture du caractère suivant.
$2434       DE contient le buffer en entrée, HL le buffer de travail.
$2435       %CHAR
$2435-$2437 Branche si le caractère suivant n'est pas une virgule. Le décodage de l'instruction est terminé.
            La fin de la routine copiera la seconde partie du numéro de ligne décodé en cours.
            Il peut y avoir des virgules pour `ON ... GOTO` et `ON ... GOSUB`.
$2439       Sinon, on place la deuxième partie du numéro de ligne dans le buffer de travail.
$243a       Et on avance le pointeur vers le buffer de travail.
$243b       La taille du buffer de travail est augmentée.
$243d       %CHAR
            Préparation dans C d'une virgule pour la prochaine boucle.
$243f       Nettoie la pile du buffer d'entrée.
$2440       Boucle sur le paramètre potentiel suivant.

$2442       [invalid_lin]
$2442       Reviens sur les registres initiaux.
$2443       Récupération dans DE du buffer d'entrée
$2444       Recalage, puisqu'il n'y avait pas de numéro de ligne.
$2445       Poursuite du décodage.

$2447       [token_end]
$2447       Récupération du buffer d'entrée dans DE.
$2448       Sauvegarde du pointeur vers le buffer de travail.
$2449       Sauvegarde du compteur d'octets dans le buffer de travail.

$244b       [not_a_tk]
            Arrivée ici lorsque :
            - aucun mot clé n'a été trouvé
            - un mot clé suivi de paramètres numériques a été trouvé
$244b       HL pointe vers le buffer en entrée, DE pointe vers le buffer de travail.
$244c       [complete_tk]
            Arrive ici lorsqu'un token a été trouvé et que ses éventuels paramètres de type ligne ont été décodées.
$244c       Récupération du caractère C dans A.
            Dans le cas où l'on a réussi la tokenisation, C contient le token.
            Dans le cas où l'on a décodé un numéro de ligne, C contient la deuxième partie (haute) du numéro de ligne.

$244d       Récupération de C, qui contient la taille du buffer de travail.
$244e       DE pointe sur le buffer de travail.
$244f       [no_token]
            On arrive ici soit par un token, soit en copie directe du buffer d'entrée vers le buffer de travail.
            Quoiqu'il arrive, la donnée à copier à dans A.
$244f       Incrémente le pointeur vers le buffer d'entrée.
$2450       Copie la donnée actuelle dans le buffer de travail.
$2451       Avance le pointer vers le buffer de travail.
$2452       Augmente la taille du buffer de travail.
$2453       %CHAR
$2453-$2455 Branche si le caractère est ':'
$2457       Avec la soustraction précédente, cela fait que l'on compare le caractère à $83
$2459       Branche si le caractère n'est pas le marqueur $83 (`DATA`)

$245b       [is_colon]
$245b       Si le caractère était ':', alors A est à 0. Sinon, le token était `DATA` et A est différent de 0, ce qui fait passer en mode littéral.

$245e       [not_data]
$245e       Avec la soustraction précédente, cela fait que l'on compare le caractère à $8E (`REM`)
$2460       Branche si le caractère n'est pas le marqueur $8E (`REM`) pour une nouvelle analyze de token
$2463       B = 0, qui sert de caractère marqueur de fin de copie.

$2464       [trailing]
            Recopie les caractères du buffer d'entrée vers le buffer de travail jusqu'à trouver le caractère marqueur fourni dans B.
$2465       A contient le prochain caractère du buffer d'entrée.
$2466       Sort si ce caractère est nul.
$2468-$2469 Branche si le caractère marqueur a été trouvé.

$246b       [ifquote]
$246b       Avance le pointeur vers le buffer d'entrée.
$246c       Copie le caractère dans le buffer de travail.
$246d       Incrémente la taille du buffer de travail.
$246e       Avance le pointer vers le buffer de travail.
$246f       Boucle sur la copie littérale.

$2471       [ifnul]
            Arrive ici lorsque le buffer d'entrée a rencontré le caractère nul final.

$2471       HL est placé juste avant le buffer de travail.
$2474-$2478 Termine le buffer de travail avec trois caractères nuls.
$2479       Fin de la routine de tokenisation

$247a       [inst_for]
            Instruction BASIC : FOR

            La structure d'un bloc `FOR` est la suivante :
            - Marqueur $81 (1 octet)
            - Adresse de la variable associée (2 octets)
            - Signe du `STEP` (1 octet)
            - Valeur du `STEP` (4 octets, format BCDE)
            - Valeur du `TO` (4 octets, format BCDE)
            - Ligne où se trouve l'instruction `FOR` (2 octets)
            - Adresse de la première instruction après le `FOR` (2 octets)

            Pour un total de 16 octets.

            %CODE
$247a-$247c Indique que la recherche/création de variable se fait pour une commande `FOR`.
$247f       Juste après le `FOR` se trouve une assignation de variable. Au retour, DE pointe sur la variable.
$2482       Retire l'adresse de retour de l'instruction `LET` ($24ea)
$2483       Sauve le pointeur vers le texte BASIC qui pointe à présent après l'assignation de variable.
$2484       Cherche le début de l'instruction suivante. (est-ce que c'est ce qui provoque l'erreur de syntaxe en mode direct ???)
$2487       Sauve le pointeur vers l'instruction suivant le `FOR`
$248a-$248d Pointe 2 octets au-dessus de la pile, c'est-à-dire après le pointeur vers le texte BASIC que l'on vient d'y pousser.

$248e       [search_for]
$248e       Cherche le bloc `FOR` associé à la variable pointée par DE. (que se passe-t-il s'il est trouvé ? Et si un autre FOR est trouvé ???)
$2491       Branche si un bloc `FOR` correspondant n'est pas trouvé.
$2493       Sinon, fait pointer vers la pile après le bloc `FOR` trouvé.
$2494       Sauve l'adresse de la variable associée.
$2495-$2498 DE pointe vers la première instruction qui suit le `FOR` trouvé (c'est-à-dire ayant la même variable).
$2499-$249b Sauve l'adresse de la pile après le `FOR` trouvé.
$249c       Récupère l'adresse de l'instruction suivant le `FOR` actuel.
$249f       Compare les deux adresses d'instruction suivante.
$24a0       Restaure le pointeur sur la pile après le bloc `FOR` trouvé.
$24a1       Restaure l'adresse de la variable associée.
$24a2       Les deux instructions suivantes étaient différentes, les deux blocs `FOR` ne sont pas identiques, on continue la recherche.
$24a4       Restaure le pointeur sur le texte BASIC en cours d'analyse, et n'en fait rien (nettoyage de la pile)
$24a5       Fixe l'adresse de la pile sur le bloc après le bloc `FOR` trouve, ce qui annule les blocs `FOR` intermédiaires.

            Cela est fait pour traiter les cas du type (invalide, mais exécutable) :
            > 10 FOR I = 1 TO 10
            > 20 FOR J = 10 TO 20
            > 30 PRINT I,J
            > 40 NEXT I
            La boucle FOR sur J n'empilera pas un nouveau bloc à chaque rencontre.

$24a6       Incrémente C pour une raison inconnue... La valeur est écrasée juste après.

$24a7       [no_for]
$24a7       Restaure le pointeur vers le texte BASIC
$24a8       DE = pas utilisé ???, HL = pointeur vers le texte BASIC
$24a9-$24ab Vérifie qu'il y a de la place pour 8 niveaux de la pile.
$24ae       Sauve le pointeur vers le texte BASIC
$24af       HL pointe sur l'instruction suivant le FOR.
$24b2-$24b3 Insère l'adresse de cette instruction sous le pointeur texte BASIC dans la pile.
$24b4       Récupère le numéro de la ligne actuelle en exécution.
$24b7       Sauve la ligne courante sur la pile et récupère le pointeur vers le texte BASIC.
$24b8       Vérifie que la variable déclarée était de type numérique.
$24bb       Le token qui suit doit être $b3 (`TO`)
$24bc       %DATASKIP
$24bd       Évaluation de l'expression après `TO`
$24c0       Sauve le pointeur vers le texte BASIC
$24c1       Ramène l'expression vers `BCDE` en tant qu'entier 16 bits.
$24c4       Récupère le pointeur vers le texte BASIC
$24c5-$24c6 Sauve BCDE dans le bloc `FOR`
$24c7-$24cb BCDE = 1, `STEP` par défaut
$24cc-$24cd Vérifie si le token suivant est `STEP`
$24cf       A = 1, pour signaler le signe positif de `STEP`
$24d1       Branche s'il n'y a pas de token `STEP`
$24d3-$24d4 Sinon, évalue l'expression pour `STEP`
$24d7       Sauve le pointeur vers le texte BASIC
$24d8       Ramène l'expression vers `BCDE` en tant qu'entier 16 bits.
$24db       Teste le signe du `STEP`
$24dc       Récupère le pointeur vers le texte BASIC (dans A)

$24dd       [no_step]
$24dd-$24de Pousse la valeur du `STEP` dans le bloc `FOR`
$24df       Sauve le signe de `STEP`
$24e0       Remonte la pile d'octet, pour ignorer le registre `F`.
$24e1       Sauve le pointeur vers le texte BASIC
$24e2       Récupère l'adresse de la variable associée, placée par l'instruction `LET`.
$24e5       Met l'adresse de la variable sur la pile et récupère dans HL le pointeur vers le texte BASIC.

$24e6       [end_for]
$24e6-$24e9 Sauve $81 (marqueur du bloc `FOR`) sur la pile.

$24ea       [end_of_inst]
            %CODE
            Appelée à la fin de chaque instruction lors d'une exécution.
            Recherche l'instruction suivante.
            
            MS_BASIC=RUNCNT
$24ea       Vérifie si une interruption de commande a été demandée.
$24ed       Sinon, sauve le pointeur de texte BASIC.
$24f1       %CHAR
$24f0-$24f3 Branche si le caractère suivant est `:`, la ligne n'est pas terminée, il faut exécuter l'instruction suivante.
$24f5-$24f6 Si le pointeur de texte BASIC ne pointe ni sur ':' ni sur le caractère nul de fin de ligne, c'est une erreur de syntaxe.
$24f9-$24fd Branche si l'adresse de chaînage de la ligne suivante est nulle. La dernière ligne du programme a été atteinte.
$2500-$2503 Lecture du numéro de la nouvelle ligne dans DE.
$2504       HL = le numéro de ligne, DE = pointeur vers les tokens de la ligne.
$2505       Mise à jour du numéro de la ligne courante.
$2508       DE = le numéro de ligne, HL = pointeur vers les tokens de la ligne. Prêt à exécuter la ligne suivante.

$2509       [exec_token]
            Exécute le contenu d'une ligne BASIC tokenisée.
            
            MS_BASIC=EXECUTE
$2509       Récupère le premier octet de l'instruction à exécuter.
$250a-$250d Met sur la pile l'adresse de retour vers laquelle aller à la fin de l'instruction.

$250e       [if_jump]
$250e       Si le caractère sur la ligne était nul, alors le retour provoquera le traitement de la fin de ligne.

$250f       [on_jump]
$250f-$2511 Branche si l'octet n'était pas un token (les tokens sont tous supérieurs à $80). Exécute par défaut l'assignation de variable.
$2514-$2516 Les 50 ($32) premiers tokens sont des instructions. Au-delà, provoque une erreur de syntaxe, ce n'est pas un token d'instruction.
$2519-$251b BC = (token - $80) * 2
$251d       Sauvegarde de HL, pointeur vers le texte BASIC, dans DE.
$251e       HL pointe vers la table des adresses d'instructions.
$2521       HL pointe vers l'adresse d'execution de l'instruction.
$2522-$2524 BC contient l'adresse d'execution de l'instruction.
$2525       L'adresse est mise sur la pile.
$2526       HL pointe vers le texte BASIC.
            La routine continue sur l'acquisition du prochain caractère signifiant du texte BASIC.
            Le `ret` qui terminera cette routine provoquera le branchement vers l'exécution de l'instruction, avec HL qui pointe vers le premier octet du texte BASIC.
            A contiendra le caractère lu, et les drapeau Carry et Z seront positionnés.

$2527       [get_char]
            Recupère le caractère suivant pointé par HL.

            Entrée :
            - HL pointe vers le buffer à lire

            Sortie :
            - A contient l'octet lu
            - Carry est à 0 si l'octet est supérieur ou égal à $3a (':')
            - Carry à 1 si c'est un chiffre, 0 sinon
            - Z à 1 si A est nul
$2529       %CHAR
$2527-$252b Lit le caractère suivant et retourne immédiatement si celui-ci est supérieur ou égal à ':', tout comme le fait `chget`

$252c       [chget_2]
            Suite du traitement de chget.

            A contient le caractère lu dans le buffer, qui est inférieur à $3a (':')
$252c-$252e Lit le caractère suivant si celui-ci était un espace. Les espaces ne sont pas significatifs.
$2530       Branche si le caractère est entre ' ' et ':'
$2532-$2534 Branche si le caractère est entre %0f et $1f (contient les caractères accentués, le caractère `DISK` et deux caractères de contrôle)
$2536-$2538 Branche si le caractère est inférieur strictement à $0d (une autre partie des caractères de contrôle, dont 0)
$253a       Reste les cas $0d (retour chariot, cas normalement impossible) et $0e (marqueur d'entier 16 bits).
            Le pointeur sur le texte BASIC est sauvé.
$253b-$253e Le position après le nombre entier sur 16 bits est mise dans `(contxt)`.
$2541       Et HL pointe à nouveau sur le texte BASIC en cours d'exécution.

$2542       [chget_std]
$2542       Place les drapeaux en fonction de la valeur de A.
$2543       Retour soit de `chget`, soit exécution de l'instruction donc l'adresse a été poussée sur la pile.

$2544       [chget_digit]
$2544       %CHAR
$2544-$2546 Carry à 1 si le caractère est supérieur ou égal à '0' et inférieur strictement à ':'. Donc un chiffre.
$2547-$2548 Permet de positionner le Z sans toucher à Carry.
$2549       Retour soit de `chget`, soit exécution de l'instruction donc l'adresse a été poussée sur la pile.

$254a       [read_index]
            Lecture d'un nombre entier depuis une chaine pointée par HL.

            En branchant avant `deint_impl`, le nombre doit être positif.
            En branchant vers `deint_impl`, le nombre peut être positif ou négatif.

            Entrée :
            - HL pointe vers un buffer de texte

            Sortie :
            - DE contient le nombre entier sur 16 bits
            
            MS_BASIC=FPSINT
$254a       Cette première entrée est utilisée pour un index de tableau, et commence par ignorer le premier caractère.

$254b       [pos_int]
$254b       Évaluation de l'expression numérique pointée par HL. Utilisé par l'instruction `CLEAR`.
            MS_BASIC=POSINT

$254e       [dep_int]
$254e       Vérifie le signe de l'expression dans FAC
            MS_BASIC=DEPINT
$254f       Lance une erreur si le nombre est négatif.

$2552       [deint_impl]
$2552       Récupère l'exposant de FAC ; MS_BASIC=DEINT
$2555       Et le compare à $80+16 (donc 16).
$2557       Branche si l'exposant est inférieur ou égal à 16 (codé $80+$10). Dans ce cas, la partie entière du nombre peut tenir sur 16 bits.
$255a-$255d BCDE = -32768, qui est le seul nombre avec un exposant à $90 qui est valide.
$2560       Sauve le pointeur vers le texte BASIC.
$2561       Compare FAC et BCDE.
$2564       Restaure le pointeur vers le texte BASIC.
$2565       DE = $8000, soit -32878 sur 16 bits signé.
$2566       Si FAC = -32768, alors retour.
$2567       [ill_call]
$2567-$2569 Erreur "Illegal function call"

$256c       [get_lin_num]
            Lecture depuis le buffer pointé par HL d'un nombre entier positif.
            Ce nombre peut soit être exprimé en ASCII, soit déjà décodé avec le marqueur `$0e`.

            La routine est utilisée pour les numéros de ligne, et vérifie que le nombre est entre 0 (exclu ???)
            et 65529, numéro de ligne maximum.
            
            Entrée :
            - HL pointe sur un buffer de type texte BASIC

            Sortie :
            - DE contient le nombre entier décodé depuis HL
            - A contient le dernier caractère lu
            
            MS_BASIC=ATOH
$256c       Ajuste le pointur vers le texte BASIC.

$256d       [get_lin_nu2]
$256d       Lecture du caractère. Un branchement direct ici permet d'accéder à la routine sans le recalage de HL.
$256e-$2570 Branche si le nombre est en ASCII.
$2572-$2575 Sinon, le nombre a déjà été codé, il est lu directement dans DE.
$2576       Puis lecture du caractère suivant dans A.

$2578       [ascii_num]
$2578       Revient en arrière dans le buffer d'entrée.
$2579       Initialise l'accumlateur de résultat à 0.
$257c       [num_decode]
$257c       Lecture d'un caractère depuis le buffer d'entrée.
$257d       Si le caractère n'était pas un chiffre, retour immédiat.
$257e       Sauve HL
$257f       Sauve AF
$2580-$2583 Compare l'accumulateur DE avec HL ($1998 = 6552), numéro de ligne maximum divisé par 10.
$2584       Branche à la fin de la fonction si l'accumulateur a dépassé le numéro de ligne maximum divisé par 10.
            Cela signifie que dans le cas contraire, le numéro de ligne est au maximum 6552 et qu'un nouveau chiffre a été lu.
            Par la suite, l'accumulateur va être multiplié par 10 et le nouveau chiffre ajouté, ce qui porte le numéro
            de ligne maximum à 65529.
$2586-$258b HL <- DE * 10. Au final, HL contient l'accumulateur multiplié par 10.
$258c       Restaure AF, A contient le nouveau caractère lu.
$258d       %CHAR
$258d-$2590 DE prend la valeur numérique du caractère lu, qui a déjà été vérifiée comme étant un chiffre en ASCII.
$2592       Ajoute le novueau chiffre à l'accumulateur.
$2593       DE redevient l'accumulateur.
$2594       Restaure le pointeur vers le buffer d'entrée.
$2595       Traite un nouveau chiffre.

$2597       [num_dec_end]
$2597       Restaure AF, contenant le dernière caractère lu.
$2598       Restaure le pointeur vers le texte BASIC.

$259a       [inst_run]
            %CODE
            Instruction BASIC : RUN

            L'instruction RUN sans argument branche sur la boucle d'exécution directement. (tracer ???)
            Avec un argument, le contexte BASIC est réinitialisé puis continue vers l'instruction `GOTO`.

            MS_BASIC=RUN
$259a       Coupe l'affichage du curseur (au prochain rafraichissement)
$259e       Branche s'il n'y a pas d'argument à la commande. (du coup, comment ça démarre ???)
$25a1       Réinitialise les variables de contexte BASIC.
$25a4       Prépare le retour dans la boucle d'exécution.
$25a7       Branche vers l'instruction `GOTO` précédé de la mise sur la pile de BC.

$25a9       [inst_gosub]
            %CODE
            Instrution BASIC : GOSUB

            MS_BASIC=GOSUB

$25a9-$25ab Vérifie qu'il y a 3 niveau dans la pile.
$25ae       Récupère l'adresse de retour dans BC
$25af       Sauve le pointeur d'exécution HL.
$25b0-$25b4 Met le numéro de la ligne courante au sommet de la pile. HL pointe sur le texte BASIC.
$25b5-$25b8 Place un marqueur `GOSUB` (`$8c`) sur la pile. La pile est ajustée pour ne pas retenir la partie `F` de `AF`.

$25b9       [run_from_ln]
$25b9       Remet l'adresse de retour sur la pile, puis enchaîne sur GOTO.
            Instruction partagée avec RUN pour lancer un programme depuis une ligne particulière.

$25ba       [inst_goto]
            %CODE
            Instruction BASIC : GOTO

            Du fait d'ignorer ce qui se trouve après le numéro de ligne, une ligne qui contient "GOTO 20 HOP HOP" est valide.

            MS_BASIC=GOTO

$25ba       Lit le numéro de ligne dans DE.
$25bd       Le reste de la liste ne peut pas être atteint, on ignore jusqu'à la fin de la ligne.
$25c0-$25c1 Et sauve le pointeur ajusté sur la ligne suivante.
$25c2-$25c5 Compare la ligne courante (HL) et la ligne voulue (DE)
$25c6       Restaure le pointeur de texte BASIC.
$25c7       Appelle si le numéro de ligne voulue est au-delà de la ligne courante.
$25ca       Appelle si le numéro de ligne voulue est avant la ligne courante (ou égal à ???)
$25cd-$25ce Copie de la ligne trouvée dans HL
$25cf       Ajuste le pointeur vers la ligne un octet avant.
$25d0       Retour si la ligne a été trouvée.
$25d1       [udef_line]
$25d1-$25d3 Sinon, lance une erreur "Undefined line number"

$25d6       [inst_return]
            %CODE
            Instruction BASIC : RETURN

            MS_BASIC=RETURN

$25d6       `RETURN` n'a pas de paramètre. S'il y a quelques chose derrère l'instruction, retour immédiat, ce qui provroquera une erreur de syntaxe.
$25d7-$25d9 DE à $ff évite qu'une variable associée à un bloc `FOR` soit valide par hasard, et permet donc de dépiler tous les blocs `FOR` jusqu'à un bloc non `FOR`.
            Après l'appel, A contient l'octet qui débute le bloc non `FOR` et HL pointe un octet plus loin.
$25dc       La pile est positionnée juste après le marqueur du bloc non `FOR` trouvé.
$25dd-$25e1 Si l'octet ne contient pas le marqueur de bloc `GOSUB` ($8c), alors branche sur une erreur "RETURN without GOSUB".
$25e4       Après le marqueur de bloc `GOSUB` se trouve le numéro de ligne qui contenait le `GOSUB`.
$25e5       Inscription de ce numéro de ligne dans `(curlin)`.
$25e8-$25eb Si on était en mode direct, HL est à $FFFF et A est donc à 0, la branche n'est pas prise. Sinon, la branche est prise.
            Mais sur cette implémentation, on ne fait rien de spécial. Ce qui permet un `RETURN` en mode direct (`GOSUB` vers un `STOP` permet de reprendre avec `RETURN`).

$25ed       [useless_jp]
$25ed       Préparation de l'adresse de retour de la fonction.
$25f0       L'adresse de retour est mise sur la pile, HL pointe vers l'instruction `GOSUB` du bloc.
$25f1       Évite le `pop hl` qui suit pour se caler sur l'instruction qui suit le `GOSUB` actuellement pointé par HL.

$25f2       [next_data]
            Un appel ici suppose que la chaîne à traiter est sur la pile.
            Enchaîne sur DATA pour faire pointer HL vers l'instruction suivante.

            MS_BASIC=NXTDTA

$25f3       [inst_data]
            %CODE
            Instruction BASIC : DATA

            En arrivant ici, C sera chargé avec $3a (':' == fin d'instruction).
            Ainsi, un marqueur possible sera $00, et l'autre ':'. L'instruction est ignorée jusqu'à la prochaine, qu'elle soit séparée par ':' ou par une fin de ligne.

            MS_BASIC=DATA
$25f3-$25f4 Charge C avec $3a et continue sur le `NOP` plus bas.

$25f5       [inst_rem]
            %CODE
            Instruction BASIC : REM
            En arrivant ici, C sera chargé avec $00.
            Ainsi, les deux marqueurs possibles seront tous les deux à $00. Le reste de la ligne sera ignoré.

            MS_BASIC=REM
$25f5       Charge C avec $00 quand on arrive directement ici.
$25f6       Avec le $0e précédent, forme ld c,$00, et sert d'adresse d'arrivée pour `inst_data`.
$25f7       Charge B, le second marqueur, avec $00.

$25f9       [rem_ex_lp]
$25f9-$25fb Échange le contenu de B et C.

$25fc       [rem_loop]
$25fc       Lit l'octet pointé par HL.
$25fd-$25ff Branche si ce n'est pas un marqueur d'entier 16 bits décodé.
$2601-$2604 Sinon, ignore le nombre codé et lit à nouveau le caractère pointé.

$2605       [no_number]
$2605-$2606 Retour si la fin de ligne a été atteinte.
$2607-$2608 Retour immédiat si le caractère marqueur de fin a été trouvé.
$2609       Sinon, HL pointe sur le caractère suivant.
$260a       %CHAR
$260a       Détection de chaîne de caractères.
$260c       Si on trouve un marqueur de chaîne de caractères, les deux marqueurs B et C seront échangés.
            Cela permet de protéger un ':' situé à l'intérieur d'une chaîne de caractères et ne pas considérer qu'il marque une fin d'instruction.
$260e       Sinon, on continue le traitement de la ligne.

$2610       [inst_let]
            %CODE
            Instruction BASIC : LET

$2610       En retour, DE pointe sur la variable, qui a été créée au besoin.
$2613       Vérifie la présence de l'opérateur '=' (tokenisé), ou génère une erreur de syntaxe.
$2614       %DATASKIP
$2615       Sauve le pointeur sur la variable.
$2616       Récupère le type de la variable.
$2619       Et le sauve sur la pile.
$261a       Évaluation de l'expression qui suit le signe '='.
$261d       Récupère le type de la variable.
$261e       Sauve le pointeur texte BASIC sur le pile et récupère le pointeur de variable dans HL.
$261f       Sauve l'adresse de la variable dans `(temp)`
$2622       Le type de la variable passe dans Carry (1 si chaîne, 0 si numérique).
$2623       Vérification de la compatibilité du type de l'expression et de la variable.
            Si la routine revient, c'est que les types étaient identiques.
$2626       Branche en cas de variable numérique.
$2628       [let_string]
            Assigne une chaîne de caractères à une variable.

$2628       Sauve le pointeur vers la variable.
$2629       Récupère depuis FAC le pointeur vers le descripteur de chaîne du resultat de l'expression.
$262c       Et sauve ce pointeur.
$262d-$262e Ignore la taille de la chaîne.
$262f-$2631 Adresse de la chaîne dans `DE`
$2632-$2635 Compare l'adresse de la chaîne avec `(txttab)`.
$2636       Branche si l'adresse de la variable est avant `(txttab)`, autrement dit, dans un buffer temporaire. Il faut donc créer une entrée.
$2638-$263b Vérifie si la chaîne se trouve entre `(txttab)` et `(strend)`, c'est-à-dire dans une zone allouée (programme, variable, tableau...).
            Le vrai test aurait probablement du être avec `(vartab)`. Une chaîne ne peut pas se trouve entre `(vartab)` et `(strend)`. Cela fonctionne donc quand même.
$263c       Récupère le pointeur sur le descripteur de chaine.
$263d       Branche si la chaîne est dans une zone allouée.
$263f-$2643 Branche si la chaîne n'est pas dans le buffer temporaire de chaîne.
            Test inutile sur VG5000, puisque le buffer temporaire est de toute façon avant `(txttab)`. Relicat probable du portage BASIC sur cette machine.
$2645       On a déjà fait le `pop de`, on ignore le suivant.
$2646       [alloc_str]
$2646       Récupère le pointeur sur le descripteur de chaine.
$2647       Récupèration dans BC de la chaîne en haut du buffer de chaînes temporaires.
$264a       HL = pointeur de descripteur de la chaîne, BC = pointeur vers le contenu de la chaîne
$264b       Sauve la chaîne dans l'espace de sauvegarde des chaînes de caractères.

$264e       [pop_string]
$264e       Récupération de la chaîne temporaire en haut du buffer
$2651       Récupération de l'adresse de la variable.
$2652       Copie le descripteur de chaine vers l'entrée de variable, ce qui donne sa valeur finale à la valeur (longueur et pointeur de chaine).
$2655       Restauration du pointeur vers le texte BASIC.

$2657       [let_numeric]
            Assigne un nombre à une variable.

$2657       Sauve le pointeur vers la variable.
$2658       Copie le contenu de FAC vers la variable.
$265b       Restaure l'adresse de la variable dans DE (pour quelle raison ???)
$265c       Restaure le pointeur vers le texte BASIC.

$265e       [inst_on]
            %CODE
            Instruction BASIC : ON

            MS_BASIC=ON
$265e       Evalue l'expression qui suit `ON` sous la forme d'un entier sur un octet.
$2661       Lit le token qui suit.
$2662       Sauve le token dans B.
$2663-$2665 Branche si le token est `GOSUB`
$2667       S'assure que le token suivant est `GOTO`, ou provoque une erreur de syntaxe.
$2668       %DATASKIP
$2669       Recale le pointeur vers le texte BASIC.
$266a       [on_line]
$266a       Copie le résultat de l'évaluation vers C en tant que compteur.
$266b       [on_branch]
$266b       Décrémente le compteur
$266c       Ramène le token (`GOTO` ou `GOSUB`) dans A.
$266d       Si le compteur est arrivé à 0, provoque le saut en exécutant le token dans A avec la ligne pointée par HL.
$2670       Lecture du numéro de ligne.
$2673       %CHAR
$2673-$2675 Retour s'il n'y a pas de ligne supplémentaire.
$2676       Essaie le numéro de ligne suivant.

$2679       [inst_if]
            %CODE
            Instruction BASIC : IF

            MS_BASIC=IF
$2679       Evaluation de l'expression qui suit `IF`.
$267c-$267f Branche si le token qui suit est `GOTO`
$2681       Sinon, s'assure que le token qui suit est `THEN` ou provoque une erreur de syntaxe.
$2682       %DATASKIP
$2683       Recale HL sur le token.

$2684       [if_line]
$2684       S'assure que l'expresison du `IF` est de type numérique.
$2687       En prend son signe.
$2688       Si l'expression s'évalue à 0, elle est fausse. Branche sur l'instruction `REM` pour ignorer le reste de la ligne.
$268b       Lit l'octet suivant.
$268c-$268e Branche s'il s'agit d'un nombre sur 16 bits déjà décodé. C'est un numéro de ligne qui fonctionne comme un `GOTO`.
$2691       Sinon, exécute la suite de la ligne.

$2694       [inst_lprint]
            %CODE

            Instruction BASIC : LPRINT
$2694-$2696 Indique l'imprimante comme périphérique de sortie.

$2699       [print_next]
$2699-$269a Relit le caractère pointé par HL (car A a été utilisé).

$269b       [inst_print]
            %CODE
            Instruction BASIC : PRINT
$269b       Appel du `hook` sur `PRINT`.
$269e       Sans argument, affiche une ligne vide. C'est aussi le cas si le `hook` place le drapeau Z à 1.

$26a1       [pr_next_ct]
$26a1       Il n'y a plus d'expression à afficher, termine l'instruction.
$26a4-$26a6 Branche si le token `TAB(` a été trouvé.
$26a8-$26aa Branche si le token `SPC(` a été trouvé.
$26ac       Sauve le pointeur vers le texte BASIC.
$26ad       %CHAR
$26ad-$26af Branche si le caractère est ','
$26b1       %CHAR
$26b1-$26b3 Branche si le caractère est ';'
$26b6       Récupération du pointeur vers le texte BASIC (ne sert pas ???)
$26b7       Lecture de l'expression pointée par HL.
$26ba       Sauve le pointeur vers le texte BASIC.
$26bb-$26bf Branche si l'expression est de type chaine.
$26c1       Sinon, transforme le résultat numérique dans FAC en chaîne de caractères.
$26c4       Transfert cette chaîne vers une chaîne de caractères temporaire (il ne s'agit pas des mêmes buffers temporaires)
$26c7       %CHAR
            Le nombre est suivi d'un espace.
$26c9       Récupère l'adresse de la longueur de la chaîne temporaire (le decripteur de chaîne temporaire est dans FAC).
$26cc-$26d0 Branche si le périphérique de sortie est l'écran.
$26d2-$26d5 Ajoute la position actuelle en colonnes de l'imprimante avec la longueur de la chaîne à imprimer.
$26d6       Compare le résultat avec 132.
$26d8       Puis branche plus loin.

$26da       [print_scr]
$26da-$26dd Place dans B la longueur d'une ligne à l'écran.
$26de       Dans A, la longueur d'une ligne à l'écran + 1.
$26df       Branche si la longueur d'une ligne est $ff, ce qui signifie qu'il n'y a pas de limite.
$26e1-$26e4 Sinon, ajoute la position du curseur en colonnes avec la longueur de la chaîne à écrire.
$26e5       Ajuste le résultat (A avait été incrémenté)
$26e6       Compare le résultat avec la longueur de la ligne.

$26e7       [print_adjst]
$26e7       Si ce que l'on doti afficher ou imprimer dépasse la longueur permise, un saut de ligne est envoyé.

$26ea       [no_limit]
$26ea       Émission de la chaîne de caractères vers le périphérique de sortie.
$26ed       A = 0, qui permet de passer par dessus le `call` juste après.

$26ee       [print_str]
$26ee       Émission de la chaîne de caractères vers le périphérique de sortie si c'était une chaîne de caractères.
$26f1       Restaure le pointeur vers le texte BASIC.
$26f2       Boucle vers l'évaluation de la potentielle expression suivante.

$26f4       [print_zone]
$26f4-$26f8 Branche si le périphérique de sortie est l'écran.
$26fa-$26fd Compare la position en colonnes de l'imprimante avec 117.

$2701       [zone_scr]
$2701-$2704 Place la position de la dernière zone dans B.
$2705-$2708 Place la position du curseur - 1 dans A.
$2709       Compare cette position avec la dernière zone.

$270a       [zone_crdo]
$270a       Si la colonne de la dernière zone est dépassée, alors émet un retour chariot.
$270d       Puis dans ce cas, branche sur l'impression à la suite.

$270f       [zones_loop]
$270f       Soustrait 13 de la position.
$2711       Tant que le résultat est positif.
$2713       Une fois négatif, prend le complément du résultat, ce qui donnt le nombre d'espace à émettre.

$2716       [print_tab]
$2716       Sauve le token (`SPC(` ou `TAB(`)
$2717       Évalue l'expression numérique qui suit avec un résultat sur 8 bits.
$271a       S'assure qu'une parenthèse fermante est à la suite de l'expression, ou lance une erreur de syntaxe.
$271b       %DATASKIP
$271c       Recale le pointeur de texte BASIC.
$271d       Récupère le token.
$271e       Soustrait le token d'avec le token pour `SPC(`.
$2720       Sauve le pointeur de texte BASIC.
$2721       Branche si c'était `SPC(`.
$2723-$2727 Branche si le périphérique de sortie est l'écran.
$2729       Initialise A avec le numéro de colonne de l'imprimante.

$272e       [prepare_spc]
$272e       Initialise A avec la colonne à l'écran.

$2731       [print_spc]
$2731-$2732 Pour SPC(), A = argument de SPC() - 0
            Pour TAB(), A = argument de SPC() - colonne actuelle ( - 1 ???)
$2733       Continue à la suite si TAB() était inférieur à la colonne actuelle.

$2735       [output_spc]
$2735-$2736 Nombre d'espaces à émettre dans B
$2737       %CHAR
            Caractère espace à émettre dans A.
$2739       [out_spaces]
$2739       Émet l'espace.
$273a       Boucle autant de fois que le compteur B.

$273c       [print_cont]
$273c       Restaure le pointeur de texte BASIC.
$273d       Lit l'octet suivant.
$273e       Évaluation de l'expression potentielle suivante sans retour à la ligne s'il n'y en a pas.

$2741       [print_end]
$2741-$2742 Sélection l'écran comme périphérique de sortie.

$2746       [bad_input]
            Lorsque les données sont insuffisantes pour remplir les variables d'une instruction `READ` ou `INPUT`, cette routine est appelée.
            
            MS_BASIC=BADINP
$2746-$274a Branche dans le cas d'un `READ`
$274d       Jette le pointeur de données qui est sur la pile.
$275a       [redo_fr]
$274e-$275a Affiche "Redo from scratch" en fonction de la langue
$275d       Relance l'acquisition de données pour `INPUT`.

$2760       [inst_input]
            %CODE
            Instruction BASIC : INPUT
            
            MS_BASIC=INPUT
$2760       Appeler `INPUT` en direct est illégal, l'instruction doit être dans un programe.
$2763       Appel du `hook` sur `INPUT`
$2767       %CHAR
$2766-$2767 S'il y a un '"' après INPUT, c'est qu'il y a un texte à afficher.
$2769       Relicat de portage. Dans d'autres BASIC, A sert à permettre la sortie de caractères. Dans cette ROM, aucune des deux branches possbles n'utilise cette valeur.
$276b       Il n'y a rien à afficher, on passer directement à l'acquisition des données.
$276d       Évalue la chaîne de caractères à afficher.
$2770       Vérifie que le caractère suivant est un ';' ou provoque une erreur de syntaxe.
$2771       %DATASKIP 
$2772       Sauve le pointeur sur le texte BASIC.
$2773       Affiche la chaine de caractères
$2776       Évite le `push hl` qui suit.
$2777       [raw_input]
$2777       Sauve le pointeur sur le texte BASIC.
$2778       Lance la routine d'acquisition des données.
$277b       Branche sur l'acquisition des données.

$277d       Octets inutilisés.

$2780       [prompt_2]
$2780       Acquisition des données.
$2783       Rend le curseur invisible.
$2787-$278e Efface la continuité de ligne et signal que l'on a terminé l'instruction `INPUT`.

$2792       Octet inutilisé.

$2793       [input_data]
$2793       Récupère le pointeur de texte BASIC dans BC (HL est utilisé par la ligne juste entrée pour l'INPUT)
$2794       Branche en cas d'interruption de commande.
$2797-$279a Lit le premier caractère de la chaine entrée et prépare le drapeau Z (HL pointe un octet avant le buffer d'acquisition)
$279b       Sauvegarde le pointer sur le texte BASIC.
$279c       Si le buffer était vide, branche pour ignorer le reste de l'instruction. Cela signifie que la ou les variables d'`INPUT` ne sont pas touchées.
$279f       %CHAR
            Dans le cas contraire, on ',' en caractère avant les données entrées. Cela permet d'utiliser la routine de `READ`.
$27a1       Continue vers la lecture de `DATA` par `READ`.

$27a3       [inst_read]
            %CODE
            Instruction BASIC : READ
            
            MS_BASIC=READ
$27a3       Sauvegarde du pointeur vers le texte BASIC.
$27a4       HL pointe vers la prochaine zone de `DATA`.
$27a7       Initialise A avec $af pour signaler l'instruction `READ` à `(flginp)`. Saute par dessus le `xor a`.

$27a8       [read_data]
$27a8       A = 0, pour signaler l'instruction `INPUT` à `(flginpu)`.
            MS_BASIC=NXTITM
$27a9       Si A == 0, on est dans INPUT, sinon, on est dans READ. `(flginp)` porte plutôt mal son nom et devrait plutôt s'appeler `read flag`.
$27ac       HL = pointeur sur le texte BASIC, haut de la pile = pointeur vers les DATA (pour `READ`) ou le buffer d'acquisition (pour `INPUT`)
$27ad       Saute par dessus le teste de présence de ','.

$27ae       [data_loop]
$27ae       Vérifie la présence d'une virgule dans le texte BASIC. Sauf la première fois. C'est la virgule qui sépare les variables.
$27af       %DATASKIP
$27b0       Lecture d'un nom de variable. Retour dans DE.
$27b3       HL = pointeur vers les données, haut de la pile = pointeur vers le texte BASIC.
$27b4       Sauve le pointeur vers la variable sur la pile.
$27b6       %CHAR
$27b5-$27b8 Branche si le prochain caractère des données est ',' (c'est pour cela que l'INPUT est amorcé avec un ',' ???)
$27ba-$27be Branche pour l'instruction `READ`
$27c1       %CHAR
$27c1-$27c4 Il manque des données, lance une nouvelle acquisition de données.
$27c7       Récupération du pointeur vers variable
$27c8       Récupération du pointeur sur le texte BASIC
$27c9       Branche en cas d'interruption de commande.
$27cc-$27cf Prépare le test du prochain caractère comme étant nul.
$27d0       Sauvegarde le pointeur sur le texte BASIC.
$27d1       Fin de ligne lors d'un `INPUT`, ignore le reste de l'instruction et cherche la suivante. Les variables non traitées ne sont pas modifiées.
$27d4       Sinon, il y a des données, sauve le pointeur vers la variable.

$27d5       [get_value]
$27d5       MS_BASIC=ANTVLU
$27d5-$27d9 Branche si la variable est de type numérique.
$27db       Sinon, lit le prochain caractère
$27dc-$27dd Copie le caractère dans D et B
$27de       %CHAR
$27de-$27e0 Branche si le premier caractère est '"', il s'agit d'un littéral
$27e2-$27e5 Prépare les cas  `INPUT`/`READ`
$27e6       Dans le cas `INPUT`, A, et donc D, contiendront 0. D marque la fin des données.
$27e7       Branche dans le cas `INPUT`.
$27e9       %CHAR
$27e9       Sinon, dans le cas `READ`, D est ':'. D marque la fin de instruction `DATA` et donc des données (0 est toujours cherché, quoi qu'il arrive).

$27eb       [data_sep]
$27eb       %CHAR
            B == ',', séparateur de données.
$27ed       Recalage de HL, au cas où le premier caractère n'était pas '"'.

$27ee       [lit_string]
$27ee       Lecture d'une chaîne de caractères terminée par l'un des caractères dans B et D.
$27f1       DE = pointeur sur la chaine de caractères.
$27f2-$27f5 L'adresse de retour est fixée par HL, HL récupère l'adresse des données.
$27f6       Sauve le pointeur sur la chaine de caractères lue.
$27f7       Tout est prêt pour l'assignation de la variable alphanumérique. Le retour se fera à l'adresse juste spécifiée, partie commune avec la lecture d'une donnée numérique.

$27fa       [num_data]
$27fa       Lecture du premier caractère (??? amorce, ou ignore ?)
$27fb       Lecture de la donnée sous forme d'un nombre.
$27fe       HL = pointeur vers la variable, haut de la pile = pointeur vers les données.
$27ff       Assigne la valeur lue dans FAC à la variable pointée par HL.
$2802       Récupération du pointeur vers les données.
$2803       [next_comma]
$2803-$2804 Lecture du caractère suivant de buffer de données.
$2805       Branche si le buffer données est vide
$2807       %CHAR
$2807-$2809 Branche si le caractère lu n'est pas ",".

$280c       [empty_data]
$280c       HL = pointeur sur le texte BASIC, haut de la pile = pointeur vers les données.
$280d-$280f Branche s'il reste des variables à traiter pour `INPUT` ou `READ`.
$2811       Récupération du pointeur vers les données.
$2812-$2815 Préparation du cas `INPUT` ou `READ`.
$2816       HL = pointeur vers les données, DE = pointeur vers le texte BASIC.
$2817       Branche dans le cas `READ`
$281a       Sinon, cas `INPUT`, sauvegarde le pointeur vers le texte BASIC.
$281b       Comme le cas est `INPUT` (A = 0), cela donne A = (HL). Ce qui prépare le drapeau Z pour conditionner l'affichage du message qui suit.
$281c-$2826 Pointe vers le message "Extra ignored" en fonction de la langue du système.
$2829       [ignore_fr]
$282a       S'il restait des données (drapeau Z à 0), affiche le message.
$282d       Restauration du pointeur d'exécution

$282f       [go_nxt_data]
$282f       Avance jusqu'à la prochaine instruction.
            MS_BASIC=FDTLP
$2832-$2833 Branche si ce n'est pas la fin de la ligne.
$2835-$2838 Sinon, vérifie si le chaînage de la ligne suivante est nul.
$2839-$283b Si oui, sors avec une erreur "Out of DATA".
$283e-$2842 Sinon, lit le numéro de ligne dans DE et l'inscrit dans `(datlin)`.charge la ligne de DATA courante.

$2846       [test_data]
$2846-$2849 Boucle si l'instruction suivante n'est pas DATA. Jusqu'à en trouver une ou sortir avec l'erreur précédente.
$284b       HL pointe vers la prochaine zone de données, retour à l'assignation.

$284d       [eval_num_ex]
            Évalue une expression et vérifie que le résultat est numérique.

            Entrée :
            - HL pointe sur une zone texte BASIC

            Sortie :
            - Résultat dans FAC, si l'expression était numérique.
$284d       Lecture d'une expression.

$2850       [type_eq_num]
            Vérifie que le type évalué est de type numérique.

            `(valtyp)` a du être assigné au préalable.
$2850       Le `or $37` a pour but de passer le Carry à 0 et de sauter par dessus l'instruction `scf`.

$2851       [type_eq_str]
            Vérifie que le type évalué est de type chaîne de caractère.

            `(valtyp)` a du être assigné au préalable.
$2851       Place le Carry à 1.

$2852       [type_eq_chk]
            Vérifie que deux types de variables sont égaux.

            Entrée :
            - Carry flag porte le premier type, 0 = numérique, 1 = chaîne de caractères
            - `(valtyp)` porte le second type, 0 = numérique, 1 = chaîne de caractères

            Sortie :
            - Si les deux types sont égaux, la routine revient.
            - Si les deux types diffèrent, la routine branche sur une erreur "Opérande mal adaptée"

            MS_BASIC=CHKTYP

$2852       Charge le type de l'expression la plus récemment évaluée.
$2855       Double sa valeur et ajoute la retenue (Carry).
$2856       Met en place les drapeaux.
$2857       Retour si le résultat est pair (0 pour deux numériques, ou 2 pour deux chaînes).
$2858       Branche sur l'erreur sinon.
$285b       4 octets non utilisés ???

$285f       [paren_expr]
            Appelé lorsque l'on débute l'analyse d'une sous-expression entre parenthèses.

$285f       S'assure de la présence d'une parenthèse.
$2860       %DATASKIP

$2861       [read_expr]
            Lecture et évaluation d'une expression.

            Entrée :
            - HL pointe vers un texte BASIC

            Sortie :
            - FAC contient le nombre si l'expression est numérique.
            - FAC contient un descripteur de chaîne si l'expression est alphanumérique.

            Lorsqu'un opérateur est analysé, sont ajoutés sur la pile :
            - une adresse de retour (eval_2) qui sera utilisée par le `ret` de l'opérateur.
            - le premier paramètre de l'opérateur sous forme BCDE.
            - l'adresse d'exécution de l'opérateur.

            Lorsqu'un opérateur de plus faible priorité est trouvé (ou à la fin ???), le `ret nc` permet de faire un saut vers l'adresse d'exécution de l'opérateur.
            L'opérateur trouvera son paramètre sur la pile, suivi de l'adresse de retour.
            
            MS_BASIC=EVAL
$2861       Recalage du pointeur de texte BASIC.
$2862       La priorité actuelle d'opérateur est dans D.

$2864       [eval_1]
$2864       Sauve la priorité actuelle.
$2865-$2867 Vérification qu'il est possible d'ajouter 1 niveau (C) sur la pile
$286a       Lecture de la prochaine valeur.
$286d       Sauve le pointeur de texte BASIC.
$2870       [eval_2]
$2870       Récupère le pointeur de texte BASIC.
$2873       Récupère la priorité actuelle.
$2874-$2875 Comparaison avec la priorité de AND et OR
$2877       La priorité est au moins $78, vérification que l'on cherche un type numérique (d'après `(valtyp)`). Si on revient, c'est que c'était le cas.
$287a       Lecture dans A de l'octet suivant.
$287b       Sauve le pointeur vers le texte BASIC
$287e       $b9 est le token pour '+', qui est aussi le premier token des opérateurs.
$2880       Retour si l'octet lu est inférieur au token de '+', ce qui signifie que ce n'est pas un opérateur.
$2881       $c3 est le code de `SGN`, le token de première fonction prédéfinie.
$2883       Retour si l'octet lu fait partie des fonctions prédéfinie, ce qui signifie que ce n'est pas un opérateur.
$2884       Les trois derniers opérateurs sont les opérateurs relationels : $c0 '>', $c1 '=', $c2 '<'.
$2886       Branche dans le cas d'un opérateur relationel.
$2888-$288a E prend l'index de l'opérateur.
$288b       Branche si l'opérateur n'est pas '+'.
$288d-$2890 Z à 1 en cas de type chaîne de caractères.
$2891       A prend l'index de l'opérateur.
$2892       Branche si l'opérateur est '+' et que le type est chaîne de caractères. C'est une concatenation de chaînes.

$2895       [not_concat]
$2895-$2897 E prend l'index de l'opérateur multiplié par 3. Chaque entrée de la table comporte sa priorité suivi de l'adresse d'exécution de sa routine.
$2898       Charge la table des priorités
$289b-$289d Pointe vers le bon index de la table des priorités.
$289e       Sauve la priorité courante.
$289f       Récupère la priorité de l'opérateur.
$28a0       Compare les priorités.
$28a1       Si la nouvelle priorité est plus petite, le `ret` provoque le retour vers l'exécution de l'opérateur précédent.
$28a2       Sinon, HL pointe sur l'adresse de l'opérateur.
$28a3       Vérifie que le type est numérique (encore ???)
$28a6       [op_stack]
$28a6       Sauve la priorité (B) et C ???
$28a7-$28aa Sauvegarde de l'adresse de retour pour l'exécution de cet opérateur.
$28ab-$28ac Sauve le token (E) ainsi que sa priorité (D) dans BC
$28ad       Pousse la valeur de FAC sur la pile pour continuer la construction du bloc pour l'opérateur.
$28b0-$28b1 Restaure le token (E) ainsi que sa priorité (D) depuis BC
$28b2-$28b5 Récupère l'adresse d'exécution de l'opérateur dans BC.
$28b6       Met cette adresse sur la pile pour compléter le bloc pour l'opérateur.
$28b7       Restaure le pointeur vers le texte BASIC.
$28ba       Boucle sur la suite de l'analyse.

$28bd       [eval_comp]
            Évaluation d'un opérateur relationel.

            Entrée :
            - A contient l'un de '>', '=', '<'

            Sortie :
            - D est l'addition des différents signes trouvés. '>' = 1, '=' = 2, '<' = 4.

            Par exemple, '>=' donne 3.

$28bd       Initialise la détection de opérateurs à deux caractères ('<=', '>=' et les autres)
$28bf       [comp_loop]
$28bf-$28c1 Branche si A est avant '>' (pas possible au premier passage)
$28c4-$28c6 Branche si A est après '<' (pas possible au premier passage)
$28c9       Compare avec '='. Carry sera mis à 1 pour '>', 0 dans les autres cas.
$28cb       Ce qui donne au final b11 pour '>', b10 pour '=' et b00 pour '<'.
$28cc       À la première boucle, A n'est pas changé (car D est à $00).
            En seconde boucle, tous les doublons (>>, << et ==) donnent $00, '<=' et '=<' donnent b01, '>=' et '=>' donnent b10
$28cd       Compare A et D
$28ce       À la première boucle, le caractère est mis dans D.
            À la seconde boucle, peu importe.
$28cf       À la première boucle, A ne peut pas être inférieur à D.
            Lors de la seconde, si A est inférieur à D, alors c'est une erreur de syntaxe.
$28d2       Le pointeur vers le texte BASIC est ajusté.
$28d5       Lecture du caractère suivant.
$28d6       Boucle sur le second caractère de la paire possible.

$28d8       [parse_value]
            Analyse une valeur.

            Entrée :
            - HL pointe vers le texte BASIC

            Cette valeur peut être numérique, alphanumérique, ou bien une fonction prédéfinie ou utilisateur.
            
            MS_BASIC=OPRND
$28d8-$28d9 Par défaut, le type est numérique.
$28dc       Lecture du prochain caractère significatif.
$28dd       Émet une erreur d'opérande manquante si le buffer est terminé.
$28e0       Branche si le caractère est un chiffre.
$28e3       %CHAR
$28e3-$28e5 Branche si c'est le début d'un nombre en hexadécimal, qui commence par "&"
$28e8-$28eb Branche si le caractère est entre 'A' et 'Z', c'est une variable.
$28ed-$28ef Le token pour '+' est ignoré car pris pour un opérateur unaire.
$28f1       %CHAR
$28f1-$28f3 C'est un nombre sans partie entière. Sauf pour analyse d'un nombre.
$28f6-$28f8 Token pour '-', c'est un nombre négatif. Saut pour analyse de l'opposé d'un nombre.
$28fa       %CHAR
$28fa-$28fc C'est une chaîne de caractères délimité par "
$28ff-$2901 Token pour 'NOT'. Branche sur l'évaluation d'un `NOT`.
$2904-$2906 Token pour 'FN'. Brance sur l'évaluation d'une fonction utilisateur.
$2909-$290b $c3 est le token pour `SGN`, la première des fonctions prédéfinies. Si le token est supérieur ou égal, branche vers á l'évaluation d'une fonction prédéfinie.
$290d       [eval_paren]
$290d       Le dernier choix possible est celui d'une sous-expression entre parenthèses.
            Appel de l'évaluation d'une expression qui doit commencer par une parenthèse ouvrante.

            Est aussi appelé comme sous-routine directement, pour évaluer une expression entre parenthèses, incluant les paramètres de fonctions.

$2910       Vérification de la parenthèse fermante associée.
$2911       %DATASKIP
$2912       Fin de l'évaluation de l'expression entre parenthèse. Le résultat est dans FAC.

$2913       [inst_minus]
            Évaluation de '-' comme opérateur unaire.

            Entrée :
            - HL pointe vers l'expression en cours.

            Sortie :
            - FAC contient l'évaluation de l'expression.
            - HL pointe vers la suite de l'expression.

$2913       Charge la priorité de l'opérateur unaire '-' dans D.
$2915       Puis évalue l'expression. Le retour se fera lorsqu'un opérateur de moins forte priorité sera trouvé (ou une fin d'expression ???).
$2918       Recupère le pointeur sur le texte BASIC.
$291b       Sauvegarde de ce pointeur sur la pile.
$291c       Prends l'opposé de FAC dans FAC.
$291f       [ret_num]
$291f       Vérifie que le type évalué est numérique.
$2922       Restaure le pointeur sur le texte BASIC.

$2924       [str_to_var]
            Charge dans FAC la valeur d'une variable indiquée dans le buffer de texte BASIC.

            Entrée :
            - HL pointe vers l'expression en cours.

            Sortie :
            - FAC contient la valeur de l'expression numérique ou le pointeur vers la chaîne de caractères.
            - HL pointe vers la suite de l'expression.

$2924       DE pointe sur l'adresse de la variable.
$2927       [from_eval]
$2927       Sauve le pointer vers le texte BASIC.
$2928       HL = adresse de la variable, DE = peu importe
$2929       Sauve l'adresse de la variable dans les deux octets les moins significatifs de FAC.
$292c-$2930 Si le type de la variable est numérique, monte la valeur pointée par HL, le contenu de la variable numérique, dans FAC.
$2933       Restaure le pointeur vers le texte BASIC.

$2935       [function]
            Exécute le code d'une fonction BASIC prédéfinie.

            Entrées :
            - A contient l'index de la fonction, basé sur `SGN` = 0.
            - HL pointe vers l'expression en cours.
            
            Sortie :
            - FAC contient la valeur de sortie de la fonction.
            - HL pointe vers la suite de l'expression.

            MS_BASIC=FNOFST
$2935       Prépare l'index dans le tableau des fonctions.
$2937       Double l'index de la fonction.
$2938       BC = index de la fonction multiplié par 2.
$2939       Sauvegarde de l'index dans le tableau.
$293a       Ignore la parenthèse après le nom de la fonction (???)
$293b-$293e Branche si la fonction est après `CHR$`, qui sont les fonctions de traitement de chaînes de caractères qui ont plusieurs paramètres.
$2940       Sinon, c'est une fonction alphanumérique avec plusieurs paramètres. Évaluation du premier paramètre.
$2943       Vérification que le caractère suivant est ','
$2944       %DATASKIP
$2945       Le premier paramètre doit être alphanumérique.
$2948       Sauve le pointeur vers le texte BASIC.
$2949       HL = adresse de la chaîne évaluée en premier paramètre.
$294c-$294d Que l'on place sous l'index doublé dans la pile.
$294e       Restaure le pointeur vers le texte BASIC.
$294f       Évaluation du second paramètre, de type entier sur 8 bits.
$2952       DE = pointeur vers le texte BASIC, HL = entier évalué en second paramètre.
$2953       HL = index doublé, Haut de la pile = second paramètre.
$2954       Branche sur l'exécution de la fonction.
            Sur la pile se trouve :
            - la valeur du second paramètre.
            - le pointeur vers la chaîne de premier paramètre.
            - l'index doublé de la fonction à exécuter.

$2956       [eval_func]
$2956       Évaluation du premier et seul paramètre de la fonction.
$2959       HL = index doublé, Haut de la pile = pointeur vers le texte BASIC
$295a-$295d Prépare l'adresse de retour pour le prochain `ret` comme retour d'une fonction numérique.

$295e       [exec_func]
$295e-$2961 HL pointe dans le tableau d'adresse des fonctions celle correspondant à l'index
$2962-$2965 HL = adresse de la routine pour la fonction.
$2966       Branche vers l'exécution de la fonction prédéfinie.

$2967       [exp_sign]
            Retourne le signe du caractère ou token présent dans A.

            Entrées :
            - D = 0
            - A est le dernier caractère lu depuis le buffer d'analyse du nombre

            Retour :
            - HL pointe sur l'octet suivant à lire.
            - D = $ff si le signe est négatif
            - D = $00 si le signe est positif
            - Z à 1 si un signe était spécifié, à 0 sinon.
            
            MS_BASIC=SGNEXP
$2967       D = $ff
$2968-$296a Retour immédiat si l'octet lu est le token du signe '-'.
$296b       %CHAR
$296b-$296d Retour immédiat si l'octet lu est le caractère '-'.
$296e       D = 0
$296f       %CHAR
$296f-$2971 Retour immédiat si l'octet lu est le caractère '+'
$2972-$2974 Retour immédiat si l'octet lu est le token du signe '+'
$2975       Ce n'était pas un signe, recale HL, pointeur sur le texte analysé.


$2977       [fp_bcde_or]
            %CODE
            Opérateur BASIC `OR`.
            
            Appelé lors de l'évaluation d'une expression via la table de priorités.
            
            MS_BASIC=POR
$2977       Marqueur pour le traitement de `OR`. A n'est pas 0.
            En $2979 arrive le traitement de `AND` et dans ce cas, l'instruction est `xor a`, donc A = 0.

            (La détection de l'instruction partielle ne fonctionne pas dans ce cas, pourquoi ???)
$2978       [fp_bcde_and]
            %CODE
            Opérateur BASIC `AND`.
            
            Appelé lors de l'évaluation d'une expression via la table de priorités.
            
            MS_BASIC=PAND
$2978       %CODE
            Marqueur pour le traitement de `AND`. A = 0
$2979       Sauve le marqueur de l'opérateur `OR` ou `AND`.
$297a       Le type de l'expression calculée doit être numérique, ou bien c'est une erreur.
$297d       Récupère FAC en tant qu'entier dans DE.
$2980       Récupère le marqueur de l'opérateur.
$2981       HL = valeur entière de l'expression, DE = pointeur vers le texte BASIC.
$2982-$2984 Récupère BCDE depuis la pile, qui contient l'autre argument de l'opérateur. Le premier argument se retrouve en haut de la pile.
$2985       Monte BCDE dans FAC.
$2988       Sauve le marqueur de l'opérateur.
$2989       Récupère FAC en tant qu'entier dans DE. On a donc un argument dans DE et l'autre en seconde position sur la pile.
$298c       Récupère le marqueur de l'opérateur.
$298d       Récupère l'autre argument.
$298e       Monte le LSB de BC dans A.
$298f       Prépare le branchement à le fin du traitement de l'opérateur.
$2992       Branche si l'opérateur est `OR`.
$2994-$2997 AC = BC & DE
$2998       Monte AC dans FAC et termine l'instruction.

$2999       [oper_or]
$2999-$299c AC = BC | DE
$299d       Monte AC dans FAC et termine l'instruction.

$299e       [relation_op]
$299e       Prépare l'adresse de retour si un bloc d'évaluation est poussé sur la pile.
            Comme la construction du bloc prend un pointeur vers une adresse, HL pointe vers une indirection vers la routine elle-même.
$29a1-$29a4 Récupère le type de l'évaluation. Carry à 0 signifique numérique ; chaîne de caractères sinon.
$29a5-$29a7 Place dans E l'opérateur décalé d'un bit vers la gauche avec le type de donnée en bit 0.
$29a8-$29ac Retour si la priorité est plus faible que $64.
$29ad       Sinon, met un nouveau bloc à évaluer sur la pile pour délayer la comparaison.

$29b0       [comp_addr]
            Attention, le commentaire trop long ci-dessous est tromqué (bug du parser ???)
$29b0       Addresse de la fonction qui suit, afin de pouvoir construire le bloc d'évaluation à dépiler ci-dessus.

$29b2       [compare]
            %CODE
$29b2-$29b4 L'opérateur et le type de donnée initialement dans C sont décompressés pour ramener le type de donnée dans Carry et l'opérateur tel que calculé initialement.
$29b5-$29b6 Récupère le premier argument de comparaison dans BCDE.
$29b7       Sauve l'opérateur et le type de donnée dans la pile.
$29b8       Vérifie que le type des deux arguments sont les mêmes, ou provoque une erreur.
$29bb-$29be L'adresse de retour sera la routine de résultat de la comparaison.
$29bf       Branche vers la comparaison de nombre si le type est numérique.
            La routine se terminant par des `ret`, la continuité se fera dans l'adresse poussée dans la pile juste au-dessus.
$29c2-$29c3 La comparaison de chaîne de caractères donne une valeur numérique, l'indique dans `(valtyp)`.
$29c6       Branche sur la comparaison de chaînes de caractères.

$29c9       [cmp_result]
            %CODE

            Calcul pour la sortie des opérateurs de comparaison.

            Entrée :
            - A contient un résultat de comparaison.

$29c9-$29ca Transforme le résultat de comparaison on opérateur équivalent.
            Si la relation était '<', alors A = $FF et Carry 1, au final, A = 1
            Si la relation était '=', alors A = $00 et Carry 0, au final, A = 2
            Si la relation était '>', alors A = $01 et Carry 0, au final, A = 4
$29cb       Dans B, récupère l'opérateur de la comparaison en court.
$29cc       Vérifie ce que la relation calculée a en commun avec l'opération demandée.
$29cd-$29cf Si A était à 0 (pas de relation commune), alors le résultat est $00
            Si A était différent de 0 (une relation commune au moins), alors le résultat est $FF
$29d0       A devient le résultat de la fonction en étant transféré dans FAC.

$29d3       [inst_not]
$29d3       Charge la priorité pour l'opérateur NOT.
$29d5       Lance une évaluation qui sortira reviendra lorsqu'une priorité d'opérateur plus faible sera rencontrée.
$29d8       Vérifie le type numérique de la valeur obtenue.
$29db       Récupère FAC dans DE sous forme entière.
$29de-$29e2 Met dans AC la négation de DE.
$29e3       Monte AC dans FAC.
$29e6       Nettoie la pile.
$29e7       Continue l'évaluation.

$29ea       [inst_fre_2]
$29ea-$29ee AC = HL - DE, puis met le résultat dans FAC.

$29ef       [ac_to_fac]
$29ef       Copie C dans B, puis continue vers le transfert de AB vers FAC.

$29f0       [ab_to_fac]
$29f0       Met B dans D au format flottant BADE.
$29f1       Met E à 0.
$29f3-$29f6 Indique une valeur numérique.
$29f7       Place l'exposant $80+$10 dans le format BADE.
$29f9       Cela monte au final dans FAC le nombre entier initalement contenu dans la paire AB.

$29fc       [inst_lpos]
            %CODE
            Fonction BASIC : LPOS()

            La fonction LPOS retourne le numéro de colonne actuelle de l'imprimante.
            L'argument est ignoré.
$29fc       Récupère le numéro de colonne actuel de l'imprimante.
$29ff       Le retourne en tant que résultat de fonction.

$2a01       [inst_pos]
            %CODE
            Fonction BASIC : LPOS()

            La fonction POS retourne le numéro de colonne actuelle à l'écran.

            Si l'argument est 255, alors la fonction retourne plutôt le numéro de ligne actuelle à l'écran.
$2a01       Récupère l'arguement en tant qu'entier 8 bits dans A.
$2a04       Incrémente A.
$2a05       Branche si le résultat est 0 (l'arguement était 255)
$2a07-$2a0a Sinon, renvoie le numéro de colonne comme résultat.

$2a0c       [inst_posy]
$2a0c       Charge le numéro de ligne puis continue sur le retour de fonction avec résultat dans A.

$2a0f       [retfun_impl]
            Place A dans FAC.

            Appelé par les fonctions donc le résultat est dans A.

            Entrée :
            - A contient la valeur de retour de la fonction.

            Note : il existe une autre routine un peu différente qui place A dans FAC (`a_to_fac`)
$2a0f-$2a10 Construit AB.
$2a11       Monte AB vers FAC.

$2a13       [inst_def]
            %CODE
            Instruction BASIC : DEF
            
            Définition d'une fonction utilisateur.
            
            MS_BASIC=DEF
$2a13       Vérifie que l'on a affaire à une fonction (et définie l'entrée)
$2a16       Cette instruction ne peut pas être appelée en direct.
$2a19-$2a1c Prépare la valeur de retour, qui amènera à la prochaine instruction.
$2a1d       Sauve l'adresse de l'identifiant de fonction.
$2a1e       DE = 0
$2a21-$2a24 Branche si le caractère suivant n'est pas une parenthèse ouvrant.
            Dans cette version du BASIC, il n'est pas obligatoire de spécifier une variable locale.
            Dans ce cas, la variable sera prise dans le contexte global.
$2a26       Lit le caractère et avant d'un octet.
$2a27       Récupère l'identifiant (un nom de variable) en paramètre de la définition.
            `(subflg)` contient toujours $80, ce qui interdit l'utilisation d'un nom de tableau.
$2a2a       Sauve le pointeur vers le texte BASIC.
$2a2b       HL = pointeur sur la variable paramètre
$2a2c-$2a2f Lecture du nom du paramètre dans DE.
$2a30       Restaure le pointeur vers le texte BASIC.
$2a31       Vérifie que le paramètre est bien numérique.
$2a34       Le caractère suivant doit être une parenthèse fermante.
$2a35       %DATASKIP
$2a36       [no_param]
$2a36       Le caractère suivant doit être le token pour `=`.
$2a37       %DATASKIP
$2a38-$2a39 Copie le pointeur de texte BASIC dans BC.
$2a3a       HL = pointeur vers le descripteur de la fonction, Haut de la pile = pointeur sur le texte BASIC.
$2a3b-$2a3d Les deux premiers octets du descripteur de fonction pointent vers le texte BASIC décrivant la fonction.
$2a3e       Les deux octets suivant prendront la valeur de DE, c'est-à-dire le nom du paramètre.

$2a41       [inst_fn]
            Fonction BASIC : FN

            Exécute une fonction définie par `DEF FN`.

            Note : le contexte local de la fonction est traité dans la récupération de la variable.
            Un test y est fait pour vérifier si le nom de la variable est égal à celui dans `(prmnam)`.
            Si c'est le cas, alors DE est placé sur `(prmval)`.

            Pour traiter la valeur du paramètre, c'est dans la récupération de la variable qu'un test
            est fait entre le nom de la variable en cours en prmnam. Si c'est égal, la valeur prise
            l'est depuis `(prmval)`.

$2a41       Vérifie que ce qui suit est le nom de fonction.
$2a44       Sauve le pointeur vers le descripteur de fonction.
$2a45       Évaluation de l'expression argument de la fonction.
$2a48       Cette expression doit être numérique.
$2a4b       HL = pointeur sur le descripteur de la fonction, Haut de la pile = pointeur vers le texte BASIC.
$2a4c-$2a4f DE pointe vers le texte BASIC au niveau de la définition de la fonction (les deux premiers octets du descripteur).
$2a50-$2a52 Si le pointeur était nul, cela signifie que la fonction n'était pas définie. Branche vers une erreur.
$2a55-$2a58 HL = nom de la variable paramètre de la fonction.
$2a59       Le nom de la variable paramètre de la fonction est mise sur la pile.
$2a5a-$2a5d Sauve le nom actuellement dans `(prmnam)` sur la pile, afin de permettre des sous appels de fonction.
$2a5e       Place le nom du paramètre de la fonction dans `(prmnam)`.
$2a61-$2a68 Sauve la valeur actuellement dans `(prmval)`
$2a69       HL pointe sur `prmval`.
$2a6c       Sauve DE, le pointeur vers le texte BASIC de la fonction.
$2a6d       Sauve FAC, qui contient l'évaluation de l'argument de la fonction, dans `(prmval)`.
$2a70       Restaure le pointeur vers le texte BASIC vers HL.
$2a71       Lance l'évaluation du texte BASIC au niveau de la définition de la fonction.
$2a74       Recale le pointeur vers le texte BASIC de la fonction.
$2a75-$2a76 Branche vers une erreur de syntaxe si le dernier caractère lu n'est pas une fin de ligne ou d'instruction.
$2a79-$2a7e Replace l'ancienne valeur de paramètre de fonction dans `(prmval)`.
$2a81-$2a82 Replace l'ancien nom de paramètre de fonction dans `(prmnam)`.
$2a85       Restaure le pointeur vers le texte BASIC.

$2a87       [ill_direct]
            Routine appelée pour vérifier qu'une instruction n'a pas été appelée en mode direct.

            Lance une erreur dans le cas contraire.
            MS_BASIC=IDTEST
$2a87       Sauve le pointeur vers le texte BASIC.
$2a88-$2a8b HL = numéro de la ligne courante + 1
$2a8c-$2a8d A = 0 si le numéro de la ligne courante était $ffff (valeur en mode direct)
$2a8e       Restaure le pointeur vers le texte BASIC.
$2a8f       Retour si la ligne courante n'était pas $ffff.
$2a90-$2a92 Branche sur une erreur "Illegal direct" dans le cas contraire.

$2a95       [check_fn]
            Vérifie que ce qui est pointé par HL est un identifiant valide de nom de fonction utilisateur.

            Entrée :
            - HL pointe vers le texte BASIC au niveau du token `FN`

            Sortie :
            - DE pointe vers le descripteur de fonction. Si la fonction n'existait pas, l'entrée est vide.

$2a95       Vérifie que l'octet suivant pointé par HL est le token pour `FN`.
$2a96       %DATASKIP
$2a97-$2a99 Signale à la recherche d'identifiant que les tableaux sont interdits dans ce contexte.
$2a9c       A contient le caractère suivant avec le bit 7 à 1
$2a9d       Les identifiant de fonctions ont leur premier octet avec le bit de poids fort à 1 en interne.
            Prépare la lecture de ce nom en lisant le premier caractère et profite que A soit à $80.
$2a9e       Récupère l'entrée associée.
$2aa1       Les fonctions ne peuvent être que numériques.

$2aa4       [preget_byte]
            Appelle la fonction de récupèration d'un entier depuis le pointeur vers le texte BASIC avec une lecture préalable d'un octet.

            Appelé par `SPC(` et `TAB(` dans une instruction `PRINT` afin d'ignorer la parenthèse ouvrante.

$2aa5       [getbyt_impl]
            Évalue une expression depuis un buffer texte BASIC et en retourne une valeur entière sur 8 bits.

            Provoque une erreur si l'entrée est trop grande.

            Entrée :
            - HL pointe sur la zone de texte BASIC

            Sortie :
            - A contient l'évaluation de l'expression
            - Les drapeaux sont placés en fonction de la lecture du caractère suivant l'expression.

            MS_BASIC=GETINT

$2aa5       Évalue l'expression pointée par HL

$2aa8       [to_int]
$2aa8       Récupère l'expression en tant qu'entier positif dans DE (a provoqué une erreur si l'expression était négative).
$2aab-$2aad Si D n'est pas nul, c'est que le nombre est trop grand. Branche vers une erreur.
$2ab0-$2ab1 Sinon, relis le dernier caractère de l'expression.
$2ab2       Place le résultat dans A.

$2ab4       [inst_peek]
            %CODE
            Fonction BASIC : PEEK

$2ab4       Récupère l'expression en argument de PEEK sous forme d'entier sur 16 bits dans DE.
$2ab7       Lit l'octet à l'adresse correspondante.
$2ab8       Retourne A comme résultat de la fonction.

$2abb       [inst_poke]
            %CODE
            Instruction BASIC : POKE
$2abb       Récupère dans DE le premier argument de POKE, qui est l'adresse.
$2abe       Sauve l'adresse.
$2abf       Vérifie que ce qui suit est une virgule.
$2ac0       %DATASKIP
$2ac1       Récupère dans A le second argument de POKE, qui est la valeur.
$2ac4       Restaure l'adresse.
$2ac5       Place A dans l'adresse spécifiée.

$2ac7       [why]
            Ici, il y a 4 octets nuls qui semblent ne servir à rien.

$2acb       [poke_addr]
            Routine de récupération du premier argument pour `POKE`.
            Cette routine est-elle séparée de la routine pour l'instruction pour une raison inconnue.

$2acb       Lit l'expression pointée par HL
$2ace       Sauve le pointeur vers le texte BASIC.
$2acf       Récupère la valeur sous forme entière positive dans DE.
$2ad2       Restaure le pointeur vers le texte BASIC.

$2ad4       [acq_key]
            $SECTION(te)
            Décode une touche du clavier.
            
            Affiche sa valeur à l'écran en traitant les touches spéciale.
            Dans le cas d'un traitement pour la commande INPUT, ignore certaines touches.

            Si une touche a été traitée, provoque un rafraichissement de l'écran.

            Sortie :
            - A est à 0 si aucune touche n'a été appuyée ou si elle a été traitée.
            - Quelques touches spéciales n'ont pas l'air d'être traitées et sont alors renvoyées dans A. Lesquelles ???

            == DEBUT DE SECTION TE (TEXT EDITOR) ==

$2ad4-$2ad6 Sauve BC, DE et HL sur la pile.
$2ad7-$2adc Branche si la ligne n'est pas entrée depuis le BASIC. (depuis un INPUT ???)
$2adf       Attente d'une interruption
$2ae0       Décode une touche du clavier.
$2ae3-$2ae4 Branche si aucun caractère n'a été validé.
$2ae6       Sauve AF
$2ae7       Bascule sur les registres alternatifs.
$2ae8-$2aeb Configure le son émis lors de l'appuie d'un caractère.
$2aee       Pendant une durée très courte.
$2af1       Émet le son.
$2af4-$2afb Indique qu'un caractère a été entré depuis une interaction en BASIC.
            Pourquoi les deux NOPs ???
$2afe       Restaure AF
$2aff       Branche si la touche validée était une touche de fonction.
$2b02       Comparaison de la touche appuyée avec la touche Entrée.
$2b04       Il s'agit de code patché par rapport à la ROM 1.0, on branche donc plus loin avant de revenir juste après.

$2b07       [acq_key_3]
            Suite du traitement de l'appuie de touche, si la boucle BASIC est active.

$2b07-$2b09 Branche pour traiter la touche Tab.
$2b0c-$2b0e Branche pour traiter la touche Saut de ligne.
$2b11-$2b13 Branche pour traiter la touche Saut de page.
$2b16       Poursuit le traitement de l'acquisition d'une touche appuyée.

$2b19       Octet inutilisé

$2b1a       [key_effe]
            La touche EFFE a été appuyée
$2b1a-$2b1f Branche si la drapeau de commande INPUT est activé.
$2b21       Sinon, remet la valeur $1f dans la touche appuyée.

$2b23       [acq_key_7]
$2b23       Au final, la touche appuyée est émise vers le périphérique sélectionné.

$2b24       [acq_sync]
$2b24-$2b2c Force un affichage à la prochaine interruption et attend la prochaine interruption.

$2b2d       [key_nul_ret]
            Efface la valeur de la touche activée.
            
            La touche a été soit affichée, soit traitée en tant que touche spéciale,
            soit est annulée car la touche n'a pas d'effet (dans une commande INPUT par exemple).

$2b2e       [key_acq_end]
$2b2e-$2b31 Restaure les registres. D'où viennent les branchements directs ici ??? Toujours d'un traitement de touche ?

$2b32       [bufferstart]
            Avant l'acquisition d'une touche de clavier, si une ligne a été validée, cette routine est exécutée.

            À l'air de se positionner sur le premier caractère interessant à décoder ???
$2b32       Coordoonées de la ligne BASIC à décoder. H contient la ligne à l'écran, L est à 0.
$2b35       Copie du numéro de ligne dans A.
$2b36-$2b38 Branche si le numéro de ligne est 24 ou plus (la dernière ligne de l'écran)
$2b3a       Sauve les coordonnées de la ligne.
$2b3b-$2b3e Lecture du caractère en colonne 0 de la ligne suivante
$2b41       Restaure les coordonnées de la ligne.
$2b42       Branche si le caractère lu était $84.
$2b44       [if_line_24]
$2b44-$2b47 Branche si la colonne est 40 ou plus (la colonne la plus à droite est 39)
$2b49       [if_char_84]
$2b49       Sauve les drapeaux ???
$2b4a-$2b4d Branche si la colonne est 38 ou moins.
$2b4f-$2b50 Coordonnées sur la ligne suivante, première colonne.

$2b52       [if_less_39]
$2b52       Avance d'une colonne (la colonne 0 n'est pas utilisée par l'éditeur)
$2b53       Enregiste les nouvelles coordonnées.
$2b56       Et les sauve sur la pile.
$2b57-$2b5a B contient le caractère aux nouvelles coordonnées.
$2b5b       DE contient les nouvelles coordoonées.
$2b5c       Récupère les drapeaux de comparaison (de quoi ???)
$2b5d       A contient le caractère lu aux coordonnées.
$2b5e       Branche si quoi ???
$2b60       %CHAR
$2b60-$2b62 Branche si ce n'est pas un espace.
$2b64       [loop2B64]
$2b64       Incrémente la colonne.
$2b65       Place la colonne dans A.
$2b66-$2b68 Branche si la colonne est 40 ou plus.
$2b6a-$2b6b Positionne les coordonnées deux octets plus loin, donc sur le prochain caractère.
$2b6d       %CHAR
$2b6c-$2b6f Boucle si le caractère est un espace.
$2b71       %CHAR
$2b71       Sinon, on pointe sur un caractère qui n'est pas un espace. Place un espace dans A
$2b73       Et continue vers ???

$2b75       [if_col_40]
$2b75-$2b7a Remet l'indicateur de ligne entrée en BASIC à 0 .
$2b7d-$2b82 Branche si le bit 8 de `(entstt)` est à 1.
$2b84       %CHAR
$2b84-$2b86 Branche si `(entstt)` est un espace.
$2b88       %CHAR
$2b88-$2b8a Branche si le caractère est avant `0`.
$2b8c       %CHAR
$2b8c       ---
$2b8e       Branche si le caractère est au-delà de '9'
$2b90       [spc_or_dgt]
$2b90-$2b95 Branche si la colonne du curseur actuelle est 1
$2b97       [jump2B97]
$2b9a       ---
$2b9c       [skip2B9C]
$2b9f       ---
$2ba1       [not_digit]
$2ba4       ---
$2ba6       ---
$2ba7       [acquired_cr]
$2ba9       ---
$2bac       [specialchars]
$2bae       ---
$2bb0       ---
$2bb2       [skip2BB2]
$2bb4       ---
$2bb6       ---
$2bb8       [skip2BB8]
$2bba       ---
$2bbc       ---
$2bbe       [skip2BBE]
$2bc0       ---
$2bc2       ---
$2bc4       [skip2BC4]
$2bc6       ---
$2bc8       ---
$2bca       [skip2BCA]
$2bcc       ---
$2bce       ---
$2bd0       [skip2BD0]

$2bd3       [ret_to_cnt]
            Retours chariots jusqu'à trouver $84 dans la première colonne.

$2bd3-$2bd5 Envoie d'un retour à la ligne ($03 à la même effet que $0d ???)
$2bd6       Charge les coordonnées du curseur dans HL
$2bd9       Colonne précédente.
$2bda       Récupère le caractère.
$2bdd       Branche si le caractère est $84
$2bdf       Sinon retour.

$2be0       [ifcr]
            Récupération des coordonnées du curseur
$2be3       [find_start_l]
            Décrémentation de X
$2be4       Sauvegarde des coordonnées modifiées du curseur
$2be5       ---
$2be8       Récupération des coordonnées
$2be9       Comparaison à $80, la caractère de début de ligne
$2beb       ---
$2bed       ---
$2bef       ---
$2bf1       Recherche du caractère de continuation ? ($B4)
$2bf3       Boucle sur la recherche
$2bf5       [linestart]
$2bf6       ---
$2bf7       Si on n'était pas sur la colonne 0, c'était une fausse alerte et non un vrai début de ligne, on continue à chercher.
$2bf9       ---
$2bfa       ---
$2bfd       ---
$2bfe       Si on n'est pas en mode auto, on continue le traitement de la ligne.
$2c00       ---
$2c01       Sinon, le mode AUTO est annulé
$2c04       L'adresse du curseur mis à jour
$2c07       ---
$2c09       Le marqueur $84 (re)mis? en place
$2c0a       Et la touche acquise sera validée comme étant $0D (sans traitement)
$2c0d       [find_cont]
            Traitement lors d'une continuation trouvée au début de la ligne
$2c0f       [find_start]
            Remonte de ligne en ligne jusqu'au premier marqueur de non continuité (et donc à la première ligne).
$2c12       ---
$2c13       ---
$2c14       Peek du caractère en colonne 0
$2c17       ---
$2c18       Test sur $84, qui est le marquage de continuité des lignes. Saut lorsqu'on ne le trouve plus. On est en tout début du ligne.
$2c1a       ---
$2c1b       Saute si on est arrivé en haut de l'écran (H est passé à $FF)
$2c1e       Boucle sur la remontée des Y
$2c20       [found_start]
            Coordonnées placées en début de la première ligne
$2c23       Test de INPUT activé
$2c25       Traitement spécifique si le monitor était en train de traiter un INPUT
$2c27       ---
$2c28       ---
$2c29       ---
$2c2a       ---
$2c2b       ---
$2c2c       Recupération des coordonnées de début d'entrée
$2c2f       ---
$2c30       ---
$2c33       DE contient les coordonnées de début d'entrée. HL l'adresse mémoire
$2c34       [loop2C34]
$2c35       Comparaison de X avec la colonne 40
$2c37       ---
$2c39       ---
$2c3a       ---
$2c3b       ---
$2c3c       ---
$2c3d       ---
$2c3f       ---
$2c41       ---
$2c45       ---
$2c47       [skip2C47]
$2c49       ---
$2c4b       [ifinput]
$2c4e       [skip2C4E]
            Enregistrement du premier caractère de la ligne ($80 en mode direct)
$2c51       ---
$2c54       ---
$2c56       Set du flag pour "ligne entrée en BASIC"
$2c59       ---
$2c5c       ---
$2c5d       Placement des coordonnées sur le caractère en colonne précédente (donc 0?)
$2c60       [screenstart]
            La fonction sortira avec pour valeur acquise NUL.
$2c63       [iftab]
$2c66       ---
$2c67       ---
$2c69       ---
$2c6c       ---
$2c6e       ---
$2c71       ---
$2c75       ---
$2c78       ---
$2c7c       ---
$2c7d       ---
$2c7e       ---
$2c81       ---
$2c84       [skip2C84]
$2c86       ---
$2c89       [iflinef]
$2c8c       ---
$2c8e       ---
$2c91       ---
$2c94       ---
$2c96       ---
$2c99       ---
$2c9d       ---
$2c9e       ---
$2ca1       ---
$2ca4       ---
$2ca7       [jump2CA7]
$2caa       [jump2CAA]
$2cac       ---
$2caf       [ifformf]
$2cb2       ---
$2cb4       ---
$2cb7       ---
$2cb8       ---
$2cba       [jump2CBA]
$2cbb       ---
$2cbc       ---
$2cbd       ---
$2cbe       ---
$2cbf       ---
$2cc0       ---
$2cc1       ---
$2cc5       ---
$2cc6       ---
$2cc9       ---
$2cca       [skip2CCA]
$2ccb       ---
$2ccd       ---
$2cd0       ---
$2cd4       ---
$2cd8       ---
$2cdb       ---
$2cde       ---
$2ce1       ---
$2ce5       ---
$2ce8       ---
$2ce9       ---
$2cea       [loop2CEA]
$2ced       ---
$2cef       ---
$2cf2       ---
$2cf4       ---
$2cf6       ---
$2cf9       ---
$2cfb       [skip2CFB]
$2cfc       ---
$2cfe       ---
$2cff       ---
$2d01       [skip2D01]
$2d04       [skip2D04]
$2d07       ---
$2d0a       [call2D0A]
$2d0b       ---
$2d0c       ---
$2d0d       ---
$2d0e       ---
$2d0f       ---
$2d10       ---
$2d13       ---
$2d14       ---
$2d15       ---
$2d16       ---
$2d17       ---
$2d18       ---
$2d19       ---
$2d1c       ---
$2d1e       ---
$2d1f       [jump2D1F]
$2d20       ---
$2d23       ---
$2d25       ---
$2d28       [loop2D28]
$2d29       ---
$2d2a       ---
$2d2c       ---
$2d2e       ---
$2d2f       ---
$2d30       ---
$2d31       ---
$2d32       ---
$2d33       ---
$2d34       ---
$2d35       ---
$2d36       ---
$2d37       ---
$2d3a       ---
$2d3b       ---
$2d3d       [skip2D3D]
$2d3e       ---
$2d41       ---
$2d44       ---
$2d46       ---
$2d47       ---
$2d4a       ---
$2d4c       ---
$2d4e       ---
$2d52       [jump2D52]
$2d53       ---
$2d54       ---
$2d55       ---
$2d58       ---
$2d59       ---
$2d5c       [jump2D5C]
$2d5e       ---
$2d5f       ---
$2d62       ---
$2d64       ---
$2d67       ---
$2d68       ---
$2d69       ---
$2d6a       ---
$2d6d       ---
$2d70       [jump2D70]
$2d71       [jump2D71]
$2d75       ---
$2d76       [func_keys]
$2d78       Saute si la valeur est inferieure à $ba
$2d7b       ---
$2d7d       Saute si la valeur est supérieure ou égale à $fb
$2d80       ---
$2d83       [loop_accel]
            Recherche la valeur de la touche d'accélération dans le tableau
$2d84       ---
$2d85       ---
$2d87       [out_accel]
            Provoque l'affichage de la chaîne accélérée (raccourci BASIC)
$2d88       ---
$2d8a       Lorsque le bit de poids fort est 1, alors la chaîne est terminée, on sort.
$2d8d       Affichage du caractère de la chaîne en train d'être affichée.
$2d8e       ---
$2d8f       ---

$2d91       [ctrl_keys]
            Traitement des touches de contrôle (des touches de contrôle ?)
$2d91       ---
$2d93       ---
$2d94       ---
$2d96       ---
$2d99       ---
$2d9a       A est remplacé par la valeur trouvée dans la table d'indirection à 10 entrée en $487a (comment est-elle remplie ?)
$2d9b       ---
$2d9e       [accel_keys]

$2ead       [mem_move_chk]
            $SECTION(bimisc)
            Fonction : vérify la mémoire
            Entrée : DE < BC < HL trois pointeurs de mémoire
            Copie la zone [DE, BC] vers [DE+(HL-BC), HL] depuis la fin (permet le recouvrement)
$2ead       ---
$2eb0       [mem_move]
            Mise sur la pile de la taille
$2eb1       ---
$2eb2       Échange des valeurs de HL et BC
$2eb3       [cpy_loop]
            Préparation de la comparaison entre HL et DE
$2eb4       ---
$2eb5       Copie de (HL) vers (BC)
$2eb6       Retour si HL a atteind DE
$2eb7       ---
$2eb8       Décrément de HL et BC
$2eb9       Boucle de la copie

$2ebb       [stk_verify]
            Entrée : BC (B == 0), le nombre de mots de 2 octets (des "niveaux" que l'on voudrait mettre sur la pile
            S'il n'y a pas la place demandée sur la pile, provoque un message d'erreur.
            La place vérifiée semble être deux fois la place demandée avec une marge de $60 octets (jamais moins
            de $60 octets disponibles)
            Préserve HL.
            
            MS_BASIC=CHKSTK
$2ebb       Sauve le pointeur d'exécution
$2ebc       Prend la mémoire la plus basse disponible (après les chaînes?)
$2ebf       ---
$2ec1       ---
$2ec2       Ajoute deux fois l'entrée C à strend
$2ec3       ---

$2ec4       [mem_verify]
            Identique à stk_verify mais fourni HL pour comparer avec la pile.
            
            MS_BASIC=ENFMEM
$2ec4       ---
$2ec5       ---
$2ec7       ---
$2ec8       ---
$2ec9       ---
$2ecb       ---
$2ecc       HL <- $FFA0 - HL (HL étant (strend) + 2 * C)
$2ecd       S'il n'y a pas au moins $60 octets entre la valeur désirée et $FFFF, alors il n'y a plus de mémoire (oui, c'est en dur quelque soit la mémoire présente, c'est louche)
$2ecf       ---
$2ed0       Restore dans HL le pointeur d'exécution
$2ed1       Si HL + SP provoque une retenue, alors on revient, il y a assez de mémoire. Sinon, c'est qu'il y a moins de $60 octets entre la pile et (strend), il n'y a pas assez de mémoire.
$2ed2       [out_of_mem]
$2ed5       "Out of Memory"
$2ed8       ---

$2ed9       [reset_prog]
            Met 0 dans les deux premiers octets de txttab (donc efface l'accès au listing)
            L'effet sur l'utilisateur est d'effacer le programme (mais il est encore là)
            
            MS_BASIC=CLRPTR
$2ed9       ---
$2edc       [reset_prog_2]
            appelé depuis l'instruction NEW
$2edd       ---
$2ee0       [reset_prog_4]
$2ee1       txttab+2 dans (vartab)
$2ee4       [reset_vars]
            Remet à zéro les pointeurs du modèle mémoire
$2ee7       HL pointe sur l'octet avant txttab
$2ee8       [init_vars]
            HL est mis de côté ; MS_BASIC=INTVAR
$2eeb       HL prend la valeur de memsiz
$2eee       fretop est donc mis à memsiz, cela signifie que toute la mémoire est disponible.
$2ef1       ---
$2ef2       ---
$2ef5       (vartab) est placé dans (arytab) et (strend). Autrement dit, élimine toutes les variables, les tableaux et les chaînes.
$2ef8       ---
$2efb       ---

$2efe       [clear_regs]
            Fonction : remise à zéro de la pile et effacement de l'interprétation en cours. Réinitialisation de l'imprimante.
            Retour : HL contient le code de l'instruction en cours ?
            
            MS_BASIC=CLREG
$2efe       Récupération de l'adresse de retour
$2eff-$2f02 Réinitialisation de la pile (SP) à la dernière adresse RAM valide
$2f03-$2f06 Le pointeur sur la zone temporaire de descripteur est initialisé vers le buffer de construction de chaînes.
$2f09       Mise à zéro de l'état de l'imprimante.
$2f0c-$2f0e HL et A à 0
$2f0f       Mise à zéro de registre `oldtxt`, pointeur vers l'ancien text (???)
$2f12       Mise à zéro du registre `subflg`, utilisé pour FOR.
$2f15       Mise à zéro du nom du paramètre pour les fonctions utilisateurs.
$2f18       Met 0 sur la pile
$2f19       Remet l'adresse de retour sur la pile avant le RET

$2f1a       [do_again]
            %MS_BASIC(DOAGN)
            Récupère le pointeur d'exécution de l'instruction en court puis termine l'instruction
            en court. A priori pour la relancer (appelée depuis INPUT en cas de Redo from Scratch)
            A tracer depuis le reset qui précède et depuis INPUT (???)
            
$2f1a       HL est chargé avec la valeur de `temp`, qui contient l'adresse d'exécution d'une commande.
            Qu'est-ce qu'il y a au boot ???

$2f1e       [inst_restore]
            %CODE
            Instruction : RESTORE
            
            MS_BASIC=RESTORE
$2f1e       ---
$2f1f       ---
$2f22       Pas de paramètre, on restore depuis le début du programme
$2f24       ---
$2f25       ---
$2f28       ---
$2f29       ---
$2f2c       ---
$2f2d       ---
$2f2e       ---
$2f2f       Si le numéro de ligne spécifié n'est pas trouvé, erreur
$2f32       [restore_all]
            MS_BASIC=RESTNL
$2f33       [set_data]
            MS_BASIC=UPDATA
            Sauvegarde de l'octet de la prochaine ligne de DATA
$2f36       ---
$2f37       ---
$2f38       [inst_stop]
            %CODE
$2f39       ---
$2f3a       [inst_end]
            %CODE
$2f3b       ---
$2f3e       ---
$2f3f       [input_brk]
$2f41       Enlève l'adresse de retour des instructions. Le programme est terminé

$2f42       [end_of_prog]
            Traite la fin d'un programme
            
            MS_BASIC=ENDPRG
$2f42       ---
$2f45       Sauve le status de l'arrêt. STOP a mis A <- $C0, BREAK a mis A <- $FF, et END ?
$2f46       ---
$2f47       ---
$2f48       ---
$2f49       Si la dernière ligne était FFFF, alors le A est égal à 0, saut. Nous étions en mode direct.
$2f4b       Sauve la dernière ligne exécutée si elle avait un numéro
$2f4e       ---
$2f51       Sauve le dernier pointeur d'exécution concernant une ligne avec numéro. Utile pour CONT
$2f54       [no_line]
            Nouvelle ligne sur la sortie (et l'imprimante?)
$2f57       ---
$2f5a       Récupére AF... sans intérêt, on le push juste après sans rien en faire. A est écrasé par la langue et F par le test. (!!)
$2f5b       Chargement du texte pour l'arrêt
$2f5e       Remise dans la pile de AF...
$2f5f       Chargement de la langue du système.
$2f62       ---
$2f63       ---
$2f65       ---
$2f68       [break_fr]
$2f69       Si A était à zéro, il s'agissait d'un arrêt de programme normal, sinon, au saute à l'affichage de message d'arrêt.
$2f6c       Boucle sur l'affichage "Ok!"
$2f6f       [inst_cont]
            %CODE
$2f72       ---
$2f73       ---
$2f74       ---
$2f77       Sors avec l'erreur "Cannot continue"
$2f7a       ---
$2f7e       ---
$2f82       ---
$2f83       ---

$2f98       [a_to_z]
            Vérification que le caractère pointé par HL est entre A et Z inclus.
            Dans le cas contraire, lève le drapeau de retenu.
$2f98       ---
$2f99       [a_to_z_2]
            Appelé ici lorsque A contient déjà la caractère à vérifier
$2f9b       ---
$2f9c       ---
$2f9e       ---
$2f9f       ---

$2fa0       [inst_clear]
            %CODE
            Instruction : CLEAR
$2fa0       Si pas d'argument, initialise les variables avec les valeurs courantes
$2fa3       Récupère un premier paramètre entre 0 et 32768
$2fa6       ---
$2fa7       Prend le caractère suivant
$2fa8       Sauve le pointeur d'exécution
$2fa9       HL prend la dernière adresse mémoire disponible.
$2fac       Si pas de deuxième paramètre (le chget a renvoyé 0), alors on continue plus loin
$2fae       ---
$2faf       Vérifie que le caractère lu est bien une virgule
$2fb0       data -> ','
$2fb1       Sauve le premier paramètre
$2fb2       Décode le second paramètre (de -32768 à 32767)
$2fb5       ---
$2fb8       ---
$2fb9       Lit le caractère suivant.
$2fba       S'il n'est pas nul, c'est une erreur de syntaxe
$2fbd       Le pointeur d'exécution va sur la pile et on récupère le premier paramètre dans HL
$2fbe       Le premier paramètre est dans DE, le second dans HL.

$2fbf       [clr_stored]
            Le premier paramètre est dans DE, le second dans HL, qui est (memsiz) si on est venu sans second paramètre spécifié.
            
            MS_BASIC=STORED
$2fbf       Appel qui pourrait être inliné... (!!!)
$2fc2       Si HL - DE est négatif, alors erreur de mémoire
$2fc5       Sauvegarde de l'adresse mémoire haute (second paramètre)
            HL prend la valeur de (vartab), l'adresse de fin de programme BASIC stocké.
$2fc6       ---
$2fc9       En vrai, LD BC,$28 (== 40) (taille minimale voulue)
$2fcc       ---
$2fcd       Comparaison de (vartab) + $28 et de DE, qui contient la plus haute mémoire réduire de la taille pour les chaînes
$2fce       S'il n'y a pas assez de mémoire, le signaler.
$2fd1       ---
$2fd2       Stockage de HL (venant de DE) comme nouveau (stktop)
$2fd5       ---
$2fd6       Stockage de HL (venant de la pile) comme neaucou (memsiz)
$2fd9       On pop quoi ??? L'adresse de retour car on jump ?
$2fda       Saut à l'initialisation des variables.

$2fdd       [top_string]
            Soustraction du second paramètre (la mémoire haute) par la taille
            pour les chaînes demandée.
            À la fin, HL n'est pas touché, et DE contient HL - (taille demandée)
$2fdd       ---
$2fde       ---
$2fdf       ---
$2fe0       ---
$2fe1       ---
$2fe2       ---
$2fe3       ---
$2fe4       [inst_next]
            %CODE
$2fe7       [call2FE7]
$2fea       ---
$2fed       ---
$2ff0       ---
$2ff3       ---
$2ff4       ---
$2ff5       ---
$2ff6       ---
$2ff7       ---
$2ff8       ---
$2ff9       ---
$2ffc       ---
$2ffd       ---
$2ffe       ---
$3001       ---
$3002       ---
$3005       ---
$3006       ---
$3009       ---
$300a       ---
$300d       ---
$300e       ---
$300f       ---
$3010       ---
$3013       ---
$3015       ---
$3016       ---
$3019       ---
$301a       ---
$301b       ---
$301e       [skip301E]
$301f       ---
$3022       ---
$3023       ---
$3025       ---
$3028       ---
$3029       ---

$302c       [str_hex_dec]
            Transforme un nombre de la forme &"xxxx" en FP.
            
            MS_BASIC=HEXTFP
$302c       ---
$302d       Vérifie que le début du nombre (après le '&'), est un '"'
$302e       %DATASKIP
$3030       ---
$3031       ---
$3032       Compteur de chiffres maximum (4 chiffres max, la boucle djnz sort lorsque B est décrémenté à 0)
$3034       Positionnement du pointeur d'execution.
$3035       [hex_fetch]
            Va chercher un chiffre Hexa
$3038       Saute si ce n'était pas un chiffre Hexa
$303a       Temporairement sauve HL dans DE, qui contient l'accumulateur des valeurs
$303b       ---
$303c       ---
$303d       ---
$303e       HL (l'accumulateur) est décalé de 4 vers la gauche.
$303f       A est ajouté dans les 4 bits de poids faible
$3040       Remis dans l'accumulateur
$3041       Remise en place de DE=accumulateur et HL=pointeur
$3042       Si le compteur de chiffres n'est pas encore à zero, on repart pour un tour.
$3044       [not_hexa]
            Vérification que le caractère est '"' (en cas d'arrivée par caractère non hexa, on peut voir que &"" est valide et égal à 0)
$3046       Si ça n'est pas le cas, c'est une erreur de syntaxe.
$3049       On lit (puis ignore) le caractère suivant
$304a       ---
$304c       Sauvegarde du pointeur d'exécution.
$304d       B (exp) = $98, A == 0 et DE contient l'entier lu. Le tout est monté dans FP
            Ici, on ignore le caractère qui vient d'être lu
$304e       ---
$3051       Restauration du pointeur d'exécution.
$3052       ---
$3053       ---
$3058       [inst_renum]
            %CODE
$305b       ---
$305c       ---
$305d       ---
$305e       ---
$3060       ---
$3062       ---
$3064       ---
$3065       ---
$3068       ---
$3069       ---
$306a       ---
$306b       ---
$306d       [skip306D]
$306e       ---
$306f       ---
$3072       ---
$3074       ---
$3075       ---
$3076       ---
$3077       ---
$3078       ---
$307b       ---
$307e       ---
$307f       ---
$3080       ---
$3083       ---
$3084       ---
$3085       ---
$3086       [skip3086]
$3087       ---
$308a       ---
$308b       ---
$308c       ---
$308d       ---
$3090       ---
$3091       ---
$3092       ---
$3093       ---
$3094       ---
$3095       ---
$3098       ---
$3099       ---
$309a       ---
$309b       ---
$309c       ---
$309d       ---
$309f       [loop309F]
$30a0       ---
$30a3       ---
$30a4       ---
$30a5       ---
$30a8       ---
$30a9       ---
$30aa       ---
$30ad       [skip30AD]
$30ae       ---
$30af       ---
$30b0       ---
$30b1       ---
$30b2       ---
$30b3       ---
$30b4       ---
$30b5       ---
$30b7       ---
$30b8       ---
$30b9       ---
$30ba       ---
$30bb       ---
$30bc       ---
$30be       [skip30BE]
$30bf       ---
$30c2       ---
$30c3       ---
$30c4       ---
$30c5       [loop30C5]
$30c6       ---
$30c7       ---
$30c8       ---
$30c9       ---
$30ca       ---
$30cb       ---
$30cd       ---
$30ce       ---
$30cf       ---
$30d0       ---
$30d1       ---
$30d2       ---
$30d3       ---
$30d4       ---
$30d5       ---
$30d6       ---
$30d7       ---
$30d8       ---
$30da       [skip30DA]
$30dd       ---
$30de       ---
$30df       [call30DF]
$30e0       ---
$30e1       ---
$30e4       ---
$30e7       ---
$30e8       [loop30E8]
$30e9       ---
$30ea       ---
$30eb       ---
$30ec       ---
$30ed       ---
$30ee       ---
$30ef       ---
$30f0       ---
$30f1       [loop30F1]
$30f2       ---
$30f3       ---
$30f5       ---
$30f6       ---
$30f9       ---
$30fa       ---
$30fb       ---
$30fd       ---
$30ff       ---
$3101       ---
$3102       ---
$3103       ---
$3104       ---
$3105       ---
$3106       ---
$3107       ---
$3108       ---
$310b       ---
$310c       ---
$310e       ---
$3110       ---
$3113       ---
$3116       ---
$3119       ---
$311a       ---
$311c       ---
$311f       [skip311F]
$3120       ---
$3123       ---
$3124       ---
$3127       ---
$312a       ---
$312d       ---
$312e       ---
$3130       ---
$3133       [skip3133]
$3136       ---
$3137       ---
$3138       ---
$3139       ---
$313a       ---
$313d       ---
$313e       ---
$313f       ---
$3140       [loop3140]
$3142       [skip3142]
$3144       ---
$3146       ---
$3147       ---
$3148       ---
$314a       [skip314A]
$314c       ---
$314e       ---
$314f       ---
$3150       ---
$3151       ---
$3152       ---
$3153       ---
$3154       ---
$3155       ---
$3156       ---
$3157       ---
$3158       ---
$3159       ---
$315a       ---
$315b       ---
$315c       ---
$315e       [skip315E]
$3161       ---
$3162       ---
$3165       ---
$3166       ---
$3167       ---
$3168       ---
$3169       ---
$316a       ---
$316b       ---
$316c       ---
$316d       ---
$316e       [inst_auto]
            %CODE
$3171       ---
$3172       ---
$3174       ---
$3177       ---
$3178       ---
$3179       ---
$317a       ---
$317d       ---
$317e       ---
$317f       ---
$3180       ---
$3182       ---
$3183       ---
$3184       ---
$3187       ---
$3188       ---
$3189       ---
$318a       ---
$318d       ---
$318e       ---
$3191       ---
$3195       [skip3195]
$3196       ---
$319a       ---
$319c       ---
$319f       [bcode_start]
$31a0       ---
$31a3       [inst_llist]
            %CODE
$31a5       ---
$31a8       [inst_list]
            %CODE
$31ab       ---
$31ae       ---

$31b1       [line_pair]
            Récupère deux arguments de type numéro de ligne et les sauve dans (temp) et (sonsav_hi).
            Le premier numéro de ligne (trouvé) est retourné dans DE.
$31b1       ---
$31b4       ---
$31b5       Lit le premier caractères du pointeur de ligne
$31b6       Et saute s'il n'y a rien (avec DE à $0000)
$31b8       Compare avec ','
$31ba       Si ce n'était pas une ',', alors va lire un numéro de ligne (récupéré dans DE)
$31bd       [no_pair_1]
            Sauvegarde du premier numéro de ligne dans 'temp'. $0000 s'il n'y avait pas de premier paramètre.
$31c1       ---
$31c2       Cherche le premier numéro de ligne valide à partir de DE.
$31c5       ---
$31c6       Pousse dans la pile le premier numéro de ligne valide après celui demandé.
$31c7       ---
$31c8       ---
$31c9       Saute s'il n'y a pas de second numéro de ligne.
$31cb       ---
$31cd       Si le caractère suivant n'était pas une ',', alors c'est une erreur de syntaxe.
$31d0       ---
$31d1       Sinon, récupération du deuxième argument comme un numéro de ligne.
$31d4       Si ce n'était pas un numéro de ligne valide, c'est une erreur de syntaxe.
$31d7       ---
$31d8       ---
$31d9       Si ce numéro n'était pas nul, on saute à la fin de la routine pour enregistrement.
$31db       [no_pair_2]
            Par défaut, le dernier numéro de ligne est $ffff
$31de       [save_pair_2]
            Sauvegarde du dernier numéro de ligne dans 'sonsav_hi'
$31e2       Le premier numéro de ligne (valide) est récupéré dans DE.
$31e3       ---

$31e4       [prt_list]
            Routine d'affichage d'un LISTING
$31e4       ---
$31e6       ---
$31e9       ---
$31ea       [jump31EA]
$31eb       ---
$31ec       ---
$31ed       ---
$31ee       ---
$31ef       ---
$31f0       ---
$31f1       ---
$31f4       ---
$31f6       ---
$31f8       ---
$31f9       [loop31F9]
$31fc       ---
$31fd       ---
$31ff       [loop31FF]
$3202       ---
$3205       ---
$3206       ---
$3208       ---
$3209       [skip3209]
$320a       ---
$320b       ---
$320c       ---
$320d       ---
$3210       ---
$3211       ---
$3212       ---
$3213       ---
$3214       ---
$3218       ---
$3219       ---
$321a       ---
$321b       ---
$321e       ---
$3220       ---
$3221       ---
$3224       ---
$3225       ---
$3228       ---
$322c       ---
$322d       [jump322D]
$322e       [loop322E]
$322f       ---
$3230       ---
$3232       ---
$3234       ---
$3236       ---
$3237       ---
$3238       ---
$3239       ---
$323a       ---
$323b       ---
$323c       ---
$323d       ---
$323e       ---
$323f       ---
$3240       ---
$3243       ---
$3244       ---
$3246       [skip3246]
$3247       ---
$3249       ---
$324c       ---
$324e       ---
$324f       ---
$3252       ---
$3254       ---
$3256       ---
$325a       [loop325A]
$325b       ---
$325c       ---
$325d       ---
$3260       ---
$3261       ---
$3263       [jump3263]
$3265       ---
$3266       ---
$3267       ---
$3268       ---
$3269       ---
$326c       ---
$326e       [skip326E]
$3272       ---
$3275       ---

$3278       [initscreen]
            $SECTION(co)
            Réinitialisation du curseur, d'attributs
            Redéfinition de deux caractères: $20 et $7F
            Efface l'écran, remise en colonne 1
$3278       Deux accès à $47FD pour set les bits 4 et 6
$327c       Test du bit zéro sur $47FE (majuscules\minuscules)
$3280       ---
$3284       ---
$3286       Changement de l'aspect du curseur si minuscules
$328a       [skip328A]
$328d       ---
$328f       ---
$3292       [initscreen2]
$3295       ---
$3297       [init_cls]
            Efface l'écran avec la couleur de fond passée dans A.

            Entrée :
            - A contient la valeur pour le registre `attbak`.

$3297       Met la valeur de A dans le registre `attbak` (couleur de fond texte et graphique)
$329a       Efface l'écran BASIC.
$329d       [cur_home]
$329d       HL contient les coordonnées du curseur.
$32a0       Place les coordonnées du curseur en haut à droite de l'écran
$32a3-$32a7 Force le rafraichissement écran à l'interruption suivante.
$32ab       Et attend le prochain rafraichissement.

$32ad       ---

$32b7       [dec_keybrd]
            Décode le clavier et modifie la forme du curseur en fonction de la touche de vérouillage majuscules.

            La routine gère aussi la répétition des touches laissées appuyées.

            Sortie :
            - A contient le caractère appuyé ou 0.
            - Le drapeau Z correspond au contenu de A.
            - Le drapeau M est levé si la touche est une touche de fonction.

$32b7       Échange les registres avec les registres alternatifs.
$32b8       Scan le clavier
$32bb       Branche si une nouvelle touche a été appuyée.
$32bd       Sauve la touche lue dans L
$32be       Teste si  le bit 7 de `repena`. À 0, on est sur la première attente de répétition (longue), à 1, on est sur les attentes suivantes (courtes).
$32c2       Charge dans A la valeur du compteur de répétition.
$32c5       Branche si la répétition est active, pour une attente courte.
$32c8       Sinon, compare le compteur avec `$80`, attente longue.

$32cd       [short_rep]
$32cd       Compare le compteur avec $08, pour une attente courte avant la répétition de la touche.
$32cf       [long_rep]
$32cf       Branche si le compteur est inférieur à la valeur comparée. Le compteur est incrémenté à chaque interruption, qu'il y ait rafraichissement de l'affichage ou pas.
$32d2       Une première répétition de touche a eu lieu, on bascule sur les répétition courtes.
$32d6       Récupération de la touche appuyée.

$32da       [new_key]
$32da       Une nouvelle touche vient d'être appuyée, on bascule sur une répétition longue.
$32de       [new_key_p]
$32de       La touche est validée, le compteur de répétition est mis à 0.
$32e2-$32e4 Branche si la touche appuyée n'est pas la touche de vérouillage majuscule.
$32e6-$32ea Branche si la touche de vérouillage était inactive.
$32ec       Désactive le vérouillage des majuscules.
$32f0       Affichage du curseur en souligné.

$32f6       [set_lock]
$32f6       Active le vérouillage des majuscules.
$32fa       Affichage du curseur en forme pleine.

$32fe       [lock_key]
$32fe       Demande un rafraichissement d'écran à la prochaine interruption.

$3304       [not_caps]
$3304-$3308 Branche si le clavier n'est pas en vérouillage majuscule.
$330a-$330c Branche si le caractère lu est inférieur à $61 (début des minuscules)
$330e-$3310 Branche si le caractère lu est supérieur ou égal à $7b (après les minuscules)
$3312       Transforme une minuscule en majuscule.

$3316       [key_era_end]
$3317       [end_dec_key]
$3317       Place les drapeaux en fonction de A.
$3318       Revient sur les registres initiaux.

$331a       [sendchar_t2]
$331b       ---
$331c       ---
$331f       La pile contient, en haut, $33c5, puis AF (qui contient le caractère)
$3320       ---
$3322       ---
$3324       ---
$3326       ---
$3328       A est compris entre 128 et 160. La mise à 0 du bit 7 revient à soustraire 128
$332a       ---
$332c       [sdchar_bl80]
            A est inférieur ou égal à 128.
$332e       On vérifie s'il est supérieur à 32
$3330       ---
$3334       Saut si on est en train d'utiliser les caractères utilisateurs
$3336       ---
$333a       Saut si c'est un caractère graphique
$333c       [skip333C]
            Arrivé ici si le caractère était dans [128,160[ (ajusté en [0, 32[ ou un caractère redéfini de numéro inférieur strictement à 32.
$333e       ---
$333f       ---
$3340       ---
$3341       ---
$3342       E = A * 3 (A contient le caractère)
$3343       ---
$3346       ---
$3347       ---
$3348       Branchement sur la table de redirection qui commence en $3362

$3349       [sd_a_ff]
            Partial instruction trick en cascade.
            Les 6 labels suivants chargent A avec une certaine valeur.
            Puis exécutent une série de LD HL avec des valeurs inutiles
            Pour finalement arriver sur 'sdchar_pass'
            
            Cela agit comme un remapping des caractères qui étaient normalement non affichables.
$3349       ---
$334c       [sd_a_0d]
$334f       [sd_a_08]
$3352       [sd_a_04]
$3355       [sd_a_1f]
$3358       [sd_a_03]
$335a       [sdchar_pass]
$335b       $33cd est mis sur la pile pour servir de branchement lors du prochain RET, à la fin de l'émission du caractère.
$335e       ---
$335f       ---
$3362       [sdchar_ind]
            %CODE
$3365       %CODE
$3368       %CODE
$336b       %CODE
$336e       %CODE
$3371       %CODE
$3374       %CODE
$3377       %CODE
$337a       %CODE
$337d       %CODE
$3380       %CODE
$3383       %CODE
$3386       %CODE
$3389       %CODE
$338c       %CODE
$338f       %CODE
$3392       %CODE
$3395       %CODE
$3398       %CODE
$339b       %CODE
$339e       %CODE
$33a1       %CODE
$33a4       %CODE
$33a7       %CODE
$33aa       %CODE
$33ad       %CODE
$33b0       %CODE
$33b3       %CODE
$33b6       %CODE
$33b9       %CODE
$33bc       %CODE
            Fin de la table d'indirection. Caractère 31.
$33bf       ---

$33cd       %CODE
            Cette adresse est forcée dans la pile pour que le RET de l'affichage de caractère passe par là.
            Le rafraichissement de l'écran est demandé et la pile et les registres remis en ordre.
$33cd       ---
$33d1       ---
$33d2       ---
$33d3       ---

$33d4       [carreturn]
            Fonction: traitement Carriage Return
            Traitement de l'affichage du caractère 13 (et 3)
$33d4       ---
$33d7       ---
$33d9       ---
$33da       Saut si 'x' est différent de 1
$33dc       ---
$33df       ---
$33e1       Saut si 'continuation permitted' est à 0
$33e3       Si le curseur est sur la colonne 1 et 'continuation permitted' est à 1, alors la colonne 0 est mise à $80 (attributs par défaut pour l'EF9345)
            Et c'est fini.
$33e6       ---
$33e7       ---
$33e8       ---
$33ea       ---
$33eb       [skip33EB]
$33ed       Le curseur est mis sur la colonne 1 et on enchaîne sur `line_down`

$33f0       [line_down]
            Fonction: amène le curseur une ligne plus bas
            Traitement de l'affichage du caractere 10
$33f0       ---
$33f3       ---
$33f4       ---
$33f6       ---
$33f8       ---
$33fb       ---
$33fd       Si le scrolling est désactivé, on saute
$33ff       ---
$3402       ---
$3404       ---
$3407       ---
$3409       [skip3409]
$340a       ---
$340d       [skip340D]

$340e       [line_up]
            Fonction: amène le curseur une ligne plus haut
            Traitement de l'affichage du caractere 9
$340e       ---
$3411       ---
$3412       ---
$3413       ---
$3415       ---
$3418       ---
$341a       Si le scrolling est désactivé, on saute
$341c       ---
$341f       ---
$3421       ---
$3424       ---
$3426       [skip3426]
$3427       ---
$342a       [skip342A]

$342b       [col_left]
            Fonction : La position du curseur est avancée de 1 vers la gauche
            Traitement de l'affichage du caractere 8
$342b       xcursor est suivi de ycursor. Ce qui fait que H contient 'y' et L contient 'x'
$342e       ---
$342f       ---
$3431       Saut si la colonne du curseur est inférieur strictement à 2
$3433       ---
$3434       [col_l_end]
$3437       ---
$3438       [line_above]
$3439       ---
$343a       On ne fait rien si la ligne du curseur est à zéro
$343b       ---
$343e       Curseur à la dernière colonne
$3440       ---

$3442       [col_right]
            Fonction : La position du curseur est avancée de 1 vers la droite
            Traitement de l'affichage du caractere 7
$3442       ---
$3445       ---
$3446       ---
$3448       Si le curseur est en position 39, on saute
$344a       ---
$344b       [col_r_end]
$344e       ---
$344f       [line_below]
$3450       ---
$3452       On ne fait rien si le curseur est en bas à droite de l'écran.
$3453       ---
$3456       ---
$3458       ---
$345a       [jump345A]
$345d       ---
$345f       ---
$3460       ---
$3463       ---
$3464       ---
$3467       ---
$3468       ---
$3469       ---
$346a       ---
$346b       ---
$346c       ---
$346e       ---
$346f       ---
$3470       ---
$3471       ---
$3473       [loop3473]
$3475       ---
$3476       ---
$3478       ---
$3479       ---
$347a       ---
$347c       ---
$347d       ---
$347e       [loop347E]
$347f       ---
$3480       ---
$3481       ---
$3482       ---
$3483       ---
$3484       ---
$3485       ---
$3486       ---
$3487       ---
$3488       ---
$3489       ---
$348a       ---
$348b       ---
$348c       ---
$348d       ---
$348e       ---
$3491       ---
$3493       [jump3493]
$3494       ---
$3495       ---
$3496       ---
$3497       ---
$349a       ---
$349b       ---
$349d       [if_input]
$349d       Branche si le drapeau de commande INPUT était actif.
$34a0       Sinon, on remet la valeur $06 (Insertion de ligne) pour la valeur de touche appuyée.
$34a2       ---
$34a5       [skip34A5]
$34a7       ---
$34ab       ---
$34ad       ---
$34ae       [skip34AE]
$34af       ---
$34b2       ---
$34b3       [jump34B3]
$34b6       ---
$34b7       ---
$34b9       ---
$34ba       ---
$34bb       ---
$34be       ---
$34bf       ---
$34c2       ---
$34c4       ---
$34c6       ---
$34c8       ---
$34c9       [loop34C9]
$34ca       ---
$34cb       ---
$34cc       ---
$34cd       ---
$34cf       [loop34CF]
$34d0       ---
$34d2       ---
$34d3       ---
$34d4       ---
$34d7       ---
$34d8       ---
$34da       ---
$34db       ---
$34dc       ---
$34df       ---
$34e1       [skip34E1]
$34e2       [jump34E2]
$34e5       ---
$34e7       [jump34E7]
$34e8       ---
$34e9       ---
$34ec       ---
$34ed       ---
$34ee       ---
$34f1       ---
$34f2       ---
$34f3       ---
$34f4       ---
$34f5       ---
$34f6       ---
$34f7       ---
$34fb       ---
$34fd       ---
$34fe       ---
$3501       ---
$3503       [skip3503]
$3505       ---
$3508       [skip3508]
$350b       ---
$350c       ---
$350f       [jump350F]
$3510       ---
$3514       ---
$3516       ---
$3519       ---
$351c       ---
$351e       ---
$3521       ---
$3523       ---
$3524       ---
$3525       ---
$3528       [jump3528]
$352b       ---
$352c       ---
$352d       ---
$352e       ---
$3531       ---
$3532       ---
$3533       ---
$3534       ---
$3535       ---
$3538       ---
$353b       ---
$353c       ---
$353d       ---
$353e       ---
$353f       ---
$3540       ---
$3541       ---
$3543       ---
$3544       ---
$3545       ---
$3546       ---
$3547       ---
$3548       ---
$3549       ---
$354a       ---
$354b       ---
$354c       ---
$354f       [jump354F]
$3552       ---
$3553       ---
$3555       ---
$3558       ---
$3559       ---
$355a       ---
$355b       ---
$355c       ---
$355d       ---
$355f       ---
$3560       ---
$3562       ---
$3563       ---
$3564       ---
$3566       ---
$3568       [skip3568]
$356a       ---
$356e       ---
$3570       ---
$3571       [skip3571]
$3574       ---
$3577       ---

$3578       [peekchar]
            Fonction : récupère le caractère à l'écran aux coordonnées HL dans A
            HL est modifié. A contient le caractère. A est comparé à $84.
$3578       ---
$357b       ---
$357c       ---
$357e       ---
$357f       [jump357F]
$3582       ---
$3583       ---
$3584       ---
$3586       ---
$3588       ---
$358b       ---
$358e       ---
$358f       ---
$3591       ---
$3592       ---
$3593       ---
$3596       ---
$3598       [skip3598]
$359b       ---
$359e       ---
$359f       [clr_scr_btm]
            Fonction : Efface toutes les lignes à partir de la ligne courante jusqu'en bas de l'écran
            Traitement de l'affichage du caractère 31
$35a2       [loop35A2]
$35a3       ---
$35a6       ---
$35a7       ---
$35a8       ---
$35aa       ---
$35ac       ---

$35ad       [scroll_up]
            Fonction: monte le contenu de l'écran d'une ligne par recopie de la mémoire
            La nouvelle ligne a toujours l'ancien contenu
$35ad       ---
$35b0       ---
$35b3       ---
$35b6       ---
$35b8       ---

$35b9       [scroll_down]
            Fonction: descend le contenu de l'écran d'une ligne par recopie de la mémoire
            La nouvelle ligne a toujours l'ancien contenu
$35b9       ---
$35bc       ---
$35bf       ---
$35c2       ---
$35c4       ---

$35c5       [reset_term]
            La fonction réinitialise les bits 2 et 7 de $4871.
            Remet le scrolling (et ligne non entrée sous BASIC (?))
            
            Réinitialise quelques valeurs d'affichage
$35c5       ---
$35c8       ---
$35ca       ---
$35cd       $4804 à 0 : pas de redéfinition de caractères
$35d1       $4002 à 0 : couleur d'encre et fond graphique à zero, texte
$35d5       $47FB à 1 : force un affichage
$35d9       $47FC à 0 : équivalent de DISPLAY 10
$35dd       ---
$35e1       ---
$35e5       ---
$35e6       [honk]
$35e9       ---
$35ec       ---
$35ef       ---
$35f2       ---
$35f3       [jump_ret]
            Cette adresse est utilisée pour sauter à un RET depuis une table d'indirection.
$35f4       [char20]
$35fe       [char7f]
$3609       [str_cmp]
            %CODE,SECTION(bistrs)
            Comparaison entre deux chaînes de caractères.

            MS_BASIC=CMPSTR

            == DEBUT DE SECTION BISTRS (BASIC string handler) ==
$3609       ---
$360a       ---
$360d       ---
$360e       ---
$3610       ---
$3611       ---
$3612       ---
$3613       ---
$3614       ---
$3615       ---
$3616       ---
$3619       ---
$361c       ---
$361d       ---
$361e       ---
$361f       ---
$3620       ---
$3621       ---
$3622       ---
$3623       ---
$3625       ---
$3626       ---
$3627       ---
$3628       ---
$3629       ---
$362a       ---
$362b       ---
$362c       ---
$362d       ---
$362e       ---
$362f       ---
$3630       ---
$3632       ---
$3633       ---

$3636       [inst_str]
            %CODE
$3639       ---
$363c       ---
$363f       ---
$3642       ---
$3645       ---
$3646       [save_str]
            A <- longueur de la chaine
$3647       ---
$3648       ---
$3649       HL positionné sur l'adresse du contenu poussée dans la pile
$364a       Vérification qu'il y a assez de place dans la mémoire de chaines
$364d       Si oui, on lit l'adresse du contenu dans BC
$364e       ---
$364f       ---
$3650       ---
$3651       Création d'un descripteur temporaire
$3654       ---
$3655       ---
$3656       Copie L octets de BC (source) vers DE (destination)
$3659       Pointeur de descripteur de chaine dans DE
$365a       ---
$365b       [str_len_1]
            Construction après vérification d'une chaine de taille 1.
$365d       [ctr_ver_str]
            Construction d'une chaine après vérification de la mémoire disponible

$3660       [crt_str_dsc]
            Fonction: met la longueur de chaîne (A) puis rien (0, pour être sur 16 bits) puis DE (pointeur de chaîne) dans dsctmp
            Entrée: A contient un nombre de caractères (longueur de chaîne), DE le pointeur sur la chaine (sans séparateur de début)
            Sortie: HL pointe sur le buffer temporaire de chaîne, dsctmp
            
            MS_BASIC=CRTMST
$3660       ---
$3663       ---
$3664       ---
$3665       ---
$3666       [de_in_hl]
            Puts DE where HL points to
$3667       ---
$3668       ---
$3669       ---
$366a       ---
$366b       ---

$366c       [out_str_prc]
            Création d'une chaine de caractère depuis la source pointée par HL (dans le pool de string ???)
            
            MS_BASIC=CRTST (Create String?)
$366c       Positionne hl un caractère avant le début de la chaine (à cause du inc hl de la boucle qui suit)
$366d       [str_to_str]
            MS_BASIC=QTSTR
$366f       '"' est dans B puis D
$3670       [direct_str]
            Sauve la valeur courante de HL, la mémoire à parser entre guillemets. Un appel direct ici devra placer ses propres terminateurs dans B et D ; MS_BASIC=DTSTR
$3671       Compteur C de la taille de la chaine à -1
$3673       [loop_str]
$3674       Récupération du caractère dans a
$3675       Incrémentation du compteur de caractères parsés (longueur totale de la chaîne)
$3676       ---
$3677       Si le caractère est 0 (fin de chaîne)
$3679       ---
$367a       Si le caractère est $22 (=34, guillemets) (ou autre terminateur mis dans D)
$367c       Traitement du deuxième terminateur possible
$367d       Tant que l'on traite des caractères normaux
$367f       [create_str]
$3681       Si la lecture s'est terminée par des guillements, on les consomme ("BLA est une chaine valide si en fin de ligne)
$3684       Récupération du pointeur du début de la chaîne dans HL
$3685       ---
$3686       DE contient le début de la chaîne +1 (dont après les guillemets)
$3687       A <- longueur de la chaîne
$3688       Création du pointeur de chaine sur l'espace temporaire
$368b       [cpy_to_pool]
            DE <- espace temporaire
$368e       HL <- espace actuel de traitement de chaine
            Sauve l'adresse de la chaine dans FP
$3691       ---
$3694       ---
$3696       La valeur courante est une chaîne de caractères
$3699       Copie les 4 premiers octets de dsctmp vers HL, qui pointe vers (temppt). Autrement dit, copie la description de chaine temporaire dans le pool de chaine.
$369c       Comparaison avec DE, qui est dsctmp et agit donc comme gardien de fin de buffer (après tempst) (où est initialisé temppt à part au reset de stack ???)
$369d       Mise à jour du pointeur vers le buffer tempst
$36a0       Récupération du pointeur de parsing
$36a1       Lecture du prochain caractère
$36a2       Retour s'il reste de la place dans le buffer tempst
$36a3       ---
$36a6       Lancement de l'erreur "String formula too complex"

$36a9       [sharp_char]
            %CODE
            Afficher une chaîne sans le premier caractère
            
            MS_BASIC=PRNUMS
$36a9       ---

$36aa       [out_str]
            Fonction: Affichage d'une chaîne à l'écran
            Entrée: HL pointe sur la chaîne de caractère terminée par un 0
            
            MS_BASIC=PRS (Print String)
$36aa       ---
$36ad       [out_str1]
            MS_BASIC=PRS1
$36b0       ---
$36b3       ---
$36b4       [prsloop]
            MS_BASIC=PRSLP ; Compte les caractères
$36b5       ---
$36b6       ---
$36b7       ---
$36b8       ---
$36b9       ---

$36bb       [alloc_str_mem]
            Vérifie la place restante pour les chaines, alloue la chaine, lance le GC si nécessaire.
            La place demandée est dans A. À la fin de la routine, DE pointe sur un espace allouée de A
            caractères dans la mémoire dédiée, et (fretop) est ajusté en conséquence. Ainsi, ce n'est
            pas seulement un test mais un test et une allocation.
            Dans ces implémentations, Z est d'abord reset, mais plus tard Set avec un bouclage après GC.
            Si au deuxième passage il n'y a toujours pas assez de mémoire, alors l'erreur est lancée.
            
            MS_BASIC=TESTR
$36bb       Ajuste un flag pour signaler no-GC
$36bc       Annule $f1 qui est pop af
$36bd       [retry_alloc]
            %CODE
$36be       ---
$36bf       Charge le pointeur sur le haut de la stack (et donc juste sous la mémoire réservée pour les chaines)
$36c2       ... dans DE
$36c3       Charge le pointeur sur la plus haute mémoire libre disponible
$36c6       A contient la longueur cherchée.
$36c7       ---
$36c8       Met son inverse dans BC
$36ca       L'ajoute à la plus haute mémoire
$36cb       Ajustement pour le complèment à 2 de la soustraction
$36cc       Compare avec l'adresse DE (adresse minimale possible)
$36cd       Pas assez de mémoire, on lance l'erreur (ou le GC en première tentative)
$36cf       Remise en place de la plus haute mémoire après un GC.
$36d2       HL est positionné sur la première adresse après fretop (la première adresse des chaines avec une allocation de A caractères)
$36d3       ... dans DE (qui est utilisé par save_str par exemple)
$36d4       Restauration de AF
$36d5       ---
$36d6       [out_str_mem]
$36d7       ---
$36da       Sors avec l'erreur "Out of string space"
$36dd       ---
$36de       ---
$36df       ---
$36e2       ---
$36e3       [gc_start]
$36e6       [jump36E6]
$36e9       ---
$36ec       ---
$36ed       ---
$36f0       ---
$36f1       ---
$36f4       ---
$36f8       ---
$36f9       ---
$36fc       ---
$36ff       ---
$3702       [loop3702]
$3706       ---
$3707       ---
$3709       ---
$370a       ---
$370b       ---
$370c       ---
$370d       ---
$3710       ---
$3712       [jump3712]
$3713       [skip3713]
$3717       ---
$3718       ---
$371b       ---
$371e       ---
$371f       ---
$3720       ---
$3721       ---
$3722       ---
$3725       ---
$3728       ---
$3729       ---
$372a       ---
$372c       ---
$372d       ---
$372e       ---
$372f       ---
$3730       ---
$3733       ---
$3734       ---
$3735       ---
$3737       ---
$373a       [jump373A]
$373b       ---
$373d       [call373D]
$373e       ---
$373f       ---
$3740       ---
$3741       ---
$3742       ---
$3743       ---
$3744       ---
$3745       ---
$3746       ---
$3747       ---
$3748       ---
$3749       ---
$374c       ---
$374d       ---
$374e       ---
$374f       ---
$3750       ---
$3751       ---
$3752       ---
$3753       ---
$3754       ---
$3755       ---
$3756       ---
$3757       ---
$3758       ---
$3759       ---
$375a       ---
$375b       ---
$375c       ---
$375d       ---
$375e       ---
$375f       [jump375F]
$3760       ---
$3761       ---
$3762       ---
$3763       ---
$3764       ---
$3765       ---
$3766       ---
$3767       ---
$3768       ---
$3769       ---
$376a       ---
$376b       ---
$376c       ---
$376e       ---
$376f       ---
$3770       ---
$3771       ---
$3772       ---
$3773       ---
$3774       ---
$3777       ---
$377a       ---
$377b       ---
$377c       ---
$377d       ---
$377e       ---
$377f       ---
$3780       ---
$3781       ---
$3784       [str_concat]
$3785       ---
$3786       ---
$3789       ---
$378a       ---
$378d       ---
$378e       ---
$3791       ---
$3792       ---
$3793       ---
$3796       ---
$3797       ---
$3798       ---
$379b       Sors avec "String too long"
$379e       ---
$37a1       ---
$37a2       ---
$37a5       ---
$37a6       ---
$37a9       ---
$37aa       ---
$37ad       ---
$37ae       ---
$37b1       ---
$37b4       ---
$37b7       ---
$37b8       ---
$37b9       ---
$37bc       [call37BC]
$37bd       ---
$37be       ---
$37bf       ---
$37c0       ---
$37c1       ---
$37c2       ---
$37c3       ---
$37c4       ---

$37c5       [copy_str]
            Copie le contenu mémoire d'une taille de L de BC vers DE.
$37c5       ---
$37c6       [move_loop]
$37c7       ---
$37c8       ---
$37c9       ---
$37ca       ---
$37cb       ---
$37cc       ---

$37ce       [get_string]
            Vérifie le type courant comme étant un chaine, puis fallthrough dans la récupération de la chaine
            
            MS_BASIC=GETSTR
$37ce       ---

$37d1       [GSTRCU]
            MS_BASIC=GSTRCU (Current string to pool)
$37d1       ---
$37d4       [call37D4]
$37d5       [call37D5]
$37d8       ---
$37d9       ---
$37da       ---
$37db       ---
$37dc       DE <- BC, l'adresse de la chaine de caractères
$37dd       ---
$37de       C contient la taille de la chaine de caractères
$37df       ---
$37e2       ---
$37e3       ---
$37e5       ---
$37e6       ---
$37e7       ---
$37ea       [skip37EA]
$37eb       ---

$37ec       [bc_from_tmp]
            Récupère dans BC une adresse contenue dans l'adresse juste avant le pointeur (temppt)
            Si en remontant encore de deux adresse ou tombe sur DE, alors on met à jour (temppt) avec cette nouvelle adresse.
            Sinon, on retourne.
            Quoi qu'il arrive, avec BC
$37ec       ---
$37ef       ---
$37f0       ---
$37f1       ---
$37f2       ---
$37f3       ---
$37f4       ---
$37f5       ---
$37f6       ---
$37f7       ---
$37fa       ---

$37fb       [inst_len]
            %CODE
            Instruction BASIC len()
            
            MS_BASIC=LEN
$37fb       Adresse de retour qui renvoie l'entier qui est dans A
$37fe       ---
$37ff       [fetch_str]
$3802       C contient la longueur de la chaine de caractères, utilisées par certaines routines appelantes.
$3803       ---
$3804       C'est une valeur numérique
$3807       HL pointe vers la longueur de chaine, qui est donc mise dans A pour valeur de retour
$3808       ---
$3809       ---

$380a       [inst_asc]
            %CODE
            Fonction BASIC ASC()
            Et sous routine pour pointer DE vers l'adresse de la chaine (indirection) avec le première caractère dans A.
            La fonction change la valeur de retour vers la routine qui met le résultat de A dans FAC. Ce qui fait un transtypage ASCII -> VALEUR ENTIERE
$380a       ---
$380d       ---
$380e       [str_to_de]
$3811       Saute si la longueur de la chaine est 0.
$3814       ---
$3815       ---
$3816       ---
$3817       ---
$3818       DE <- pointeur sur la chaine
$3819       A <- le premier caractère de la chaine, qui est aussi le résultat en numérique
$381a       ---
$381b       [inst_chr]
            %CODE
$381e       ---
$3821       ---
$3824       ---
$3825       ---
$3826       ---
$3829       [inst_left]
            %CODE
$382c       ---
$382d       [loop382D]
$382e       ---
$382f       ---
$3830       ---
$3831       ---
$3832       ---
$3834       ---
$3835       ---
$3836       [skip3836]
$3838       ---
$3839       ---
$383c       ---
$383d       ---
$383e       ---
$383f       ---
$3840       ---
$3841       ---
$3842       ---
$3843       ---
$3844       ---
$3845       ---
$3847       ---
$3848       ---
$3849       ---
$384a       ---
$384d       ---
$384e       ---
$3851       ---
$3852       ---
$3855       ---
$3858       [inst_right]
            %CODE
$385b       ---
$385c       ---
$385d       ---
$385e       ---
$385f       ---
$3861       [inst_mid]
            %CODE
$3862       ---
$3863       ---
$3866       ---
$3867       ---
$3868       ---
$386b       ---
$386c       ---
$386e       ---
$3870       ---
$3873       ---
$3874       ---
$3875       ---
$3878       [jump3878]
$3879       ---
$387a       ---
$387b       ---
$387c       ---
$387f       ---
$3880       ---
$3881       ---
$3882       ---
$3884       ---
$3885       ---
$3886       ---
$3887       ---
$3888       ---
$3889       ---
$388a       ---
$388b       ---
$388c       ---
$388d       [inst_val]
            %CODE
            Appel à LEN
$3890       Si la longueur est 0, alors le résultat est 0
            Saute si la longueur de la chaine est 0. Le résultat est alors 0.
$3893       Sauve la longueur de la chaine dans E
$3894       ---
$3895       ---
$3896       Se positionne sur le pointeur de chaine
$3897       ---
$3898       ---
$3899       Le pointeur est à présent dans HL
$389a       Qui est poussé sur la pile
$389b       Se place à la fin de la chaîne + 1 (D doit être égal à 0)
$389c       ---
$389d       Place 0 à la fin de la chaine pour terminaison (D est toujours égal à 0)
$389e       Met la fin de chaine sur la pile et récupère le début de la chaine.
$389f       Pousse sur la pile l'ancien contenu de la chaine + 1
$38a0       Positionne le pointeur un octet avant le début de la chaine pour pouvoir appeler chget.
$38a1       Récupère le premier octet de la chaine dans A
$38a2       Appelle la conversion de chaine vers FAC
$38a5       Récupère l'ancien octet d'après la chaine
$38a6       ... et son adresse
$38a7       Replace l'octet à sa place
$38a8       ---

$38a9       [lf_rt_arg]
            Récupère l'argument numérique de LEFT et RIGHT
$38a9       ---
$38aa       Vérifie que la suite est une parenthèse fermante, sinon, c'est une erreur de syntaxe.
$38ab       Caractère ')'
$38ac       [mid_arg]
            Récupère le deuxième argument pour MID
$38ad       Récupère l'argement depuis la pile en préservant l'adresse de retour.
$38ae       ---
$38af       Met l'argument (la longeur) dans B
$38b0       ---

$38b1       [inst_fre]
            %CODE
            Instruction : FRE()
            Entrée : (valtyp)
$38b1       ---
$38b4       DE contient l'adresse de (strend)
$38b5       ---
$38b8       HL contient l'adresse de la pile
$38b9       ---
$38bc       ---
$38bd       Saute si (valtyp) est à 0 (nombre)
$38c0       ---
$38c3       ---
$38c6       ---
$38ca       HL contient (fretop) et DE contient (stktop)
$38cd       ---

$38d0       [dim_cont]
            %CODE,SECTION(biptrg)
            L'appel est induit par le push en $38d8, lors de l'exécution de l'instruction DIM.
$38d0       ---
$38d1       Si la zone de parsing contient 0, alors retour de l'instruction
$38d2       ---
$38d3       Sinon, vérification que le caractère suivant est une virgule ($2C) qui induit une deuxième définition de tableau
$38d4       Valeur pour le chkchr précédent

$38d5       [inst_dim]
            %CODE
            Instruction : DIM
            Le format d'un tableau (stocké à partir de arytab) est le suivant:
            +0/+1 : identifiant du tableau
            +2/+3 : taille des données allouées pour le tableau (dimensions comprises)
            +4    : nombre de dimensions
            paires suivantes : taille de chaque dimension
            puis la zone d'allocation de données (4 octets par indice)
$38d5       ---
$38d8       ---
$38d9       ---

$38da       [getvar]
            Fonction qui parse le nom de la variable et initialise l'espace nécessaire après vartab, en poussant
            l'existant. Puis inscrit l'identifiant. Si la variable existe, se contente de la retourner.
            En entrée: HL pointe sur la zone de parsing.
            En sortie: DE pointe sur la zone de mémoire contenant la valeur et cas d'assignation,
                       l'accumulateur flottant la valeur en cas d
                       HL sur la zone de parsing.
            L'identifant est sur deux caractères. Si le type est alphanum, alors le second caractère a son bit de poids fort à 1.
            Une variable a 4 octets de valeur.
            Si le type est une fonction, le premier caractère a son bit de poids fort à 1 (vérifier ???)
            Pour une chaine : taille, (rien), pointeur sur la chaine (en fin de mémoire)
$38da       Saut depuis LET pour définir une variable
$38db       0 dans dimflg sauf si l'on vient de DIM, auquel cas cela vaut $AF
$38de       Récupération du premier caractère de la variable dans C
$38df       [get_id]
$38e2       Si le nom de variable ne commence par par une lettre majuscule entre A et Z, c'est une erreur de syntaxe (rappel : tout ce qui est parsé hors chaîne de caractère est passé en majuscules)
$38e5       ---
$38e6       ---
$38e7       valtyp à 0 par défaut (valeur numérique)
$38ea       Lit le caractère suivant
$38eb       Saute si le caractère lu est un chiffre
$38ed       ---
$38f0       Saute si le caractère lu n'est pas entre A et Z (donc si ni chiffre ni A à Z l'identifiant est terminé)
$38f2       [idnum_trail]
            Sauve le premier caractère de la variable dans B
$38f3       [idtrail_skp]
$38f4       Avance la lecture de l'identifiant tant que l'on trouve des chiffres
$38f6       ---
$38f9       Avance la lecture de l'identifiant tant que l'on trouve des lettres
$38fb       [id_end]
            Le nom de l'identifiant a été lu. On vérifie son qualificatif en '$'
$38fd       Si '$' n'est pas présent, on saute. La valeur est bien numérique.
$38ff       Sinon, la variable est de type chaîne de caractères
$3900       Ce qui est indiqué dans valtyp
$3903       A <= $80 et Carry à 1
$3904       Ajoute $80 à B pour marque le type string de la variable
$3905       B <- B + A ($80)
$3906       Lecture du caractère suivant le '$'
$3907       [num_vrble]
            (subflg) == 1 pour une demande de tableau, >= 1 lorsque l'on vient d'un FOR ou d'une fonction ($80 lors d'une évaluation)
$390a       ---
$390b       Saut si subflg était égal à 1. L'appelant veut un tableau.
$390e       Saut si subflg était supérieur à 1 (traitement des fonctions et FOR Le subflg est à $80 pour une fonction lors d'une évaluation avec la variable paramètre)
$3911       ---
$3912       ---
$3914       Saut si le caractère suivant est une parenthèse ouvrante (pour le dimensionnement des tableaux)
$3917       [simplevar]
$3918       Reset de subflg
$391b       Push de la position actuelle du pointeur de parsing
$391c       ---
$391d       DE <- BC
$391e       ---
$3921       Compare DE (le nom de variable cherchée) et HL (le nom pointée par le paramètre)
$3922       ---
$3925       Si la valeur sont identique, saute (pour un RET) avec DE placé sur la valeur du paramètre.
$3928       ---
$392b       ---
$392c       HL est à (vartab) et DE est à (arytab). L'espace de stockage des variables est entre les deux (HL < ou égal à DE)
$392f       [next_var]
$3930       Saut si HL et DE sont égaux, c'est-à-dire (vartab) == (arytab) (donc pas de variable définie)
$3933       À cet endroit, HL < DE et l'espace entre les deux contient des variables. BC contient l'identifiant de la variable en train d'être parsée.
$3934       Comparaison du premier caractère de la variable avec le premier caractère de la variable pointée
$3935       Incrémente HL avant le saut potentiel
$3936       Saut si les caractères étaient différents (dont pas la bonne variable)
$3939       ---
$393a       Comparaison des seconds caractères
$393b       [var_diff]
            Incrémente pour la deuxième fois HL, qui pointe après l'identifiant.
$393c       Saute si le second caractère était identique à celui pointé. On a donc retrouvé la variable et on saute à la fin de la fonction
$393f       ---
$3940       ---
$3941       ---
$3942       La variable n'a pas été trouvée, on saute les 4 prochains octets pour aller vers la suivante (ou terminer en atteignant DE=(arytab))
$3943       ---
$3946       [no_var_yet]
$3947       Récupération dans HL dans la valeur de retour du CALL (2613 si appelé par LET)
$3948       Push de DE qui contient arytab
$3949       ---
$394c       Comparaison de l'adresse de retour avec $2927 (quelle instruction ???)
$394d       Pop de DE qui contient maintenant arytab
$394e       Saut si l'adresse de retour venait de str_to_var. Attention, l'adresse de retour est toujours dans HL et le pointeur de parsing sur la pile
$3951       Remise en place de l'adresse de retour et HL pointe sur le parsing.
$3952       Sauve le pointeur de parsing. On remet tout en place.
$3953       Sauve BC, qui contient le nom de la variable.
$3954       ---
$3957       ---
$395a       ---
$395b       Ajout de 6 à strend
$395c       Récupération de strend dans HL (pointeur de fin de mémoire utilisable)
$395d       Sauvegarde de strend + 6
$395e       Copie de DE,BC vers HL
$3961       ---
$3962       (strend) <- (strend) + 6
$3965       ---
$3966       HL <- BC
$3967       (arytab) <- HL
$396a       [clear_mem]
$396b       ---
$396d       ---
$396e       Mise à zéro de la partie entre l'ancien (arytab) (DE) et le nouveau (HL). C'est-à-dire l'espace libérée pour la nouvelle variable.
$3970       DE récupère le nom de la variable.
$3971       ---
$3972       ---
$3973       ---
$3974       (HL) <- DE et HL += 2, enregistrement du nom de la variable dans son emplacement.
$3975       [var_found]
            DE pointe sur la mémoire après le nom de la variable
$3976       HL pointe sur la zone de parsing
$3977       ---
$3978       [ret_null]
$397b       ---
$397e       ---
$3981       ---
$3982       ---

$3983       [subscript]
            HL pointe sur la zone de parsing
$3983       Sauvegarde du pointeur de parsing
$3984       ---
$3987       Récupération dans HL du pointeur de parsing et mise sur la pile de (dimflag)
$3988       Initialisation de D à 0 (A == 0 ici)
$3989       [loop_dim]
$398a       ---
$398b       ---
$398e       ---
$398f       ---
$3990       HL <- DE, la taille demandée du tableau
$3991       Mise sur la pile de la dimension.
$3992       Remise en place de la valeur qui était sur la pile (insertion de la dimension avant la valeur de la pile). Il s'agit de (dimflg)
$3993       DE contient le (dimflag), HL le pointeur de parsing
$3994       ---
$3995       D contient la dimension actuelle
$3996       Parsing
$3997       ---
$3999       Saut si la taille est suivie par une virgule
$399c       Vérification de parenthèse fermante
$399d       Code pour la parenthèses fermante
$399e       À ce moment, la pile contient (dimflg),(dimension tableau)+,...???, D contient le nombre de dimensions du tableau, HL le pointeur de parsing. La valeur du pointeur de parsing est sauvée dans (temp2)
$39a1       ---
$39a2       Remise en place de la valeur de (dimflg) venant de la pile (a-t-elle pu être modifiée ???)
$39a5       ---
$39a7       Nettoyage de E puis mise de DE (D contient le nombre de dimensions du tableau) sur la pile
$39a8       En arrivant par ici, les push hl et push af suivant saut ignorés.
$39a9       [aryvar]
            On arrive ici par un jump conditionnel si lors d'une recherche de variable, (subflg) == 1
$39aa       La pile contient (# de dimension),(tailles des dimensions)+
$39ab       ---
$39ae       En arrivant par ici, le add hl,de suivant est ignoré
$39af       [dim_search]
$39b0       ---
$39b4       ---
$39b5       ---
$39b7       Premier caractère du nom du tableau (BC contient le nom du tableau courant)
$39b8       ---
$39b9       ---
$39ba       Si le premier caractère est différent, on saute (c'est ok, pas de redimensionnement)
$39bc       ---
$39bd       Comparaison du second caractère du nom du tableau (le test aura lieu en $39c3)
$39be       [dim_neq]
$39bf       ---
$39c0       ---
$39c1       ---
$39c2       Récupération dans DE de la taille mémoire du contenu du tableau (pour chaînage)
$39c3       Si le nom de variable était différent, on boucle
$39c5       Arrivé ici, cela signifie qu'une entrée de tableau a été trouvée avec le même nom
$39c8       ---
$39c9       Si (dimflg) était différent de zéro, c'est que l'on cherche à redéfinir un tableau. Lancement de l'erreur
$39cc       Arrivé ici, le tableau a été trouvé (et c'est donc un accès).
$39cd       BC <- HL, qui pointe vers les attributs du tableau (debut+4)
$39ce       ---
$39cf       Saut dans quel cas ???
$39d2       Soustraction du type pour vérifier si c'est le même ???
$39d3       ---
$39d6       [out_range]
            Il n'y avait pas égalité, on lance une erreur.
$39d9       Sortie avec l'erreur "Subscript out of range"

$39dc       [ary_at_end]
            Arrive ici lorsque arytab == strend lors d'un dimensionnement de tableau.
            HL contient arytab
            BC contient le nom de la variable (du tableau)
            DE est initalisé à 4, qui est la taille d'un élément pour la première dimension
            
            MS_BASIC=CREARY
$39dc       ---
$39df       Récupération de la dimension (dans A, F == 0 normalement, sauf ???)
$39e0       Quelle est la nature du test précédente récupéré par AF ???
$39e3       Place le nom de la variable dans la zone pointée par HL (zone arytab)
$39e4       ---
$39e5       ---
$39e6       ---
$39e7       Place le nombre de dimensions dans C
$39e8       Vérifie la place restante pour stocker le nombre de dimensions * 2 (ce qui ne semble pas suffisant, cela ne compte pas le nombre de dimension ni la taille)
$39eb       ---
$39ec       ---
$39ed       Place le pointeur HL (4 octets après la variable) dans temp3
$39f0       Place le nombre de dimensions du tableau dans la structure du tableau
$39f1       HL pointe sur l'emplacement de la première dimension
$39f2       ---
$39f5       Pour setter Carry. A priori, si accès sans DIM, le Carry flag est OFF (donc bit de poids fors de A est à 0 ?)
$39f6       A contient le nombre de dimensions
$39f7       [multi_dim]
            Préparation de BC <- $000B pour le saut suivant. C'est la taille par défaut d'un tableau ; MS_BASIC=CRARLP
$39fa       ---
$39fc       BC contient la taille de la dimension traitée
$39fd       En BASIC, la taille d'un tableau est d'une unité plus grande que celle spécifiée (à cause de l'indice 0). Ce BASIC n'a pas l'option pour démarrer les indices à 1.
$39fe       [default_dim]
            MS_BASIC=DEFSIZ
$39ff       Sauvegarde de la dimension en cours sur la pile
$3a00       ---
$3a01       BC est placé dans les deux octets de la spécification de la dimension des données du tableau
$3a02       ---
$3a03       Sauvegarde sur la pile de la position suivante dans la structure du tableau
$3a04       ---
$3a07       DE <- taille nécessaire pour les données de cette dimension
$3a08       Récupération du pointeur sur les données du tableau
$3a09       Récupération de la dimension en cours
$3a0a       Dimension suivante (décroissante)
$3a0b       ---
$3a0d       Sauvegarde des flags (car A == 0 ici)
$3a0e       ---
$3a0f       BC <- DE (la taille du contenu du tableau à réserver)
$3a10       HL contient la taille à réserver, DE contient le pointeur de contenu du tableau
$3a11       Après l'addition, HL contient le pointeur de fin du contenu du tableau
$3a12       Si HL a débordé, alors il n'y avait plus de mémoire pour sûr (dépassement de la plus haute adresse adressable)
$3a15       Sinon, vérification par rapport à la mémoire installée
$3a18       Si tout est bon, comme un nouveau tableau est toujours en dernier (on ne redimensionne pas les tableaux), mise à jour de (strend)
$3a1b       [dim_nullify]
            MS_BASIC=ZERARY
$3a1c       Mise à zéro du contenu du tableau
$3a1e       ---
$3a1f       Mise à zéro du contenu du tableau en ramenant HL (pointeur sur la fin du contenu du tableau) vers DE (début du contenu du tableau)
$3a21       Incrément du la taille mémoire du tableau
$3a22       A priori, A == 0 donc mise à 0 de D
$3a23       ---
$3a26       Récupération dans E du nombre de dimensions du tableau
$3a27       ---
$3a28       ---
$3a29       HL <- 2 * (# de dimension) + BC(espace de tableau + 1)
$3a2a       DE <- HL == taille nécessaire pour les données, les tailles des dimensions et le nombre de dimension
$3a2b       ---
$3a2c       Positionnement de HL à identifiant + 2, pour stocker la taille de mémoire allouée au tableau (hors identifiant)
$3a2d       ---
$3a2e       ---
$3a2f       ---
$3a30       Placement de la taille calculée à cet endroit
$3a31       Récupération des anciens flags
$3a32       Si le Carry Flag était set, alors on a fini. Sinon, il s'agit d'un accès au tableau (allocation par défaut lors d'un accès à un tableau non défini)
$3a34       [dim_access]
            MS_BASIC=FINDEL
            En arrivant ici depuis $3a4e, a est égal à 0
$3a35       Donc BC <- $00
$3a36       HL est à identifiant+4. A <- nombre de dimensions du tableau
$3a37       HL pointe sur le début des taille de dimensions du tableau
$3a38       Le partial élimine le pop hl suivant
$3a39       [dimension_l]
            Récupération dans HL du pointeur vers la taille de la dimension courante (en première boucle, HL était initialisé par la partie précédente)
$3a3a       ---
$3a3b       ---
$3a3c       Ce qui donne DE <- taille du tableau dans la dimension actuelle
$3a3d       ---
$3a3e       Les index sont sur la pile. Récupération de l'index dans HL (en partant de la droite)
$3a3f       Sauvegarde du nombre de dimensions et flags
$3a40       ---
$3a41       Saut si l'index demandé est au delà de la taille du tableau
$3a44       Sauvegarde de l'index accédé sur la pile
$3a45       BC contient le numéro d'index accédé par la dimension précédente
$3a48       Récuépration dans DE de l'index accédé
$3a49       HL contient le début de la zone due à l'indice de la dimension précédente. On y ajoute l'index de la dimension courante.
$3a4a       Récupération de la valeur d'AF sauvegardée en $3a3f (contient la dimension en cours et les flags)
$3a4b       Décroit A, la dimension en court
$3a4c       ---
$3a4d       BC <- HL
$3a4e       ---
$3a50       ---
$3a51       HL <- Index * 4, car chaque entrée du tableau prend 4 octets.
$3a52       Récupération dans BC du pointeur des données du tableau mise sur la pile en $3a3e
$3a53       HL <- adresse de la donnée cherchée
$3a54       DE <- adresse de la donnée cherchée
$3a55       [end_dim]
            MS_BASIC=ENDDIM
            Récupération dans HL du pointeur de parsing
$3a58       En cas de lecture du tableau, DE contient le pointeur vers l'entrée cherchée.

$3a59       [k7_advance2]
            Fait avancer la k7 pour sauter l'amorce. Rien n'est écrit, ni lu.

            Il semble que cette fonction soit patchée depuis la ROM 1.0, vérifier (???)
            Elle est appelée depuis `k7_advance`.

            $SECTION(caset)
$3a59-$3a5b Allume le moteur du lecteur de k7.
$3a5d       Désactive les interruptions.

$3a5e       [loop3A5E]
$3a5e       Sauve le compteur B.
$3a5f       BC = 0
$3a62       [loop3A62]
$3a62-$3a64 Attente de 19 + 19 + 4 états.
$3a65       Décrémente la partie C de BC.
$3a66       Boucle 256 fois (sur C)
$3a68       Boucle 256 fois (sur B), pour un total de 65536.
$3a6a       Récupère le compteur global.
$3a6b       Et boucle sur celui-ci (mis à 3 au début).

$3a6d       [wait_stp_k7]
            Attend le temps de compter jusqu'à 65535 puis éteint le moteur de la K7.

$3a6d-$3a6e Sauve AF et BC sur la pile
$3a6f       BC à 0
$3a72       [loop_on_bc]
$3a72-$3a75 Boucle jusqu'à ce que BC soit égal à 0.
$3a77-$3a78 Restaure AF et BC depuis la pile
$3a79       [stop_k7]
$3a79       Sauvegarde AF
$3a7a-$3a7c Passe le registre de k7 à 0 (moteur éteint, pas de lecture)
$3a7e       Restaure AF
$3a7f       Permet l'IRQ

$3a81       [save_sync]
            ??? Mieux comprendre l'effet du paramètre A.

$3a81       Place les drapeaux en fonction de A.
$3a82       Sauve les drapeaux sur la pile.
$3a83-$3a85 Allume le moteur du lecteur k7.
$3a8a       [sync_loop]
$3a87-$3a8d Boucle d'attente le temps que HL boucle de $0000 à $0000
$3a8f       Restaure les drapeaux.
$3a90       [send_ones]
$3a93       Si le drapeau était à Z, on branche.
$3a95-$3a96 Si Z n'était pas à 1 (dans A initialement pas à 0), A est multiplié par 4.
$3a97       [not_mult]
$3a97       La valeur est ensuite stockée dans B
$3a98       Et C est mis à $00 pour former BC comme un compteur qui commence à la valeur de handler * 1024 ou handler * 256 (suivant le drapeau Z)
$3a9a       Désactivation des interruptions.
$3a9b       [send_one_lp]
$3a9e       Attente de 27 états T
$3aa1-$3aa4 Boucle tabt que BC n'atteint pas 0.
$3aa6       Pour terminer, branche sur la vérification de BREAK, d'anti copie et de reset des touches. Profitera du `ret` de la routine.

$3aa9       [k7write]
$3aa9       Charge les périodes d'écriture du son.
$3aac       Sauve le caractère à envoyer.
$3aad-$3ab0 Réduction de la période dans L de $0e
$3ab1       Envoie un premier cycle long (0) sur la k7.
$3ab4       Restaure le caractère à envoyer
$3ab5       8 bits à traiter.
$3ab7       [byte_to_k7]
$3ab7       Bit de poids fort de l'octet dans Carry
$3ab8       Appel si le Carry est à 1
$3abb       Appel si le Carry est à 0
$3abe       Boucle sur les 8 bits.
$3ac0-$3ac3 Envoie de deux "1" sur la k7 pour terminer l'octet.
$3ac6       Retour de la fonction en passant par le test d'interruption de commande.

$3ac9       [s0_to_k7]
            Envoie sur la k7 un cycle décrivant un '0'
$3ac9       Charge les périodes longues pour décrire un '0'.
$3acc       Envoie sur la k7
$3acf       [wait_27]
$3acf       L'entrée ici sert de petite attente (17 T du `call` + 10 T du `ret`, donnent 27 états T)

$3ad0       [s1_to_k7]
            Envoie sur la k7 un double cycle décrivant un '1'.
$3ad0       Envoie un premier cycle court pour un '1'
$3ad3-$3ad8 Attente de 10 * 2 (ex) + 4 * 4 (nop) états T.
$3ad9       Envoie un second cycle court pour terminer le '1'

$3add       [k7_send_h1]
            Envoie un cycle court sur la sortie k7.

            Doublé, cela code un '1', la routine envoie donc une moitié du code complet.

$3add       Met la valeur du timing de cycle 1 (HIGH) dans HL
$3ae0       [k7_send_hl]
$3ae0       Sauve AF
$3ae1       [k7_1_loop_h]
$3ae1       Boucle sur L
$3ae2       Tant que L n'atteint pas 0
$3ae5-$3ae7 Signal `haut` et `moteur en route` sur la sortie k7.
$3ae9       [k7_1_loop_l]
$3ae9       Boucle sur H
$3aea       Tant que H n'atteint pas 0
$3aed-$3aef Signal `bas` et `moteur en route` sur la sortie k7.
$3af1       Restaure AF

$3af3       [calibrate]
            Calibre la lecture de la cassette.

            ??? Vérifier les calculs.

$3af3-$3af5 Démarre le moteur du lecteur k7 (si la prise remote est branchée).
$3af7       Désactive l'IRQ

$3af8       [cal_retry]
$3af8       Compteur à $457 (1111)
$3afb       [cal_adjust]
$3afb       Mise dans D de la valeur précédente du compteur de cycle 0/1 (et à la première itération ???)
$3afc       Lit un cycle 0/1
$3aff       Si le Carry est levé, l'interruption de la commande a été demandée, retour immédiat.
$3b00       Compteur de cycle 0/1 dans A
$3b01-$3b03 Boucle si le compteur est supérieur à 222
$3b05-$3b07 Boucle si le compteur est inférieur à 5
$3b09-$3b0a Le compteur est dans ses bornes. Branche plus loin si A était supérieur à D, la valeur précédente. A contient la différence entre la nouvelle et l'ancienne valeur.
$3b0c-$3b0d Complément à 2 de A, pour prendre sa valeur opposée.

$3b0e       [cycle_abs]
$3b0e       A contient la valeur absolue de la différence entre les deux précédent compteur de cycle 0/1
$3b10       Boucle si cette différence est de 4 ou plus avec le compteur HL réinitialisé.
$3b12       Décrémente HL
$3b13-$3b15 Boucle si HL n'est pas nul pour lire une nouvelle valeur.
$3b17       Force HL à 0 (il est déjà à 0 normalement ???)
$3b1a-$3b1b B et D à 0 aussi

$3b1c       [read_256]
$3b1c       Lecture d'un cycle 0/1
$3b1f       Retour si l'interruption de la commande a été demandé.
$3b20       Ajoute BC (donc C, car B est initialisé à 0) à l'accumulateur HL
$3b21-$3b22 Boucle 256 fois (D initialement à 0)
$3b25-$3b28 Un dernier ajoute de $5fa (1530) à l'accumulateur, pour l'arrondi ???
$3b29       A contient la moyenne du compteur de 256 lectures de cycle 0/1 (à l'ajout de 5 prêt)
$3b2a-$3b2b Moyenne divisée par 2
$3b2d       Et mise dans D
$3b2e       Double l'accumulateur de toutes les durées de lecture.
$3b2f       A contient deux fois la moyenne du compteur de 256 lectures.
$3b30       Différence entre 2 fois la moyenne et la moitié de la moyenne.
$3b31       Sauvegarde de la différence dans D
$3b32       Soustraction de 5 à la différence (ajoutée précédemment à la somme)
$3b34       Enregistrement de la différence entre la moitiée et le double de la moyenne.
$3b37-$3b38 Doublement de la différence
$3b39       Initialise B pour calculer A / 3.
$3b3b       [lim_div_3]
$3b3b       Réduit A de 3.
$3b3d       Incrémente B (`inc` ne touche pas Carry)
$3b3e       Boucle tant que A est positif.
$3b40-$3b41 A prend le résultat de la division - 3.
$3b43       Ce qui donne la taille de la fenêtre.
$3b46       Met Carry à 0, car Carry indique une demande d'interruption de commande.

$3b48       [k7_read_byt]
            Lecture d'un octet de donnée depuis la k7

            Sortie :
            - A, le résultat de l'octet lu.
            - Carry à 1 en cas d'interruption de commande ou d'erreur.

$3b48       Lit la valeur du calibrage `lowlim`
$3b4b       Et la place dans D
$3b4c       [wait_1]
$3b4c-$3b4f Sort si une demande d'interruption de commande a été demandée, avec un petit délai.
$3b50       Lecture de la k7 (donnée sur le bit 7)
$3b52       Récupération de la donnée dans Carry
$3b53       Boucle si la donnée lue est 0.
$3b55       [wait_0]
$3b55-$3b58 Sort si une demande d'interruption de commande a été demandée, avec un petit délai.
$3b59       Lecture de la k7 (donnée sur le bit 7)
$3b5b       Récupération de la donnée dans Carry
$3b5c       Boucle si la donnée lue est 1.
$3b5e       On est maintenant callé juste après un premier cycle 0/1.
$3b60       Lecture d'un demi cycle à 0, avec calcul de la période.
$3b63       [half_cycle]
$3b63       B prend la période de la lecture de 0.
$3b64       Lecture d'un demi cycle à 1, avec calcul de la période.
$3b67       Retour si demande d'interruption de commande.
$3b68-$3b69 Ajout du total des deux périodes.
$3b6a       Si la somme dépasse 255 (en cas d'échec de lecture), nouvelle tentative.
            À chaque fois, la somme calculée est celle des deux demi-périodes du cycle lues.
$3b6c-$3b6d Nouvelle tentative si la période du cycle complet est plus petite que `lowlim` actuellement dans D.
$3b6f       L compte les 8 bits à lire.

$3b71       [rd_nxt_byte]
$3b71       Lecture pendant la durée d'une fenêtre.
$3b74-$3b77 Retour s'il y a eu plus de 4 changements de signal pendant la période avec le Carry à 1.
$3b78-$3b7a Si le nombre de changements est inférieur strictement à 2, le Carry est à 0, sinon (donc pour 2, 3 ou 4 changements), le Carry est à 1.
            Normalement, on s'attend à avoir 3 changements (bit à 1) ou 1 changement (bit à 0). Le Carry porte donc la valeur du bit.
$3b7b       Construction progressive de l'octet lu par rotation et valeur lue en bit 7.
$3b7d       A = C, mais n'étaient-ils pas déja égaux ???
$3b7e-$3b7f En cas d'un nombre de changement impaire, on attent le prochain changement pour se recaler.
$3b82       Puis attente d'un nouveau changement de signal. Ce qui fait qu'on a toujours un nombre de changement impaire ???
$3b85-$3b86 Boucle 8 fois.
$3b89       Vérifie l'interruption de commande.
$3b8c       Résultat de l'octet lu de l'opération dans A.

$3b8e       [read_window]
            Lecture de cycles 0/1 limités dans le temps par la valeur de calibrage `winwid`.

            Entrée : 
            - E bit 7, la donnée sur laquelle la routine commence

            Sortie :
            - A et C, à la fin de la période, le nombre de changements de signal
            - E contient le dernier signal lu.

$3b8e-$3b91 Lecture dans B de `winwid` longueur de la fenêtre calibrée précédemment.
$3b92       C initialisé à 0.
$3b94       [window_loop]
$3b94       Lecture de la k7 (donnée dans le bit 7)
$3b96-$3b97 Branche plus loin si la donnée correspond au contenu du bit 7 de E.
$3b9a-$3b9c Inverse la valeur de E
$3b9d       Incrémente le compteur C
$3b9e       Boucle autant de fois que B, la valeur de `winwid`.
$3ba0       Place le compteur C dans A.

$3ba2       [still_same]
$3ba2-$3ba5 Attente similaire dans les deux branches du test.
$3ba6       Boucle autant de fois que B, la valeur de `winwid`.
$3ba8       Place le compteur C dans A.

$3baa       [wait_chnge_b]
            Appel de `wait_change` avec une vérification d'interruption de commande.

$3baa-$3bad Retour si une interruption de commande à été demandée.

$3bae       [wait_change]
            Renvoie une valeur d'attente du changement de valeur de lecture depuis la k7.

            Entrée :
            - E, la valeur actuelle de la k7, et donc celle qu'on attend de voir changer.

            Sortie :
            - C, le compteur d'attente, 255 max
            - E, la valeur complémentée si trouvée, ou initiale si pas trouvée

$3bae       Initialise le compteur à 0
$3bb0       [same_value]
$3bb0       Incrémente le compteur
$3bb1       Au bout de 256 itérations, branche à la fin.
$3bb3       Lit la valeur de l'entrée son/k7 (sur le bit 7)
$3bb5       Ou exclusif avec la lecture précédente inversée
$3bb6       Boucle tant que la valeur lue et la valeur actuelle (dans E) sont les même.
$3bb9-$3bbb La valeur vient de changer, E est complémenté à 1.
$3bbc       Lors du retour, C est le timing d'attente avant d'avoir reçu l'autre valeur en lecture.

$3bbd       [wait_timout]
$3bbd       Ramène C à $ff

$3bbf       [read_cycle]
            Lit depuis la k7 un cycle 0/1 et renvoie dans C le temps total.

            Sortie :
            - C, compteur total pour le cycle 0/1, ou 255 en cas d'échec.

$3bbf       Vérifie si une interruption de commande a été demandée (avec un petit délai)
$3bc2       Retour si oui.
$3bc3       Lecture de l'entrée son/k7
$3bc5       Décalage à gauche (l'entrée k7 est sur le bit 7)
$3bc6       Boucle tant que le signal d'entrée est à haut, afin de se caler sur une valeur basse.
$3bc8       On est actuellement sur une valeur basse.
$3bca       Attente jusqu'à la fin de la valeur basse.
$3bcd       Attente jusqu'à la fin de la valeur haute.

$3bd0       [outdo_impl]
            $SECTION(bio)
            Fonction : envoie d'un caractère sur le périphérique sélectionné
            Entrée : le caractère est contenu dans A
$3bd0       ---
$3bd3       ---
$3bd4       ---
$3bd7       ---
$3bd8       ---
$3bda       ---
$3bdb       ---
$3bdd       ---
$3bde       ---
$3be1       [sendchar_pt]
$3be4       ---
$3be6       ---
$3be8       ---
$3be9       ---
$3bea       ---
$3bec       ---
$3bee       [loop3BEE]
$3bf0       ---
$3bf1       ---
$3bf4       ---
$3bf6       ---
$3bf8       ---
$3bf9       ---
$3bfa       [skip3BFA]
$3bfc       ---
$3bfe       ---
$3c00       ---
$3c02       ---
$3c04       ---
$3c07       ---
$3c09       ---
$3c0c       ---
$3c0d       [skip3C0D]
$3c10       [skip3C10]
$3c11       ---

$3c14       [resetprt]
            Fonction: Mise à zéro de l'état de l'imprimante
$3c14       ---
$3c16       Sélectionne l'imprimante pour l'affichage
$3c19       ---
$3c1c       ---
$3c1e       ---
$3c20       Récupération et mise à zéro du Bit 7 du status de l'imprimante
$3c23       ---
$3c25       Si le bit était à 0, récupération du numéro de ligne de l'imprimante dans a
$3c28       Permet de mettre à jour les flags de F
$3c29       [skip3C29]
            Appel si le bit 7 du status était 1, ou bien si la ligne de l'imprimante n'est pas 0
$3c2c       ---
$3c2f       ---
$3c31       Clear du picflg sauf le bit 6 (signal de curseur en fin de page)
$3c34       ---
$3c35       Sélection du terminal comme sortie des caractères
$3c38       Mise à zéro de l'état de l'imprimante.
$3c3b       ---
$3c3c       [sendchar_te]
            Récupération de AF qui contient prtflg
$3c3d       ---

$3c40       [cursor_x0]
            Remet le terminal en état. Puis, si le curseur n'était pas en
            première colonne, fait un saut à la ligne sur le terminal. Sinon, ressort.
            
            MS_BASIC=STTLIN
$3c40       ---
$3c43       ---
$3c46       ---
$3c47       ---
$3c48       ---

$3c4a       [putnulatend]
            Fonction: met un caractère NUL à la fin de la chaîne précédent le pointeur HL actuel, en ignorant les espaces.
            À la fin de la fonction, HL contient $4897, c'est-a-dire juste avant le buffer de crunch de la ligne.
$3c4a       ---
$3c4b       ---
$3c4c       ---
$3c4e       Recale le pointeur HL sur le derniere caractère non espace ($20) avant le CR ($0D)
$3c50       HL pointe donc à présent juste après le dernier caractère de la ligne à traiter

$3c51       [hl_on_buf]
$3c51-$3c52 Place un $0 sur ce que pointe HL, qui est la fin d'un buffer pour la ligne entrée dans le moniteur.
$3c53       Et faite pointer HL un octet avant le buffer de travail `buf`.

$3c57       [crdo]
            Fonction : Envoi d'un retour chariot sur la sortie de caractère actuel
$3c57       ---
$3c5a       ---
$3c5d       ---
$3c5e       Saut si la sortie de caractère se faire sur le terminal
$3c60       ---
$3c61       Saut si la sortie de caractère n'est pas l'imprimante (donc la k7)

$3c63       [crdo_prt]
            Fonction : Retour chariot à la ligne suivante sur l'imprimante
$3c63       ---
$3c65       ---
$3c66       ---
$3c68       ---
$3c69       ---
$3c6a       Mise à zéro de la colonne de l'imprimante (aucun test de la véracité...)
$3c6d       ---
$3c6e       [crdo_k7]
$3c70       ---
$3c71       ---
$3c72       [crdo_term]
$3c74       ---
$3c75       ---
$3c76       ---

$3c77       [chk_break]
            Vérifie la séquence de BREAK puis continue sur l'instruction STOP.
            L'instruction STOP commence par 'ret nz', qui fera donc un RET s'il
            n'y a pas eu de BREAK, et qui fera un STOP dans le cas contraire.
$3c77       ---
$3c7a       ---

$3c7d       [break_delay]
            Vérifie si SHIFT + RUN-STOP est appuyée (interruption de commande).
            Avec un délai préalable.

            Si oui, le Carry est positionné à 1 au retour.

$3c7d-$3c7e Perd un peu de temps (2 fois 19 états T)

$3c7f       [break_impl]
            Vérifie si SHIFT + RUN-STOP est appuyée (interruption de commande).

            Si oui, le Carry est positionné à 1 au retour.
$3c7f-$3c83 Retour immédiat si RUN-STOP n'est pas appuyée.
$3c84-$3c88 Retour immédiat si SHIFT n'est pas appuyée.
$3c89-$3c8d Retour immediat si la boucle BASIC n'est pas en route. (pas certain du traitement de allflg)
$3c8e       Met la valeur $f2 dans la dernière touche scannée.
$3c92       Réinitialisation du drapeau de répétition des touches.
$3c96       Réinitialisation du compteur de répétition des touches.
$3c9a       Set Carry, pour signaler que l'interruption de commande a été demandée.

$3c9c       [print_prt]
            Affiche l'invite d'acquisition "? " pour l'instruction `INPUT`.

            Puis continue sur l'acquisition des données.
            
            MS_BASIC=PROMPT
$3c9c       %CHAR
$3c9c-$3c9e Émet '?' sur le périphérique de sortie.
$3c9f       %CHAR
$3c9f-$3ca1 Émet ' ' sur le périphérique de sortie.

$3ca2       [get_line]
            Récupération d'une ligne d'instruction entrée au BASIC
            Entre à chaque nouvelle invite. Sort lorsque la touche CR est appuyée.

            Sortie :
            - Le buffer `buf` contient les données lues.
            
            MS_BASIC=GETLIN
$3ca2       Appel au hook d'entrée de ligne.
$3ca5       HL pointe vers le buffer de travail
$3ca8       [get_line2]
$3cab-$3cac Branche si le périphérique d'entrée actuel est le clavier.
$3cae       Sinon, l'entrée est autre chose. Pour la ROM de base, c'est la k7, via la routine de chargement de `LOAD`. ???
            L'adresse à lire est dans `(high)` et l'octet lu sera en retour dans A.
            Le drapeau Z est à 1 si l'octet lu était le marqueur de fin de buffer, $03 et dans ce cas, A est à 0.
$3cb1       Branche si un octet a été lu depuis le buffer.
$3cb3       Sinon, la fin du buffer a été atteinte, et on branche pour finaliser la ligne entrée.

$3cb5       [keyloop]
            Traitement du moniteur pour une entrée par le clavier.
$3cb5       Traitement de l'appuie d'une touche, qui est éventuellement traitée.
$3cb8-$3cb9 Branche si une touche validée nécessite un traitement. La plupart des touches sont traitées directement et A est alors à 0. Quelles touchent sortent-elles avec A != 0 ??? STOP par exemple.
$3cbb-$3cbe Retour à la boucle de traitement si la touche STOP n'a pas été appuyée
$3cc0       La combinaison d'interruption de commande (SHIFT+STOP) a été détectée. Carry est à 1 et on termine l'acquisition des touches. Le retour se fait en $22b1

$3cc1       [decodebasic]
            Fonction : décode la ligne en BASIC ?
$3cc1       ---
$3cc3       Saute si la touche était la touche entrée.
$3cc5       ---
$3cc7       Remise du caractère dans le buffer en s'assurant qu'il soit sur 7 bits
$3cc8       ---
$3ccb       Comparaison de HL avec $4918, qui est juste avant la fin du buffer de crunch. Mais comment est-ce que HL pourrait déborder ? Pas en entrée direct on dirait... Il est possible qu'on n'arrive là que via la lecture k7 ?
$3ccc       ---
$3ccf       [hl_incbuf]
            HL pointe sur la position suivante dans le buffer de crunch
$3cd0       ---
$3cd2       [jump3CD2]
            $SECTION(biprtr)
$3cd3       ---
$3cd4       ---
$3cd5       ---
$3cd6       ---
$3cd9       ---
$3cdb       ---
$3cde       ---
$3ce1       ---
$3ce3       ---
$3ce5       ---
$3ce8       [skip3CE8]
$3ceb       ---
$3ced       ---
$3cee       ---
$3cef       ---
$3cf2       ---
$3cf3       ---
$3cf6       ---
$3cf7       [skip3CF7]
$3cf8       ---
$3cf9       ---
$3cfa       ---
$3cfb       ---
$3cfc       [call3CFC]
$3cfe       ---
$3d01       ---
$3d02       ---
$3d05       [loop3D05]
$3d06       ---
$3d07       ---
$3d0a       ---
$3d0b       ---
$3d0d       ---
$3d0e       ---
$3d0f       [call3D0F]
$3d10       ---
$3d11       ---
$3d12       ---
$3d14       ---
$3d17       [loop3D17]
$3d1a       [loop3D1A]
$3d1c       ---
$3d1e       ---
$3d1f       ---
$3d20       ---
$3d21       [loop3D21]
$3d22       ---
$3d23       ---
$3d25       ---
$3d26       ---
$3d27       ---
$3d29       ---
$3d2a       ---
$3d2d       ---
$3d2f       [loop3D2F]
$3d31       ---
$3d32       ---
$3d34       ---
$3d37       ---
$3d39       ---
$3d3c       ---
$3d3d       ---
$3d3f       ---
$3d42       ---
$3d45       ---
$3d46       ---
$3d48       ---
$3d4b       [skip3D4B]
$3d4e       [skip3D4E]
$3d50       ---
$3d53       [loop3D53]
$3d56       ---
$3d57       ---
$3d59       ---
$3d5b       ---
$3d5d       [call3D5D]
$3d60       ---
$3d62       ---
$3d64       ---
$3d67       ---
$3d69       ---
$3d6a       ---
$3d6b       ---
$3d6c       ---
$3d6d       [call3D6D]
$3d6e       ---
$3d71       ---
$3d72       ---
$3d74       ---
$3d77       ---
$3d78       ---
$3d79       ---
$3d7b       ---
$3d7c       ---
$3d7d       ---
$3d7e       ---
$3d80       ---
$3d81       ---
$3d82       ---
$3d83       ---
$3d84       [skip3D84]
$3d85       ---
$3d86       [call3D86]
$3d88       ---
$3d8a       ---
$3d8c       ---
$3d8e       ---
$3d90       ---
$3d91       [reset_prog_3]
            0 dans (autflg)
$3d94       0 dans les deux premiers octets de (txttab). Cela coupe le premier lien du listing BASIC.
$3d95       ---
$3d96       ---
$3d97       ---

$3d9a       [auto]
            Traitement du mode AUTO actif.

            Cette partie est patchée par rapport à la ROM 1.0

            Entrée :
            - HL contient l'ancien numéro de ligne

$3d9a       Sauve HL sur la pile.
$3d9b       Affiche HL sur le périphérique de sortie.
$3d9e       Récupération du numéro de ligne dans DE
$3d9f       Recherche de la ligne
$3da2       Branche si la ligne n'a pas été trouvée (affichera un espace avant de continuer sur la boucle du moniteur BASIC)
$3da5-$3da7 Sinon, affiche le caractère $a0 pour indiquer qu'il y a déjà du contenu. Puis continue aussi sur la boucle du moniteur BASIC.

$3daa       [auto_patch]
            Partie patchée en ROM 1.1 avec l'amélioration de la commande `AUTO`.
$3daa       Branche si le calcul de la nouvelle ligne a provoqué un dépassement de capacité. `AUTO` est terminé.
$3dac-$3db1 Compare le numéro de ligne avec $fff9 (65529, plus haut numéro de ligne valide)
$3db2       Branche si le numéro de ligne courant (dans HL) est égal ou supérieur à 65529.
$3db4       Sinon, la nouvelle ligne de `AUTO` est validée et enregistrée.
$3db7       Branchement vers la suite du patch

$3db9       [stop_auto]
$3db9-$3dba Annule le mode `AUTO`.

$3dbd       [auto_patch2]
$3dbd       Retour à la suite de la routine. Fin du patch pour `AUTO`.

$3dc0       [initscreen1]
$3dc3       ---
$3dc6       ---
$3dc8       ---
$3dcb       ---

$3dce       [inst_new]
            %CODE
            Instruction : NEW
            Efface le listing courant.
            S'il n'y a pas de paramètre, on branche directement vers le reset de la mémoire.
            S'il y a un paramètre`et que c'est un numéro de ligne, on efface à partir de ce numéro de ligne (a vérifier ???)
            
            MS_BASIC=NEW
$3dce       ---
$3dd1       ---
$3dd4       ---
$3dd5       ---
$3dd8       ---
$3dd9       ---
$3ddc       ---
$3ddd       ---
$3dde       ---
$3de1       [decodenext]
            Si HL était avant la fin du buffer de crunch, on incrémente HL et on continue.
$3de3       Si HL n'est pas égal non plus, c'est qu'il est supérieur à la fin du buffer de crunch, on loop directement sur le moniteur sans toucher à HL.
            Sinon, HL est sur la dernière position du buffer, on émet le caractere $0E (signification ?) puis on passe à l'incrémentation de HL. $0E semble donc être un marqueur de fin de buffer.
$3de6       ---
$3de8       ---
$3de9       [ind_inchl]
            Saut intermédiaire pour aller incrémenter HL

$3dec       [prompt_1]
            Code patché de la ROM 1.1 ???

$3dec-$3df1 Signal le fait que l'on est dans une instruction `INPUT` (bit 5 de `picflg`)
$3df4       Affiche le curseur.
$3df8       Branche sur la suite de l'initialisation de l'invite d'acquisition.

$3dfb       [acq_key_4]
            Suite du traitement de l'entrée de caractère.
            On arrive ici que la boucle de BASIC soit active ou non.

            Il s'agit ici de code patché pour la ROM 1.1
$3dfb-$3dfd Branche si la touche appuyée n'est pas Insertion de ligne (touche INSL, valeur non ASCII)
$3dff-$3e02 Test du drapeau de commande INPUT actif

$3e07       [acq_key_6]
$3e07       Trampoline qui permet d'utiliser le `JR` conditionnel pour un saut long... Pourquoi ne pas utiliser un `JP` conditionnel ???
$3e0a       [acq_key_5]
$3e0a-$3e0c Branche si la touche appuyée n'est pas Effacement de l'écran (touche EFFE, valeur non ASCII)
$3e0e       ---
$3e11       [jump3E11]
$3e14       ---
$3e16       ---
$3e19       ---
$3e1b       ---
$3e1c       ---
$3e1f       [jump3E1F]
$3e22       ---
$3e25       ---
$3e27       ---
$3e2a       ---

$3e2d       [acq_key_2]
            Suite du traitement de l'entrée de caractère.

            Il s'agit ici de code patché pour la ROM 1.1

$3e2d       Branche si la touche appuyée est Entrée.
$3e30       Sauve AF
$3e31-$3e35 Branche si la boucle BASIC n'est pas active, pour éviter de traiter certaines touches d'édition.
$3e37       Restaure AF

$3e3b       [skip_ctrl_k]
$3e3b       Restaure AF
$3e3c       Évite le traitement des touches d'édition.

$3e3f       [end_of_rom]
$4000       [screen]
$47d0       [inthk]
$47d3       [calhk]
            Tremplin pour la commande `CALL` qui y place l'opcode `call`/$c3
$47d4       [calhk_addr]
            Addresse pour le tremplin `calhk`.
$47d6       [sonhk]
$47d9       [plyhk]
$47dc       [rsthk]
$47df       [prthk]
$47e2       [outhk]
$47e5       [crdhk]
$47e8       [inlhk]
$47eb       [inphk]
$47ee       [nmihk]
$47ef       [nmihk_addr]
$47f1       [inst_lpen]
            %CODE
$47f4       [inst_disk]
            %CODE
$47f7       [inst_modem]
            %CODE
$47fa       [intdiv]
            Début de la zone de données graphiques pour la communication avec le EF9345
$47fb       [intact]
$47fc       [intrat]
$47fd       [cursor]
$47fe       [fklock]
$47ff       [crchar]
            valeur scannée du clavier la plus récente
$4800       [reptim]
$4801       [repena]
$4802       [attcar]
$4803       [attbak]
$4804       [extenf]
$4805       [xcursor]
$4806       [ycursor]
$4807       [prelin]
$4809       [homeln]
$480b       [retadr]
            Coordonnées de la prochaine ligne à interpréter
$480d       [entstt]
            programme ($82) ou direct ($80)
$480e       [sonsav_hi]
$480f       [sonsav_lo]
$4810       [ft]
            Table de fichier
$4811       [ft_filename]
$4817       [ft_version]
$4818       [ft_st_line]
$4819       [ft_st_line1]
$481d       [ft_protect]
$481e       [ft_sum_pos]
$4820       [ft_addr]
$4822       [ft_data_len]
$4824       [ft_sumchk]
$4825       [ft_sumchk1]
$4826       [low]
$4828       [high]
$482a       [handler]
$482c       [ft_sumchkr]
$482e       [lowlim]
$482f       [winwid]
$4830       [ramlow]
$4833       [inst_usr]
            %CODE
$4836       [fdivc]
$4837       [fdivc_1]
$483b       [fdivc_2]
$483f       [fdivc_3]
$4842       [fdivc_4]
$4844       [rnd_seed_0]
$4845       [rnd_seed_1]
$4846       [rnd_seed_2]
$4867       [rnd_gen]
$486e       [lptpos]
$486f       [prtflg]
            Selectionne la sortie des caractères (0=Terminal, 1=printer, ff=k7)
$4870       [getflg]
            Entrée des caractères sur clavier (0) ou cassette (255)
$4871       [picflg]
$4872       [cascom]
$4873       [rawprt]
$4874       [prtstt]
            État de l'imprimante
$4875       [prtcom]
$4876       [prtint]
$4878       [prtxlt]
$487a       [contbl]
$4884       [autflg]
            Etat courant de la commande AUTO
$4885       [autlin]
            Ligne courante de la commande AUTO
$4887       [autostep]
            Incrément du mode AUTO
$4889       [allflg]
            Execution de la boucle BASIC (0 to execute BASIC control loop)
$488a       [linlen]
$488b       [clmlst]
$488c       [curlin]
            Ligne courante du BASIC
$488e       [txttab]
$4890       [frgglg]
            Messages en anglais (1) ou francais (0)
$4891       [kbdtbl]
            Table de transcription du clavier
$4893       [tmpsav]
            Tempo actuel pour le générateur de son.
$4894       [octsav]
            Octave actuel pour le générateur de son.
$4895       [stktop]
            Addresse de départ (maximale) pour la pile. Initialisée tout en haut de la RAM.
$4897       [bufmin]
            Zone précédent la zone de tokenisation. Mis dans HL après avoir mis NUL en fin de chaîne à traiter.
$4898       [buf]
            Buffer d'entrée pour le BASIC
$4918       [endbuf_pre]
            Juste avant la fin du buffer
$4919       [endbuf]
            Fin du buffer
$491a       [dimflg]
$491b       [valtyp]
            (0 = numeric, 1=string)
$491c       [dores]
            Drapeau de suppression de la tokenisation
$491d       [contxt]
$491f       [memsiz]
            Plus haute mémoire disponible (pour le BASIC ?)
$4921       [temppt]
$4923       [tempst]
$499b       [dsctmp]
$49c3       [fretop]
$49c5       [temp3]
$49c7       [temp8]
$49c9       [endfor]
$49cb       [datlin]
$49cd       [subflg]
$49ce       [flginp]
$49cf       [temp]
$49d1       [ptrfrg]
$49d2       [temp2]
$49d4       [oldlin]
$49d6       [oldtxt]
$49d8       [vartab]
$49da       [arytab]
$49dc       [strend]
$49de       [datptr]
$49e0       [prmnam]
$49e2       [prmval]
$49e4       [prmval_2]
$49e6       [fac_lsb]
$49e8       [fac_msb]
$49e9       [fac_exp]
$49ea       [fac_sgn]
$49eb       [fbuffr]
$49f8       [fmltt1]
$49f8       Valeur temporaire pour la multiplication (`fp_bcde_mul`)
$49f9       [fmltt2]
$49f9       Valeur temporaire pour la multiplication (`fp_bcde_mul`)
$49fb       [end_vars]
            Adresse juste après la dernière des variables système.
$e1c1       [jumpE1C1]
