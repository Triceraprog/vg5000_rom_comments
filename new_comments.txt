$0000       [reset]
            %CODE,SECTION(in)
            Tout commence par un saut à l'adresse $1000.

            C'est aussi `RST 0`.

            Le Z80 réserve le bas de la mémoire aux branchements de type `RST`.
            Il est donc standard que `RST 0`, le reset, branche vers une
            adresse plus loin pour la phase démarrage du système.

            Cette adresse est variable d'une machine à l'autre. Sur VG5000µ, c'est
            $1000.

            == DEBUT DE SECTION IN (bas niveau et interruptions) ==

$0003       %NTS
            Numéro de la version de la ROM

$0008       [chkchr]
            %CODE
            Vérifie que le caractère pointé par HL est égal au caractère qui suit exactement
            l'instruction `RST $8`/`RST 1` appelante.
            
            Si ce n'est pas le cas, affiche un message d'erreur de syntaxe BASIC.

$0008       Enregistre le caractère pointé par HL
$0009       Échange le contenu sur le haut de la pile (l'adresse de retour de RST) et HL
$000a       Compare le contenu de l'adresse de retour et la valeur sauvée dans A
$000b       Incrémente HL afin que l'adresse de retour saute le caractère suivant l'instruction appelante
$000c       Remet la nouvelle adresse de retour en place sur la pile
$000d       Si les deux caractères comparés étaient différent, saute en stx_err_prt ; sinon, passe dans chget

$0010       [chget]
            %CODE,MS_BASIC(GETCH)
            Incrémente HL et met le caractères pointé par le nouveau HL dans A.

            Appelé par `RST $10`/`RST 2`

            Retour:
            - A = code caractère
            - Carry = 1 si c'est un chiffre, 0 sinon
            - Z = 1 si c'est une fin de ligne (A était égal à 0)
$0010-$0011 A prend la valeur pointée par HL incrémenté de 1
$0012       %CHAR
            ':' est le premier caractère après '9'
$0014       Ce n'est pas un chiffre (ni zéro), retour immédiat.

$0018       [outdo]
            %CODE
            Envoi d'un caractère sur le périphérique sélectionné par `prtflg`.

            Appel par `RST $18`/`RST 3`.

            Entrée :
            - le caractère à envoyer est dans A.

$0018       L'implémentation de `outdo` est plus loin.

$001b       [setext]
            %CODE
            Redéfinition d'un caractère programmable de la mémoire vidéo.

            Entrée :
            - A[6:0] contient le carractère à changer (sur 7 bits).
            - A[7] contient la nature de la palette (0 == Texte, 1 == Graphique)
            - HL pointe sur le buffer de 10 octets avec les valeurs de caractère.

            [ArticleSETEXT]

$001b       L'implémentation de `setext` est plus loin.
$001e       ---

$0020       [dcompr]
            %CODE
            Comparaison de HL et DE.

            Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
            Aucun des deux registres n'est modifié.

            Appel par `RST $20`/`RST 4`.

            Entrée :
            - HL et DE, les deux registres à comparer.
            
            Sortie :
            - A est modifié
            - Carry est à 1 si DE est supérieur à HL.
            - Z est à 1 si les deux registres sont égaux.

$0020-$0024 Effectue d'abord la soustraction (H-D) puis (L-E) si H et D sont égaux.
            Aucun des deux registres n'est modifié.

$0026       ---

$0028       [getsign]
            %CODE
            Détermine le signe du nombre dans l'accumulateur flottant.

            Appel par `RST $28`/`RST 5`.

            Retour:
            - A retourne $FF (négatif), $00 (nul) ou $01 (positif).
            - Préserve HL
$0028-$002b Si l'exposant est à 0, alors le nombre est nul.
$002c       Saute si l'exposant est 0.
$002f       Sinon sort avec 0 dans A.

$0030       [usrrst]
            %CODE
            Cette entrée de `RST` est réservée pour l'utilisateur.

            Appel par `RST $30`/`RST 6`.

            [ArticleRST6]

$0030       Saut vers le trampoline, initialement contenant `RET`.

$0033       [warmgo]
            %CODE
            Indirection pour le redémarrage à chaud.

            Est-ce jamais utilisé ???

$0033       Saute vers l'implémentation du démarrage à chaud.
$0036       ---

$0038       [irq]
            %CODE
            Traitement de l'interruption (IRQ) du Z80.

            Le Z80 fonctionne en mode 1. Dans ce mode, un signal IRQ provoque, après
            traitement de l'instruction en cours, un branchement à cette addresse.

            Sur le VG5000µ, cette interruption est levée par le signal VBLANK (???)
            de l'affichage, provoqué par l'EF9345.

            Un vecteur est disponible pour installer une routine d'utilisateur qui
            sera appelée lors du traitement de l'IRQ.

            Appel par `RST $38`/`RST 7`. ???

            [ArticleUserIRQ]

$0038       Appel au vecteur utilisateur.
$003b       Sauve AF.
$003c       Décrémente le compteur de temporisation d'affichage
$003f       Si le compteur n'est pas nul, on évite le rafraichissement.
$0042-$0045 Chargement de la valeur de référence du compteur de rafraichissement.
$0048-$004c Test puis mise à zéro du bit 0 du flag d'affichage.
$0050       Si le flag d'affichage était à zéro, on évite le rafraichissement.
$0053-$0055 Début du rafraichissement de l'affichage, avec sauvegarde
            de registres.
$0056       Envoi à EF9345 de commandes (à décoder)
$0058       ---
$005a       ---
$005c       ---
$005e       ---
$0060       ---
$0062       ---
$0065       ---

$0066       [nmi]
            %CODE
            Interruption non masquable.

            L'interruption est provoquée par l'appui sur la touche Delta, qui est branchée
            sur l'interruption du processeur (via ???)

            L'interruption branche immédiatement vers un vecteur qui, par défaut, branche à
            son tour vers `test_reset`. Cette routine par défaut vérifie l'appuie sur la
            touche CTRL. Si c'est le cas, un redémarrage à chaud aura lieu. Sinon, il ne
            se passe rien de plus.

            [ArticleUserNMI]

$0069       [lang_to_eng]
            %CODE
            Met le système en anglais.

            Le seul accès semble être via la valeur que prend temporairemet `nmihk` pendant le démarrage.
$0069-$006b Messages en anglais.
$006e-$0071 Table de transcription du clavier en anglais.
$0074       Retour d'interruption NMI.

$0076       ---

$0080       [retfun]
            %CODE
            Fin de fonction d'utilisateur.

            Doit être appelé à la fin d'une fonction utilisateur afin de placer le contenu de A comme
            résultat de la fonction.

            Entrées : 
            - A contient la valeur de retour de la fonction
            - HL pointe sur le texte BASIC
$0080       Saut vers l'implémentation.

$0083       [deint]
            %CODE
            Place l'accumulateur flottant en tant qu'entier dans DE.

            Peut être appelé par une fonction utilisateur afin de récupérer le contenu de
            l'accumulateur flottant en tant qu'entier, dans DE. Si ce n'est pas possible,
            une erreur BASIC est provoquée.

            Entrées :
            - HL pointe généralement sur le texte BASIC (mais ne sert pas et est préservé).
            
            Sortie :
            - DE contient la valeur de l'accumulateur flottant, sous forme entière.
$0083       Saut vers l'implémentation.

$0086       [getbyt]
            %CODE
            Évalue l'expression BASIC pointée par HL et renvoie son résultat dans A.

            Le résultat de l'expression doit être numérique et tenir sur 8 bits.
            Dans le cas contraire, une erreur BASIC sera levée.

            Entrées :
            - HL pointe sur le texte BASIC.

            Sortie :
            - DE contient l'évaluation de l'expression, sous forme entière.
            - HL est avancé après l'expression.
$0086       Saut vers l'implémentation.

$0089       [frmnum]
            %CODE
            Évalue l'expression BASIC pointée par HL et renvoie son résultat dans FAC.

            Si l'expression n'est pas numérique, une erreur BASIC sera levée.
            
            Cette opération peut être enchaînée avec un appel à `deint` pour récupérer le
            résultat sous forme d'entier 16 bits dans DE.

            Entrées :
            - HL pointe sur le texte BASIC.

            Sortie :
            - FAC contient l'évaluation de l'expression.
            - HL est avancé après l'expression.
$0089       Saut vers l'implémentation.
$008c       [beep]
            %CODE
            Produit un son.

            Entrées :
            - DE contient la durée du son.
            - (sonsav_hi) contient le temps "mark" du son (trouver un nom en francais) ???
            - (sonsav_lo) contient le temps "space" du son (trouver un nom en francais) ???

            [ArticleBeep]
$008c       Saut vers l'implémentation.

$008f       [play]
            %CODE
            Joue une séquence sonore codée par une chaîne de caractères selon le format de la commande
            BASIC `PLAY`.

            Entrées :
            - BC pointe vers la chaîne de commande.
            - E contient la taille de la chaîne de commande en octets.

            [ArticleVDP]
$008f       Saut vers l'implémentation.

$0092       [putahl]
            %CODE
            Place une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            La position est spécifiée.

            Le BASIC n'utilise pas cette commande et passe par une mémoire intermédiaire.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC et AF

            [ArticleVDP]
$0092       Saut vers l'implémentation.

$0095       [putici]
            %CODE
            Place une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            Le caractère est placé à la position courante du curseur.

            Le BASIC n'utilise pas cette commande et passe par une mémoire intermédiaire.

            Entrées :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC et AF

            [ArticleVDP]
$0095       Saut vers l'implémentation.

$0098       [getahl]
            %CODE
            Lit une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            La position est spécifiée.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            Sorties :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC DE, et AF

            [ArticleVDP]
$0098       Saut vers l'implémentation.

$009b       [getici]
            %CODE
            Lit une paire « caractère / attribut » sur 16 bits en s'adressant directement au VDP.
            Le caractère est lu depuis la position courante du curseur.

            Entrées :
            - H contient la ligne du curseur (0 = première ligne, 8-31 = lignes 1 à 24)
            - L contient la colonne du curseur (0-39)
            Sorties :
            - D contient le code caractère
            - E contient l'attribut
            Modifie :
            - BC DE, et AF

            [ArticleVDP]
$009b       Saut vers l'implémentation.

$009e       [cls]
            %CODE
            Efface la mémoire tampon de l'écran.

            L'effacement se fait en effçant la première selon la procédure `cll` qui suit, puis
            en recopiant son contenu dans le reste de la mémoire tampon.

            Entrées :
            - (attbak) contient la couleur de fond.
            - (attcar) contient les attributs de caractères.

            [ArticleScreenBuffer]
$009e       Saut vers l'implémentation.

$00a1       [cll]
            %CODE
            Efface une ligne donnée de la mémoire tampon de l'écran.

            L'effacement se fait en plaçant en début de ligne un caractère de délimitation dont les paramètres
            se trouvent en (attbak). Puis en remplissant la ligne avec $20 (espace ASCII) en mode
            texte, ou $00 en mode graphique, avec un attribut, selon la directive (attcar).

            Entrées :
            - A contient le numéro de la ligne.
            - (attbak) contient la couleur de fond.
            - (attcar) contient les attributs de caractères.

            [ArticleScreenBuffer]
$00a1       Saut vers l'implémentation.

$00a4       [wait]
            %CODE
            Attente que le VDP soit prêt.

            Modifie :
            - AF

            [ArticleVDP]
$00a4       Saut vers l'implémentation.

$00a7       [fndadr]
            %CODE
            Calcule de l'adresse dans le tampon vidéo de coordonnées.

            Entrées :
            - H contient le numéro de la ligne (Y)
            - L contient le numéro de la colonne (X)
            Sortie :
            - HL contient l'adresse correspondante dans le tampon vidéo

            [ArticleScreenBuffer]
$00a7       Saut vers l'implémentation.

$00aa       [kbscan]
            %CODE
            Renvoi le numéro de la touche clavier appuyée, ou 0.

            Effectue un scan du clavier sur le moment.

            Sortie :
            - A contient le caractère ASCII produit par la touche appuyée, ou bien 0.
            - Le Carry Flag indique si la lue touche a changé depuis le dernier appel (0) ou est restée identique (1).

            [ArticleKeyboard]
$00aa       Saut vers l'implémentation.

$00ad       [regst]
            %CODE
            Envoie au VDP une liste de paires (registres, valeur).

            Le premier élément de la liste est le nombre de paires de la table.
            Suivent les paires sous forme de deux octets, le premier contenant l'adresse de selection de registre et le deuxième la valeur à transmettre.

            Entrées :
            - HL pointe vers la table des valeurs.

            Modifie :
            - HL, BC, AF
            [ArticleVDP]
$00ad       Saut vers l'implémentation.

$00b0       [stkv]
            %CODE
            Vérification de l'axe vertical pour les déplacements.

            L'axe vertical est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. A pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.
            
            Sortie :
            - A = 0, aucune action selon l'axe vertical.
            - A = 1, action vers le bas.
            - A = 255, action vers le haut.

            Modifie :
            - AF, B

            [ArticleActions]
$00b0       Saut vers l'implémentation.

$00b3       [stkh]
            %CODE
            Vérification de l'axe horizontal pour les déplacements.

            L'axe horizontal est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. A pour le joystick gauche, 1 pour le joystick droit, 2 pour les touches curseurs du clavier.
            
            Sortie :
            - A = 0, aucune action selon l'axe horizontal.
            - A = 1, action vers la droite.
            - A = 255, action vers la gauche.

            Modifie :
            - AF, B

            [ArticleActions]
$00b3       Saut vers l'implémentation.

$00b6       [stka]
            %CODE
            Vérification du bouton d'action.

            Le bouton d'action est vérifié sur un des deux joysticks ou sur le clavier en fonction de la valeur de selection contenue dans A.

            Entrées :
            - A contient le choix du périphérique à scanner. A pour le joystick gauche, 1 pour le joystick droit, 2 pour la barre espace du clavier.
            
            Sortie :
            - A = 0, aucune action.
            - A = 1, bouton actif.

            Modifie :
            - AF, B

            [ArticleActions]
$00b6       Saut vers l'implémentation.

$00b9       [break]
            %CODE
            Vérification de la séquence `break` (shift + stop appuyés au clavier).

            Sortie :
            - A = 1 si `stop` n'était pas pressé
            - A = 4 si `stop` était pressé, mais pas `shift`.
            - A = 0 si `stop` et `shift` étaient pressés, le Carry est à mis à 1.
$00b9       Saut vers l'implémentation.

$00bc       [disp_refrsh]
            Rafraichissement de l'état de l'affichage sur l'EF9345 en fonction
            du contenu de la mémoire vidéo en RAM ($4000)

            Le séquence commence avant le branchement à la fin de `irq:`.
$00bc       ---
$00bf       Séquence EF9345 à décoder
$00c1       ---
$00c3       ---
$00c5       ---
$00c7       ---
$00c9       ---
$00ca       ---
$00cc       ---
$00ce       ---
$00d0       ---
$00d1       ---
$00d3       ---
$00d6       ---
$00d8       ---
$00da       ---
$00dc       ---
$00de       ---
$00e0       [r_line0_lp]
$00e2       ---
$00e4       ---
$00e6       ---
$00e8       ---
$00ea       ---
$00ec       Boucle sur les 80 octets de la première ligne
$00ee       ---
$00f0       ---
$00f2       ---
$00f4       ---
$00f6       ---
$00f8       ---
$00fa       ---
$00fb       ---
$00fd       24 lignes
$00ff       [r_line_loop]
$0101       ---
$0103       ---
$0105       [jump0105]
$0107       ---
$0108       ---
$010b       ---
$010d       ---
$010f       ---
$0111       [loop0111]
$0113       ---
$0115       [jump0115]
$0117       ---
$0118       ---
$011b       ---
$011d       ---
$011f       ---
$0121       ---
$0123       ---
$0125       ---
$0127       ---
$0129       ---
$012b       ---
$012d       [jump012D]
$012f       ---
$0130       ---
$0133       ---
$0135       ---
$0137       ---
$0139       ---
$013b       ---
$013c       ---
$013e       ---
$0142       ---
$0144       ---
$0147       ---
$0148       ---
$0149       ---
$014b       ---
$014d       ---
$014e       [skip014E]
$0150       ---
$0152       ---
$0154       ---
$0156       ---
$0158       ---
$015a       ---
$015c       ---
$015e       ---
$0160       ---
$0162       ---
$0164       ---
$0166       ---
$0168       [jump0168]
$016a       ---
$016b       ---
$016e       ---
$0170       ---
$0172       ---
$0174       ---
$0176       ---
$0178       ---
$017a       ---
$017e       ---
$0181       ---
$0183       [skip0183]
$0184       ---
$0185       ---
$0186       [skip_dsplay]
$0189       ---
$018a       ---
$018b       ---

$018c       [putahl_impl]
            Implémentation de `putahl:`.
$018c       ---
$018e       ---
$0190       ---
$0192       Place le curseur sur le ligne H
$0194       ---
$0196       ---
$0198       Place le curseur sur le colonne L

$019a       [putici_impl]
            Implémentation de `putici:`.
$019a       ---
$019d       ---
$019f       ---
$01a1       [put_wait1]
$01a3       ---
$01a4       ---
$01a7       ---
$01a9       ---
$01ab       ---
$01ad       ---
$01af       ---
$01b1       [put_wait2]
$01b3       ---
$01b4       ---
$01b7       ---
$01b9       ---
$01bb       ---
$01bd       ---
$01bf       ---
$01c1       ---
$01c3       ---

$01c4       [getahl_impl]
            Implémentation de `getahl:`.
$01c4       ---
$01c6       ---
$01c8       ---
$01ca       ---
$01cc       ---
$01ce       ---
$01d0       ---

$01d2       [getici_impl]
            Implémentation de `getici:`.
$01d2       ---
$01d5       ---
$01d7       ---
$01d9       ---
$01db       ---
$01dd       ---
$01df       [get_wait1]
$01e1       ---
$01e2       ---
$01e5       ---
$01e7       ---
$01e9       ---
$01eb       ---
$01ed       ---
$01ef       [get_wait2]
$01f1       ---
$01f2       ---
$01f5       ---
$01f7       ---
$01f9       ---
$01fb       ---
$01fc       [call01FC]
$01ff       ---
$0202       ---
$0203       ---
$0204       ---
$0207       ---
$0208       ---
$0209       ---
$020c       ---
$020d       ---
$020e       ---
$020f       ---
$0210       ---
$0213       ---
$0215       ---
$0216       ---
$0217       ---
$0219       ---
$021b       ---
$021d       ---
$021e       ---
$021f       ---
$0221       ---
$0223       ---
$0224       ---
$0227       ---
$0229       ---
$022c       ---
$022e       ---
$0230       ---
$0231       ---
$0234       ---
$0236       ---
$0239       ---
$023a       ---
$023e       ---
$0241       [skip0241]
$0244       ---
$0246       ---
$0248       ---
$024a       ---
$024d       ---
$024f       ---
$0250       [skip0250]
$0251       ---
$0254       ---

$0255       [cls_impl]
            Implémentation de `cls:`.
$0255       ---
$0256       ---
$0259       ---
$025c       ---
$025f       ---
$0262       ---
$0264       ---

$0265       [cli_impl]
            Implémentation de `cli:`.
$0265       ---
$0267       ---
$0268       ---
$026b       Écriture de $80 à la première position de la ligne
$026d       Récupération des attributs par défaut
$0270       ---
$0271       Écriture dans la position suivante des attributs par défaut
$0272       ---
$0275       ---
$0276       if bit(C,7) == 1 then A = 0 else A = $20
            Le bit 7 de C étant à 1 pour un caractère graphique, 0 pour texte
$0278       ---
$027a       ---
$027c       ---
$027d       [cli_default]
            Boucle pour écrire dans les positions suivantes de la ligne alternativement A et C.
            Donc un espace pour le mode texte et 0 pour le mode graphique, suivi des attributs
$027f       [cli_loop]
$0280       ---
$0281       ---
$0282       ---
$0283       ---
$0285       ---

$0286       [wait_impl]
            Implémentation de `wait:`.
$0286       ---
$0288       ---
$028a       [wait_loop]
$028c       ---
$028d       ---
$0290       ---

$0291       [fndadr_impl]
            Implémentation de `fndadr:`.

            Effectue le calcul $4000 + (80 * y) + (2 * x).
$0291       C contient x
$0292       L contient y
$0293-$0297 HL = L * 8 (c'est-à-dire y * 8)
$0298-$0299 DE = HL = y * 8
$029a-$029c HL = 32 * y + 8 * y = 40 * y
$029d       HL = 80 * y
$029e       C contient x
$02a0-$02a1 HL = 80 * y + 2 * x
$02a2-$02a5 HL = $4000 + 80 * y + 2 * x

$02a7       [kbscan_impl]
            Implémentation de `kbscan:`.

            Les touches sont branchées sur une matrice de 8 lignes de 8 colonnes.

            La première étape est de trouver la premier ligne contenant une touche appuyée,
            puis dans cette ligne, trouver laquelle des 8 touches est appuyée.

            À partir de la ligne et de la colonne, un index est calculé et cet index sert
            à lire la valeur de la touche dans une table.

            Il y a trois tables consécutives.
            - Table standard
            - Table avec `shift` appuyée.
            - Table avec `control` appuyée.

            Ces tables sont en RAM et remplies à l'initialisation en fonction de la langue
            du sytème.

$02a7       Prépare C avec le premier port à scanner ($87) et B avec le nombre de ports (7).
$02aa       [kb_row_loop]
            lecture de l'entrée
$02ac-$02ad La ligne est à l'état haut lorsque la touche n'est pas pressée.
            En prenant son complément, un résultat à 0 signifie qu'aucune touche de la rangée n'est pressée.
$02ae       Branche si une touche est pressée sur cette ligne.
$02b0       Vise le port précédent.
$02b1       Boucle sur le nombre de ports (7).
$02b3       Quel est le port ici ???
$02b5       ---
$02b6       Masque avec b10111011 de la dernière ligne lue.
$02b8       [key_pressed]
$02b8       Branche si aucune touche n'est pressée.
$02ba       ---
$02bc       [col_count]
$02bc-$02bf Cherche la 'colonne' de la touche appuyée et décalant
            vers la gauche A jusqu'à ce que Carry passe à 1, tout
            en comptant depuis 7 à rebours.
$02c1       [col_exit]
$02c1       Place dans A la colonne de la touche pressée.
$02c2       A=2 * colonne
$02c3       A=4 * colonne
$02c4       A=8 * colonne
$02c5       A=(8 * colonne) + (port de la ligne) ($80 à $87)
$02c6       A=(8 * colonne) + (port de la ligne - $80) (0 à 7)
            Cela donne l'index dans la table de décodage.
$02c8       ---
$02ca       Lecture du rang 0 dans B pour vérifier l'appui sur `shift` et `control`.
$02cc-$02cf Préparation de la table de décodage dans HL et du potentiel décalage.
$02d2       Vérification de la touche `shift` appuyée.
$02d4       Branchement si `shift` n'est pas appuyée.
$02d6       Déplacement du pointeur vers la table de décodage avec `shift` appuyée.
$02d7       Si `shift` est appuyée, `control` est ignorée.
$02d9       [key_noshift]
$02d9       Vérification de la touche `control` appuyée.
$02db       Branchement si la touche `control` n'est pas appuyée.
$02dd-$02de Ajoute $80 (2 * $40) à l'adresse de la table de décodage.
$02df       [key_noctrl]
$02df-$02e0 L'index de la table, dans A, est copié dans DE.
$02e2       L'index est ajouté au pointeur de la table.
$02e3       La valeur de la table est lue dans A.
$02e4       [key_changed]
$02e4       Comparaison avec la valeur précédente lue au clavier.
$02e7       Set Carry flag
$02e8       Branche si la nouvelle touche pressée est identique à la précédente.
$02ea       Sinon, on enregistre la nouvelle valeur
$02ed       Et le Carry flag est enlevé
$02ee       [kbscan_exit]

$02ef       [regst_impl]
            Implémentation de `regst:`.
$02ef       Lecture dans B de la longueur (nombre de paires) de la table.
$02f0       Place HL sur l'octet suivant de la séquence.
$02f1       [regst_loop]
$02f4-$02dc Utilisation de `outi` pour enoyer les paires vers le VDP.
            À chaque tour de boucle, le premier octet est envoyé vers le port `$8f`
            et le second vers le port `$cf`. Chaque envoie est précédé d'une attente
            d'état `prêt` du VDP.

$02ff       [add_half]
            %SECTION(f4i),MSBASIC(ROUND)
            Ajoute `0.5` à FAC (l'accumulateur flottant).

            Est utilisé pour faire un arrondi à l'entier le plus proche.

            == DEBUT DE SECTION F4I (mathématiques flottantes) ==

$0302       [fp_add_hl]
            %MS_BASIC(ADDPHL)
            Addition flottante : (HL) + FAC

            Entrées :
            - FAC
            - Le nombre flottant pointé par HL.

            Sortie :
            - FAC contient le résultat.
$0302       Charge les quatre octetcs pointés par HL dans BCDE.
$0305       Branche vers l'addition entre BCDE et FAC.
$0307       [fp_sub_hl]
            %MS_BASIC(SUBPHL)
            Soustraction flottante : (HL) - FAC

            Entrées :
            - FAC
            - Le nombre flottant pointé par HL.

            Sortie :
            - FAC contient le résultat.

            La suite se décode comme :
            - call     hl_to_bcde ; (cd e0 05)
            - ld       hl,$d1c1   ; (21 c1 d1)
            La deuxième instructon saute par dessus les deux `pop` pour arriver directement sur
            l'inversion de signe de `fp_bcde_sub`.

$030b       [fp_stck_sub]
            %CODE,MS_BASIC(PSUB)
            Appelé via la table des priorités lors de l'évaluation d'une expression.
            Soustrait FAC du contenu de la pile, placé dans BCDE.
$030b-$030c Récupère le nombre flottante depuis la pile puis continue
            sur l'inversion de signe et l'ajout de BCDE à FAC.

$030d       [fp_bcde_sub]
            %MS_BASIC(SUBBCDE)
            Inverse le contenu de FAC puis y ajoute BCDE.
            Ce qui revient à faire BCDE - FAC.

$0310       [fp_bcde_add]
            %MS_BASIC(FPADD)
            Appelé via la table des priorités lors de l'évaluation d'une expression.
            Ajoute le contenu de BCDE et de FAC.
$0310-$0312 Si l'exposant de BCDE est 0, il n'y a rien à ajouter, on ne touche pas à FAC et on sort.
$0313-$0317 Si l'exposant dans FAC est 0, alors on copie BCDE dans FAC et c'est terminé
$031a-$031b Si l'exposant de BCDE (B) est plus petit que celui de FAC (A), on garde comme ça. Sinon, on les échange.
$031d-$031e Oppose la différence entre les expostants (complément à 2)
$031f       Sauve DE...
$0320       Le temps de mettre FAC sur la pile
$0323       ... et restaure DE
$0324       Copie BCDE dans FAC
$0327-$0328 Et récupère BCDE (l'ancien FAC) depuis la pile.
$0329       [no_swap]
            Ici, BCDE contient le plus petit des nombres. A contient la différence (positive) entre les deux exposants.
$0328-$032b Si la différence est de plus de 25. BCDE est négligeable face à FAC, on a terminé.
$032c       Sauve AF
$032d       Extrait les signes de FAC et BCDE, A bit 7 à 1 si les signes sont opposés, 0 si identiques.
$0330       Sauve le résultat du signe dans H
$0331       Et récupère AF
$0332       Déplace la mantisse à droite (division) d'un nombre de position égal à A
$0335-$0336 Test le résultat de signe
$0337       Pointe sur la mantisse
$033a       Branche si les signes étaient différents. Dans ce cas, on doit faire une soustraction.
$033d       Ajoute les mantisses de FAC et BCDE
$0340       Pas d'overflow, on passe à l'arrondi du résultat (et sa normalisation)
$0342       Sinon, il faut augmenter...
$0343       .. l'exposant de 1
$0344       Si l'exposant a dépassé sa limite (boucle sur zéro), branche sur une erreur de dépassement de capacité.
$0347-$0349 Sinon, il faut corriger la mantisse avec un décalage de 1 (L) vers la droite
$034c       Puis on passe à l'arrondi

$034e       [min_bcde]
            FAC - CDEB -> BCDE. Si un overflow (underflow) est provoqué, le nombre est complémenté à 2 à la fin. Puis fallback dans la normalisation.
$0350       B ici contient le résultat du shift à droite le moins signifiant. Le nombre est sous forme CDEB
$035c       [pos_norm]
            Met le nombre en positif potentiellement avant de normer et compacter.
$035c       Si Carry est à 1, fait le complément à 2 de CDEB.

$035f       [bcde_norm]
            Lors de la normalisation, BCDE n'a pas le format normal. B n'est pas l'exposant, mais le poids le plus faible de la mantisse.

            C'est donc une mantisse sous forme CDEB qui est traitée. L'exposant est celui de FAC.
$035f-$0360 L et H sont les plus petits signifiants de la mantisse, qui est sous la forme CDHL (l'exposant est dans FAC)
$0361       A = 0, va servir de compteur

$0362       [rot_loop]
            La partie ci-dessous prend C, D, H, L, A comme un buffer en decalage vers la gauche
            (octet par octet). A est un compteur (sauvé temporairement dans B pendant la rotation) auquel
            on soustrait 8 à chaque fois, jusqu'à attendre $e0 (ce qui fait 4 fois avec A = 0 au début)
$0362       Sauvegarde du compteur dans B
$0363       Récupère le MSB de la mantisse dans A
$0364       Si A est différent de 0, c'est que C (la partie la plus haute de la mantisse) était non nul
$0365       Si A (dont l'octet le plus haut) est 0, on peut faire le décalage d'un octet complet. Sinon, bit par bit
$0367       On décale...
$0368       ... CDHL
$0369       ... vers
$036a       ... DHLA (et A est égal à 0 ici). On embarque L (l'exposant) dans le shift, pour tester au passage s'il était nul.
$036b       Récupération temporaire dans A du compteur
$036c-$036e Soustrait 8 du compteur, puisque l'on vient de décaler de 8, et comparaison avec -24-8.
$0370       Arrêt si le compteur est arrivé à 32. On a shifté de 32 bits au max, le résultat est donc 0. Sinon, on continue le shift
$0372       [clear_fac]
$0372       On met 0 dans le FAC
$0373       [a_to_exp]
$0376       Charge A dans l'exposant de FAC.
$0377       [normal]
$0378-$0379 Vérifie s'il y a des bits dans DHL (les LSBs de la mantisse).
$037a       Si oui, il faut les traiter avec les routines complète
$037c       Sinon, on ne traite que C pour trouver le premier bit de poids fort. Routine optimisée
$037d       [bit_find]
$037d-$037f Diminue B jusqu'à trouver le premier bit à 1 dans A (qui vient de C). B est le résultat du nombre de shift de 8 effectué précédemment, en soustraction de $00.
$0381       Bit à 1 trouvé. On remet B un cran avant.
$0382       On remet aussi le nombre au cran d'avant (remettre le CY dans le nombre)
$0383       C (MSB de la mantisse) est normalisé (avec 1 en msb)
$0386       [norm_full]
$0386       Compte un bit de shift
$0387       Décale HL à gauche de 1
$0388-$038a Shift D de 1 en récupérant le Carry de HL
$038b-$038d Shift C de 1 en récupérant le Carry de D
$038e       [norm_bit]
$038e       Il reste quelque chose, on continu la normalisation
$0391       [norm_nxt]
$0391       Le compteur de shift est mis dans A. CDHL est normalisé.
$0392-$0393 Reconstruction de CDEB contenant la mantisse
$0394-$0395 On n'a rien shifté, on passe à l'arrondi
$0397-$039a Modification de l'exposant avec le compteur de décalage (B est négatif en complément à 2).
$039b       Remise en place de l'exposant ajusté.
$039c       Le décalage est trop grand, on n'a plus de précision, le résultat est 0
$039e       L'exposant est 0, le résultat est donc 0 (dans d'autres versions, un RET Z est fait ici)
$03a0       [round]
$03a0       Récupère la plus petite partie de la mantisse
$03a1       [round0]
$03a4       Vérifie si la plus petite partie de la mantisse a son msb à 1
$03a5       Dans ce cas, on arrondi vers le haut.
$03a8       Récupération dans B de l'exposant
$03a9-$03aa Récupération dans A du résultat de signe
$03ab       Récupération du bit de signe (seul le msb compte)
$03ad       Place le bit de signe (le msb de C est forcément à 1, donc un XOR fonctionne si 1 signifie + ?)
$03ae       Remet en place le MSB + Signe de la mantisse
$03af       Place le résultat dans FAC
$03b2       [round_up]
$03b2       Incrément la partie basse de la mantisse
$03b3       Si on n'a pas fait d'overflow (retour à zero), c'est ok, on revient
$03b4       Sinon, on augmente la partie suivante
$03b5       On vérifie encore
$03b6       Si on doit toujours arrondir, on arrondie la partie suivante
$03b7       Dernière chance
$03b8       Tout a été arrondi, on reset C
$03ba       Et on incrémente l'exposant
$03bb       Retour si tout va bien. Mais si l'exposant a bouclé sur 0
$03bc       Alors c'est que le nombre est trop grand, on lance l'erreur.

$03bf       [add_bcde]
            Ajoute les mantisses de FAC et CDE. Le résultat dans FAC, et Carry à 1 si dépassement de capacité.

$03bf-$03ca HL pointe sur la mantisse de FAC. Y ajoute la mantisse CDE.

            Les exposants des deux nombres doivent être identiques pour que cela ait du sens.
            Si la mantisse provoque un dépassement de capacité, le Carry sera à 1 en sortie.

$03cb       [cpl_2]
            Complément à 2 de la mantisse sous forme CDEB.
$03cb-$03cd Inverse le bit de signe temporaire.

$03df       [scale]
            %MS_BASIC(SCALE)
            Décalage vers la gauche de la mantisse CDEB d'un nombre donné par A.

            Le décalage se fait d'abord par groupe de 8 bits tant que c'est possible, puis continue bit à bit.
            
$03df       Initialise B à 0. B contiendra les bits les moins significatifs de la mantisse.
$03e1       [shiftr_8]
$03e1-$03ea Décale la mantisse de 8 bits (un registre complet) vers la droite.
$03ec       [end_256]
$03ec       La denière soustractiona a fait passer A négatif, on y ajoute 8+1.
$03ee       Sauvegarde de l'exposant restant dans A
$03ef-$03f2 S'il y a des bits à 1 dans le bas de la mantisse (DEB), on passe sur la méthode complète (plus lente) de shift vers la droite L fois.
$03f4       Sinon, on s'occupe uniquement de la partie haute de la mantisse (C)
$03f5       [msb_shift]
$03f5       Décrémentation du nombre de décalage restant (la boucle commence par le test, ce qui explique le 8+1 ajouté à A).
$03f6       Traitement terminé, routine terminée.
$03f7       Décalage à droite.
$03f8       Résultat dans C.
$03f9       Si le décalage a fait sortir un bit à 1, branchement vers la méthode complète.
$03fb       Le décalage n'a pas fait sortir de bit à 1, on continue avec le décalage de C uniquement.

$03fd       [fp_shift_r]
            %MS_BASIC(SHRLP)
            Décalage vers la droite L fois de la mantisse CDEB.
            Méthode complète.
            
$03fd       A prend 0. Et Carry est à 0 (important pour initialiser le décalage à droite)
$03fe       Décrémentation du nombre de décalage restant (la boucle commence par le test, ce qui explique le 8+1 ajouté à A).
$03ff       Traitement terminé, routine terminée.
$0400       Début du décalage du groupe CDEB vers la droite de 1.

$0401       [shft_right]
$0401-$0402 Décalage d'un bit vers la droite de CDEB, partie C.
$0403       [shift_rgt_2]
$0403-$0405 Décalage d'un bit vers la droite de CDEB, partie D.
$0406-$0408 Décalage d'un bit vers la droite de CDEB, partie E.
$0409-$040B Décalage d'un bit vers la droite de CDEB, partie B.
$040e       [unity]
$0412       [logtab]
$0412       Longueur du tableau.
$0413       [logtab_0]
$0413       4.811474800109863
$0417       [logtab_1]
$0417       6.105852127075195
$041b       [logtab_2]
$041b       -8.86266040802002
$041f       [logtab_3]
$041f       -2.054666757583618
$0423       [logtab2]
$0423       Longueur du tableau.
$0424       [logtab2_0]
$0424       1.0
$0428       [logtab2_1]
$0428       6.427842140197754
$042c       [logtab2_2]
$042c       4.545170783996582
$0430       [logtab2_3]
$0430       0.3535534143447876
$0434       [inst_log]
            %CODE
$0434-$0426 Branche sur une erreur si l'argument, dans FAC, est négatif ou nul.       
$0439       Appel le calcul du log.
$043c-$043f BCDE = ln(2)
$0442       Multiplie le résultat par ln(2)
$0444       [log]
$0444       L'argument de l'instruction log est ramenée dans BCDE.
$0447-$0449 Initialise l'exposant de FAC avec $80 (c'est-à-dire exposant 0)
$044c       Opération sur l'exposant de FAC pour en retirer la valeur entière, qui sera utilisée plus loin.
            Note : le bit 7 de l'exposant, inversé, se retrouvera dans le bit de signe du nombre monté dans FAC (???)
$044d       Sauvegarde de AF
$044e       Pousse FAC (l'argument du `log` avec son exposant à `$80`) sur la pile.
$0451       Fait pointer HL vers la table de facteurs pour `log`.
$0454       Calcule le polynome avec les facteurs de `logtab`.
$0457-$0458 Récupère l'argument dans BCHL (car DE va être utilisé)
$0459       Pousse le résultat du polynome sur la pile.
$045c       Reconstitue BCDE, argument du `log`.
$045d       Monte BCDE dans FAC.
$0460-$0463 Calcule le second polynome avec les facteurs de `logtab2`.
$0466-$0467 Récupère BCDE, l'argument du `log`.
$0468       Division de l'argument dans BCDE par le polynome.
$046b       Récupération de l'opération sur l'exposant de FAC (inversion du bit 7).
$046c       Résultat de la division dans la pile.
$046f       Placement du nombre dans A dans FAC (qui était la valeur de l'exposant)
$0472-$0473 Récupération du résultat du calcul qui avait été mis sur la pile.
$0474       Ajout avec FAC.
$0477       Saute les deux `pop` suivant pour aller vers la multiplication.

$0478       [fp_stk_mul]
            %CODE
            Appelé via la table des priorités

            Multiplication du nombre flottant sur la pile avec FAC.
$0478-$0479 Récupération du nombre flottant sur la pile dans BCDE.

$047a       [fp_bcde_mul]
            Multiplication flottante

            Multiplication de BCDE et de FAC.
$047a       Récupère le signe de FAC.
$047b       Retourne immédiatement si c'est 0.
$047c-$047e Ajoute les exposants de FAC et BCDE
$0481-$0482 Sauve le MSB de BCDE dans le premier buffer de travail.
$0485-$0486 Sauve le reste de BCDE dans le second buffer de travail.
            Ces deux buffers servent à garder l'argument de la multiplication.
$0489-$048d BCDE = 0
$048e-$0491 Place l'adresse de retour sur la pile vers la normalisation de BCDE.
$0492       Charge l'adresse de la multiplication sur 8 bits
$0495-$0496 Et la place sur la pile comme deux adresses de retour.
            Ainsi, les trois prochains RET provoqueront deux appels à `mul_8b` puis un appel à `bcde_norm`.
$0497       HL pointe vers le LSB de FAC.
$049a       [mul_8b]
$049a       Début de la multiplication sur 8 bits. Récupération de la partie FAC du nombre.
$049b       Et déplacement de HL vers l'octet suivant.
$049c-$049d Branchement si cette partie est nulle.
$049f       Sauvegarde de HL, qui pointe vers l'octet suivant de FAC.
$04a0       Compteur de 8 bits pour la multiplication partielle par A.
$04a2       [mul_8b_loop]
$04a2       Récupération du bit de poids faible dans le Carry.
$04a3       Sauvegarde du multiplicateur dans A
$04a4       Copie du MSB de BCDE dans A.
$04a5       Branche si le bit du multiplicateur était à zéro : pas d'addition.
$04a7       Sauvegarde de l'octet du multiplicateur et du compteur de bits.
$04a8       Récupération des deux octets bas de l'accumulateur pour la multiplication.
$04ab       Addition de cette partie basse avec la partie basse de BCDE (l'accumulateur de résultat)
$04ac       Le résultat devient le nouveau DE.
$04ad       Restauration de H (multiplicateur) et L (compteur de bits)
$04ae-$04b1 Addition des deux MSB (argument et accumulateur) en tenant compte de la retenue des parties basses.
$04b2       [no_add]
$04b2       
$04b2-$04bc Décalage du résultat vers la droite de CDEB.
            Dans l'opération, les bits les plus faibles de la mantisse peuvent être perdus.
$04bd       Test si le décalage a amené un bit en position 5 de B (l'octet de récupération de la précision).
$04bf       Branche si ça n'est pas le cas.
$04c1-$04c4 Sinon, place un bit en position 6 de B, pour faire un arrondi vers le haut.
$04c5       [no_lost]
$04c5       Décrémente le compteur de bits
$04c6       Ramène l'octet de multiplicateur dans A
$04c7       Boucle s'il reste des bits à traiter
$04c9       [pop_hl_ret]
$04c9       Restaure l'adresse de l'octet de FAC à traiter.
$04ca       Ce RET va rappeler deux fois la multiplication puis la normalisation de BCDE (cf. le commentaire plus haut)
$04cb       [byte_shift]
$04cc-$04ce Décalage d'un octet complet de l'accumulateur CDEB.
$04cf       Voir les commentaires ci-dessus sur l'effet de RET dans cette routine de multiplication.

$04d0       [fp_div_10]
            Division de FP par 10
            
            MS_BASIC=DIV10
$04d0       Place FAC sur la pile
$04d3-$04d6 Monte le nombre "10" dans BCDE
$04d9       Monte BCDE dans FAC

$04dc       [fp_stk_div]
            Appelé via la table des priorités

            Division du nombre flottant sur la pile par FAC.
$04dc-$04dd Extrait BCDE depuis la pile.
$04de       [fp_bcde_div]
            Division du nombre BCDE par FAC.
$04df-$04e2 Branche vers une erreur de division par zéro si FAC est nul.
$04e4-$04e7 Soustrait les exposants des deux nombres (celui de BCDE par celui de FAC)
$04e8       Ajoute 1 à l'exposant
$04eb       Si boucle sur zéro, branche vers un dépassement de capacité.
$04ec       Ajoute 1 à l'exposant à nouveau
$04ef       Et vérifie à nouveau un dépassement de capacité.
$04f0       Fait pointer HL sur le MSB de FAC.
$04f1       Charge le MSB de FAC dans A.
$04f4       Et le sauve dans la mémoire de travail de la division.
$04f5-$04f6 Fait de même pour l'octet du milieu de FAC
$04f9-$04fb Et enfin pour l'octet le moins signifiant.
$04fe       Charge le MSB de BCDE dans B.
$04ff       Sauve la partie basse de BCDE dans HL.
$0500-$0503 CDE = 0. Contiendra le quotient de la division.
$0504       Dépassement/VLSB
$0507       [fp_div_loop]
$0507       Sauve la partie basse du dividende
$0508       Sauve la partie haute (B) du dividende.
$0509       Prend le LSB du dividende
$050a       Soustrait le diviseur (injecté dans la routine) du dividende (LHB).
            La routine de division, copiée en RAM au démarrage, est la suivante :

                div_subr:    sub      a,$00 ; LSB
                             ld       l,a
                             ld       a,h
                             sbc      a,$00 ; Middle
                             ld       h,a
                             ld       a,b
                             sbc      a,$00 ; MSB
                             ld       b,a
                             ld       a,$00 ; VLSB
                             ret

$050d       Continue la soustraction en accumulant les dépassements dans `fdivc_4`
$050f       Complémente le Carry
$0510       Branche si le diviseur était plus grand que le dividende.
$0512       Sinon, sauve le compteur de dépassement.
$0515-$0516 Supprime le diviseur de la pile.
$0517       Met le Carry à 1
$0518       Saute par dessus les deux `pop` suivant
$0519       [restore_div]
$0519-$051a Restaure le diviseur depuis la pile.
$051b       Prend le MSB du quotient.
$051c       Incrémente
$051d       Décrémente
$051e       Amène le Carry vers le bit 7 et le bit 0 vers le Carry.
$051f       Branche si le résultat est positive.
$0522       Rotation dans l'autre sens pour restaurer A.
$0523       Récupération du nombre de dépassements.
$0526       Rotation vers la droite.
$0527       Masque avec $c0
$0529       Sauve AF
$052a-$052d Branche si L = H = B = 0, c'est-à-dire qu'il n'y a plus rien à diviser.
$052f       Sinon, A = $20
$0531       [div_end]
$0531       Restaure HL (qui était AF)
$0532       Prépare les drapeaux pour l'arrondi.
$0533       Branche vers l'arrondie.
$0536       [div_2]
$0536       Pour initialiser un flag ???
$0537-$0539 Décale E vers la gauche
$053a-$053c Décale D vers la gauche (avec le bit sorti de E)
$053d-$053f Décale C vers la gauche (avec le bit sorti de D)
$0540       Double HL
$0541-$0543 Décale B vers la gauche (avec le bit sorti du doublement de HL)
$0544-$0548 Décale `fdivc_4` vers la gauche (avec le bit sorti du doublement de B)
$054b-$054e Saute si C, D ou E contiennent encore des bits à 1 (la division continue)
$0550       Sauve HL
$0551       Pointe vers l'exposant de FAC.
$0554       Décrémente l'exposant
$0555       Restaure HL
$0556       Si l'exposant est non nul, on boucle vers la suite de la division.
$0558       Sinon, on a perdu toute précision, FAC passe à zéro et la division est terminée.
$055b       [add_exp]
            %MS_BASIC(ADDEXP)
            Ajoute ou soustrait l'exposant de BCDE à celui de FAC.

            Entrée :
            - L = 0, ajoute
            - L = $FF, soustrait

$055b-$055d Branche si l'exposant du dividende est zéro.
$055f       Place l'argument (ajoute ou soustrait) dans A.
$0560       HL pointe vers l'exposant de FAC.
$0563       Si l'argument était L = 0, ne fait rien, si L = FF, complément à 1 de l'exposant.
$0564       Ajoute les deux exposants.
$0565       Résultat des exposants dans BCDE.
$0566       Récupération de Carry dans le bit de poids fort de A
$0567       Détection du dépassement de capacité de l'addition précédente.
$0568       Copie l'exposant dans A.
$0569       Branche en cas de possible dépassement de capacité.
$056c       Normalise l'exposant autour de 128.
$056e       Et le place dans FAC.
$056f       Branche si l'exposant est zéro.
$0572       Sinon, extrait le bit de signe.
$0575       Place le nouvel exposant.
$0576       Fait pointer HL juste avant l'exposant (MSB de FAC)
$0578       [truc]
            %CODE
$0578       [ovrflw_tst1]
$0578       Chercher le signe de FAC.
$0578       Prend son opposé
$0578       Nettoie la pile
$057b       [ovrflw_tst2]
$057b       Vérifie si la valeur est nulle (l'exposant ou le signe)
$057c       [exp_no_add]
$057c       Retire l'adresse de retour de la pile.
$057d       Si le résultat est positif, le résultat est zéro, on branche vers FAC = 0
$0580       Sinon, c'est un dépassement de capacité, on branche vers l'erreur.

$0583       [fp_x_10]
            Multiplication de FAC par 10
            
            MS_BASIC=MLSP10
$0583       Récupère FAC dans BCDE
$0586-$0588 Si BCDE est nul, retour immédiat (il suffit de vérifier l'exposant B)
$0589       En ajoutant 2 à l'exposant, on multiplie le nombre par 4
$058b       Sortie si Overflow avec le message d'erreur
$058e       Sinon, on remet l'exposant en place dans BCDE
$058f       Ce nombre x4 est ajouté à FAC, pour un résultat de x5
$0592-$0595 Incrémente directement l'exposant dans FAC, pour obtenir x10.
$0596       Retour si on n'a pas fait passer l'exposant à zéro, cela s'est bien passé.
$0597       Sinon, c'est un dépassement de capacité.

$059a       [getsign_2]
$059d       Saute le `cpl` qui suit
$059e       [ret_cmp]
$059e       %CODE
            Prend le complément de A.
$059f       Rotation à gauche via Carry, qui contient donc le bit de poids fort de A.
$05a0       [flag_diff]
$05a0       Soustraction de A avec A avec retenu.
$05a1       Saute si la rotation avait débordée dans la retenue.
$05a2       Sinon, augmente A de 1 (autrement, dit A = 1 puisque la soustraction avait donné 0)
            Au final, le bit de poids fort de A est transformé en -1 (si bit à 0) ou 1 (si bit à 1)
$05a4       [inst_sgn]
            %CODE,MS_BASIC(SGN)
            Fonction BASIC `SGN()`.

            Place dans FAC le nombre entier dépendant du signe initial de FAC (-1, 0 ou 1).

$05a5       [a_to_fac]
            Place le contenu de A en tant qu'entier sur 8 bit vers FAC.
$05a5-$05a7 BCDE est préparé avec les valeurs $80,xx,$00,$00. A prendra la place de xx.
$05aa       [bade_to_fac]
            Place BADE sous format de nombre flottant dans FAC.
$05aa       Appelé depuis le traitement d'auto ($072e), A = 0, B = $98, DE = numéro de ligne ???
$05ad       Place la partie manquante de BCDE.
$05ae       Place l'exposant dans FAC.
$05af       Initialise B comme VLSB, à 0, pour donner CDEB.
$05b1       Pointe HL vers le bit de signe de FAC.
$05b2       Bit de signe à 1 (ce qui signifie positif, ce bit étant inversé par rapport à la forme normalisée BCDE)
$05b4       Place le bit de signe réel de A dans Carry
$05b5       Puis normalise.

$05b8       [inst_abs]
            %CODE,MS_BASIC(ABS)
            Fonction BASIC `ABS()`.

            Place dans FAC la valeur absolue de FAC.
$05b8       Prend le signe de FAC
$05b9       Retour immédiat si le signe est positif
$05ba       [inv_sign]
            Change le signe de FAC par son opposé
$05ba-$05bd Prend le MSB de FAC, dont le bit de poids fort est le bit de signe.
$05be       Inverse le bit de poids fort.
$05c0       Replace MSB avec le nouveau bit de signe.

$05c2       [fac_to_stck]
            Place le contenu de FAC sur la pile.

            Modifie :
            - DE
$05c2       Préserve HL.            
$05c3       Récupère les deux premiers octets de FAC.
$05c6       Les place sur la pile.
$05c7       Restaure l'adresse de retour.
$05c8       Récupère les deux octets suivants de FAC.
$05cb       Les place sur la pile.
$05cc       Restaure l'adresse de retour.
$05cd       Restaure HL

$05cf       [hl_to_fac]
$05cf       La valeur numérique pointée par HL est extraite dans BCDE.

$05d2       [bcde_to_fac]
            Place BCDE dans FAC.
            
            Préserve HL et BCDE.
$05d2       Échange DE et HL pour préserver HL et récupérer la partie basse du nombre
$05d3       Place la partie basse du nombre dans le début de FAC.
$05d6-$05d7 Charge HL avec BC, la partie haute du nombre et son exposant.
$05d8       Les place dans la seconde partie de FAC.
$05db       Restaure HL et DE.

$05dd       [fac_to_bcde]
            Extrait le contenu de FAC vers BCDE
$05dd       HL pointe vers le début de FAC.

$05e0       [hl_to_bcde]
            %MS_BASIC(LOADFP)
            Charge BCDE avec le nombre pointé par HL.
$05e0-$05e6 Place le contenu de FAC octet par octet dans BCDE
$05e7       [inc_hl]
$05e8       Incrémente une dernière fois HL.

$05e9       [fac_to_hl]
            Copie le contenu FAC vers ce que pointe HL.
$05e9       Fait pointer DE sur FAC

$05ec       [cpy_detohl_4]
            Copie le contenu des 4 premiers octets pointés par DE vers ce que pointe HL.
$05ec       Initialise le compteur de boucle à 4.
$05ee       [cpy_4_loop]
$05ee       Récupère l'octet pointé par DE
$05ef       Le copie vers ce que pointe HL
$05f0       Incrémente DE
$05f1       Incrémente HL
$05f2       Boucle selon le compteur B

$05f5       [ext_sign]
            Extrait le signe de BCDE et FAC et place 1 à la place.
            Sauve le signe de FAC dans l'octet de signe.

            Condition: BCDE est plus petit que FAC.

            Sortie :
            - Bit 7 de A à 1 si les signes de BCDE sont identiques, ou 0 si non.
            - HL pointe sur l'octet de signe
$05f5       Fait pointer HL vers le MSB de FAC
$05f8       Copie MSB vers A
$05f9       Rotation à gauche, ce qui place le btit de signe de FAC dans Carry et dans le bit 0 de A.
$05fa       Met le Carry à 1.
$05fb       Puis rotation à droite. Le MSB à donc son bit de poids fort à 1 et Carry contient le bit de signe initial.
$05fc       Replace le MSB de FAC, avec le 1 implicite de la mantisse explicité.
$05fd       Inverse le Carry (positif devient 1, négatif devient 0)
$05fe       Met le Carry dans le bit 7 de A, par rotation.
$05ff-$0600 Place HL après l'exposant, sur l'octet contenant le signe.
$0601       Place l'octet de signe.
$0602-$0607 Effectue la même opération avec BCE.
$0608       XOR entre les deux bits de signe (celui de BCDE et de FAC). BCDE non opposé, FAC opposé.
            Le bit 7 de A est donc à 1 si les deux nombres étaient de même signe, 0 sinon.

$060a       [cmp_num]
            %MS_BASIC(CMPNUM)
            Compare les nombres BCDE et FAC (-1 si FAC < BCDE, 0 si FAC = BCDE, 1 si FAC > BCDE)
$060a-$060c Si BCDE est nul, revient à calculer le signe de FAC.
$060f-$0612 Place sur la pile l'adresse de retour qui sera donc appelée au prochain RET.
$0613       Prend le signe de FAC.
$0614       Prend le MSB de BCDE (avec son signe)
$0615       Si FAC est nul, termine ici (et donc appelle ret_cmp qui transforme le bit de signe de BCDE en résultat -1/1)
$0616       Fait pointer HL sur le MSB de FAC.
$0619       Combine les deux signes (seul le bit 7 est important ici). Si les deux signes sont identiques, alors le bit 7 est à 0, sinon, il est à 1 et le drapeau M est à 1.
$061a       Remet le MSB de BCDE dans A
$061b       Termine si les signes étaient différents (le résultat est donc fonction du signe de BCDE)
$061c       Les nombres sont de même signe, on appel la comparaison générique.
$061f       Amène le Carry dans le bit 7.
$0620       Le combine avec le bit de signe de BCDE
$0621       Branche sur le calcul du résultat.
$0622       [cmp_fp]
            Compare les nombres flottants BCDE et FAC de même signe.

            Préserve BCDE et FAC.
$0622       HL pointait sur MSB à l'appel, on le décal vers l'octet de signe de FAC
$0623       Charge l'exposant de BCDE dans A.
$0624       Compare les exposants.
$0625       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$0626       HL pointe à nouveau sur MSB
$0627-$0628 Compare les deux MSB.
$0629       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$062a       HL pointe sur l'octet du milieu de FAC
$062b-$062c Compare les deux octets du milieu.
$062d       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$062e       HL pointe sur le LSB de FAC.
$062f-$0630 Compare les deux LSB.
$0631       Termine le calcul pour un résultat -1/1 si les exposants sont différents.
$0632       Arrivé ici, les deux nombres sont identiques, on retire de la pile l'adresse de retour vers `cmp_num`
$0633       Puis on retire l'adresse de retour qui branche vers `ret_cmp`.
$0634       Termine la comparaison avec A = 0.

$0635       [fp_to_int]
            %MS_BASIC(FPINT)
            Transforme un nombre flottant en décalant la mantisse jusqu'à ne garder que la partie entière.

            Entrées :
            - A contient l'exposant du nombre.
            - HL pointe sur FAC
$0635-$0638 Initialise B, C, D et E avec l'exposant.
$0639-$063a Si l'exposant est nul, retourne immédiatemet (avec BCDE à zéro par la méme occasion)
$063b       Sauvegarde de HL qui pointe sur FAC
$063c       BCDE prend la valeur de FAC.
$063f       Sortie des signes des nombres et mise en place des 1 de mantisse explicite.
$0642       Effectue à nouveau le XOR présent en fin de `ext_sign` pour retrouver le signe de BCDE (et FAC, qui sont identiques)
$0643       Met l'octet de signe dans H
$0644       Décrémente BCDE si le nombre est négatif.
$0647       Exposant maximal significatif pour un entier ($80 + 24)
$0649       Exposant maximum - exposant du nombre donne le nombre de bits de décalage.
$064a       Effectue le décalage de A bits. Après l'appel, on a donc le nombre sous forme entière 24 bits dans CDE.
$064d       Récupération du signe (en tant que bit de signe normal, non inversé)
$064e       Place le signe dans Carry.
$064f       Si le signe était 1 (donc négatif), appel l'arrondi vers le haut.
$0652       L'exposant de BCDE est mis à 0.
$0654       Si le nombre est négatif, prend son complément à 2.
$0657       Restaure HL

$0659       [dec_bcde]
            Soustrait 1 de BCDE

            Modifie :
            - A
$065d       Continue si la soustraction de 1 de DE nécessite une soustraction de DE.

$0660       [inst_int]
            %CODE,MS_BASIC(INT)
            Fonction BASIC `INT()`.
$0660       ---
$0663       ---
$0664       Comparaison avec $98, c'est à dire exposant 24, car c'est la capacité maximale de la mantisse. Au dela, il n'y a plus de précision pour les décimale.
$0666       Pourquoi prendre FAC LSB juste avant de retourner le résultat ??? (le résultat est dans le buffer flottant de toute façon)
$0669       La partie entière est donc trouvée immédiatement.
$066a       ---
$066b       En sortant de cet appel, E contient la partie basse entiere du nombre (si inférieur à 256)
$066e       Puisque le nombre entier est complètement à droite de la mantisse, l'exposant est à $98. Le nombre se fera normaliser par la suite.
$0670       ---
$0671       Mise sur la pile de l'octet le plus bas du nombre entier résultat (??? pourquoi ?)
$0672       ---
$0673       ---
$0674       ---
$0677       ---
$0678       ---

$0679       [dim_compute]
            Calcul la taille mémoire nécessaire pour stocker une dimension de tableau
            Entrées :
            BC == taille d'une dimension (ou index) du tableau
            DE == taille d'une entrée pour cette dimension (4 pour la première dimension, puis la taile d'une dimension pour les suivantes)
            Si une taille devient trop grande, lance une erreur Subscript Out of Range
            Retour :
            HL contient la taille nécessaire (ou le déplacement)
            DE == 0
            BC n'est pas touché
$0679       ---
$067c       ---
$067d       ---
$067e       Si BC == 0, retour immédiat
$067f       Préparation d'une boucle de 16 itérations
$0681       [loop0681]
            HL <- HL * 2
$0682       ---
$0685       ---
$0686       ---
$0687       DE <- DE * 2
$0688       ---
$068a       ---
$068b       ---
$068e       [skip068E]
$068f       Boucle sur A (16 fois)
$0691       ---

$0692       [str_to_num]
            Function: transforme le texte pointé par HL en nombre dans l'accumulateur FP
            
            MS_BASIC=ASCTFP
$0692       Cas hexa (commence par `&`)
$0694       On branche immédiatement dans ce cas, c'est une autre routine qui se charge de ça. (à noter que parse_value fait déjà ce test, qui n'est pas inutile car cherche d'autres préfixes)
$0697       Cas négatif qui commence par '-'
$0699       Sauvegarde des flags de la comparaison avec '-'
$069a       ---
$069c       Cas positif qui commence par '+'
$069e       ---
$06a0       Positionne HL un caractère avant dans les autres cas (car chget avance d'un avant toute chose)
$06a1       [skip_sign]
            Initialise l'exposant de FP à 0. Effet de bord, A = 0
$06a4       Nombre de chiffres après le point (la virgule) (B = 0)
$06a5       Signe de l'exposant (D = 0)
$06a6       Puissance de 10 (E = 0)
$06a7       ---
$06a8       Met C à FF, flag pour situer le parsing avant ou après le point
$06a9       [prse_flt_lp]
            Lecture du caractère suivant
$06aa       Cas d'un chiffre
$06ac       ---
$06ae       Cas du caractère `.`
$06b0       ---
$06b2       Cas du caractère `e`
$06b4       ---
$06b6       Cas du caractère pas `E`
$06b8       [case_exp]
$06b9       Au retour, le signe de l'exposant est dans D
$06bc       [exp_loop]
$06bd       C'est un chiffre, on l'ajoute à l'exposant
$06bf       Ce n'est pas un chiffre, on vérifie le signe de l'exposant
$06c0       Saut s'il était positif, on a fini
$06c2       ---
$06c3       ---
$06c4       S'il était négatif, on inverse E (l'exposant)
$06c5       Le flag de passage de point est augmenté pour s'assurer qu'on ne bouclera plus dans le parsing
$06c6       [case_dot]
            Le flag du passage du point est incrémenté (pour le premier point, passe de FF à 00)
$06c7       Si le flag est passé à 0, alors on boucle pour parser la suite, le flag est maintenant sur 0.
$06c9       [exp_end]
            Que ce soit avec un deuxième point ou la fin de l'exposant, le parsing du nombre est terminé. Il faut le finaliser. On sauve le pointeur d'execution.
$06ca       ---
$06cb       A contient l'exposant moins le nombre de chiffre après le point. L'exposant est donc tel que tous les chiffres significatifs sont à gauche du point
$06cc       [adj_loop]
            Saute si l'exposant ajusté est positif
$06cf       Si A toujours positif, vérifie la fin de boucle
$06d2       ---
$06d3       L'exposant est négatif, on divise FP par 10 et on augmente A
$06d6       ---
$06d7       ---
$06d8       [adj_div_10]
$06da       Restaure le pointeur d'execution.
$06db       Restaure le signe du nombre
$06dc       S'il était négatif, appel l'inversion de signe
$06df       Récupère le pointeur d'execution dans HL
$06e0       ---

$06e1       [adj_x_10]
            Ajuste en multipliant par 10 et en décrémentant A
$06e1       Si A était 0, retour immédiat
$06e2       [fp_x_10_dec_a]
$06e3       ---
$06e6       ---
$06e7       ---
$06e8       ---

$06e9       [case_digit]
            Parses a digit loaded in A
$06e9       Sauve l'exposant
$06ea       Sauve le chiffre dans D
$06eb       Récupère le nombre de chiffres après le point
$06ec       On est arrivé dans cette routine avec le Carry Flag Set. Si C == FF, alors on ajoute zéro, si C == 0, alors on ajoute 1
$06ed       Compteur après le point ajusté, remis dans B
$06ee       Sauvegarde des informations sur la position du oint
$06ef       Sauvegarde du pointeur d'execution.
$06f0       Sauvegarde du chiffre (qui est dans D)
$06f1       ---
$06f4       Récupération de la valeur du caractère
$06f5       Transformation en valeur numérique
$06f7       Ajoute A à FP
$06fa       ---
$06fb       ---
$06fc       Restaure le contexte du parsing
$06fd       Va chercher le caractère suivant.
$06ff       [add_a_to_fp]
            Met le FP sur la pile
$0702       Met le digit dans A dans FP
$0705       [eval_add]
            Appelé a travers la table des priorités ; MS_BASIC=PADD
$0706       Récupère le nombre depuis la pile
$0707       ---

$070a       [add_to_exp]
            Prend l'exposant actuel E et le multiplie par 10, ajoute le caractère de (HL) et en soustrait '0'
            Puis va chercher un autre chiffre pour l'exposant
            
            MS_BASIC=EDIGIT
$070a       ---
$070b       ---
$070c       ---
$070d       ---
$070e       ---
$070f       ---
$0710       ---
$0712       ---
$0713       ---

$0715       [out_in]
            Affiche à l'écran le texte " en "/" in " suivant la langue, suivi du numéro de ligne présent dans HL
            
            MS_BASIC=LINEIN
$0715       ---
$0716       ---
$0719       ---
$071c       ---
$071d       ---
$071f       ---
$0722       [out_in_fr]
$0725       ---

$0726       [out_number]
            Affiche à l'écran un nombre contenu dans HL
$0726       DE contient une adresse de retour
$0729       Sauvegarde de la valeur dans la pile pour un prochain RET
$072a       Et échange de HL et DE (HL contient donc l'adresse du signe '#'. DE contient le numéro de ligne d'AUTO
$072b       ---
$072c       ---
$072e       À l'appel, A = 0 et B = $98
$0731       [out_fp]
            Affiche à l'écran le contenu de l'accumulateur flottant
$0734       ---
$0735       ---
$0736       Place $20 dans fbuffr (un espace)
$0738       ---
$073b       Place $2d dans fbuffr (le signe '-') si le flag M est levé (résultat M dans le test des flottants)
$073d       [pos_sign]
$073e       place $30 dans fbuffr[1] (le chiffre '0')
$0740       Saut si le résultat était 0
$0743       ---
$0744       Saut si le résultat était < 0
$0747       ---
$0748       ---
$0749       ---
$074c       [loop074C]
            Aussi appelé (jp (hl))depuis $07fe
$074f       ---
$0752       ---
$0755       ---
$0756       ---
$0759       ---
$075a       ---
$075d       ---
$075e       ---
$0760       [jump0760]
$0763       ---
$0764       ---
$0765       ---
$0766       ---
$0769       [jump0769]
$076c       ---
$076d       ---
$0770       ---
$0773       ---
$0776       ---
$0777       ---
$0778       ---
$0779       ---
$077c       ---
$077e       ---
$0780       ---
$0781       ---
$0782       ---
$0784       [skip0784]
$0785       ---
$0786       ---
$0787       ---
$0788       ---
$078b       ---
$078c       ---
$078e       ---
$0790       ---
$0791       ---
$0793       ---
$0794       [loop0794]
$0795       ---
$0797       ---
$079a       ---
$079b       ---
$079c       ---
$079d       ---
$07a0       ---
$07a1       ---
$07a3       [loop07A3]
$07a4       ---
$07a5       ---
$07a6       ---
$07a7       ---
$07a8       ---
$07a9       ---
$07aa       ---
$07ab       ---
$07ac       ---
$07ad       ---
$07ae       ---
$07af       ---
$07b0       ---
$07b1       ---
$07b3       ---
$07b6       ---
$07b7       ---
$07ba       ---
$07bb       ---
$07bc       ---
$07bd       ---
$07be       ---
$07bf       ---
$07c0       ---
$07c2       ---
$07c3       ---
$07c5       [loop07C5]
$07c6       ---
$07c7       ---
$07c9       ---
$07cb       ---
$07cd       ---
$07d0       [skip07D0]
$07d1       ---
$07d3       ---
$07d5       ---
$07d6       ---
$07d8       ---
$07db       ---
$07dd       ---
$07de       ---
$07df       [jump07DF]
$07e1       [loop07E1]
$07e2       ---
$07e4       ---
$07e6       ---
$07e8       ---
$07e9       ---
$07ea       [out_zero]
$07eb       ---
$07ec       ---
$07ed       [skip07ED]
$07ee       ---
$07ef       ---
$07f0       [call07F0]
$07f3       ---
$07f6       ---
$07f9       ---
$07fa       ---
$07fb       ---
$07fe       ---
$07ff       [fp_half]
            %DATA
            Contient le nombre `0.5` flottant.
$0800       ---
$0801       ---
$0802       ---
$0803       ---
$0804       ---
$0805       ---
$0806       ---
$0807       ---
$0808       ---
$080b       ---
$080c       ---
$080d       ---
$080e       ---
$080f       ---
$0810       ---
$0811       ---
$0812       ---
$0813       ---
$0814       ---
$0815       ---
$0818       [call0818]
$081b       ---
$081c       ---
$081d       [inst_sqr]
            %CODE
$0820       ---
$0823       ---
$0826       [fp_bcde_pow]
$0827       ---
$0828       ---
$0829       ---
$082a       ---
$082c       ---
$082f       ---
$0830       ---
$0833       [jump0833]
$0834       ---
$0837       ---
$0838       ---
$0839       ---
$083a       ---
$083c       ---
$083f       ---
$0842       ---
$0843       ---
$0846       ---
$0848       ---
$084a       ---
$084b       ---
$084d       [skip084D]
$084e       ---
$084f       ---
$0850       ---
$0853       ---
$0854       ---
$0855       ---
$0856       ---
$0859       ---
$085a       ---
$085b       ---
$085c       [skip085C]
$085d       ---
$0860       ---
$0861       ---
$0864       ---
$0867       ---
$086a       ---
$086b       ---
$086c       ---
$086f       ---
$0870       ---
$0871       ---
$0874       [inst_exp]
            %CODE
$0877       ---
$087a       ---
$087d       ---
$0880       ---
$0882       ---
$0884       ---
$0886       ---
$0888       ---
$088b       ---
$088e       ---
$0890       ---
$0891       ---
$0892       ---
$0894       ---
$0895       ---
$0898       ---
$089b       ---
$089e       ---
$089f       ---
$08a2       ---
$08a3       ---
$08a6       [skip08A6]
$08a9       [skip08A9]
$08ac       ---
$08ad       ---
$08b0       ---
$08b1       ---
$08b2       ---
$08b5       [jump08B5]
$08b8       [skip08B8]
$08bb       ---
$08be       ---
$08c1       [exptab]
$08c1       Taille de la table utilisée par l'exponentielle.
$08c2       [exptab_0]
$08c2       0.0002074557705782354
$08c6       [exptab_1]
$08c6       0.0012710057199001312
$08ca       [exptab_2]
$08ca       0.00965065136551857
$08ce       [exptab_3]
$08ce       0.055496565997600555
$08d2       [exptab_4]
$08d2       0.2402271330356598
$08d6       [exptab_5]
$08d6       0.6931471824645996
$08da       [exptab_6]
$08da       1.0
$08de       [sum_series]
            %MS_BASIC(SUMSER)
$08e1       ---
$08e4       ---
$08e5       ---
$08e6       ---
$08e9       ---
$08ec       ---
$08ed       [sum_ser_1]
            Effectue une somme polynomiale.

            Avec 4 coefficients, on a :
            c1.x^4 + c2.x^3 + c3.x + c4
$08ed       Pousse FAC sur la pile.
$08f0       Récupère le nombre de coefficients.
$08f1       Pointe vers le premier coefficient.
$08f2-$08f2 Charge le premier coefficient dans FAC. HL est avancé vers le coefficient suivant.
$08f5       Saute par dessus le `pop af` pour arriver sur le `pop bc`.
$08f6       [sum_ser_lp]
$08f6       Restaure AF.
$08f7-$08f8 Lit BCDE depuis la pile. Contient toujours l'argument initial.
$08f9       Décrémente le nombre de facteurs restants.
$08fa       Retourne si le nombre restant est de 0.
$08fb-$08fc Place BCDE sur la pile.
$08fd-$08fe Sauve les autres registres (HL pointe sur le coefficient suivant de la table, A est le compteur de coefficients).
$08ff       Multiplie BCDE (l'argument) et FAC (l'accumulateur de résultat)
$0902       Retrouve le pointeur sur les coefficients.
$0903       Charge le nombre suivant de la table dans BCDE. HL pointe sur le nombre qui suit.
$0906       Sauve le pointeur sur la table.
$0907       Ajoute le nombre à FAC.
$090a       Restaure le pointeur vers la table.
$090b       Et boucle

$090d       [inst_rnd]
            %CODE
$090e       Pointe vers la seed (pourquoi cette instruction n'est pas dans reseed !!!)
$0911       Si l'argument est négatif, reseed
$0914       Point vers le dernier nombre généré
$0917       Déplacement vers l'accumulateur flottant
$091a       Pointe vers la seed à nouveau
$091d       Retour si l'argument est 0, on renvoit le dernier nombre généré (qui est dans le FAC)
$091e       On ajoute la seed avec le contenu de A (qui est à 1 car le sign est positif)
$091f       ... uniquement les 3 premiers bits (0 à 7)
$0921       ---
$0923       On sauve la seed
$0924       ---
$0925       ---
$0926       ---
$0927       Offset dans la table des coefficients (seed * 4, B étant à zéro)
$0928       On pointe vers la table des coefficients
$0929       Charge le coefficient en tant que FP dans BCDE
$092c       Multiplication du nombre en FAC avec le coefficient
$092f       Prend l'autre seed
$0932       L'incrémente...
$0933       Limite entre 0 et 3
$0935       ---
$0937       Compare la seed à 1
$0939       Si A était zéro, alors Carry est à 1 et donc A passe à 1.
$093a       On sauve la seed
$093d       4 octets avant rnd_add
$0940       ---
$0941       ---
$0942       Index dans la table des additions
$0943       Pointe sur l'entrée de la table
$0944       Addition du contenu de la table avec FAC
$0947       [afterreseed]
            Récupération de FAC dans BCDE
$094a       A récupère le poids faible de la mantisse
$094b       Met le poids fort de la mantisse dans le poids faible
$094c       Modifie des bits de A
$094e       Met le résultat en haut de la mantisse
$094f       HL pointe sur fac_1 (signe résultant). On y met $80 pour positif.
$0951       HL pointe sur l'exposant
$0952       Que l'on récupère dans B (étrange... on avait déjà récupéré dans BCDE)
$0953       On fixe l'exposant à $80 (donc puissance 0)
$0955       ---
$0958       Incrémentation de la troisième seed
$0959       Récupération de sa valeur
$095a       Modulo 171
$095c       ---
$095e       Si on boucle, on bouge un peu la mantisse
$095f       ---
$0960       ---
$0961       ---
$0962       [rnd_cnt]
            Normalisation
$0965       ---
$0968       Copie FAC dans (HL), donc dans le dernier numéro généré.
$096b       [reseed]
$096c       ---
$096d       ---
$096e       ---
$096f       ---
$0970       ---
$0972       [rnd_add]
$0976       [rnd_add_1]
$097a       [rnd_add_2]
$097e       [inst_cos]
            %CODE
$0981       ---
$0984       [inst_sin]
            %CODE
$0987       ---
$0989       ---
$098a       ---
$098d       ---
$098e       ---
$0991       ---
$0993       ---
$0996       ---
$0999       ---
$099a       [jump099A]
$099d       ---
$09a0       ---
$09a3       ---
$09a6       ---
$09a9       ---
$09aa       ---
$09ab       ---
$09ae       ---
$09b1       ---
$09b4       ---
$09b7       ---
$09ba       ---
$09bd       ---
$09c0       ---
$09c3       ---
$09c6       ---
$09c9       ---
$09cc       ---
$09cd       ---
$09d0       ---
$09d3       ---
$09d6       ---
$09d9       ---
$09dc       [jump09DC]
$09df       ---
$09e0       ---
$09e1       ---
$09e4       ---
$09e6       ---
$09e9       [jump09E9]
$09ec       ---
$09ef       ---
$09f0       ---
$09f1       ---
$09f4       ---
$09f6       ---
$09f9       ---
$09fa       ---
$0a17       [inst_tan]
            %CODE
$0a1a       ---
$0a1d       ---
$0a1e       ---
$0a1f       ---
$0a22       ---
$0a23       ---
$0a26       ---
$0a29       ---
$0a2c       [inst_atn]
            %CODE
$0a2d       ---
$0a30       ---
$0a33       ---
$0a36       ---
$0a38       ---
$0a3a       ---
$0a3d       ---
$0a3e       ---
$0a3f       ---
$0a42       ---
$0a45       ---
$0a46       [skip0A46]
$0a49       ---
$0a4c       ---
$0a4f       ---
$0a50       ---
$0a75       [inst_play]
            %CODE,SECTION(gr)
$0a78       Désactivation de l'affichage
$0a7c       ---
$0a7f       ---
$0a80       ---
$0a83       ---
$0a86       ---

$0a87       [play_impl]
            Joue une séquence sonore
            BC = Pointeur vers la séquence ASCII
            E = taille du buffer
$0a87       ---
$0a8a       lecture du caractère suivant
$0a8b       ---
$0a8c       ---
$0a8d       saute si le buffer est épuisé
$0a90       ---
$0a92       Cas de ','
$0a94       ---
$0a96       Cas de codage de fin de ligne (?)
$0a98       ---
$0a9a       Cas de l'espace
$0a9c       ---
$0a9e       Cas inférieur à 'A'
$0aa1       ---
$0aa3       ---
$0aa5       ---
$0aa8       ---
$0aaa       ---
$0aad       ---
$0aaf       ---
$0ab2       ---
$0ab4       ---
$0ab7       ---
$0ab9       ---
$0aba       ---
$0abb       ---
$0abc       ---
$0abd       ---
$0abf       ---
$0ac1       ---
$0ac2       ---
$0ac3       ---
$0ac4       [skip0AC4]
$0ac6       ---
$0ac8       ---
$0ac9       ---
$0aca       ---
$0acb       [skip0ACB]
$0ace       ---
$0acf       ---
$0ad0       ---
$0ad3       ---
$0ad4       ---
$0ad5       ---
$0ad6       ---
$0ad7       ---
$0ad9       ---
$0adc       ---
$0add       ---
$0ade       ---
$0adf       ---
$0ae0       ---
$0ae1       ---
$0ae2       ---
$0ae6       ---
$0ae7       ---
$0ae8       ---
$0ae9       ---
$0aec       ---
$0aed       ---
$0aef       ---
$0af1       ---
$0af2       ---
$0af4       ---
$0af6       ---
$0af7       ---
$0af9       ---
$0afb       ---
$0afe       ---
$0b01       ---
$0b02       ---
$0b04       ---
$0b06       ---
$0b07       ---
$0b09       ---
$0b0b       ---
$0b0e       ---
$0b11       [play_exit]
$0b12       provoque un rafraichissement 3 IRQ plus tard.
$0b16       ---
$0b1a       ---
$0b1b       [jump0B1B]
$0b1c       ---
$0b1d       ---
$0b1e       ---
$0b21       ---
$0b23       ---
$0b26       ---
$0b28       ---
$0b2b       ---
$0b2d       ---
$0b2e       ---
$0b2f       ---
$0b30       ---
$0b31       ---
$0b32       ---
$0b33       ---
$0b36       ---
$0b39       [jump0B39]
$0b3a       ---
$0b3c       ---
$0b3f       ---
$0b41       ---
$0b44       ---
$0b45       ---
$0b46       ---
$0b47       ---
$0b49       ---
$0b4a       ---
$0b4c       ---
$0b4e       ---
$0b50       ---
$0b52       ---
$0b53       ---
$0b54       ---
$0b55       ---
$0b56       ---
$0b57       ---
$0b58       ---
$0b59       ---
$0b5a       ---
$0b5b       ---
$0b5c       ---
$0b5d       ---
$0b5f       ---
$0b60       ---
$0b62       ---
$0b64       ---
$0b66       ---
$0b68       ---
$0b69       ---
$0b6a       ---
$0b6b       ---
$0b6c       ---
$0b6d       ---
$0b6e       ---
$0b6f       ---
$0b70       ---
$0b71       ---
$0b72       ---
$0b73       [skip0B73]
$0b74       ---
$0b75       ---
$0b76       ---
$0b77       ---
$0b78       ---
$0b79       ---
$0b7c       ---
$0b7f       [jump0B7F]
$0b82       ---
$0b83       ---
$0b84       ---
$0b85       ---
$0b88       ---
$0b8b       [loop0B8B]
$0b8c       ---
$0b8e       [loop0B8E]
$0b8f       ---
$0b91       ---
$0b92       ---
$0b93       ---
$0b95       ---
$0b96       ---
$0b99       [call0B99]
$0b9c       ---
$0b9d       ---
$0b9f       ---
$0ba0       ---
$0ba2       ---
$0ba3       ---
$0ba4       ---
$0ba6       ---
$0ba7       ---
$0ba8       ---
$0ba9       ---
$0baa       ---
$0bac       ---
$0bad       ---
$0baf       ---
$0bb0       ---
$0bb1       ---
$0bb2       ---
$0bb3       ---
$0bb4       ---
$0bb5       ---
$0bb6       ---
$0bb7       ---
$0bb8       ---
$0bba       ---
$0bbb       ---
$0bbc       ---
$0bbd       ---
$0bbe       ---
$0bbf       ---
$0c6a       [inst_sound]
            %CODE
$0c6d       Récupère le premier paramètre
$0c70       ---
$0c71       ---
$0c73       Si le premier paramètre est 0, l'augmente de 1
$0c74       [snd_val_ok]
$0c75       ---
$0c76       Met la valeur du son dans DE'
$0c78       ---
$0c79       Attente du son = 256 - A (plus la valeur du paramètre est haute, moins on attend)
$0c7a       -val du son dans C'
$0c7b       ---
$0c7c       Vérification de la présence d'une virgule
$0c7d       ---
$0c7e       Récupère le deuxième paramètre
$0c81       ---
$0c82       HL <- DE << 8 ; DE <- DE * A
$0c85       ---
$0c87       [de_d_16_lp]
$0c88       ---
$0c8a       ---
$0c8c       DE est divisé par 16
$0c8e       Et íncrémenté
$0c8f       ---
$0c90       ---
$0c91       ---
$0c93       Valeur par défaut du troisième paramètre
$0c95       Saut si pas de troisième paramètre (pas de virgule)
$0c97       ---
$0c98       Sinon, récupération dans A du troisième paramètre
$0c9b       [no_cycle]
$0c9c       Sauvegarde du troisième paramètre
$0c9d       ---
$0c9e       Première valeur du cycle = attente du son + troisième paramètre
$0ca1       ---
$0ca2       ---
$0ca3       ---
$0ca4       Deuxième valeur du cycle = attente du son - troisième paramètre

$0ca7       [snd_emit]
            Fonction : émet un son
            Durée dans DE
            SONSAV_1 et SONSAV_2 indiquent la phase (première et seconde)
$0ca7       ---
$0ca8       [snd_dur_lp]
$0ca9       ---
$0caa       ---
$0cac       ---
$0caf       [snd_L_wait]
$0cb2       ---
$0cb3       ---
$0cb6       ---
$0cb8       Mise à état haut de la sortie son
$0cba       ---
$0cbb       ---
$0cbe       ---
$0cc1       [snd_H_wait]
$0cc4       ---
$0cc5       ---
$0cc8       ---
$0cca       Mise à état bas de la sortie son
$0ccc       ---
$0ccd       ---
$0cce       ---
$0cd1       ---
$0cd2       ---
$0cd3       Fin de la procédure snd_emit

$0cd4       [de_mul_a]
            Entrée : A, DE
            Sortie : HL = DE << 8 (autrement dit, H <- E) ; DE = DE * A ; A inchangé
$0cd4       ---
$0cd6       ---
$0cd9       [next_bit]
$0cda       ---
$0cdc       ---
$0cdd       [dont_add]
$0cde       ---
$0ce0       ---
$0ce2       ---
$0ce4       ---
$0ce5       ---
$0ce6       [wait_69c]
            Wait 69 cycles, call included
$0ce7       ---
$0ce8       [wait_31c]
$0ce9       [wait_27c]
$0cea       ---
$0ced       [inst_sete]
            %CODE
$0cee       ---
$0cef       ---
$0cf1       ---
$0cf3       ---
$0cf5       ---
$0cf7       ---
$0cf9       ---
$0cfc       [skip0CFC]
$0cfd       ---
$0d01       ---
$0d04       ---
$0d06       ---
$0d09       ---
$0d0b       ---
$0d0c       ---
$0d0e       ---
$0d0f       ---
$0d12       ---
$0d13       ---
$0d14       ---
$0d16       ---
$0d17       ---
$0d19       ---
$0d1c       ---
$0d1e       ---
$0d20       ---
$0d23       ---
$0d25       ---
$0d26       ---
$0d27       ---
$0d28       ---
$0d29       ---
$0d2a       ---
$0d2b       ---
$0d2d       ---
$0d2e       ---
$0d31       ---
$0d33       ---
$0d34       ---
$0d36       ---
$0d37       ---
$0d38       ---
$0d39       ---
$0d3c       ---
$0d3e       ---
$0d40       ---
$0d43       ---
$0d44       ---
$0d45       ---
$0d46       ---
$0d49       ---
$0d4a       [loop0D4A]
$0d4d       ---
$0d4e       ---
$0d50       [loop0D50]
$0d51       ---
$0d53       ---
$0d55       ---
$0d56       ---
$0d57       ---
$0d58       ---
$0d5a       ---
$0d5d       ---
$0d60       ---
$0d62       ---
$0d64       ---
$0d66       ---
$0d68       ---
$0d69       ---
$0d6b       ---
$0d6e       ---
$0d70       ---
$0d71       ---
$0d72       ---
$0d74       ---
$0d76       ---
$0d77       [skip0D77]
$0d7b       ---

$0d7c       [SendToEF]
            Fonction: Envoi d'une donnée à l'EF9345
            Registre en entrée : DE
            Registre modifié : C
            D est envoyé sur le port $8F
            C est envoyé sur le port $CF
$0d7c       ---
$0d7e       ---
$0d80       ---
$0d82       ---
$0d84       ---

$0d85       [setext_impl]
            Fonction: Redéfinition d'un caractère
            Registres en entrée : HL et A
            Registres modifiés : AF, HL, BC, DE
$0d85       if bit(A, 7) == 0 then B = $C0 else B = $40
$0d87       ---
$0d89       ---
$0d8b       ---
$0d8d       [setext_2]
            Le haut de la pile contient BC
$0d8e       Désactivation de l'affichage
$0d92       ---
$0d94       ---
$0d95       ---
$0d97       ---
$0d98       Envoi à l'EF9345 de $22,A (avec le bit 7 de A mis à 1) (R2=A)
            (A est envoyé à travers E)
$0d9b       Récupération de la valeur de BC dans AF
$0d9c       Remise du contenu de BC sur la pile
$0d9d       Inversion du bit 7 de A, qui est la valeur de B du début de la fonction ($C0 ou $40)
$0d9f       ---
$0da0       ---
$0da2       Envoi à l'EF9345 de $21,A (A est envoyé à travers E) (R1=A)
$0da5       ---
$0da7       ---
$0da9       Envoi à l'EF9345 de $20,$03 (R0=3 -> KRG+Inc)
$0dac       ---
$0dae       Récupération, à travers E, de la valeur de A en entrée de fonction (avec les trois lignes suivantes)
$0daf       ---
$0db0       ---
$0db1       ---
$0db2       ---
$0db3       ---
$0db4       A = (A >> 2) & $1F
$0db6       ---
$0db7       Envoi à l'EF9345 de $24,A (A est envoyé à travers E) (R4=A)
$0dba       ---
$0dbc       ---
$0dbd       A = (A initial de la fonction) & $03
$0dbf       Récupération du contenu du BC initial ($C0 ou $40)
$0dc0       A = A | B
$0dc1       ---
$0dc2       Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0dc5       ---
$0dc7       ---
$0dc9       Envoi à l'EF9345 de $20,$34 (R0=OCT Write AP NoInc, écrit R1 en mémoire désigné par R4 R5)
$0dcc       Boucle extérieure, 10 itérations
$0dce       [setext_lp2]
            Récupère la valeur suivante de la redéfinition de caractère dans A
$0dcf       ---
$0dd0       Boucle intérieure, 8 itérations
$0dd1       ---
$0dd3       [setext_lp3]
$0dd4       Inverse le contenu de A et C, bit à bit
$0dd6       ---
$0dd8       La ligne de redéfinition lue dans (HL) est à présent inversée dans A
$0dd9       ---
$0dda       ---
$0ddb       ---
$0ddd       Envoi à l'EF9345 de $29,A (A est envoyé à travers E) (R1=A + Execute)
$0de0       ---
$0de3       ---
$0de5       Envoi sur $8F de $25 puis récupération sur $CF d'une valeur dans A (Read R5)
            Puis A = A + $04
$0de7       ---
$0de9       ---
$0deb       ---
$0dec       ---
$0dee       Envoi à l'EF9345 de $25,A (A est envoyé à travers E) (R5=A)
$0df1       ---
$0df3       Réactivation de l'affichage
$0df7       Fin de la fonction setext
$0df8       [inst_tx]
            %CODE
$0dfa       ---
$0dfd       [jump0DFD]
$0dfe       ---
$0e00       ---
$0e03       ---
$0e04       ---
$0e05       ---
$0e08       ---
$0e09       ---
$0e0b       ---
$0e0c       ---
$0e0f       ---
$0e11       ---
$0e12       ---
$0e15       ---
$0e16       ---
$0e17       ---
$0e18       ---
$0e19       ---
$0e1c       ---
$0e1d       ---
$0e1f       ---
$0e20       ---
$0e21       ---
$0e22       ---
$0e23       ---
$0e26       ---
$0e29       ---
$0e2a       ---
$0e2b       ---
$0e2c       ---
$0e2d       ---
$0e30       ---
$0e31       ---
$0e32       ---
$0e36       ---
$0e37       [inst_gr]
            %CODE
$0e3b       ---
$0e3d       ---
$0e40       [inst_et]
            %CODE
$0e44       ---
$0e46       ---
$0e49       [inst_eg]
            %CODE
$0e4b       ---
$0e4e       ---
$0e51       [inst_init]
            %CODE
$0e55       ---
$0e56       ---
$0e58       ---
$0e5a       ---
$0e5b       ---
$0e5e       ---
$0e60       ---
$0e61       ---
$0e62       ---
$0e63       ---
$0e66       ---
$0e68       ---
$0e69       ---
$0e6c       ---
$0e6e       ---
$0e6f       ---
$0e72       ---
$0e73       [skip0E73]
$0e74       ---
$0e76       ---
$0e77       ---
$0e78       ---
$0e79       ---
$0e7a       ---
$0e7b       ---
$0e7c       ---
$0e7e       [skip0E7E]
$0e81       ---
$0e82       ---
$0e83       [inst_cursor]
            %CODE
            Récupère le caractère après 'CURSOR'.
$0e84       HL pointe sur le caractère suivant.
$0e85       ---
$0e87       ---
$0e89       ---
$0e8b       Si ce n'est ni X, ni Y, c'est une erreur de syntaxe
$0e8e       Récupère l'argument suivant la commande
$0e91       ---
$0e93       Saute si moins de 40
$0e95       Si 40 ou plus, bloque à 39
$0e97       [set_curx]
            Met la valeur dans la variable système
$0e9a       ---
$0e9b       [cursory]
            Récupère l'argument suivant la commande
$0e9e       ---
$0ea0       Saute si moins de 25
$0ea2       Si 25 ou plus, bloque à 24
$0ea4       [set_cury]
            Met la valeur dans la variable système
$0ea7       ---
$0ea8       [inst_scroll]
            %CODE
$0eab       ---
$0ead       ---
$0eb0       ---
$0eb1       [inst_page]
            %CODE
$0eb4       ---
$0eb6       ---
$0eb9       ---
$0eba       [inst_stickx]
            %CODE
$0ebd       ---
$0ec0       ---

$0ec3       [stkh_impl]
            Fonction : vérifie la valeur STICK horizontale
            A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier)
$0ec3       ---
$0ec5       ---
$0ec7       ---
$0ec9       ---
$0eca       ---
$0ecc       ---
$0ece       Lecture flêche vers le gauche du clavier
$0ed0       ---
$0ed2       B passe à $FF
$0ed3       [stkv_nol_k]
            Lecture flêche vers le droite du clavier
$0ed5       ---
$0ed7       [stkh_joy0]
$0ed9       ---
$0edb       ---
$0edd       B passe à $FF
$0ede       [stkh_nol_0]
$0ee0       ---
$0ee2       [stkh_joy1]
$0ee4       ---
$0ee6       ---
$0ee8       B passe à $FF
$0ee9       [stkh_nol_1]
$0eeb       [stk_end]
            Fin des functions stkh et stkv
$0eed       Si le dernier test était nul (pas de touche appuyée), alors B est incrémenté. Si deux touches opposée étaient appuyée, cela met le résultat à 0.
$0eee       [stk_exit]
            Placement du résultat dans A
$0eef       ---
$0ef0       [inst_sticky]
            %CODE
$0ef3       ---
$0ef6       ---

$0ef9       [stkv_impl]
            Fonction : vérifie la valeur STICK verticale
            A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier)
$0ef9       ---
$0efb       ---
$0efd       ---
$0eff       ---
$0f00       ---
$0f02       ---
$0f04       Lecture flêche vers le haut du clavier
$0f06       ---
$0f08       B passe à $FF
$0f09       [stkv_noup_k]
$0f0b       Lecture flêche vers le bas du clavier
$0f0d       ---
$0f0f       [stkv_joy0]
$0f11       ---
$0f13       ---
$0f15       B passe à $FF
$0f16       [stkv_noup_0]
$0f18       ---
$0f1a       [stkv_joy1]
$0f1c       ---
$0f1e       ---
$0f20       B passe à $FF
$0f21       [stkv_noup_1]
$0f23       ---
$0f25       [inst_action]
            %CODE
$0f28       ---
$0f2b       ---

$0f2e       [stka_impl]
            Fonction : vérifie la valeur ACTION
            A=0 (joystick 0) 1 (joystick 1) ou 2 (clavier/barre espace)
$0f2e       ---
$0f30       ---
$0f32       ---
$0f34       ---
$0f35       ---
$0f38       ---
$0f3a       Vérification de l'appuie de la touche ESPACE
            Vérification de l'appuie sur la bouton action du joystick 0
$0f3c       ---
$0f3e       [stka_joy0]
$0f40       ---
$0f41       ---
$0f43       ---
$0f44       ---
$0f45       ---
$0f46       ---
$0f47       ---
$0f48       ---
$0f49       [inst_key]
            %CODE
$0f4a       ---
$0f4d       ---
$0f4e       ---
$0f4f       ---
$0f52       [inst_delim]
            %CODE
$0f55       ---
$0f56       ---
$0f58       ---
$0f59       ---
$0f5c       ---
$0f5e       ---
$0f5f       ---
$0f60       ---
$0f61       ---
$0f62       ---
$0f63       ---
$0f66       ---
$0f68       ---
$0f69       ---
$0f6a       ---
$0f6b       ---
$0f6c       ---
$0f6d       ---
$0f6e       ---
$0f70       ---
$0f73       ---
$0f74       ---
$0f75       ---
$0f78       ---
$0f7a       ---
$0f7c       ---
$0f7e       ---
$0f80       [skip0F80]
$0f81       ---
$0f84       ---
$0f85       ---
$0f86       ---
$0f89       ---
$0f8d       ---
$0f8e       [inst_screen]
            %CODE
            Force l'affichage et met le compteur de rafraichissement à 1
$0f92       ---
$0f96       Attend la prochaine interruption qui provoquera un rafraichissement
$0f97       ---
$0f98       [inst_display]
            %CODE
            Valeur par défaut pour DISPLAY
$0f9a       ---
$0f9c       ---
$0f9f       [display_def]
$0fa2       Enchaine sur l'instruction SCREEN
$0fa4       [inst_store]
            %CODE
$0fa8       ---
$0fac       ---

$0fad       [inst_call]
            %CODE
            Instruction CALL
            Évalue l'argument, le cast en int, puis utilise le vecteur `calhk` comme tremplin.
$0fad       ---
$0fb0       ---
$0fb3       ---
$0fb5       ---
$0fb8       ---
$0fbc       ---
$0fbf       [call0FBF]
$0fc2       ---
$0fc5       ---
$0fc6       ---
$0fc7       ---
$0fc8       ---
$0fc9       ---
$0fca       ---
$0fcd       ---
$0fd0       ---
$0fd1       ---

$0fd2       [get_hex]
            Lecture d'un chiffre Hexa depuis HL (HL doit donc être positionné sur le caractère précédent)
            Le caractère est valide si le Carry est reset, A contient alors la valeur.
            Si le Carry est set, la valeur n'était pas valide
$0fd2       ---
$0fd3       ---
$0fd4       Comparaison avec '0'
$0fd6       Saute si en dessous, c'est invalide
$0fd8       Comparaison avec ':' (juste après '9')
$0fda       Saute si en dessous (on est donc entre '0' et '9', c'est valide)
$0fdc       toupper() du caractère
$0fde       ---
$0fe0       Saute si en-dessous de 'A'
$0fe2       ---
$0fe4       Saute si au-dessus ou égal à 'G'
$0fe7       Soustrait $37 à A pour obtenir la valeur ('A' - $37 donne $0A)
$0fe9       [valid_hex]
            S'assure que le résultat dans de $00 à $0F, au passage clear du carry
$0feb       ---
$0fec       [invalid_hex]
            set le carry et revient
$0fed       ---
$0fee       ---

$1000       [start]
            $SECTION(biinit)
            C'est ici que commence l'intialisation complète de la machine.
            La première étape est de recopier le contenu de la ROM dans
            l'espace RAM adressable. Adressable ne signifie pas que de la RAM
            est effectivement branchée. Cela ne pose pas de problème au
            niveau hardware du VG5000 d'envoyer une demande d'écriture.
            
            Le contenu de la mémoire est ensuite lu et comparé à la ROM.
            Tant que c'est identique, c'est qu'il y a quelque chose de branché
            qui répond correctement. Dès que c'est différent, c'est qu'on est
            sorti de la zone de la mémoire inscriptible disponible.
            
            La dernière adresse valide est stockée dans $4895 et dans SP, le
            registre pointeur de pile (Stack Pointer)
            
            On remarquera que si une ROM répond avec un contenu identique à
            la ROM à une adresse multiple de 16ko, l'initialisation va
            penser que c'est de la RAM accessible.
$1000       Démarrage complet de la machine.
            Vérifier pourquoi c'est appelé depuis $2282
$1001       ---
$1004       ---
$1007       ---
$100a       Copie de la ROM sur toute la mémoire adressable
            Equivalent C-style de : memcpy($4000, $0000, $C000)
$100c       À la fin de LDIR, HL == $C000, DE == $0000, BC == $0000
$100d       ---
$100e       À présent, HL == $4000, DE == $0000, BC == $C000
$1011       [jump1011]
$1012       ---
$1014       ---
$1015       Si le contenu de (HL) et (DE) est différent, on saute en $101B
$1017       Si le contenu de (HL) et (DE) est identique
            et que BC est > 0, on loop

$101a       L'instruction partielle suivante ne sert à rien d'autre qu'à gagner un peu
            d'espace lorsque BC == 0 et que la boucle est terminée.
            Le contenu de A est écrasé un peu plus loin.
$101a       ---
$101b       [skip101B]
            HL est décrémenté pour retrouver la dernière addresse testée (CPI augmente HL).
            HL contient donc la première adresse invalide de l'espace mémoire en écriture.
            Cette adresse est mise dans SP et stockée en $4895
$101c       ---
$101d       ---

$1020       La seconde étape de l'initialisation consiste à remplir les vecteurs
            utilisateur par des instructions spécifiques. Ces vecteurs, situés
            en RAM, permettent d'intervenir lors de certaines opérations avec
            du code écrit par l'utilisateur et donc de modifier le comportement
            du système.
$1020       Les adresses $47D0 à $47EE vont ensuite est remplies par des RET ($C9).
            Equivalent C-style de : memset($47D0, $1E, $C9)
$1022       ---
$1025       ---
$1027       [hk_ini_lop]
$1028       ---
$1029       ---
$102b       ---
$102d       ---
$1030       ---
$1033       ---
$1036       ---
$1039       ---
$103c       ---
$103f       ---
$1042       ---
$1045       ---
$1048       L'adresse $47EE reçoit un JP $0069.

$104b       La troisième phase initialise le processeur graphique EF9345. Pour commencer,
            une séquence est envoyée au périphérique, puis quelques variables en RAM sont
            mises initialisées.
            
            Attention, la valeur de IX doit rester constante. Le système de cette ROM
            considère que IX est en tout temps égal à $47FA et référence certaines
            variables par index par rapport à IX.
            
            La séquence est
             $28,$81 -> Écriture de quelque chose dans le TGS
             $29,$00 -> TGS = 0 (625 lignes, non entrelacé, no-input-resync, output VSync+HSync, Service Row = 0, 40 Char
             $20,$82,$29,$6e -> MAT = $6e (Marge = B+G, Insert Marge, Curseur plein/flash, Curseur affiché, simple hauteur
             $20,$83,$29,$f7 -> PAT = $f7 (Ligne 0 'ON', Bulk haut et bas activé, pas de conceal, Insert mode : Active Area, Flash ON, Format court pour le 40 Char
             $20,$84,$29,$13 -> DOR = $13 (Block G0=3, Block G1=1<<1, Block Q=0<<3)
             $20,$87,$29,$08 -> ROR = $08 (Z=0, Y=8)
             $26,$08,$27,$00,$28,$02 -> R6=$08, R7=$00, KRG sans incrémentation avec MP=$0800 (data R1, R2 = $08, ??)
            
            Envoyés par pairs sur les ports $8f, $cf
$104b       IX prend la valeur $47FA qui est la base de la zone de données graphiques.
$104f       -> $1179 est la zone mémoire contenant la séquence à envoyer au EF9345.
            HL pointe sur la taille de la séquence à envoyer au EF9345.
$1052       ---
$1055       Initialisation de la variable $47FA : compteur d'interruptions à 5
$1059       Initialisation de la variable $47FB : besoin de rafraichissement à faux
$105d       Initialisation de la variable $47FA : utilisation des majuscules
$1061       ---

$1063       Les interruptions sont réactivées pour la suite de l'initialisation.
$1063       ---
$1064       ---
$1067       Numéro de la première ligne du BASIC ?
$106a       Couleur du pourtour et aspect du curseur
$106e       ---
$1071       ---
$1074       ---
$1077       ---
$107a       Copie les valeurs initiales des différentes variables du système en RAM
$107c       ---
$107d       Envoi 0 sur le port $EF, censé être non utilisé
            Envoi 0 sur le port $AF, pour le son-k7
$107f       ---
$1081       ---
$1084       Modification de l'adresse du hook "nmihk"
$1087       ---
$108a       ---
$108d       ---
$1090       ---

$1093       Calcul des bornes de pile, memsize et place disponible
$1093       ---
$1096       hl <- sp - 2 (sp == (stktop))
$1097       ---
$109a       ---
$109b       hl < $03e8 ? (comment serait-ce possible ?)
$109e       de <- $ffce (-50)
$10a1       ---
$10a4       ---
$10a5       Calcul final du haut de la pile comme étant (memsize) - 50
$10a8       ---
$10ab       Récupération du haut de la pile
$10ae       ---
$10b1       hl <- (stktop) - 17
$10b2       ---
$10b5       ---
$10b6       ---
$10b7       ---
$10b8       ---
$10b9       ---
$10ba       hl = hl - de, soit ((stktop) - 17 - end_vars)
            Autrement dit, la taille disponible entre la fin des variables internes et la pile -17.
$10bb       Cette taille disponible est poussée dans la pile.

$10bc       Affichage du texte de démarrage. VG5000 + numéro de version
$10bc       Texte en double hauteur, double largeur
$10c0       ---
$10c3       ---
$10c6       ---
$10c9       ---
$10cc       ---
$10cf       ---
$10d3       ---
$10d6       ---
$10d9       ---
$10dc       ---
$10df       ---
$10e2       ---
$10e3       ---
$10e6       ---
$10e9       ---
$10ec       ---
$10ed       ---
$10ef       ---
$10f2       [skip10F2]
$10f5       ---
$10f8       ---
$10fb       ---
$10fc       ---
$10ff       ---
$1102       [loop1102]
$1103       ---
$1105       ---
$1106       ---
$1107       ---
$1108       ---
$1109       ---
$110a       ---
$110b       ---
$110c       ---
$110d       ---
$110e       ---
$110f       ---
$1111       ---
$1112       ---
$1113       ---
$1114       ---
$1115       ---
$1116       ---
$1117       ---

$1118       [test_reset]
            Fonction : appelé par le vecteur nmihook ($47ee) qui par défaut est un jp $1118.
            Teste si CTRL est appuyé et si oui, effectue un reset.
            Plus exactement, pendant le boot, le vecteur est à JP $0069, puis à la fin du boot JP $1118
$1118       ---
$1119       ---
$111b       ---
$111d       ---
$111f       ---
$1120       ---

$1122       [warm_boot]
            Fonction: Effectue le reset à chaud
$1122       ---
$1125       ---
$1126       ---
$1128       ---
$112b       ---
$112c       ---
$112e       ---
$112f       ---
$1132       ---
$1135       ---
$1139       ---
$113c       ---
$113f       ---
$1142       ---
$1145       ---
$1148       [vg5000_txt]
$1163       [version_txt]
$1179       [InitEfSeq]
            Séquence d'intialisation de l'EF9345 au démarrage.
$1194       [initvalues]
$119a       [div_subr]
            %CODE
$119a-$11a7 Cette routine fait partie des valeurs montées en RAM au démarrage.
            Elle contient la soustraction du dividende par le diviseur.
            Les valeurs sont injectées à la place des $00 par la routine de
            division.
$11f9       [keybfr_0]
            %SECTION(txtfil)
$1201       [keybfr_1]
$1209       [keybfr_2]
$1211       [keybfr_3]
$1219       [keybfr_4]
$1221       [keybfr_5]
$1229       [keybfr_6]
$1231       [keybfr_7]
$1239       [keybfr_s0]
$1241       [keybfr_s1]
$1249       [keybfr_s2]
$1251       [keybfr_s3]
$1259       [keybfr_s4]
$1261       [keybfr_s5]
$1269       [keybfr_s6]
$1271       [keybfr_s7]
$1279       [keysfr_c0]
$1281       [keysfr_c1]
$1289       [keysfr_c2]
$1291       [keysfr_c3]
$1299       [keysfr_c4]
$12a1       [keysfr_c5]
$12a9       [keysfr_c6]
$12b1       [keysfr_c7]
$12b9       [keybeng_0]
$12c1       [keybeng_1]
$12c9       [keybeng_2]
$12d1       [keybeng_3]
$12d9       [keybeng_4]
$12e1       [keybeng_5]
$12e9       [keybeng_6]
$12f1       [keybeng_7]
$12f9       [keybeng_s0]
$1301       [keybeng_s1]
$1309       [keybeng_s2]
$1311       [keybeng_s3]
$1319       [keybeng_s4]
$1321       [keybeng_s5]
$1329       [keybeng_s6]
$1331       [keybeng_s7]
$1339       [keyseng_c0]
$1341       [keyseng_c1]
$1349       [keyseng_c2]
$1351       [keyseng_c3]
$1359       [keyseng_c4]
$1361       [keyseng_c5]
$1369       [keyseng_c6]
$1371       [keyseng_c7]
$1379       [errors_fr]
$13ef       [out_mem_fr]
$153f       [errors_eng]
$159e       [out_mem_eng]
$16c6       [txt_fre_fr]
$16db       [txt_fre_en]
$170f       [txt_igno_fr]
$172d       [txt_igno_en]
$173c       [txt_redo_fr]
$1752       [txt_redo_en]
$1763       [txt_arret]
$176a       [txt_break]
$1771       [txt_in_fr]
$1776       [txt_in_en]
$177b       [txt_next]

$1945       [inst_save]
            %CODE,SECTION(bicset)
            Sauvegarde du listing BASIC en ASCII.
            Attention, la routine efface tout le contenu mémoire à la fin.
$1945       ---
$1948       ---
$194b       ---
$194c       ---
$194d       ---
$1950       DE contient le numéro de première ligne à sauver.
$1951       ---
$1954       Place $0000 dans le numéro de ligne BASIC à décoder
$1957       ---
$1959       La sortie de caractère se fait sur K7
$195c       ---
$195e       ---
$1961       Met $82 en premier octet de la zone des variables.
$1962       Pointe sur l'octet suivant de la zone des variables.
$1963       Met HL dans ($4810 + $10) (ft + $10) (adresse de départ dans le descripteur de K7)
$1966       Met $82 dans ($4810 + $14) (ft + $14) (premier octet de checksum ?)
$1969       Envoie le listing vers la K7
$196c       ---
$196e       Envoie le caractère $83 vers la K7
$1971       Récupère le contenu de (fr + $14)
$1974       ---
$1977       ---
$197a       ---
$197b       Réinitialise la mémoire.
$197e       [inst_load]
            %CODE
$1981       ---
$1984       ---
$1986       ---
$1989       ---
$198c       ---
$198e       ---
$1991       ---
$1994       ---
$1996       ---
$1999       ---
$199b       ---
$199d       ---
$199e       ---
$19a0       ---
$19a3       ---
$19a6       [skip19A6]
$19a9       ---
$19aa       ---
$19ad       ---
$19ae       ---
$19b1       ---
$19b3       ---
$19b6       ---
$19b9       ---
$19ba       ---
$19bc       ---
$19bf       [skip19BF]
$19c2       ---
$19c5       [skip19C5]
$19c8       ---
$19ca       ---
$19cc       ---
$19cf       ---
$19d2       [skip19D2]
$19d5       ---
$19d8       ---
$19d9       ---
$19dc       ---
$19dd       ---
$19e0       ---
$19e3       [pause_msg]
$19ed       [inst_csave]
            %CODE
            'M'
$19ef       Branchement pour "CSAVEM"
$19f1       'S'
$19f3       Branchement pour "CSAVES"
$19f5       ???
$19f7       Branchement pour "CSAVE ???"
$19f9       'X'
$19fb       Branchement pour "CSAVEX"
$19fd       'L'
$19ff       Branchement pour "CSAVEL"
$1a02       L'instruction suivante est ld a,$20 en $1a05
$1a03       [csave_prm]
            Déplacement au caractère suivante. En arrivant par ici, l'instruction suivante est ld bc,$203e puis ld (ft),a (le LD BC ne sert à rien)
$1a04       ---
$1a05       Place $20 dans le type de fichier en cas de "CSAVE" sans paramètre
$1a07       Met le type de fichier contenu dans A dans le descripteur de type de fichier.
$1a0a       ---
$1a0d       ---
$1a10       Initialise FT
$1a13       ---
$1a14       Calcul et écrit le checksum et FT sur la K7
$1a17       ---
$1a19       ---
$1a1c       ---
$1a1d       [call1A1D]
$1a1e       [skip1A1E]
$1a21       ---
$1a23       ---
$1a26       ---
$1a28       ---
$1a2b       ---
$1a2e       ---
$1a2f       ---
$1a31       ---
$1a34       [skip1A34]
$1a37       [skip1A37]
$1a38       ---
$1a39       [inst_cload]
            %CODE
$1a3b       ---
$1a3e       ---
$1a40       ---
$1a41       [skip1A41]
$1a44       ---
$1a46       ---
$1a48       ---
$1a4a       ---
$1a4c       ---
$1a4d       [skip1A4D]
$1a4e       ---
$1a4f       ---
$1a50       [skip1A50]
$1a51       ---
$1a52       ---
$1a54       ---
$1a55       ---
$1a58       ---
$1a5a       ---
$1a5d       ---
$1a60       ---
$1a63       ---
$1a66       [loop1A66]
$1a68       ---
$1a6b       ---
$1a6e       ---
$1a70       ---
$1a73       ---
$1a75       ---
$1a78       ---
$1a7b       ---
$1a7d       ---
$1a80       ---
$1a83       ---
$1a84       ---
$1a86       ---
$1a89       [skip1A89]
$1a8c       ---
$1a8e       ---
$1a91       ---
$1a94       ---
$1a96       [loop1A96]
$1a98       [loop1A98]
$1a9b       ---
$1a9d       ---
$1a9e       ---
$1aa0       ---
$1aa2       ---
$1aa4       [skip1AA4]
$1aa7       ---
$1aaa       ---
$1aab       ---
$1aad       ---
$1ab0       [skip1AB0]
$1ab3       ---
$1ab5       ---
$1ab8       ---
$1abb       ---
$1abd       ---
$1abf       ---
$1ac2       ---
$1ac4       ---
$1ac6       ---
$1ac7       ---
$1aca       ---
$1acd       ---
$1ad0       ---
$1ad2       ---
$1ad3       [skip1AD3]
$1ad6       ---
$1ad7       ---
$1ada       ---
$1adb       [skip1ADB]
$1adc       ---
$1adf       ---
$1ae2       ---
$1ae4       ---
$1ae6       ---
$1ae7       ---
$1ae8       ---
$1ae9       ---
$1aeb       ---
$1aed       ---
$1aef       [ok_clear]
            Affiche le message d'invite "Ok!" et réinitialise le chaînage et les variables.
$1af2       ---
$1af5       ---
$1af8       [mem_out_err]
$1afa       ---
$1afc       Affiche l'erreur "Out of Memory"
$1aff       [jump1AFF]
$1b01       ---
$1b04       ---
$1b07       ---
$1b08       ---
$1b0a       ---
$1b0d       ---
$1b0f       [skip1B0F]
$1b11       ---
$1b13       ---
$1b16       ---
$1b19       ---
$1b1a       ---
$1b1c       ---
$1b1f       ---
$1b21       [skip1B21]
$1b24       [skip1B24]
$1b27       ---
$1b2a       [call1B2A]
$1b2d       ---
$1b30       ---
$1b31       ---
$1b32       ---
$1b35       ---
$1b36       [skip1B36]
$1b38       ---
$1b3a       ---
$1b3c       ---
$1b3e       [skip1B3E]
$1b41       ---
$1b43       ---
$1b45       ---
$1b47       ---
$1b49       ---
$1b4a       ---
$1b4c       ---
$1b4e       ---
$1b51       ---
$1b54       [skip1B54]
$1b57       ---
$1b58       ---
$1b5a       ---
$1b5d       ---
$1b5e       ---
$1b5f       ---
$1b61       ---
$1b63       ---
$1b65       ---
$1b67       [skip1B67]
$1b6a       ---
$1b6b       ---
$1b6c       ---
$1b6e       [skip1B6E]
$1b71       ---
$1b73       ---
$1b75       ---
$1b78       [skip1B78]
$1b79       ---
$1b7b       [loop1B7B]
$1b7c       ---
$1b7d       ---
$1b7e       ---
$1b7f       ---
$1b81       ---
$1b82       [skip1B82]
$1b83       ---
$1b86       [skip1B86]
$1b89       ---

$1b8a       [get_bauds]
            Récupère le paramètre optionnel de vitesse sur les opérations K7, et place le flag correspondant dans "cascom".
$1b8a       Replace le pointeur de texte sur le caractère précédent
$1b8b       Afin de récupérer le caractère.
$1b8c       Retourne tout de suite s'il n'y a rien.
$1b8d       ---
$1b8f       Retourne s'il n'y a pas une '('
$1b90       Sinon, récupére le caractère suivant.
$1b91       S'il n'y a rien, c'est une erreur de syntaxe
$1b94       ---
$1b96       Saute si le paramètre est 1
$1b98       ---
$1b9a       Si ce n'est pas 2, c'est un appel illégal.
$1b9d       [valid_bauds]
            Met dans D l'argument entre parenthèses (qui est la vitesse d'enregistrement)
$1b9e       ---
$1b9f       Si la commande s'arrête là, c'est une erreur de syntaxe.
$1ba2       Vérifie que le caractère suivant est ')' ou c'est aussi une erreur de syntaxe.
            Caractère ')'
$1ba3       ---
$1ba4       Sauve HL
$1ba5       ---
$1ba8       Met le flag de vitesse de la cassette à 0 (1200 bauds)
$1baa       ---
$1bab       Test le bit de poids faible de l'argument ('1' ou '2' en ASCII, soit $31 ou $32).
$1bad       Saute s'il n'est pas nul, c'est-à-dire si l'argument était '1'.
$1baf       Sinon, passe le flag de vitesse à 1, pour '2400 bauds'
$1bb1       [bauds_keep]
            Restaure HL
$1bb2       ---
$1bb3       [call1BB3]
$1bb4       ---
$1bb7       ---
$1bb8       ---
$1bb9       ---

$1bba       [name_to_ft]
            Place le nom de fichier en paramètre dans FT
$1bba       DE pointe vers l'adresse de la chaine, et C contient sa longueur.
$1bbd       ---
$1bbe       Longueur de la chaine dans B
$1bbf       ---
$1bc1       HL pointe vers fr + 1 (début du nom de fichier)
$1bc4       [cpy_name_lp]
            Copie le nom de fichier vers FT, 6 caractères maximum.
$1bc5       ---
$1bc6       ---
$1bc7       ---
$1bc8       ---
$1bc9       Si le compteur dans C (6 initialement) tombe à zéro, on sort de la boucle
$1bcb       Boucle sur la taille de la chaîne, qui s'arrêtera si B est inférieur à 6.
$1bcd       Si on s'est arrêté avant 6 caractères, place un $00 de terminaison de chaîne.
$1bcf       [cpy_name_end]
$1bd0       ---
$1bd1       [call1BD1]
$1bd3       [loop1BD3]
$1bd6       ---
$1bd7       ---
$1bd9       ---
$1bdb       ---
$1bdd       ---
$1be0       ---
$1be2       [loop1BE2]
$1be5       ---
$1be6       ---
$1be7       ---
$1be8       ---
$1bea       ---
$1beb       [call1BEB]
$1bee       ---
$1bf0       [loop1BF0]
$1bf1       ---
$1bf2       ---
$1bf3       ---
$1bf4       ---
$1bf5       ---
$1bf6       ---
$1bf7       ---
$1bf8       ---
$1bf9       ---
$1bfb       ---
$1bfc       [call1BFC]
$1bfd       ---
$1bfe       ---
$1c01       ---
$1c03       ---
$1c05       ---
$1c08       ---
$1c0b       ---
$1c0d       [loop1C0D]
$1c0e       ---
$1c0f       ---
$1c11       ---
$1c12       ---
$1c13       ---
$1c15       [skip1C15]
$1c18       ---
$1c1a       ---
$1c1b       ---
$1c1e       ---
$1c1f       ---
$1c20       [skip1C20]
$1c21       ---
$1c22       ---
$1c23       [call1C23]
$1c27       [loop1C27]
$1c28       ---
$1c29       ---
$1c2a       ---
$1c2b       ---
$1c2c       ---
$1c2d       ---
$1c2e       [loop1C2E]
$1c2f       ---
$1c30       [loop1C30]
$1c31       ---
$1c32       ---
$1c34       ---
$1c36       ---
$1c37       ---
$1c39       ---
$1c3a       ---
$1c3b       ---
$1c3c       ---
$1c3d       ---
$1c3f       [k7_skip]
$1c40       ---
$1c42       ---
$1c45       [init_ft]
$1c46       HL pointe vers FT+7 (numéro de version)
$1c49       ---
$1c4a       ---
$1c4c       [zero_ft]
            Efface FT de 7 inclus à 16 exclus en y mettant des 0 (numéro de version, numéro de ligne de départ, octet de protection, position de checksum)
$1c4d       ---
$1c4e       Fin de la boucle d'effacement
$1c50       Récupère l'octet de proection
$1c53       Et le place à sa position dans FT
$1c56       Récupère le type du fichier depuis FT
$1c59       ---
$1c5b       Branche si le type n'est pas $20
$1c5d       Traitement du type $32 (CSAVE simple)
$1c60       Récupération dans HL de (txttab) (début du listing BASIC)
$1c63       ---
$1c64       Récupération dans HL de (vartab) (début des variables, et aussi fin + 1 du listing BASIC)
$1c67       Préparation de la soustraction en effaçant la Carry
$1c68       Soustraction des deux pointeurs pour avoir la taille de la zone BASIC
$1c6a       [write_k7_len]
            Écriture de la taille du fichier dans FT + 18 (taille du fichier)
$1c6d       ---
$1c6f       [ft_type_4d]
$1c71       Branchement si le type de fichier n'est pas $4d
$1c73       Traitement du type $4d (CSAVEM). Récupération du pointeur de parsing.
$1c74       Vérification de la présence d'une virgule ou erreur de syntaxe
$1c75       ---
$1c76       Évaluation du paramètre numérique (S = adresse du premier octet à stocker)
$1c79       Valeur entière dans DE
$1c7c       Placement de l'adresse de départ dans FT+16 (adresse de départ)
$1c80       Vérification de la présence d'une virgule ou erreur de syntaxe
$1c81       ---
$1c82       Évaluation du paramètre numérique (T = longueur à stocker)
$1c85       Valeur entière dans DE
$1c88       Sauvegarde du pointeur de parsing
$1c89       Placement de la longueur dans HL
$1c8a       Et branchement sur la suite identique à CSAVE (pour l'écriture de la longueur et le paramètre optionnel I)
$1c8c       [ft_type_53]
            Traitement du type de fichier $53 (sauvegarde de l'écran)
$1c8e       Branchement si le type n'est pas $53
$1c90       ---
$1c93       L'adresse de départ est celle de l'écran
$1c96       En vrai ld hl,$07d0 (taille de l'écran)
$1c99       [write_k7_len2]
            Placement de la longueur comme étant $7d0
$1c9c       ---
$1c9e       [ft_type_bb]
            Récupère le pointeur de parsing. Traitement de CSAVE*
$1c9f       ---
$1ca1       Branchement si le type n'est pas $bb
$1ca3       Récupération des informations de tableau
$1ca6       Sauvegarde du pointeur de parsing
$1ca7       Sauvegarde de l'adresse du tableau dans l'adresse de départ de FT
$1cab       Placement de la longueur (DE) dans HL
$1cac       Mutualisation d'écriture de longueur sans autre paramètre.
$1cae       [ft_type_58]
            Lecture de l'expression chaine de caractère
$1cb1       Placement de l'adresse de début de chaîne
$1cb5       Placement de la longueur de la chaîne.
$1cb9       ---
$1cba       [k7_line_prm]
            Récupération du paramètre optionnel de numéro de ligne
$1cbb       ---
$1cbc       ---
$1cbd       S'il n'y a pas de paramètre optionnel, on a terminé.
$1cbe       Sinon, il doit y avoir une virgule ou bien c'est une erreur de syntaxe.
$1cbf       ---
$1cc0       DE pointe sur FT + 8 (numéro de première ligne)
$1cc3       Récupération des 5 prochains octets directement (il n'y a pas de traduction en entier pour ce paramètre, il est sauvé directement en ASCII)
$1cc5       [prm_i_loop]
            Sauvegarde du pointeur de parsing
$1cc6       [ft_end]
            Récupération du pointeur de parsing
$1cc7       Si on a terminé le parsing, on sort de la fonction
$1cc8       Si le caractère n'était pas un chiffre, c'est une erreur de syntaxe.
$1ccb       Copie du chiffre (en caractère) vers FT
$1ccc       DE pointe sur le caractère suivant dans FT
$1ccd       Lecture du prochain caractère sur la ligne à parser.
$1cce       Il reste des caractères à parser.
$1cd0       La limite de 5 chiffres à été atteinte, on sort.
$1cd1       [call1CD1]
$1cd2       ---
$1cd3       ---
$1cd4       ---
$1cd5       ---
$1cd8       ---
$1cd9       ---
$1cdb       ---
$1cdd       ---
$1cdf       ---
$1ce1       [loop1CE1]
$1ce2       ---
$1ce4       ---
$1ce7       ---
$1ce8       ---
$1ce9       ---
$1ceb       [skip1CEB]
$1cee       ---
$1cef       ---
$1cf2       ---
$1cf3       [skip1CF3]
$1cf4       ---
$1cf5       ---
$1cf6       ---
$1cf8       ---
$1cfa       ---
$1cfb       ---
$1cfc       ---
$1cfe       [skip1CFE]
$1cff       ---
$1d00       ---
$1d01       ---
$1d03       ---
$1d06       ---
$1d08       ---
$1d0a       ---
$1d0d       ---
$1d0e       ---
$1d0f       [loop1D0F]
$1d10       ---
$1d12       [skip1D12]
$1d15       ---
$1d16       ---
$1d17       ---
$1d19       [call1D19]
$1d1c       ---
$1d1e       ---
$1d20       ---
$1d23       ---
$1d25       ---
$1d27       ---
$1d2a       ---
$1d2b       ---
$1d2c       ---
$1d2d       [skip1D2D]
$1d30       ---
$1d31       [skip1D31]
$1d33       ---
$1d35       ---
$1d38       ---
$1d39       [skip1D39]
$1d3b       ---
$1d3d       ---
$1d40       ---
$1d41       [skip1D41]
$1d44       ---
$1d46       ---
$1d48       ---
$1d4b       ---
$1d4c       ---
$1d4e       ---
$1d51       ---
$1d52       [loop1D52]
$1d55       ---
$1d58       ---
$1d59       ---
$1d5a       ---
$1d5b       ---
$1d5c       ---
$1d5f       ---
$1d62       ---
$1d65       [skip1D65]
$1d68       ---
$1d69       ---
$1d6b       ---
$1d6e       ---
$1d6f       ---
$1d70       ---
$1d71       ---
$1d73       [skip1D73]
$1d76       ---

$1d79       [fetch_dim]
            Récupère le pointeur et la longueur vers un tableau DIM
$1d79       ---
$1d7b       Mise à 1 de subflg pour demander la recherche d'un tableau
$1d7e       Recherche de la variable
$1d81       "Appel illégal" si le tableau n'a pas été trouvé
$1d84       Remise à 0 de subflg (???)
$1d87       ---

$1d88       [read_str_expr]
            Évalue une expression de type chaîne de caractères.
            DE pointe vers l'adresse de la chaîne.
            C contient la longueur de la chaîne.
$1d88       Évaluation de l'expression
$1d8b       ---
$1d8c       DE pointe sur l'adresse de la chaine évaluée(la vérification du type chaîne est incluse)
$1d8f       ---
$1d90       ---
$1d91       Recalage de HL pour pointer vers la taille de la chaîne.
$1d92       ---
$1d94       BC contient le taille de la chaine
$1d95       Restauration de HL
$1d96       ---
$1d97       [sendchar_k7]
$1d99       ---
$1d9a       ---
$1d9d       ---
$1d9e       ---
$1d9f       ---
$1da1       ---
$1da3       ---
$1da4       ---
$1da7       ---
$1daa       ---
$1dac       ---
$1daf       ---
$1db0       ---
$1db4       ---
$1db5       ---
$1db6       ---
$1db8       ---
$1db9       ---
$1dbb       ---
$1dbc       ---
$1dbf       ---
$1dc2       ---
$1dc3       ---
$1dc4       ---
$1dc6       ---
$1dc7       ---
$1dc9       ---
$1dca       ---
$1dcd       ---
$1dcf       ---
$1dd2       ---
$1dd3       [skip1DD3]
$1dd4       [skip1DD4]
$1dd7       ---
$1dd8       ---
$1dd9       ---
$1ddc       ---
$1ddd       ---
$1dde       ---
$1ddf       ---

$1de0       [save_asc_k7]
            ???
$1de0       Récupère l'adresse sauvegardée en début de 'SAVE' ((vartab) + 1)
$1de3       Y place A (qui contient ???)
$1de4       Place HL un octet plus loin
$1de5       Met (vartab) dans DE)
$1de9       Met A à 0
$1dea       Différence entre HL (pointeur vers... ?) et DE (vartab)
$1dec       Valeur que l'on sauve
$1ded       A passe à $FF (???)
$1dee       Sauvegarde du buffer sur la K7 pour de vrai ???
$1df1       ---
$1df2       ---
$1df3       [loop1DF3]
$1df4       ---
$1df5       ---
$1df6       ---
$1df9       ---
$1dfa       ---
$1dfb       ---
$1dfc       ---
$1dfe       ---
$1dff       ---
$1e02       [call1E02]
$1e05       ---
$1e08       ---
$1e09       ---
$1e0c       ---
$1e0d       ---
$1e0e       ---
$1e0f       ---
$1e11       [loop1E11]
$1e13       ---
$1e14       ---
$1e16       ---
$1e18       ---
$1e1a       ---
$1e1d       ---
$1e20       ---
$1e22       ---
$1e25       ---
$1e27       ---
$1e28       ---
$1e2b       ---
$1e2c       ---
$1e2d       ---
$1e2f       ---
$1e31       ---
$1e32       ---
$1e33       ---
$1e34       ---
$1e37       ---
$1e38       ---
$1e39       ---
$1e3b       ---
$1e3c       [loop1E3C]
$1e3f       ---
$1e40       ---
$1e41       ---
$1e42       ---
$1e43       ---
$1e45       [skip1E45]
$1e46       ---
$1e47       ---
$1e49       ---
$1e4a       ---
$1e4b       ---
$1e4e       ---
$1e50       ---
$1e52       ---
$1e55       ---
$1e57       ---
$1e59       ---
$1e5b       [skip1E5B]
$1e5c       [loop1E5C]
$1e5d       ---
$1e5e       ---
$1e61       [skip1E61]
$1e62       [loop1E62]
$1e63       ---
$1e64       ---
$1e66       [skip1E66]
$1e67       ---
$1e68       ---
$1e6a       [skip1E6A]
$1e6d       ---
$1e6f       ---
$1e70       [skip1E70]
$1e73       ---
$1e74       ---
$1e75       ---
$1e78       ---
$1e79       ---
$1e7c       ---
$1e7d       ---
$1e80       ---
$1e82       ---
$1e83       ---
$1e84       [skip1E84]
$1e85       ---
$1e87       ---
$1e88       ---

$1e89       [fetch_next]
            Va chercher une adresse stockée dans le compteur 'high' (normalement utilisé par les cassettes)
            L'incrémente et va y chercher la valeur en entrée.
            Si cette valeur est $03, alors termine l'action en revenant sur le clavier.
            Sinon, la valeur est retournée par A pour être décodée.
$1e89       ---
$1e8d       ---
$1e8e       ---
$1e8f       ---
$1e93       ---
$1e95       ---
$1e96       ---
$1e97       Replace le périphérique d'entrée sur le clavier
$1e9a       ---

$1e9d       [k7_1200]
            Paramètre K7 pour 1200 bauds
$1e9d       ---

$1ea2       [k7_2400]
            Paramètre K7 pour 2400 bauds
$1ea2       ---

$1ea7       [k7_set_prms]
            Remet le flag 'abort' à 0.
            Si le flag de suppression LHH n'est pas mis, alors recopie les informations de cycles de la K7 vers les paramètres actuels.
$1ea7       ---
$1eaa       Met le flag 'abort' de la K7 à 0.
$1eac       ---
$1ead       Test le flag de supression des informations de vitesse K7
$1eaf       Et sort de la routine s'il est mis
$1eb0       Prépare la copie des 5 octets de paramétrage de la K7
$1eb3       ---
$1eb6       ---
$1eb9       ---
$1ebb       Saute si le flag de vitesse de K7 est à 1200 bauds
$1ebd       Sinon, pointe vers les 5 octets suivants pour la vitesse à 2400 bauds.
$1ebe       [k7_params]
            Copie les paramètres de vitesse de la K7
$1ec0       ---

$1ec1       [k7_chksum]
            Calcul le Checksum, synchronise la K7, écrire l'entête (D3) puis le contenu de FT
$1ec1       Monte les timings en RAM
$1ec4       DE = FT + $10 (Start address)
$1ec8       BC = FT + $12 (Taille à sauver)
$1ecc       ---
$1ecd       ---
$1ece       HL = 0
$1ecf       [k7_sum_lp]
            Octet pointé par DE
$1ed0       ---
$1ed1       L += cet octet
$1ed2       A = 0, sans toucher aux flags
$1ed4       ---
$1ed5       Ajout de la retenue éventuelle à H.
$1ed6       Octet suivant
$1ed7       Et taille diminuée de 1
$1ed8       ---
$1ed9       ---
$1eda       Boucle tant que BC est différent de 0
$1edc       Écriture de la somme de contrôle.
$1edf       A = $FF
$1ee0       Synchronisation de la K7
$1ee3       Retour si BREAK (???)
$1ee4       ---
$1ee6       [k7_head_lp]
            Ecriture de 10 fois $d3 en entête de fichier.
$1ee8       ---
$1eeb       Arrêt en cas de coupure (???)
$1eec       ---
$1eee       ---
$1ef0       ---
$1ef3       [k7_ft_lp]
            Écriture de FT dans le fichier
$1ef4       ---
$1ef5       ---
$1ef8       ---
$1ef9       ---
$1efb       ---

$1efc       [k7_write_pl]
            Écrit la synchro entre FT et le contenu (D6)
            Puis le contenu.
$1efc       ---
$1efd       ---
$1f00       ---
$1f01       ---
$1f03       [k7_split_lp]
            Écrit 10 fois $D6 sur la K7
$1f05       ---
$1f08       ---
$1f09       ---
$1f0b       DE = Adresse de départ
$1f0f       BC = Taille du contenu
$1f13       [payload_wrt]
            Boucle d'écriture du contenu sur K7
$1f14       ---
$1f15       ---
$1f16       ---
$1f19       ---
$1f1a       ---
$1f1b       ---
$1f1c       Continue tant que la taille (BC) restante est non nulle
$1f1e       ---
$1f20       [zero_wrt]
            Écrit 10 fois $00 après le contenu du fichier.
$1f21       ---
$1f24       ---
$1f25       ---
$1f27       ---
$1f28       [call1F28]
$1f29       ---
$1f2a       ---
$1f2d       ---
$1f30       ---
$1f33       ---
$1f36       ---
$1f37       ---
$1f38       ---
$1f39       ---
$1f3a       ---
$1f3b       [loop1F3B]
$1f3d       [loop1F3D]
$1f40       ---
$1f41       ---
$1f43       ---
$1f45       ---
$1f47       ---
$1f4b       [loop1F4B]
$1f4e       ---
$1f4f       ---
$1f50       ---
$1f51       ---
$1f54       ---
$1f55       ---
$1f56       ---
$1f57       ---
$1f59       ---
$1f5a       ---
$1f5b       ---
$1f5e       ---
$1f5f       ---
$1f60       ---
$1f61       ---
$1f62       ---
$1f64       ---
$1f67       ---
$1f69       ---
$1f6c       ---
$1f6d       [skip1F6D]
$1f6e       ---
$1f70       ---
$1f73       ---
$1f76       ---
$1f78       ---
$1f7b       ---
$1f7d       ---
$1f7f       ---
$1f82       ---
$1f83       [skip1F83]
$1f84       ---
$1f85       ---
$1f86       ---
$1f87       ---
$1f89       ---
$1f8a       ---
$1f8b       ---
$1f8e       ---
$1f92       ---
$1f93       ---
$1f94       [call1F94]
$1f95       ---
$1f98       ---
$1f9a       ---
$1f9b       ---
$1f9c       [call1F9C]
$1f9d       ---
$1f9f       ---
$1fa0       ---
$1fa1       ---
$1fa3       ---
$1fa4       ---
$1fa5       ---
$1fa7       ---
$1fa8       ---
$1fa9       ---
$1faa       ---
$1fab       [skip1FAB]
$1fac       ---
$1fad       ---
$1fae       ---

$1faf       [k7write_reg]
            Appel l'écriture sur la K7 en préservant les registres.
$1faf       ---
$1fb0       ---
$1fb1       ---
$1fb2       ---
$1fb5       ---
$1fb6       [pop_dehlret]
$1fb7       ---
$1fb8       ---
$1fb9       [call1FB9]
$1fba       ---
$1fbb       ---
$1fbc       ---
$1fbf       ---
$1fc0       ---
$1fc1       ---
$1fc2       ---
$1fc3       [call1FC3]
$1fc6       ---
$1fc9       ---
$1fcc       ---
$1fcd       [call1FCD]
$1fd0       ---
$1fd3       ---
$1fd7       ---
$1fd9       ---
$1fdc       ---
$1fdd       ---
$1fde       [call1FDE]
$1fe0       ---
$1fe2       ---
$1fe4       ---
$1fe6       ---
$1fe8       ---
$1fea       ---
$1fed       ---
$1fef       ---
$1ff0       ---
$1ff2       ---
$1ff3       [stka_joy1]
            Vérification de l'appuie sur la bouton action du joystick 1
$1ff5       ---
$1ff6       ---
$1ff8       ---
$1ff9       ---
$1ffa       ---
$1ffb       ---
$1ffc       ---
$1ffd       ---
$1ffe       ---
$2000       [instructions]
            $SECTION(bintrp)
$2064       [functions]
$209d       [prekeywords]
$209e       [keywords]
$21fd       [keywstop]
$21fe       [prio_table]
$2213       [null_str]
$2214       [ok_str]
$2219       [marker_vrfy]
$221c       HL pointe 4 octet plus haut que le haut de la pile (skip l'adresse de retour de cette fonction et de celle appelante, l'instruction)
$221d       [call221D]
$221e       ---
$221f       Compare au token de FOR
$2221       Si différent, retourne immédiatement
$2222       ---
$2223       ---
$2224       ---
$2225       ---
$2226       ---
$2227       ---
$2228       ---
$2229       ---
$222a       ---
$222d       ---
$222e       ---
$222f       ---
$2230       ---
$2232       [jump2232]
$2235       ---
$2238       [stx_err_prt]
$223a       ---
$223b       [divbyzero]
            Affiche une erreur "Division par Zéro".
$223d       ---
$223e       [missfor]
            Affiche une erreur "NEXT sans FOR"
$2240       ---
$2241       [redim]
            Affiche une erreur "Tableau redimensionné"
$2243       ---
$2244       [undeffn]
            Affiche une erreur "Fonction utilisateur non définie"
$2246       ---
$2247       [overflow]
            Affiche une erreur "Dépassement de capacité"
$2249       ---
$224a       [missing_op]
            Affiche une erreur "Opérande manquante"
$224c       ---
$224d       [wrong_op]
            Affiche une erreur "Opérande mal adaptée"
$224f       ---
$2250       [no_device]
            %CODE
            Affiche une erreur "Device not supported"
            Les adresses $47F1, $47F4 et $47F7 reçoivent elles un JP $2250.

$2252       [error_out]
            Fonction : affiche un message d'erreur
            Entrée : E contient le numéro de l'erreur
            L'erreur est ensuite cherché dans la table, donc chaque message est séparé des autres par un $00
$2252       ---
$2255       ---
$2258       ---
$225b       ---
$225e       ---
$225f       ---
$2261       ---
$2264       [err_msg_fr]
$2265       ---
$2266       Ajoute 2 à l'erreur et prends le multiple de 2 inférieur
$2268       ---
$226a       ---
$226b       Saute si E est inférieur à $2b
$226d       ---
$226f       [err_loop]
            E est le min entre E et $2a
$2270       ---
$2271       ---
$2272       ---
$2274       ---
$2275       ---
$2276       ---

$2278       [disp_break]
            Lorsqu'arrive directement ici, c'est pour afficher un arrêt d'exécution en ligne (curlin)
            
            MS_BASIC=ERRIN
$2278       ---
$227b       ---
$227e       ---
$2281       Si le numéro de ligne est 65534, alors c'est un cold start.
$2282       ---
$2285       ---
$2286       ---
$2287       ---
$2288       Il y avait un numéro de ligne, on l'affiche. Sinon fallthrough dans la loop Ok!
$228b       ---
$228c       [nok_loop]
            MS_BASIC=POPNOK

$228d       [ok_loop]
            Reset l'imprimante, remet le curseur en début de ligne et affiche "Ok".
            Puis tombe dans la boucle du moniteur.
            
            MS_BASIC=PRNTOK
$228d       ---
$2290       ---
$2293       Affiche Ok!
$2296       ---
$2299       [monitorloop]
            Ligne courante du BASIC à -1 ; MS_BASIC=GETCMD
$229c       ---
$229f       ---
$22a2       ---
$22a3       Saute si hors du mode AUTO
$22a5       Ligne courante du mode AUTO dans HL
$22a8       ---

$22ab       [out_space]
            Suivant si la ligne a déjà du contenu ou pas, le mode de numérotation automatique
            arrivera sur out_space ou out_loop, puis tombera dans la boucle de l'éditeur.
$22ab       Affiche le caractère espace puis continue dans la boucle BASIC
$22ad       [out_loop]
            Affiche le caractère qui est dans A puis continue dans la boucle BASIC

$22ae       [stoploop]
            Boucle de traitement du BASIC
$22ae       ---
$22b1       Lorsque monitor sort avec Carry (touche STOP), on boucle immédiatement.

$22b3       Lorsqu'on arrive ici, CR a été appuyée.
            HL pointe sur l'adresse précédente le buffer en entrée, qui se termine par 0.
            (Ce buffer est tout le temps basbuf en entrée normale ?)
$22b3       Acquisition d'un nouveau caractère depuis HL dans A
$22b4       ---
$22b5       On ne test pas avec "or a" à cause du test de Carry plus loin en $22ca. Le inc,dec n'affecte pas le Carry flag.
$22b6       Si rien n'a été entré, on repart pour un tour.
$22b8       Sauve le Carry flag.
$22b9       ---
$22bc       ---
$22bd       Si le flag d'exécution BASIC est différent de 0, branchement en 0 pour un reset de la machine. C'est le cas avec les programmes "protégés", dont l'arrêt provoque le RESET de la machine.
$22c0       ---
$22c3       DE contient soit un numéro de ligne, soit 0.
$22c4       ---
$22c7       En fin de tokenisation, A == 0, donc B prend 0 aussi (ou plutôt, A contient la longueur de la ligne tokenisée ??? Ou bien est-ce C ???)
$22c8       Récupération du numéro de ligne dans D
$22c9       Récupération du AF de $22b8
$22ca       Carry est set lorsqu'il y avait un numéro de ligne. Dans le cas contraire, exécution immediate.
$22cd       Push numéro de ligne
$22ce       Push de C qui contient la taille du résultat de tokenisation (B = 0 depuis $22c7)
$22cf       Push de l'adresse de tokenisation (un octet avant)
$22d0       ---
$22d3       Incrément du mode AUTO. DE contenait la ligne décodée, HL contient la ligne suivante.
$22d4       ---
$22d7       [line_record]
            Récupération de l'adresse de tokenisation
$22d8       Et du prochain token à décoder
$22d9       ---
$22da       Préparation et sauvegarde d'un test sur le token récupéré
$22db       ---
$22de       Le numéro de ligne qui était dans DE (le numéro de la ligne en cours) a été trouvé.
$22e0       ---
$22e1       ---
$22e2       Si le caractère récupéré était NUL, alors on sort vers le moniteur. En effet, si la ligne n'existait pas et qu'il n'y a rien à y encoder, on ne fait rien.
$22e5       Pourquoi refaire un "or a,a" ici ? Il faut apparamment clearer le Carry flag
$22e6       [prev_found]
            BC contient l'adresse de la ligne trouvée.
            Sauvegarde dans la pile de l'adresse de ligne précédente trouvée
$22e7       Saut si on ne vient pas $22de directement. Autrement dit, si la ligne courante n'a pas été trouvée.
$22e9       DE=adresse de la ligne suivante à celle trouvée
$22ea       HL=pointeur de la zone des variables
$22ed       [erase_line]
            Copie de la zone depuis la ligne suivante à celle trouvée jusqu'à l'adresse de la ligne trouvée. Autrement dit, on écrase la ligne courante. Ce qui invalide au passage tous les pointeurs de chaînage.
$22ee       ---
$22ef       ---
$22f0       ---
$22f1       ---
$22f2       Boucle pour la copie
$22f4       ---
$22f5       ---
$22f6       Ajustement de la nouvelle valeur de (vartab) (comme étant la dernière adresse recopiée dans le bloc précédent)
$22f9       [prev_nfound]
            Récupération de l'adresse initiale de la ligne trouvée (avant déplacement)
$22fa       Récupération du résultat du test du token sauvé en $22e1 (fait en $22d9)
$22fb       ---
$22fd       HL pointe sur l'adresse des variables
$2300       Récupération dans HL de la taille de la tokenisation
$2301       Récupération dans BC de l'adresse des variables (vartab)
$2302       HL contient la nouvelle valeur voulue pour (vartab)
$2303       Sauvegarde de cette valeur
$2304       Déplacement du bloc text vers le haut de la mémoire pour faire la place nécessaire à la ligne qui arrive (avec vérification que HL n'a pas touché la stack, sinon, erreur)
$2307       Récupération de la valeur voulue pour (vartab)
$2308       Et mise à jour de (vartab)
$230b       Récupération dans HL de l'adresse de la ligne
$230c       Mise en place de la première partie de l'adresse de chaînage (nécessaire pour éviter que le chaînage ne soit NUL plus tard et confondre avec la fin de chaîne)
$230d       DE récupère le numéro de ligne
$230e       ---
$230f       ---
$2310       ---
$2311       ---
$2312       ---
$2313       Placement du numéro de ligne, HL pointe sur le début du contenu de la ligne (qui n'est pas encore là)
$2314       Sauvegarde du pointeur de contenu
$2315       HL pointe sur le buffer de tokenisation
$2318       [cpy_line]
            Commence la copie du contenu de la ligne
$2319       ---
$231b       Cas spécial pour les valeurs numériques sur 16 bits
$231d       ---
$231f       ---
$2321       La copie des deux octets des valeurs numériques
$2323       ---
$2325       [cpy_not_num]
$2326       Continue la copie tant que la valeur n'est pas zéro. En sortie de boucle, la ligne a été insérée dans la partie texte.
$2328       [line_empty]
            Saut si la ligne est vide
$232b       HL pointe sur (txttab)
$232c       DE pointe sur (txttab)
$232d       [make_chain]
$232e       HL <- DE
$232f       ---
$2330       ---
$2331       ---
$2332       Si le chaînage est NUL, retour au moniteur (d'où l'intérêt de mettre une valeur temporaire dans le chaînage)
$2335       HL pointe sur le numéro de ligne
$2336       [skip_2bytes]
$2337       Saut du numéro de ligne
$2338       [adv_1byte]
$2339       Copie dans A de la valeur et avancée du pointeur
$233a       ---
$233c       Si on est sur un marqueur de valeur numérique entière, on saute deux octets (en profitant du saut du numero de ligne)
$233e       ---
$233f       Si l'octet n'est pas NUL, on continue
$2341       Fin de ligne. On reprend dans HL le pointeur de la ligne précédente (DE en début de boucle)
$2342       ---
$2343       ---
$2344       Placement dans le chaînage de la ligne précédente du pointeur de ligne actuel
$2345       ---

$2347       [line_search]
            Chercher la ligne de BASIC à exécuter, présent dans DE
            En sortie, si Carry Flag est levé, alors HL contient le pointeur vers la ligne de BASIC trouvée.
            Si Carry Flag est reset, alors la ligne n'a pas été trouvée. BC contient le pointeur vers la ligne de numéro inférieur à celui cherché. HL contient la ligne suivante à celle pointée par BC.
            (prelin) contient toujours le pointeur vers la ligne cherchée précédemment.
            
            MS_BASIC=SRCHLN
$2347       ---
$234a       HL contient la première adresse du listing BASIC
$234d       [line_search_lp]
            Met la dernière ligne trouvée dans (prelin) ; MS_BASIC=SRCHLP
$2351       ---
$2352       HL dans BC
$2353       ---
$2354       ---
$2355       ---
$2356       A contient le OR des deux premier octets de la ligne actuelle (HL n'est pas touché)
$2357       Retour immédiat si A est à 0 (fin des liens)
$2358       ---
$2359       Pointe HL deux octets plus loin
$235a       ---
$235b       ---
$235c       ---
$235d       Lecture de la valeur pointée par HL dans HL. C'est le numéro de la ligne.
$235e       Comparaison de HL (numéro de ligne considérée) et DE (numéro de ligne recherchée)
$235f       ---
$2360       BC dans HL (le pointeur sur la ligne qui avait été sauvé)
$2361       ---
$2362       ---
$2363       ---
$2364       Lecture dans HL de la valeur pointées par HL. C'est le pointeur vers la ligne suivante.
$2365       Inverse la retenue. Dans le cas Z, C n'est pas mis, et du coup le set, ce qui indique que la recherche a réussi.
$2366       Retour immédiat si la ligne considérée était celle cherchée.
$2367       Inverse la retenue. La remet donc à l'état du test précédent (de_compare)
$2368       Retour immédiat si HL > DE dans le test de ligne (on a dépassé la ligne sans la trouver)
$2369       Retour en début de recherche

$236b       [tokenize]
            Fonction : effectue la tokenisation du buffer d'entrée (HL) vers BASBUF
            Entrée : HL pointe vers le contenu à traiter
            Sortie : C contient la taille du résultat de tokenisation en octets (?)
            
            MS_BASIC=CRUNCH
$236b       ---
$236c       Le flag est à 0 pour signaler la tokenisation
$236f       ---
$2371       DE pointe sur le buffer de tokenisation
$2374       [analyze]
            Récupération dans A du caractère à traiter
$2375       ---
$2377       Est-ce un espace ?
$237a       B contient le caractère aussi
$237b       ---
$237d       Sont-ce des guillemets ?
$2380       ---
$2381       Est-ce NUL ?
$2384       ---
$2387       Préparation du test de flag de tokenisation
$2388       A est à nouveau le caractère à l'étude
$2389       Si on est hors tokenisation, on saute.
$238c       ---
$238e       ---
$2390       Est-ce que le caractère est '?' ? A est préchargé avec $94 dans ce cas. Raccourci vers l'instruction PRINT.
$2393       A est à nouveau le caractère à l'étude
$2394       ---
$2396       ---
$2398       Est-ce que le caractère est '…' ? A est préchargé avec $AF dans ce cas. Raccourci vers DISK (est-ce vraiment utilisé, DISK est vectorisée ?)
$239b       A est à nouveau le caractère à l'étude
$239c       ---
$239e       Est-ce inférieur à '0' ?
$23a0       ---
$23a2       Est-ce inférieur à '<' ? (les chiffres et ':' et ';' ne sont pas tokenisés)
$23a5       [specialchr]
            Ici, A contient tout caractère hors chiffre et ':; "?…\0'. Et le flag de tokenisation est à 0 (donc, actif). DE, qui contient le buffer de tokenisation, est sauvé sur la pile.
$23a6       DE contient le début du buffer des mots clés du BASIC -1 (car le traitement commence par augmenter le pointeur)
$23a9       Pourquoi sauve-t-on BC ?
$23aa       BC contient $244b
$23ad       BC est sauvé sur la pile, ce qui provoquera la sortie à cette adresse si le token n'est pas trouvé
$23ae       B contient $7F et sera incrémenté avec chaque token étudié. Le premier token a donc pour numéro $80
$23b0       A est à nouveau le caractère à l'étude
$23b1       ---
$23b3       Est-ce inférieur à 'a' ?
$23b5       ---
$23b7       Est-ce supérieur à 'z' ?
$23b9       Passage en majuscule
$23bb       Mise dans le buffer de la lettre passée en majuscule
$23bc       [notlowerchr]
            C contient le caractère à traiter
$23bd       HL pointe sur le buffer de keywords - 1
$23be       [nextkeyword]
$23bf       ---
$23c0       Boucle jusqu'au premier caractère avec un bit de poids fort à 1 (cela indique le début d'un mot)
$23c3       Augmenter l'index de mot-clé
$23c4       ---
$23c5       A contient le premier caractère de la table des mots clé, sur 7 bits (nécessaire pour enlever le marqueur de début de mot)
$23c7       Si égal à NUL, alors la fin du buffer est atteinte, on sort. Comme tokennotfound est actuellement en haut de pile, c'est vers là que l'on sort.
$23c8       ---
$23c9       Si le caractère à traiter et celui du mot-clé sont différent, on cherche le mot clé suivant
$23cb       Le pointeur sur le mot clé à traité est mis dans DE. HL contient à nouveau l'adresse du buffer en traitement.
$23cc       ---
$23cd       [strcmpkw]
$23ce       ---
$23cf       ---
$23d0       Puisqu'on atteint un nouveau marqueur de mot clé, c'est que le match a été fait correctement.
$23d3       C contient le caractère courant dans le buffer des mots clé
$23d4       A contient le caractère du buffer d'entrée à traiter
$23d5       Marqueur pour ?
$23d7       ---
$23d9       Marqueur pour ?
$23db       ---
$23dd       [marker_1]
            Lecture du caractère suivant pour l'oublier (le marqueur $8c ou $88)
$23de       ---
$23df       [marker_2]
$23e0       Lecture d'un nouveau caractère.
$23e1       ---
$23e3       ---
$23e5       Passage en majuscule (voir $23b9), mais on ne vérifie pas le supérieur à 'z' cette fois. En effet, seuls les caractères alphabétiques matcherons un mot clé de toute façon.
$23e7       [notlower2]
$23e8       Pour le moment, ça match, on continue.
$23ea       ---
$23eb       Ça ne matche pas, on essaie le mot clé suivant après avoir récupéré le pointeur vers la chaîne à traiter depuis son début de mot…
$23ed       [foundkeyw]
$23ee       Pop de HL l'adresse du début du mot
$23ef       Pop de l'adresse de retour 'tokennotfound'
$23f0       A contient le token
$23f1       ---
$23f3       Saut si le token est $88 (GOTO)
$23f5       ---
$23f7       Saut si le token est $8c (GOSUB)
$23f9       ---
$23fb       Saut si le token est $8b (RESTORE)
$23fd       ---
$23ff       Saut si le token n'est pas $b6 (???)
$2401       [test_number]
            Vérifie s'il y a un paramètre nombre derrière l'instruction
$2402       ---
$2403       ---
$2404       Ce qui suit n'est pas un nombre, on considère qu'il n'y a pas de paramètre.
$2406       Sauvegarde du HL courant dans DE
$2407       pop IY ?!!! (on doit en être à la sauvegarde de BC)
$2409       Pop de la valeur de DE en $23a5, qui pointe sur le buffer de tokenisation
$240a       [dec_number]
            On place le token dans le buffer de tokenisation.
$240b       On récupère et on sauve DE, qui pointe sur la zone à parser.
$240c       ---
$240d       Échange des registres secondaires.
$240e       Récupération dans HL de la zone à parser.
$240f       Remise dans la pile de l'adresse de la zone à parser.
$2410       Tentative de récupération d'un numéro de ligne.
$2413       ---
$2414       ---
$2415       Si le numéro de ligne est 0 (ligne invalide), on sort.
$2417       Récupération dans BC de la zone à parser (pour remettre la pile en état)
$2418       Octet bas du numéro de ligne dans A (exx n'echange pas AF, on garde donc une partie de numéro de ligne, voir plus loin)
$2419       ---
$241a       Mise dans la pile dans l'adresse de décodage ajustée
            On incrémente le pointeur de la zone de tokenisation
$241b       On repasse au registre primaires
$241c       On récupère dans DE le pointeur à parser.
$241d       ---
$241e       On annote avec $0e pour indiquer qu'un paramètre suit.
$2420       ---
$2421       Placement de la première partie du numéro de ligne
$2422       ---
$2423       ---
$2424       Récupération de la seconde partie du numéro de ligne
$2425       ---
$2426       La seconde partie du numéro de ligne est placée dans C
$2427       ---
$2429       ---
$242b       Hein ???
$242d       [miss_line]
$242e       DE doit toujours être supérieur à HL, sinon, c'est qu'il n'y avait pas d'opérande lorsqu'une était attendue (vérifier)
$2431       HL contient le buffer à parser, DE le buffer tokenisé en cours.
$2432       Sauvegarde du pointeur de parsing en cours
$2433       Lecture du caractère suivant.
$2434       DE=buffer à parser, HL=buffer tokenisé
$2435       Comparaison du dernier caractère lu avec $2ca (virgule ',')
$2437       Si pas de virgule, c'est terminé
$2439       Sinon, on place la deuxième partie du numéro de ligne dans le buffer tokenisé
$243a       Puis passage à l'emplacement suivant dans le buffer tokenisé
$243b       Mais que pointe iy ?
$243d       C contient maintenance $2c (virgule), préparer pour être copié à la prochaine itération.
$243f       Pop de l'adresse de parsing (pour balance)
$2440       ---
$2442       [invalid_lin]
$2443       ---
$2444       ---
$2445       ---
$2447       [token_end]
            DE recupère le pointeur de parsing final
$2448       Sauvegarde du pointeur tokenisé
$2449       Sauvegarde de IY... ?

$244b       [tokennotfound]
            Arrivée ici que la tokenisation échoue ou réussie.
$244b       HL pointe à nouveau sur le buffer en entrée
$244c       [tokencomplete]
            Récupération du caractère dans A. Dans le cas où l'on a réussi la tokenisation, C contient le token. Dans le cas où l'on a décodé un numéro de ligne, C contient la deuxième partie (haute) du numéro.
$244d       Nettoyage de la pile
$244e       DE pointe sur la partie tokenizée
$244f       [no_token]
$2450       Recopie du caractère actuel (ou du token ?) dans la partie tokenisée
$2451       Passage à l'adresse suivante dans le buffer tokenisé
$2452       Pourquoi agumenter C ? (vérifier suivant arrivée par no_token ou autre cas)
$2453       ---
$2455       Saut si A est égal à ':'
$2457       Avec la soustraction précédente, cela fait que l'on compare le caractère à $83
$2459       Saut si le caractère n'est pas le marqueur $83 (qui est ?)
$245b       [is_colon]
            A est forcément égal à 0. On passe en tokenisation.
$245e       [not_83]
            Avec la soustraction précédente, cela fait que l'on compare le caractère à $8E
$2460       Saut si le caractère n'est pas le marqueur $8E (qui est ?) pour une nouvelle analyze de token
$2463       ---
$2464       [trailing]
            Recopie le reste de la chaîne à traiter
$2465       ---
$2466       Sort si le caractère à parser est NUL
$2468       ---
$2469       Saute si le caractère nouveau est identique au précédent (qui a été soustrait !)
$246b       [ifquote]
$246c       Copie le caractère nouveau dans le buffer de tokenisation
$246d       Augmente C (pourquoi ?)
$246e       Augmenter le pointeur de buffer de tokenisation
$246f       ---

$2471       [ifnul]
            Arrive ici lorsque la chaîne a été complètement parsée.
$2471       HL est placé juste avant le buffer de traitement
$2474       DE pointe sur la fin du buffer tokenizé. Comme A contient 0, le buffer est terminé par trois 0.
$2475       ---
$2476       ---
$2477       ---
$2478       ---
$2479       Fin de la fonction de tokenisation
$247a       [inst_for]
            %CODE
$247c       ---
$247f       ---
$2482       ---
$2483       ---
$2484       ---
$2487       ---
$248a       ---
$248d       ---
$248e       [loop248E]
$2491       ---
$2493       ---
$2494       ---
$2495       ---
$2496       ---
$2497       ---
$2498       ---
$2499       ---
$249a       ---
$249b       ---
$249c       ---
$249f       ---
$24a0       ---
$24a1       ---
$24a2       ---
$24a4       ---
$24a5       ---
$24a6       ---
$24a7       [skip24A7]
$24a8       ---
$24a9       ---
$24ab       ---
$24ae       ---
$24af       ---
$24b2       ---
$24b3       ---
$24b4       ---
$24b7       ---
$24b8       ---
$24bb       ---
$24bc       ---
$24bd       ---
$24c0       ---
$24c1       ---
$24c4       ---
$24c5       ---
$24c6       ---
$24c7       ---
$24ca       ---
$24cb       ---
$24cc       ---
$24cd       ---
$24cf       ---
$24d1       ---
$24d3       ---
$24d4       ---
$24d7       ---
$24d8       ---
$24db       ---
$24dc       ---
$24dd       [skip24DD]
$24de       ---
$24df       ---
$24e0       ---
$24e1       ---
$24e2       ---
$24e5       ---
$24e6       [jump24E6]
$24e8       ---
$24e9       ---

$24ea       [end_of_inst]
            %CODE
            Recherche l'instruction suivante
            
            MS_BASIC=RUNCNT
$24ea       ---
$24ed       ---
$24f0       ---
$24f1       Comparaison avec ':'
$24f3       Il y a une autre instruction à exécuter
$24f5       ---
$24f6       HL doit pointer sur le NUL de fin de ligne ou bien ':'. Si ce n'est pas le cas, c'est une erreur de syntaxe (l'instruction n'a pas tout consommé)
$24f9       ---
$24fa       ---
$24fb       ---
$24fc       La dernière ligne chaine sur l'adresse de ligne $0000. C'est ce qu'on lit ici.
$24fd       Saut si on est sur la dernière ligne du programme (l'adresse de ligne suivante était $0000)
$2500       ---
$2501       ---
$2502       ---
$2503       ---
$2504       HL contient le numéro de ligne, DE contient le pointeur sur le contenu de la ligne BASIC
$2505       Enregistrement du numéro de la ligne courante
$2508       Récupération dans HL du pointeur sur le contenu de la ligne BASIC
$2509       [exec_token]
            Récupère le première token du buffer ; MS_BASIC=EXECUTE
$250a       ---
$250d       Met sur la pile une adresse de retour qui est "end_of_inst"
$250e       [retz]
            Retourne en "end_of_inst" si le caractère du buffer est NUL, c'est-à-dire que le contenu de la ligne était vide (':' en fin de ligne principalement ? Protection contre une ligne vide ?)
$250f       [jump250F]
            Les tokens sont tous supérieurs à $80
$2511       Si la soustraction a provoqué un Carry, alors ce n'était pas un token. Exécute par défaut l'assignation de variable.
$2514       ---
$2516       Si le token est supérieur à $32 (les 50 premiers token sont des instructions, suivent les fonctions dont les 16 premieres n'ont pas d'adresse), affiche une Erreur de Syntaxe.
$2519       Le token est multiplié par 2
$251a       puis stocké dans C
$251b       B est à 0, donc BC contient le numéro de token * 2
$251d       Sauvegarde de HL dans DE
$251e       HL est chargé avec la table des adresses d'instructions
$2521       HL contient le pointeur adresse d'execution de l'instruction tokenisée
$2522       ---
$2523       ---
$2524       BC contient l'adresse d'execution de l'instruction tokenisée
$2525       L'adresse est mise sur la pile
$2526       Récupération de l'adresse en cours du buffer tokenisé (cf. $251d)

$2527       [skipch]
            Fonction: recupère le caractère suivant du pointeur HL
            Retourne immédiatement si le caractère est superieur à $3a avec NC
            sinon, fallthrough dans chget_2
            Retourne avec Z set si le caractère lu était NUL
            Retourne avec C set si
            
            La fonction est à la suite du décodage de token, ce qui permet d'avancer le pointeur directement.
            "RET" signifie donc aussi dans ce contexte un saut à l'adresse de l'instruction.
$2527       ---
$2528       ---
$2529       ---
$252b       ---

$252c       [chget_2]
            Suite du traitement de chget.
            A contient le caractère lu dans le buffer, qui est inférieur ou égal à $3a
$252c       HL contient la ligne courante exécutée
$252e       Se positionne sur le premier caractère qui n'est pas un espace et est inférieur ou égal à '9'
$2530       Si le caractère est supérieur à ' ', saut plus loin
$2532       ---
$2534       Saute si le caractère est entre 0F et 1F (une partie des caractères de contrôle)
$2536       ---
$2538       Saute si le caractère est inférieur à 0D (une autre partie des caractères de contrôle, dont 0)
$253a       Reste les cas 0D et 0E. Dans ce cas, le pointeur d'execution + 3 est sauvé dans (contxt) puis HL est restauré.
$253b       ---
$253c       ---
$253d       ---
$253e       ---
$2541       ---
$2542       [chget_3]
$2543       Ce RET branchera sur l'instruction à exécuter si un token a été décodé. Si appel depuis RST, retourne normalement avec le flag Z si A était à NUL. Cela signifie aussi que les exécution d'instruction arrivent avec Z=1 si le caractère lu après le token est NUL (modulo le recalage précédent)
$2544       [chget_4]
            Compare avec '0'
$2546       Inverse la retenue. Donc le flag C sera mis si le caractère est supérieur ou égal à '0' (donc un chiffre).
$2547       ---
$2548       Manipulation de A pour setter Z si A était NUL
$2549       ---

$254a       [num_read]
            Lecture d'un nombre depuis une chaine pointée par HL.
            Ce nombre doit être entre 0 et 32767. (avec un parsing tel que str_to_num, on parse un FP)
            Sortie dans DE.
            Une structure récurante est d'appeler frnum_impl puis deint_impl, pour récupérer un entier de -32768 à 32767
            (la vérification du signe est "évitée")
            
            MS_BASIC=FPSINT
$254a       ---

$254b       [pos_int]
            Lecture d'un nombre dans DE
            MS_BASIC=POSINT
$254b       ---
$254e       [dep_int]
            MS_BASIC=DEPINT
$254f       Erreur si le nombre est négatif
$2552       [deint_impl]
            Récupère l'exposant
$2555       Et le compare à $80+16 (donc 16).
$2557       Si l'exposant est ok, on convertie en INT.
$255a       Limite haute: -32768
$255d       ---
$2560       ---
$2561       ---
$2564       ---
$2565       ---
$2566       Si dans le range, retour. Sinon, fallthrough dans l'erreur
$2567       [ill_call]
$2569       Affichage "Illegal function call"

$256c       [get_lin_num]
            Fonction : sur la ligne pointée par HL, récupère le paramètre numérique sur 16 bits dans DE
            Sortie : le paramètre dans DE. Le dernier caractère pointé dans A.
            Le numéro de ligne maximum est limité par le test avec $1998 (6552). Ce nombre est multiplié par 10
            avant la dernière addition. Ce qui porte le numéro maximum de ligne à 65529. Au delà, le parsing
            sera étrange. Par exemple 65530 sera compris comme : ligne 6553, qui contient '0'.
            Le caractère $OE sert de marqueur pour récupérer une valeur 16 bits entière directement dans le buffer.
            
            MS_BASIC=ATOH ; ASCII to HEX?
$256c       ---
$256d       [get_lin_nu2]
            Accès sans recalage de HL
$256e       ---
$2570       Si le caractère actuel du buffer n'est pas $OE (shift out), branchement
$2572       ---
$2573       ---
$2574       ---
$2575       Sinon, récupération du nombre entier sur 16 bits dans DE
$2576       Puis lecture du caractère dans A
$2577       ---
$2578       [not_oe]
$2579       Initialise le résultat à 0
$257c       [num_decode]
            La boucle décode une valeur numérique depuis sa forme ASCII. Le nombre maximum est $1998 (6552)
$257d       Si le caractère n'était pas un chiffre, retour immédiat
$257e       ---
$257f       ---
$2580       ---
$2583       Comparaison de DE (résultat) avec HL ($1998 = 6552).
$2584       Si DE est supérieur à HL, saut
$2586       ---
$2587       ---
$2588       HL <- DE * 2
$2589       HL <- DE * 4
$258a       HL <- DE * 5
$258b       HL <- DE * 10. Au final, HL contient le résultat précédent multiplié par 10.
$258c       ---
$258d       Transposition du caractère "chiffre" en sa valeur entre 0 et 9
$258f       ---
$2590       ---
$2592       Ajout au résultat de la valeur de chiffre décodée.
$2593       DE contient à présent le résultat précédent multiplié par 10 plus le nouveau chiffre.
$2594       ---
$2595       ---
$2597       [num_dec_end]
$2598       ---
$2599       ---
$259a       [inst_run]
            %CODE
$259e       ---
$25a1       ---
$25a4       ---
$25a7       ---

$25a9       [inst_gosub]
            %CODE
            Instrution : GOSUB
$25a9       ---
$25ab       ---
$25ae       Récupère l'adresse de retour dans BC
$25af       ---
$25b0       Sauve le pointeur d'exécution HL une fois, puis réserve un emplacement en haut de la pile (peu importe le contenu)
$25b1       HL contient la ligne courante
$25b4       Met le numéro de la ligne courante au sommet de la pile
$25b5       ---
$25b7       Place un marqueur sur la pile ($8c, qui est le token d'exécution de GOSUB)
$25b8       Ajuste la pile pour ne pas enregistrer la partie F de AF.
$25b9       [inst_run_2]
            Remet l'adresse de retour sur la pile, puis enchaîne sur GOTO. Instruction partagée avec RUN pour lancer un programme.

$25ba       [inst_goto]
            %CODE
            Instrution : GOTO
$25ba       DE contient l'argument (numéro de ligne)
$25bd       Le reste de la liste ne peut pas être atteint, on ignore donc tout
$25c0       ---
$25c1       Le pointeur sur l'éxecution de la ligne suivante est mis sur la pile. Pourquoi???
$25c2       ---
$25c5       C si DE supérieur à HL
$25c6       ---
$25c7       Saute si le numéro de ligne du GOTO est au-delà de la ligne courante
$25ca       Saute si le numéro de ligne du GOTO est avant la ligne courante
$25cd       ---
$25ce       ---
$25cf       ---
$25d0       Retour en cas de ligne trouvée (HL pointe sur l'octet avant la ligne courante)
$25d1       [udef_line]
$25d3       Erreur "Undefined line number"

$25d6       [inst_return]
            %CODE
            Instruction : RETURN
$25d6       S'il y a des choses après le RETURN, retour immédiat. Return n'a pas de paramètre.
$25d7       ---
$25d9       ---
$25dc       Ajuste la pile à la valeur calculée par marker_vrfy. Ce qui remet la pile avant le marqueur (au passage, on n'a plus l'adresse de retour de l'appel à l'instruction en cours). Cela a aussi pour effet d'enlever tous les contextes sur la pile, comme les FOR (uniquement les FOR ?)
$25dd       Vérification du marqueur placé par GOSUB
$25df       ---
$25e1       S'il n'est pas là, lancement d'une erreur "RETURN without GOSUB"
$25e4       ---
$25e5       Récuération de l'adresse de la ligne appelante et sauvegarde dans (curlin)
$25e8       ---
$25e9       ---
$25ea       ---
$25eb       Si on était en mode direct, HL est à $FFFF et donc fallthrough. Sinon, on saute plus loin, on était dans un programme... Mais sur cette implémentation, on ne fait rien de spécial. Ce qui permet un `RETURN` en mode direct après un pending `GOSUB`
$25ed       [useless_jp]
$25f0       Remise en place en haut de pile de l'adresse de retour de l'instruction. La reste de la ligne est ignoré en fallthrough sur DATA.REM
$25f1       ---
$25f2       [next_data]
            MS_BASIC=NXTDTA, un appel ici suppose que la chaîne à traiter est sur la pile. Fallthrough sur inst_data. On va donc mettre HL sur le statement ou fin de ligne suivante.

$25f3       [inst_data]
            %CODE
            Instruction DATA
            En arrivant en DATA, C sera chargé avec $3e (: == end of statement)
$25f3       ---
$25f4       ---

$25f5       [inst_rem]
            %CODE
            Instruction REM
            En arrivant en REM, C sera chargé avec $00 (identique à la fin de ligne, donc pas de traitement particulier de ':')
$25f5       ---
$25f6       ---
$25f7       ---
$25f9       [rem_ex_lp]
$25fa       ---
$25fb       Swap le contenu de B et C. Donne $3a00 en venant de RETURN (ce qui signfie que l'on cherche un ':'). Cela permet de chercher temporairement " pour les chaîne de caractères en mettant le ':' de côté.
$25fc       [rem_loop]
$25fd       Vérifie la présence d'un argument (numérique sur 16 bits?)
$25ff       ---
$2601       ---
$2602       ---
$2603       S'il y a un argument, saute le marqueur et la valeur
$2604       Puis lit dans A la valeur suivante
$2605       [no_number]
$2606       Si la dernière valeur lue est zéro, retour immédiat. C'est la fin de la ligne.
$2607       Compare avec le caractère spécifique cherché (: ou 0 suivant si on traite REM ou DATA)
$2608       Retour immédiat si trouvé
$2609       Sinon, on passe au caractère suivant
$260a       Comparaison avec " pour une chaîne de caractères.
$260c       Si c'est $22 ('"'), on loop sur l'échange du caractère recherché
$260e       Sinon, on continue le parsing de la ligne

$2610       [inst_let]
            %CODE
            Instruction : LET
            Appelé lorsque le buffer tokenisé ne contenait pas un token.
$2610       ---
$2613       ---
$2614       Code $C1 pour la vérification du dessus. $C1 est l'opérateur '=', ici d'assignation. Une erreur de syntaxe est émise s'il n'est pas présent.
$2615       Sauvegarde de la zone de la variable (deux octets après son identifiant)
$2616       Récupération de son type
$2619       Sauvegarde de son type
$261a       Évaluation de l'expression.
$261d       Récupération du type. HL pointe actuellement sur la suite du parsing.
$261e       Récupération dans HL de l'adresse du contenu de la variable
$261f       Cette adresse est sauvegardée dans (temp)
$2622       Mise du type de la variable dans le Carry (1 si chaîne, 0 si numérique). A est à 0.
$2623       Vérification de la compatibilité du type de l'expression et de la variable.
$2626       Saut en cas de variable numérique
$2628       [let_string]
            Sauvegarde du pointeur vers la variable
$2629       Récupération de la valeur de l'expression
$262c       ... et la sauvegarde
$262d       ---
$262e       ---
$262f       ---
$2630       ---
$2631       Adresse de la chaine dans `DE`
$2632       ---
$2635       ---
$2636       Saute si l'adresse de la variable est avant (txttab), autrement dit, dans un buffer temporaire. Il faut donc créer une entrée.
$2638       ---
$263b       Vérifie si la chaîne est présente dans le programme
$263c       Récupère le pointeur sur le descripteur de chaine
$263d       Si la chaîne est dans le programme, on saute à la fin
$263f       ---
$2642       ---
$2643       Saute aussi si la chaîne n'est pas dans le buffer temporaire
$2645       On a déjà fait le POP DE, il est sauté
$2646       [crtstrentry]
$2647       Récupération de la chaîne en haut du buffer temporaire (qui est popée si elle est égale à `DE`
$264a       BC contient l'adresse du contenu de la chaîne, DE contient le pointeur vers le descripteur
$264b       ---
$264e       [pop_string]
            Récupération de la chaîne temporaire en haut du buffer
$2651       Récupération de l'adresse de la variable
$2652       Copie de descripteur de chaine vers la variable
$2655       Restauration du pointeur d'exécution
$2656       ---
$2657       [set_num_var]
$2658       ---
$265b       ---
$265c       ---
$265d       ---
$265e       [inst_on]
            %CODE
$2661       ---
$2662       ---
$2663       ---
$2665       ---
$2667       ---
$2668       ---
$2669       ---
$266a       [skip266A]
$266b       [jump266B]
$266c       ---
$266d       ---
$2670       ---
$2673       ---
$2675       ---
$2676       ---
$2679       [inst_if]
            %CODE
$267c       ---
$267d       ---
$267f       ---
$2681       ---
$2682       ---
$2683       ---
$2684       [skip2684]
$2687       ---
$2688       ---
$268b       ---
$268c       ---
$268e       ---
$2691       ---
$2694       [inst_lprint]
            %CODE
$2696       ---
$2699       [loop2699]
$269a       ---
$269b       [inst_print]
            %CODE
$269e       ---
$26a1       [jump26A1]
$26a4       ---
$26a6       ---
$26a8       ---
$26aa       ---
$26ac       ---
$26ad       ---
$26af       ---
$26b1       ---
$26b3       ---
$26b6       ---
$26b7       ---
$26ba       ---
$26bb       ---
$26be       ---
$26bf       ---
$26c1       ---
$26c4       ---
$26c7       ---
$26c9       ---
$26cc       ---
$26cf       ---
$26d0       ---
$26d2       ---
$26d5       ---
$26d6       ---
$26d8       ---
$26da       [skip26DA]
$26dd       ---
$26de       ---
$26df       ---
$26e1       ---
$26e4       ---
$26e5       ---
$26e6       ---
$26e7       [skip26E7]
$26ea       [skip26EA]
$26ed       ---
$26ee       [skip26EE]
$26f1       ---
$26f2       ---
$26f4       [skip26F4]
$26f7       ---
$26f8       ---
$26fa       ---
$26fd       ---
$26ff       ---
$2701       [skip2701]
$2704       ---
$2705       ---
$2708       ---
$2709       ---
$270a       [skip270A]
$270d       ---
$270f       [loop270F]
$2711       ---
$2713       ---
$2714       ---
$2716       [skip2716]
$2717       ---
$271a       ---
$271b       ---
$271c       ---
$271d       ---
$271e       ---
$2720       ---
$2721       ---
$2723       ---
$2726       ---
$2727       ---
$2729       ---
$272c       ---
$272e       [skip272E]
$2731       [skip2731]
$2732       ---
$2733       ---
$2735       [skip2735]
$2736       ---
$2737       ---
$2739       [loop2739]
$273a       ---
$273c       [jump273C]
$273d       ---
$273e       ---
$2741       [jump2741]
$2742       ---
$2745       ---

$2746       [bad_input]
            Arrive ici si les données sont insuffisantes pour les variables à remplir
            
            MS_BASIC=BADINP
$2746       ---
$2749       ---
$274a       Saute dans le cas d'un READ
$274d       Jette le pointeur de données courant
$274e       ---
$2751       ---
$2754       ---
$2755       ---
$2757       ---
$275a       [redo_fr]
            Affiche "Redo from scratch" en fonction de la langue
$275d       ---

$2760       [inst_input]
            %CODE
            Instruction INPUT
            
            MS_BASIC=INPUT
$2760       ---
$2763       Appel du hook sur INPUT
$2766       ---
$2767       S'il y a un " après INPUT, c'est qu'il y a un texte à afficher.
$2769       Efface A et laisse les flags (reste de MS pour enable output ? Pas besoin de clearer A ici... !!)
$276b       ---
$276d       ---
$2770       Vérifie que le caractère suivant est un ';'
$2771        ';'
$2772       Sauvegarde du pointeur d'exécution
$2773       Affiche la chaine de caractères
$2776       ---
$2777       [raw_input]
$2778       ---
$277b       ---
$277d       ---
$2780       [prompt_2]
$2783       ---
$2787       ---
$278a       ---
$278c       ---
$278e       Remet en place le contact du curseur et de l'INPUT flag
$2791       ---
$2792       ---
$2793       [inst_input_2]
            Récupération du pointeur d'exécution dans BC (HL est utilisé par la ligne juste entrée pour l'INPUT)
$2794       Comme on est passé par get_line, si Carry set, c'est qu'on a appuyé sur Break. On arrête le programme.
$2797       ---
$2798       ---
$2799       ---
$279a       Peek du premier caractère de la chaine pour voir s'il est NUL.
$279b       Sauvegarde du pointeur d'exécution.
$279c       Si c'était la fin de la ligne, alors on saute jusqu'au prochain statement. Les variables ne seront pas touchées.
$279f       Sinon, on place ',' comme premier caractère (avant la ligne)
$27a1       ---

$27a3       [inst_read]
            %CODE
            Instruction : READ
            
            MS_BASIC=READ
$27a3       Sauvegarde du pointeur d'exécution
$27a4       Chargement de l'emplacement du prochain DATA
$27a7       ---
$27a8       [read_data]
            MS_BASIC=NXTITM
$27a9       Si A == 0, on est dans INPUT, sinon, on est dans READ. (flginp) est donc plutôt un Flag Read?
$27ac       Met sur la pile le pointeur DATA et récupère le pointeur d'exécution.
$27ad       ---
$27ae       [data_loop]
            Vérifie qu'il y a un ',' (sauf la première fois)
$27af       ','
$27b0       Récupération de la variable (retour dans DE)
$27b3       Swap pour récupérer la ligne d'INPUT,DATA
$27b4       Sauvegarde de la variable
$27b5       ---
$27b6       ---
$27b8       Saute si le prochaine caractère de la donnée est ',' (c'est pour cela que l'INPUT est amorcé avec un ',')
$27ba       ---
$27bd       ---
$27be       Saute si on est dans le cas READ
$27c1       Il manque des données, réaffiche le prompt
$27c3       ---
$27c4       ---
$27c7       Récupération de la variable
$27c8       Récupération du pointeur d'exécution
$27c9       Traitement du break
$27cc       ---
$27cd       ---
$27ce       ---
$27cf       INPUT line vide ?
$27d0       Sauvegarde du pointeur d'exécution
$27d1       Si vide, alors statement suivant, la variable ne sera pas touchée.
$27d4       Sauvegarde de la variable
$27d5       [get_value]
            MS_BASIC=ANTVLU
$27d8       ---
$27d9       Saute si la variable est de type numérique ; Si la donnée et le variable ne correspondent pas, que se passe-t-il ???
$27db       Récupération du prochain caractère
$27dc       ---
$27dd       Sauvegarde du caractère dans D et B
$27de       ---
$27e0       Saute si le premier caractère est "
$27e2       ---
$27e5       A == 0 si on est dans INPUT
$27e6       Dans ce cas, D contiendra 0, sinon, D sera fixé en $27e9
$27e7       ---
$27e9       En cas de READ, D est ':'
$27eb       [data_sep]
            B == ',', séparateur des données
$27ed       Remise en place de HL sur le premier caractère dans le cas où il n'était pas "
$27ee       [lit_string]
            Au final, B et D contiennent des séparateurs de données, et HL est sur la première position intéressante. Récupération de la chaine.
$27f1       DE <- adresse de la chaine de caractères.
$27f2       ---
$27f5       Branchement pour le RET
$27f6       Sauvegarde de la chaine de caractères de données
$27f7       Tout est prêt pour l'assignation de la variable alphanumérique. Le retour se fera à l'adresse juste spécifiée.
$27fa       [num_data]
$27fb       Transformation de la donnée en nombre
$27fe       Sauve le pointeur de données, récupération de la variable
$27ff       Assignation de la variable (par copie du buffer flottant vers HL, qui est le contenu de la variable)
$2802       Récupération du pointeur de données.
$2803       [next_comma]
$2804       ---
$2805       Saute si le buffer données est vide
$2807       ---
$2809       Saute si le caractère suivant n'est pas ","
$280c       [empty_data]
            HL <- pointeur d'exécution. Pointeur DATA sur la pile
$280d       Recalage
$280e       ---
$280f       Saute s'il reste du contenu dans la paramètres d'INPUT ou de READ
$2811       Récupération du pointeur DATA
$2812       ---
$2815       Est-ce qu'on est dans INPUT (== 0) ou READ ?
$2816       Échange de DATA et d'exécution
$2817       Mise à jour du pointeur de DATA pour les prochains READ
$281a       Sauvegarde du pointeur d'exécution
$281b       Est-ce qu'il restait des choses dans les données pour INPUT ?
$281c       ---
$281f       ---
$2820       ---
$2823       ---
$2824       ---
$2826       ---
$2829       [ignore_fr]
$282a       Si oui, on affiche que le reste est ignoré (après restauration des flags)
$282d       Restauration du pointeur d'exécution
$282e       ---
$282f       [go_nxt_data]
            MS_BASIC=FDTLP ; Va à la prochaine instruction
$2832       Test de fin de ligne
$2833       Saute si ce n'est pas la fin de la ligne
$2835       ---
$2836       ---
$2837       ---
$2838       On est à la fin de la ligne, est-ce que la ligne suivante est NUL ?
$2839       ---
$283b       Si oui, sors avec "Out of DATA"
$283e       ---
$283f       ---
$2840       ---
$2841       ---
$2842       Sinon, charge la ligne de DATA courante. Il y a ici in EX HL,DE dans MS_BASIC, que se passe-t-il ???
$2846       [test_data]
$2847       Compare avec le token DATA
$2849       Saute si ce n'est pas une instruction DATA pour aller chercher plus loin
$284b       On a trouvé la prochaine donnée, on peut aller l'assigner à la variable

$284d       [eval_num_ex]
            Fonction : Evalue une expression et vérifie que le résultat est numérique.
$284d       ---

$2850       [type_eq_num]
            Fonction: vérifie que le type évalué est de type numérique.
            Le OR A,$37 va faire un clear Carry et sauter le Set Carry du test de type chaîne
$2850       ---

$2851       [type_eq_str]
            Fonction: vérifie que le type évalué est une chaine de caractère
$2851       ---

$2852       [type_eq_chk]
            Fonction: vérifie que deux types sont égaux
            Entrée: Carry flag pour l'un des deux types, (valtyp) pour le second
            Sortie: Retour en cas de parité paire, c'est-à-dire si Carry et (valtype) sont égaux.
            Sinon, branche sur "Opérande mal adapté"
$2852       ---
$2855       ---
$2856       ---
$2857       ---
$2858       ---
$285b       ---

$285f       [paren_expr]
            Fonction appelée récursivement par l'évaluation commencée par read_expr.
            Commence par vérifier la présence d'une parenthèse ouvrante puis continue l'évaluation.
            Il n'y a pas de partial instruction en $2860, c'est uniquement le paramètre de chkchr
$285f       ---
$2860       Vérifie la parenthèse ouvrante

$2861       [read_expr]
            Lecture et évaluation d'une expression
            À chaque parsing, est mis sur la pile l'adresse de l'opérande, suivi du FP (BCDE), suivi du retour en eval_2 (qui sera exécuté par le RET dans l'opérande)
            Cela forme une liste de commandes à exécuter lorsqu'un bloc est évalué.
            Lorsqu'un opérateur de plus faible priorité est trouvé, le RET NC permet de faire un saut vers l'adresse d'exécution de l'opérateur, qui trouvera son
            paramètre sur la pile, suivi de l'adresse de retour en eval_2, qui considère que l'accumulateur FP est rempli (et contient donc l'évaluation).
            
            MS_BASIC=EVAL
$2861       ---
$2862       La priorité est stockée dans D.
$2864       [eval_1]
            Sauvegarde de la priorité
$2865       ---
$2867       Vérification qu'il est possible d'ajouter 1 niveau (C) sur la pile
$286a       Attention, la lecture de caractère via RST $10 commence par un INC HL, les opérateurs sont donc 'ignorés' naturellement à ce niveau du parsing. D'où aussi la nécessité du DEC HL en début de fonction
$286d       Sauvegarde de l'adresse de parsing courante
$2870       [eval_2]
            Récupération de l'adresse de parsing courante
$2873       Récupération de la priorité
$2874       ---
$2875       Comparaison avec la priorité de AND et OR
$2877       Si ce n'est pas AND et OR (la priorité est au moins à $78), vérification que l'on veut un type numérique. Si on revient, c'est que c'était le cas
$287a       Récupération dans A de l'opérateur suivant (ou de la fonction)
$287b       Sauvegarde de l'adresse de parsing courante
$287e       $b9 est le token pour '+', qui est aussi le premier token qui n'est pas une instruction (les opérateurs)
$2880       Retour si ce qui est parsé est avant le '+', donc ne faisant plus partie de l'expression
$2881       $c3 est le code de SGN, la première fonction prédéfinie.
$2883       Si c'est une fonction ou ensuite, ce n'est pas un opérateur, on sort de l'évaluation.
$2884        $c0 '>' $c1 '=' $c2 '<'
$2886       Saute si '>' ou au-delà
$2888       Index de l'opérateur (en commençant par '+' comme 0)
$288a       Sauvegarde de l'index dans E
$288b       Saute si l'opérateur n'est pas '+'
$288d       [no_call]
            Il n'y a pas d'appel ici, c'est l'appelant qui est un "skip"
$2890       Type de la valeur : -1=num 0=string
$2891       Récupération de l'index de l'opérateur sauvé en $288a
$2892       Si la valeur est une chaîne de caractères, on saute (concatenation de chaînes)
$2895       [not_plus]
$2896       ---
$2897       Index de l'opérateur multiplié par 3 dans E
$2898       Charge la table des priorités
$289b       ---
$289d       Indexation dans la table
$289e       Sauvegarde de la priorité courante
$289f       Récupération de la priorité du nouvel opérateur
$28a0       Comparaison des priorités
$28a1       Si la nouvelle priorité est plus petite, on sort (== on saute à l'adresse de l'opérateur sur la pile)
$28a2       Sinon, HL pointe sur l'adresse de l'opérateur
$28a3       On vérifie que l'on a affaire à un type numérique (encore ???)
$28a6       [jump28A6]
            Sauvegarde de B (précédente actuelle) et C (???)
$28a7       ---
$28aa       Sauvegarde de l'adresse de retour lorsque l'expression de cette priorité sortira
$28ab       Sauve l'index dans la table de priorité
$28ac       ---
$28ad       Monte la valeur FP sur la pile
$28b0       ---
$28b1       Restaure l'index dans la table de priorité
$28b2       ---
$28b3       ---
$28b4       Récupération de l'adresse de l'opérateur dans BC
$28b5       ---
$28b6       Qui est mis sur la pile
$28b7       Restauration du pointeur de parsing
$28ba       On continue le parsing jusqu'á sortir de la priorité courante

$28bd       [eval_comp]
            Lorsque l'on arrive ici, A contient > = <
            Il s'agit de chercher un motif d'opérateur de comparaison composé.
$28bd       ---
$28bf       [comp_loop]
$28c1       Saut si A est avant >
$28c4       ---
$28c6       Saut si A est après <
$28c9       Est-ce '=' ?
$28cb       > donne b11, = donne b10, < donne b00
$28cc       À la première boucle, A n'est pas changé (D == 0). En deuxième boucle, tous les doublons (>>, << et ==) donnent b00, <= et => donnent b01, >= et => donnent b10
$28cd       ---
$28ce       Le premier caractère est mis dans D
$28cf       À la première boucle, A ne peut pas être inférieur à D.
$28d2       Le pointeur de parsing est ajusté (à la deuxième boucle surtout)
$28d5       Lecture du caractère suivant
$28d6       ---

$28d8       [parse_value]
            Fonction: parse une valeur depuis HL+1. Cette valeur peut être numérique, alphanum ou bien une fonction
            prédéfinie ou utilisateur.
            
            MS_BASIC=OPRND
$28d8       ---
$28d9       On cherche un type numérique par défaut
$28dc       Lecture du prochain caractère (non blanc, numérique, essayer avec INIT ABC ?)
$28dd       Saute dans le cas où le caractère est NUL
$28e0       Saute dans le cas où le caractère est un chiffre.
$28e3       Caractère '&'
$28e5       Saut si sur le point de parser un nombre en hexa
$28e8       ---
$28eb       Saut si la valeur est entre A et Z (on va chercher une variable)
$28ed       Token pour '+'
$28ef       La valeur commence par un '+', on ignore et on relance le parsing
$28f1       Caractère '.'
$28f3       C'est un nombre (flottant)
$28f6       Token pour '-'
$28f8       Saut pour prendre l'opposé du parsing
$28fa       Caractère '"'
$28fc       C'est une chaîne de caractères délimité par "
$28ff       Token pour 'NOT'
$2901       Saute å l'évaluation d'un NOT
$2904       Token pour 'FN'
$2906       Saute à l'évaluation d'une fonction utilisateur
$2909       Token pour 'SGN', la première des fonctions
$290b       Saute á l'évaluation d'une fonction prédéfinie
$290d       [eval_paren]
            Cas de la sous-expression entre parenthèses, qui est le dernier choix possible. Pour cela, on lance une évaluation de sous expression qui commencera par vérifier l'existence de cette parenthèse.
$2910       ---
$2911       Caractère ')' pour le check du-dessus. Donc erreur de syntaxe si une parenthèse fermante n'est pas trouvée.
$2912       À ce niveau là, la sous-expression est dans l'accumulateur FP.
$2913       [str_to_min]
            Un '-' comme opérateur unaire doit s'évaluer sur ce qui suit. Charge la précédence de l'opérateur.
$2915       Puis évalue l'expression. Qui sortira lorsque la précédence sera moins forte
$2918       Récupération de l'adresse de parsing du prochain opérateur
$291b       Que l'on sauve
$291c       Le temps d'inverser le signe de ce que contient FP
$291f       [ret_num]
            Et de vérifier que l'on a bien affaire à un type numérique
$2922       Restauration du pointeur d'exécution
$2923       ---

$2924       [str_to_var]
            Récupère la valeur d'une variable lors d'une évaluation.
$2924       Récupère l'adresse de la variable dans DE
$2927       [from_eval]
            Sauve le contexte
$2928       HL prend l'adresse de la variable
$2929       Sauve l'adresse de la variable
$292c       ---
$292f       ---
$2930       Appel si le type de la variable est numérique (pour mettre sa valeur dans FP)
$2933       Restaure le contexte
$2934       ---

$2935       [str_to_func]
            Exécute le code d'une fonction interne lors de l'évaluation d'une expression
            En entrée, A contient l'index de la fonction (token soustrait du token de la première fonction)
            
            MS_BASIC=FNOFST
$2935       ---
$2937       Double l'index de la fonction
$2938       Avec B mis à 0, BC contient l'index doublé de la fonction
$2939       Que l'on sauve
$293a       Saute la '(' qui doit suivre
$293b       A <- index doublé de la fonction
$293c       Compare par rapport au token 220 (token CHR$ - token SGN, le tout * 2)
$293e       Saute si c'est une fonction qui renvoie une valeur numérique
$2940       On est dans une des fonctions renvoyant une valeur alphanumériques. Évaluation du premier paramètre.
$2943       ---
$2944       Vérification que le caractère suivant est ','
$2945       Et que la valeur évaluée est bien alphanumérique.
$2948       Sauve le pointeur d'exécution
$2949       HL <- adresse de la chaîne évaluée
$294c       Que l'on met en haut de la pile (et récupération de l'index doublé)
$294d       Push de l'index doublé
$294e       HL <- pointeur d'exécution
$294f       Récupération d'un entier sur 8 bits (dans A et DE)
$2952       Pointeur d'exécution dans DE, HL <- l'int récupéré
$2953       HL <- index doublé, en haut de pile, l'entier du second paramètre
$2954       ---
$2956       [num_func]
            Évaluation du paramètre de la fonction (qui est donc dans FP)
$2959       HL <- index doublé, en haut de la pile, le pointeur d'exécution
$295a       ---
$295d       Prépare l'adresse de retour pour le prochain RET comme retour de fonction numérique
$295e       [exec_func]
$2961       Pointe dans le tableau d'adresse des fonctions celle correspondant à l'index
$2962       ---
$2963       ---
$2964       ---
$2965       Chargement de l'adresse dans HL
$2966       Saut à l'implémentation de la fonction interne

$2967       [exp_sign]
            Retourne D == FF si le caractère dans A est - (token) ou '-', D == 0 si + (token) ou '+' avec Z flag set. Si rien trouvé, NZ (et D = 0), et HL reculé (pour recommencer le parsing)
            
            MS_BASIC=SGNEXP
$2967       ---
$2968       ---
$296a       ---
$296b       ---
$296d       ---
$296e       ---
$296f       ---
$2971       ---
$2972       ---
$2974       ---
$2975       ---
$2976       ---

$2977       [fp_bcde_or]
            %CODE
            Execution de AND et OR. Appelé via la table de priorités.
            
            MS_BASIC=PAND
$2977       ---
$2978       [fp_bcde_and]
            %CODE
            MS_BASIC=PAND
$2979       ---
$297a       ---
$297d       ---
$2980       ---
$2981       ---
$2982       ---
$2983       ---
$2984       ---
$2985       ---
$2988       ---
$2989       ---
$298c       ---
$298d       ---
$298e       ---
$298f       ---
$2992       ---
$2994       ---
$2995       ---
$2996       ---
$2997       ---
$2998       ---
$2999       [skip2999]
$299a       ---
$299b       ---
$299c       ---
$299d       ---
$299e       [jump299E]
$29a1       ---
$29a4       ---
$29a5       ---
$29a6       ---
$29a7       ---
$29a8       ---
$29aa       ---
$29ab       ---
$29ac       ---
$29ad       ---
$29b0       ---
$29d3       [str_to_not]
            Charge la priorité pour l'opérateur NOT
$29d5       Lance une évaluation qui sortira en descente de priorité
$29d8       Vérifie le type numérique de la valeur obtenue
$29db       FP to Signed Int
$29de       ---
$29df       ---
$29e0       ---
$29e1       ---
$29e2       Inverse les valeurs de la mantisse (D et E) et met le résultat dans A et C
$29e3       Résultat dans FP
$29e6       ---
$29e7       Suite de l'évaluation
$29ea       [inst_fre_2]
$29eb       ---
$29ec       ---
$29ed       ---
$29ee       ---
$29ef       [ac_to_fp]
            Met A dans B, pour fallthrough dans ab_to_fp
$29f0       [ab_to_fp]
            Met B dans D (de BADE)
$29f1       Net E à 0.
$29f3       ---
$29f6       Place 0 dans la globale valtyp, ce qui signifie que la valeur est numérique
$29f7       Exposant $80+$10
$29f9       ---
$29fc       [inst_lpos]
            %CODE
$29ff       ---
$2a01       [inst_pos]
            %CODE
$2a04       ---
$2a05       ---
$2a07       ---
$2a0a       ---
$2a0c       [skip2A0C]

$2a0f       [retfun_impl]
            Function : met en place la valeur de retour d'une fonction
            Prerequis : valeur dans A
            Sortie : valeur entière dans FAC
$2a0f       ---
$2a10       ---
$2a11       ---

$2a13       [inst_def]
            %CODE
            Instruction: DEF, définition d'une fonction
            
            MS_BASIC=DEF
$2a13       Vérifie que l'on a affaire à une fonction (et définie l'entrée)
$2a16       Cette instruction ne peut pas être appelé en direct
$2a19       ---
$2a1c       Prépare la valeur de retour pour aller à la prochaine instruction
$2a1d       Sauve l'adresse de la fonction (de son pointeur)
$2a1e       DE <- 0
$2a21       ---
$2a22       Caractère suivant est '(' ?
$2a24       Saute si non (il n'y a pas de paramètre, légal pour ce BASIC, même si l'appel doit quand même spécifier un argument...)
$2a26       Saute le caractère '('
$2a27       Récupère la variable en paramètre. check_fn a mis $80 dans subflg
$2a2a       Sauvegarde du pointeur d'exécution
$2a2b       HL <- pointeur sur la variable paramètre
$2a2c       ---
$2a2d       ---
$2a2e       ---
$2a2f       DE <- nom de la variable paramètre
$2a30       HL <- pointeur d'exécution
$2a31       Vérification du type numérique (pas de fonction alphanum)
$2a34       ---
$2a35       Le caractère suivant est bien ')' ?
$2a36       [no_param]
$2a37       Le caractère suivant est bien '=' ?
$2a38       ---
$2a39       BC <- HL (pointeur d'exec)
$2a3a       HL <- pointeur de fonction, Stack -> pointeur d'exécution
$2a3b       ---
$2a3c       ---
$2a3d       Le pointeur de fonction reçoit l'adresse du pointeur d'exécution au niveau de la fonction
$2a3e       DE (nom de la variable) sera mis à la suite, avant un RET

$2a41       [str_to_fn]
            Pour traiter la valeur du paramètre, c'est dans la récupération de la variable qu'un test
            est fait entre le nom de la variable en cours en prmnam. Si c'est égal, alors DE est
            placé sur prmval
$2a41       Vérification que l'on a bien une fonction numérique (DE prend le pointeur vers la variable)
$2a44       Sauvegarde du pointeur de fonction
$2a45       Évaluation du paramètre de la fonction
$2a48       Qui doit être numérique
$2a4b       HL <- Pointeur sur la fonction (qui contient en premier un pointeur vers le code de la fonction)
$2a4c       ---
$2a4d       ---
$2a4e       ---
$2a4f       DE <- Pointeur sur la chaîne de code de la fonction
$2a50       ---
$2a51       ---
$2a52       Saute si le pointeur était NUL, et donc la fonction non définie
$2a55       ---
$2a56       ---
$2a57       ---
$2a58       HL <- Second paramètre de la variable, qui contient l'emplacement de la variable de fonction
$2a59       Que l'on met sur la pile
$2a5a       ---
$2a5d       Sauvegarde du contenu du nom de paramètre sur la pile et échange avec l'actuel (les fonctions peuvent appeler de fonctions ???)
$2a5e       ---
$2a61       ---
$2a64       ---
$2a65       ---
$2a68       Sauvegarde du contenu actuel de la valeur du paramètre
$2a69       ---
$2a6c       Sauve DE (code de la fonction)
$2a6d       Copy FP dans ce qui est pointé par HL (valeur paramètre)
$2a70       Pointeur sur le code de la fonction dans HL
$2a71       Évaluation de la fonction (qui est une expression numérique)
$2a74       Recalage du pointeur de parsing
$2a75       ---
$2a76       ---
$2a79       ---
$2a7a       ---
$2a7d       ---
$2a7e       ---
$2a81       ---
$2a82       Remise en place de la valeur et du nom du paramètre précédent
$2a85       ---
$2a86       ---

$2a87       [ill_direct]
            Vérifie que la ligne courante n'est pas -1.
            Si c'est le cas, lance l'erreur correspondante.
            MS_BASIC=IDTEST
$2a87       ---
$2a88       ---
$2a8b       ---
$2a8c       ---
$2a8d       ---
$2a8e       ---
$2a8f       ---
$2a90       ---
$2a92       Sors avec "Illegal direct"
$2a95       [check_fn]
            Vérifie que ce qui suite est une fonction (au sens DEFFN)
$2a96       Token pour FN
$2a97       Signal à la recherche de variable que les tableaux sont interdits dans ce contexte
$2a99       ---
$2a9c       A contient le caractère suivant avec le bit 7 à 1
$2a9d       Qui est mis dans C
$2a9e       ---
$2aa1       Vérification du type numérique (qui se chargera du RET)
$2aa4       [preget_byte]

$2aa5       [getbyt_impl]
            Fonction : récupère un entier sur un octet depuis le buffer d'entrée
            Entrée : HL pointe sur la zone de texte
            Sortie : A contient l'entrée (ainsi que DE ?)
$2aa5       ---
$2aa8       [to_int]
$2aab       ---
$2aac       ---
$2aad       ---
$2ab0       ---
$2ab1       ---
$2ab2       ---
$2ab3       ---

$2ab4       [inst_peek]
            %CODE
            Fonction : Peek
            Récupère le paramètre entier, déférence l'adresse dans A et en fait la valeur de retour
$2ab4       ---
$2ab7       ---
$2ab8       ---

$2abb       [inst_poke]
            %CODE
            Instruction : Poke
$2abb       ---
$2abe       Sauve la partie entière du paramètre (assuré d'être entier)
$2abf       ---
$2ac0       Vérifie la présence de ','
$2ac1       Récupère un octet (dans A)
$2ac4       ---
$2ac5       Met A à l'adresse DE
$2ac6       ---
$2ac7       [why]
            Pourquoi ???
$2acb       [get_poke_addr]
$2ace       ---
$2acf       ---
$2ad2       ---
$2ad3       ---

$2ad4       [acquirekey]
            $SECTION(te)
            Fonction: décode une touche du clavier et l'affiche à l'écran à la position du curseur.
            Attends un refresh (HALT) puis scrute le clavier.
            Si rien n'a été appuyé, sort immédiatement. A == 0
            Si la touche a été traitée, A == 0
            Quand est-ce que A != 0 ?
            Sinon, traitement.
$2ad4       ---
$2ad5       ---
$2ad6       ---
$2ad7       ---
$2ada       ---
$2adc       ---
$2adf       Attente d'une interruption
$2ae0       ---
$2ae3       ---
$2ae4       Saute en fin de fonction si aucun caractère n'a été entré
$2ae6       ---
$2ae7       ---
$2ae8       Son lorsqu'un caractère est reçu
$2aeb       ---
$2aee       ---
$2af1       ---
$2af4       ---
$2af7       ---
$2af8       ---
$2af9       ---
$2afb       Bit pour indiquer que la ligne est entrée en BASIC (quelque chose a été entré en tout cas et sera traité par le saut en $2adc)
$2afe       ---
$2aff       Si le bit de signe était 1 dans le caractère lu
$2b02       Comparaison de la touche avec ENTREE
$2b04       ---

$2b07       [acquirekeyn3]
            Suite (2) du traitement de l'entrée
$2b07       ---
$2b09       ---
$2b0c       ---
$2b0e       ---
$2b11       ---
$2b13       ---
$2b16       ---
$2b19       ---
$2b1a       [jump2B1A]
$2b1d       ---
$2b1f       ---
$2b21       ---

$2b23       [acquirekeyn7]
            Suite (6) du traitement de l'entrée
$2b23       ---
$2b24       [acquire_sync]
            Attend le prochain affichage puis passe dans l'annulation de la valeur acquise et la sortie.
            Force un affichage
$2b28       ---
$2b2c       ---
$2b2d       [acquire_nul]
            Ici, la valeur acquise passe à zéro avant de sortir de la fonction
            A est effacée en traitement normal de touche (et déjà 0 si pas de touche entrée)
$2b2e       [endacquirek]
            Nettoyage de fin de fonction
$2b2f       ---
$2b30       ---
$2b31       ---

$2b32       [bufferstart]
            Fonction : lorsque le bit 1 de $4871 est à 1, arrive ici pour analyse
            À l'air de se positionner sur le premier caractère interessant à décoder
$2b32       Coordoonées de la ligne BASIC à décoder
$2b35       A contient la ligne
$2b36       Comparaison avec 24 (le nombre de lignes)
$2b38       ---
$2b3a       ---
$2b3b       ---
$2b3c       ---
$2b3e       Lecture du caractère en colonne 0 de la ligne suivante
$2b41       ---
$2b42       ---
$2b44       [ifabove24]
$2b45       Comparaison de la colonne avec 40 (colonne max)
$2b47       ---
$2b49       [skip2B49]
$2b4a       ---
$2b4b       ---
$2b4d       Comparaison de la colonne avec 40 (colonne max)
$2b4f       ---
$2b50       ---
$2b52       [ifbelow40]
$2b53       Stockage des nouvelles coordonnées (ajustées comment?)
$2b56       ---
$2b57       ---
$2b5a       B contient le caractère aux coordonnées
$2b5b       DE contient les coordoonées
$2b5c       ---
$2b5d       A contient le caractère aux coordonnées
$2b5e       Not carry de quoi ?
$2b60       ---
$2b62       Si ce n'est pas un espace
$2b64       [loop2B64]
$2b65       ---
$2b66       ---
$2b68       ---
$2b6a       ---
$2b6b       ---
$2b6c       ---
$2b6d       ---
$2b6f       ---
$2b71       ---
$2b73       ---
$2b75       [ifabove40]
$2b78       ---
$2b7a       ---
$2b7d       ---
$2b80       ---
$2b82       ---
$2b84       ---
$2b86       ---
$2b88       ---
$2b8a       ---
$2b8c       ---
$2b8e       ---
$2b90       [skip2B90]
$2b93       ---
$2b95       ---
$2b97       [jump2B97]
$2b9a       ---
$2b9c       [skip2B9C]
$2b9f       ---
$2ba1       [skip2BA1]
$2ba4       ---
$2ba6       ---
$2ba7       [acquired_cr]
$2ba9       ---
$2bac       [specialchars]
$2bae       ---
$2bb0       ---
$2bb2       [skip2BB2]
$2bb4       ---
$2bb6       ---
$2bb8       [skip2BB8]
$2bba       ---
$2bbc       ---
$2bbe       [skip2BBE]
$2bc0       ---
$2bc2       ---
$2bc4       [skip2BC4]
$2bc6       ---
$2bc8       ---
$2bca       [skip2BCA]
$2bcc       ---
$2bce       ---
$2bd0       [skip2BD0]
$2bd3       [call2BD3]
$2bd5       ---
$2bd6       ---
$2bd9       ---
$2bda       ---
$2bdd       ---
$2bdf       ---
$2be0       [ifcr]
            Récupération des coordonnées du curseur
$2be3       [find_start_l]
            Décrémentation de X
$2be4       Sauvegarde des coordonnées modifiées du curseur
$2be5       ---
$2be8       Récupération des coordonnées
$2be9       Comparaison à $80, la caractère de début de ligne
$2beb       ---
$2bed       ---
$2bef       ---
$2bf1       Recheche du caractère de continuation ? ($B4)
$2bf3       Boucle sur la recherche
$2bf5       [linestart]
$2bf6       ---
$2bf7       Si on n'était pas sur la colonne 0, c'était une fausse alerte et non un vrai début de ligne, on continue à chercher.
$2bf9       ---
$2bfa       ---
$2bfd       ---
$2bfe       Si on n'est pas en mode auto, on continue le traitement de la ligne.
$2c00       ---
$2c01       Sinon, le mode AUTO est annulé
$2c04       L'adresse du curseur mis à jour
$2c07       ---
$2c09       Le marqueur $84 (re)mis? en place
$2c0a       Et la touche acquise sera validée comme étant $0D (sans traitement)
$2c0d       [find_cont]
            Traitement lors d'une continuation trouvée au début de la ligne
$2c0f       [find_start]
            Remonte de ligne en ligne jusqu'au premier marqueur de non continuité (et donc à la première ligne).
$2c12       ---
$2c13       ---
$2c14       Peek du caractère en colonne 0
$2c17       ---
$2c18       Test sur $84, qui est le marquage de continuité des lignes. Saut lorsqu'on ne le trouve plus. On est en tout début du ligne.
$2c1a       ---
$2c1b       Saute si on est arrivé en haut de l'écran (H est passé à $FF)
$2c1e       Boucle sur la remontée des Y
$2c20       [found_start]
            Coordonnées placées en début de la première ligne
$2c23       Test de INPUT activé
$2c25       Traitement spécifique si le monitor était en train de traiter un INPUT
$2c27       ---
$2c28       ---
$2c29       ---
$2c2a       ---
$2c2b       ---
$2c2c       Recupération des coordonnées de début d'entrée
$2c2f       ---
$2c30       ---
$2c33       DE contient les coordonnées de début d'entrée. HL l'adresse mémoire
$2c34       [loop2C34]
$2c35       Comparaison de X avec la colonne 40
$2c37       ---
$2c39       ---
$2c3a       ---
$2c3b       ---
$2c3c       ---
$2c3d       ---
$2c3f       ---
$2c41       ---
$2c45       ---
$2c47       [skip2C47]
$2c49       ---
$2c4b       [ifinput]
$2c4e       [skip2C4E]
            Enregistrement du premier caractère de la ligne ($80 en mode direct)
$2c51       ---
$2c54       ---
$2c56       Set du flag pour "ligne entrée en BASIC"
$2c59       ---
$2c5c       ---
$2c5d       Placement des coordonnées sur le caractère en colonne précédente (donc 0?)
$2c60       [screenstart]
            La fonction sortira avec pour valeur acquise NUL.
$2c63       [iftab]
$2c66       ---
$2c67       ---
$2c69       ---
$2c6c       ---
$2c6e       ---
$2c71       ---
$2c75       ---
$2c78       ---
$2c7c       ---
$2c7d       ---
$2c7e       ---
$2c81       ---
$2c84       [skip2C84]
$2c86       ---
$2c89       [iflinef]
$2c8c       ---
$2c8e       ---
$2c91       ---
$2c94       ---
$2c96       ---
$2c99       ---
$2c9d       ---
$2c9e       ---
$2ca1       ---
$2ca4       ---
$2ca7       [jump2CA7]
$2caa       [jump2CAA]
$2cac       ---
$2caf       [ifformf]
$2cb2       ---
$2cb4       ---
$2cb7       ---
$2cb8       ---
$2cba       [jump2CBA]
$2cbb       ---
$2cbc       ---
$2cbd       ---
$2cbe       ---
$2cbf       ---
$2cc0       ---
$2cc1       ---
$2cc5       ---
$2cc6       ---
$2cc9       ---
$2cca       [skip2CCA]
$2ccb       ---
$2ccd       ---
$2cd0       ---
$2cd4       ---
$2cd8       ---
$2cdb       ---
$2cde       ---
$2ce1       ---
$2ce5       ---
$2ce8       ---
$2ce9       ---
$2cea       [loop2CEA]
$2ced       ---
$2cef       ---
$2cf2       ---
$2cf4       ---
$2cf6       ---
$2cf9       ---
$2cfb       [skip2CFB]
$2cfc       ---
$2cfe       ---
$2cff       ---
$2d01       [skip2D01]
$2d04       [skip2D04]
$2d07       ---
$2d0a       [call2D0A]
$2d0b       ---
$2d0c       ---
$2d0d       ---
$2d0e       ---
$2d0f       ---
$2d10       ---
$2d13       ---
$2d14       ---
$2d15       ---
$2d16       ---
$2d17       ---
$2d18       ---
$2d19       ---
$2d1c       ---
$2d1e       ---
$2d1f       [jump2D1F]
$2d20       ---
$2d23       ---
$2d25       ---
$2d28       [loop2D28]
$2d29       ---
$2d2a       ---
$2d2c       ---
$2d2e       ---
$2d2f       ---
$2d30       ---
$2d31       ---
$2d32       ---
$2d33       ---
$2d34       ---
$2d35       ---
$2d36       ---
$2d37       ---
$2d3a       ---
$2d3b       ---
$2d3d       [skip2D3D]
$2d3e       ---
$2d41       ---
$2d44       ---
$2d46       ---
$2d47       ---
$2d4a       ---
$2d4c       ---
$2d4e       ---
$2d52       [jump2D52]
$2d53       ---
$2d54       ---
$2d55       ---
$2d58       ---
$2d59       ---
$2d5c       [jump2D5C]
$2d5e       ---
$2d5f       ---
$2d62       ---
$2d64       ---
$2d67       ---
$2d68       ---
$2d69       ---
$2d6a       ---
$2d6d       ---
$2d70       [jump2D70]
$2d71       [jump2D71]
$2d75       ---
$2d76       [func_keys]
$2d78       Saute si la valeur est inferieure à $ba
$2d7b       ---
$2d7d       Saute si la valeur est supérieure ou égale à $fb
$2d80       ---
$2d83       [loop_accel]
            Recherche la valeur de la touche d'accélération dans le tableau
$2d84       ---
$2d85       ---
$2d87       [out_accel]
            Provoque l'affichage de la chaîne accélérée (raccourci BASIC)
$2d88       ---
$2d8a       Lorsque le bit de poids fort est 1, alors la chaîne est terminée, on sort.
$2d8d       Affichage du caractère de la chaîne en train d'être affichée.
$2d8e       ---
$2d8f       ---

$2d91       [ctrl_keys]
            Traitement des touches de contrôle (des touches de contrôle ?)
$2d91       ---
$2d93       ---
$2d94       ---
$2d96       ---
$2d99       ---
$2d9a       A est remplacé par la valeur trouvée dans la table d'indirection à 10 entrée en $487a (comment est-elle remplie ?)
$2d9b       ---
$2d9e       [accel_keys]

$2ead       [mem_move_chk]
            $SECTION(bimisc)
            Fonction : vérify la mémoire
            Entrée : DE < BC < HL trois pointeurs de mémoire
            Copie la zone [DE, BC] vers [DE+(HL-BC), HL] depuis la fin (permet le recouvrement)
$2ead       ---
$2eb0       [mem_move]
            Mise sur la pile de la taille
$2eb1       ---
$2eb2       Échange des valeurs de HL et BC
$2eb3       [cpy_loop]
            Préparation de la comparaison entre HL et DE
$2eb4       ---
$2eb5       Copie de (HL) vers (BC)
$2eb6       Retour si HL a atteind DE
$2eb7       ---
$2eb8       Décrément de HL et BC
$2eb9       Boucle de la copie

$2ebb       [stk_verify]
            Entrée : BC (B == 0), le nombre de mots de 2 octets (des "niveaux" que l'on voudrait mettre sur la pile
            S'il n'y a pas la place demandée sur la pile, provoque un message d'erreur.
            La place vérifiée semble être deux fois la place demandée avec une marge de $60 octets (jamais moins
            de $60 octets disponibles)
            Préserve HL.
            
            MS_BASIC=CHKSTK
$2ebb       Sauve le pointeur d'exécution
$2ebc       Prend la mémoire la plus basse disponible (après les chaînes?)
$2ebf       ---
$2ec1       ---
$2ec2       Ajoute deux fois l'entrée C à strend
$2ec3       ---

$2ec4       [mem_verify]
            Identique à stk_verify mais fourni HL pour comparer avec la pile.
            
            MS_BASIC=ENFMEM
$2ec4       ---
$2ec5       ---
$2ec7       ---
$2ec8       ---
$2ec9       ---
$2ecb       ---
$2ecc       HL <- $FFA0 - HL (HL étant (strend) + 2 * C)
$2ecd       S'il n'y a pas au moins $60 octets entre la valeur désirée et $FFFF, alors il n'y a plus de mémoire (oui, c'est en dur quelque soit la mémoire présente, c'est louche)
$2ecf       ---
$2ed0       Restore dans HL le pointeur d'exécution
$2ed1       Si HL + SP provoque une retenue, alors on revient, il y a assez de mémoire. Sinon, c'est qu'il y a moins de $60 octets entre la pile et (strend), il n'y a pas assez de mémoire.
$2ed2       [out_of_mem]
$2ed5       "Out of Memory"
$2ed8       ---

$2ed9       [reset_mem]
            Met 0 dans les deux premiers octets de txttab (donc efface l'accès au listing)
            L'effet sur l'utilisateur est d'effacer le programme (mais il est encore là)
            
            MS_BASIC=CLRPTR
$2ed9       ---
$2edc       [reset_mem_2]
            appelé depuis l'instruction NEW
$2edd       ---
$2ee0       [reset_mem_4]
$2ee1       txttab+2 dans (vartab)
$2ee4       [reset_vars]
            Remet à zéro les pointeurs du modèle mémoire
$2ee7       HL pointe sur l'octet avant txttab
$2ee8       [init_vars]
            HL est mis de côté ; MS_BASIC=INTVAR
$2eeb       HL prend la valeur de memsiz
$2eee       fretop est donc mis à memsiz, cela signifie que toute la mémoire est disponible.
$2ef1       ---
$2ef2       ---
$2ef5       (vartab) est placé dans (arytab) et (strend). Autrement dit, élimine toutes les variables, les tableaux et les chaînes.
$2ef8       ---
$2efb       ---

$2efe       [resetstack]
            Fonction : remise à zéro de la pile et effacement de l'interprétation en cours. Réinitialisation de l'imprimante.
            Retour : HL contient le code de l'instruction en cours ?
            
            MS_BASIC=CLREG
$2efe       Récupération de l'adresse de retour
$2eff       Réinitialisation de la pile (SP) à la dernière addresse RAM valide
$2f02       ---
$2f03       ---
$2f06       Le pointeur sur la zone temporaire de descripteur est initialisé
$2f09       ---
$2f0c       ---
$2f0d       ---
$2f0e       ---
$2f0f       Mise à zéro de `oldtxt`
$2f12       Mise à zéro du buffer `subflg` (utilisé pour FOR)
$2f15       Mise à zéro du nom du paramètre pour les fonctions utilisateurs
$2f18       Met 0 sur la pile
$2f19       Remet l'adresse de retour sur la pile avant le RET

$2f1a       [do_again]
            Récupère le pointeur d'exécution de l'instruction en court puis termine l'instruction
            en court. A priori pour la relancer (appelée depuis INPUT en cas de Redo from Scratch)
            A tracer depuis le reset qui précède et depuis INPUT (??)
            
            MS_BASIC=RUNFST <- Non, ça fait autre chose
$2f1a       HL contient la valeur de `temp` (code d'une instruction)
$2f1d       ---

$2f1e       [inst_restore]
            %CODE
            Instruction : RESTORE
            
            MS_BASIC=RESTORE
$2f1e       ---
$2f1f       ---
$2f22       Pas de paramètre, on restore depuis le début du programme
$2f24       ---
$2f25       ---
$2f28       ---
$2f29       ---
$2f2c       ---
$2f2d       ---
$2f2e       ---
$2f2f       Si le numéro de ligne spécifié n'est pas trouvé, erreur
$2f32       [restore_all]
            MS_BASIC=RESTNL
$2f33       [set_data]
            MS_BASIC=UPDATA
            Sauvegarde de l'octet de la prochaine ligne de DATA
$2f36       ---
$2f37       ---
$2f38       [inst_stop]
            %CODE
$2f39       ---
$2f3a       [inst_end]
            %CODE
$2f3b       ---
$2f3e       ---
$2f3f       [input_brk]
$2f41       Enlève l'adresse de retour des instructions. Le programme est terminé

$2f42       [end_of_prog]
            Traite la fin d'un programme
            
            MS_BASIC=ENDPRG
$2f42       ---
$2f45       Sauve le status de l'arrêt. STOP a mis A <- $C0, BREAK a mis A <- $FF, et END ?
$2f46       ---
$2f47       ---
$2f48       ---
$2f49       Si la dernière ligne était FFFF, alors le A est égal à 0, saut. Nous étions en mode direct.
$2f4b       Sauve la dernière ligne exécutée si elle avait un numéro
$2f4e       ---
$2f51       Sauve le dernier pointeur d'exécution concernant une ligne avec numéro. Utile pour CONT
$2f54       [no_line]
            Nouvelle ligne sur la sortie (et l'imprimante?)
$2f57       ---
$2f5a       Récupére AF... sans intérêt, on le push juste après sans rien en faire. A est écrasé par la langue et F par le test. (!!)
$2f5b       Chargement du texte pour l'arrêt
$2f5e       Remise dans la pile de AF...
$2f5f       Chargement de la langue du système.
$2f62       ---
$2f63       ---
$2f65       ---
$2f68       [break_fr]
$2f69       Si A était à zéro, il s'agissait d'un arrêt de programme normal, sinon, au saute à l'affichage de message d'arrêt.
$2f6c       Boucle sur l'affichage "Ok!"
$2f6f       [inst_cont]
            %CODE
$2f72       ---
$2f73       ---
$2f74       ---
$2f77       Sors avec l'erreur "Cannot continue"
$2f7a       ---
$2f7e       ---
$2f82       ---
$2f83       ---

$2f98       [a_to_z]
            Vérification que le caractère pointé par HL est entre A et Z inclus.
            Dans le cas contraire, lève le drapeau de retenu.
$2f98       ---
$2f99       [a_to_z_2]
            Appelé ici lorsque A contient déjà la caractère à vérifier
$2f9b       ---
$2f9c       ---
$2f9e       ---
$2f9f       ---

$2fa0       [inst_clear]
            %CODE
            Instruction : CLEAR
$2fa0       Si pas d'argument, initialise les variables avec les valeurs courantes
$2fa3       Récupère un premier paramètre entre 0 et 32768
$2fa6       ---
$2fa7       Prend le caractère suivant
$2fa8       Sauve le pointeur d'exécution
$2fa9       HL prend la dernière adresse mémoire disponible.
$2fac       Si pas de deuxième paramètre (le chget a renvoyé 0), alors on continue plus loin
$2fae       ---
$2faf       Vérifie que le caractère lu est bien une virgule
$2fb0       data -> ','
$2fb1       Sauve le premier paramètre
$2fb2       Décode le second paramètre (de -32768 à 32767)
$2fb5       ---
$2fb8       ---
$2fb9       Lit le caractère suivant.
$2fba       S'il n'est pas nul, c'est une erreur de syntaxe
$2fbd       Le pointeur d'exécution va sur la pile et on récupère le premier paramètre dans HL
$2fbe       Le premier paramètre est dans DE, le second dans HL.

$2fbf       [clr_stored]
            Le premier paramètre est dans DE, le second dans HL, qui est (memsiz) si on est venu sans second paramètre spécifié.
            
            MS_BASIC=STORED
$2fbf       Appel qui pourrait être inliné... (!!!)
$2fc2       Si HL - DE est négatif, alors erreur de mémoire
$2fc5       Sauvegarde de l'adresse mémoire haute (second paramètre)
            HL prend la valeur de (vartab), l'adresse de fin de programme BASIC stocké.
$2fc6       ---
$2fc9       En vrai, LD BC,$28 (== 40) (taille minimale voulue)
$2fcc       ---
$2fcd       Comparaison de (vartab) + $28 et de DE, qui contient la plus haute mémoire réduire de la taille pour les chaînes
$2fce       S'il n'y a pas assez de mémoire, le signaler.
$2fd1       ---
$2fd2       Stockage de HL (venant de DE) comme nouveau (stktop)
$2fd5       ---
$2fd6       Stockage de HL (venant de la pile) comme neaucou (memsiz)
$2fd9       On pop quoi ??? L'adresse de retour car on jump ?
$2fda       Saut à l'initialisation des variables.

$2fdd       [top_string]
            Soustraction du second paramètre (la mémoire haute) par la taille
            pour les chaînes demandée.
            À la fin, HL n'est pas touché, et DE contient HL - (taille demandée)
$2fdd       ---
$2fde       ---
$2fdf       ---
$2fe0       ---
$2fe1       ---
$2fe2       ---
$2fe3       ---
$2fe4       [inst_next]
            %CODE
$2fe7       [call2FE7]
$2fea       ---
$2fed       ---
$2ff0       ---
$2ff3       ---
$2ff4       ---
$2ff5       ---
$2ff6       ---
$2ff7       ---
$2ff8       ---
$2ff9       ---
$2ffc       ---
$2ffd       ---
$2ffe       ---
$3001       ---
$3002       ---
$3005       ---
$3006       ---
$3009       ---
$300a       ---
$300d       ---
$300e       ---
$300f       ---
$3010       ---
$3013       ---
$3015       ---
$3016       ---
$3019       ---
$301a       ---
$301b       ---
$301e       [skip301E]
$301f       ---
$3022       ---
$3023       ---
$3025       ---
$3028       ---
$3029       ---

$302c       [str_hex_dec]
            Transforme un nombre de la forme &"xxxx" en FP.
            
            MS_BASIC=HEXTFP
$302c       ---
$302d       Vérifie que le début du nombre (après le '&'), est un '"'
$302e       ---
$302f       [dummy]
            %CODE
            Pour forcer la donnée de chkchr. Le décodage ne fonctionne pas bien ici, c'est vraiment LD DE,$0000 qu'il faut lire. C'est l'initialisation de l'accumulateur de la valeur lue.
$3030       ---
$3031       ---
$3032       Compteur de chiffres maximum (4 chiffres max, la boucle djnz sort lorsque B est décrémenté à 0)
$3034       Positionnement du pointeur d'execution.
$3035       [hex_fetch]
            Va chercher un chiffre Hexa
$3038       Saute si ce n'était pas un chiffre Hexa
$303a       Temporairement sauve HL dans DE, qui contient l'accumulateur des valeurs
$303b       ---
$303c       ---
$303d       ---
$303e       HL (l'accumulateur) est décalé de 4 vers la gauche.
$303f       A est ajouté dans les 4 bits de poids faible
$3040       Remis dans l'accumulateur
$3041       Remise en place de DE=accumulateur et HL=pointeur
$3042       Si le compteur de chiffres n'est pas encore à zero, on repart pour un tour.
$3044       [not_hexa]
            Vérification que le caractère est '"' (en cas d'arrivée par caractère non hexa, on peut voir que &"" est valide et égal à 0)
$3046       Si ça n'est pas le cas, c'est une erreur de syntaxe.
$3049       On lit (puis ignore) le caractère suivant
$304a       ---
$304c       Sauvegarde du pointeur d'exécution.
$304d       B (exp) = $98, A == 0 et DE contient l'entier lu. Le tout est monté dans FP
            Ici, on ignore le caractère qui vient d'être lu
$304e       ---
$3051       Restauration du pointeur d'exécution.
$3052       ---
$3053       ---
$3058       [inst_renum]
            %CODE
$305b       ---
$305c       ---
$305d       ---
$305e       ---
$3060       ---
$3062       ---
$3064       ---
$3065       ---
$3068       ---
$3069       ---
$306a       ---
$306b       ---
$306d       [skip306D]
$306e       ---
$306f       ---
$3072       ---
$3074       ---
$3075       ---
$3076       ---
$3077       ---
$3078       ---
$307b       ---
$307e       ---
$307f       ---
$3080       ---
$3083       ---
$3084       ---
$3085       ---
$3086       [skip3086]
$3087       ---
$308a       ---
$308b       ---
$308c       ---
$308d       ---
$3090       ---
$3091       ---
$3092       ---
$3093       ---
$3094       ---
$3095       ---
$3098       ---
$3099       ---
$309a       ---
$309b       ---
$309c       ---
$309d       ---
$309f       [loop309F]
$30a0       ---
$30a3       ---
$30a4       ---
$30a5       ---
$30a8       ---
$30a9       ---
$30aa       ---
$30ad       [skip30AD]
$30ae       ---
$30af       ---
$30b0       ---
$30b1       ---
$30b2       ---
$30b3       ---
$30b4       ---
$30b5       ---
$30b7       ---
$30b8       ---
$30b9       ---
$30ba       ---
$30bb       ---
$30bc       ---
$30be       [skip30BE]
$30bf       ---
$30c2       ---
$30c3       ---
$30c4       ---
$30c5       [loop30C5]
$30c6       ---
$30c7       ---
$30c8       ---
$30c9       ---
$30ca       ---
$30cb       ---
$30cd       ---
$30ce       ---
$30cf       ---
$30d0       ---
$30d1       ---
$30d2       ---
$30d3       ---
$30d4       ---
$30d5       ---
$30d6       ---
$30d7       ---
$30d8       ---
$30da       [skip30DA]
$30dd       ---
$30de       ---
$30df       [call30DF]
$30e0       ---
$30e1       ---
$30e4       ---
$30e7       ---
$30e8       [loop30E8]
$30e9       ---
$30ea       ---
$30eb       ---
$30ec       ---
$30ed       ---
$30ee       ---
$30ef       ---
$30f0       ---
$30f1       [loop30F1]
$30f2       ---
$30f3       ---
$30f5       ---
$30f6       ---
$30f9       ---
$30fa       ---
$30fb       ---
$30fd       ---
$30ff       ---
$3101       ---
$3102       ---
$3103       ---
$3104       ---
$3105       ---
$3106       ---
$3107       ---
$3108       ---
$310b       ---
$310c       ---
$310e       ---
$3110       ---
$3113       ---
$3116       ---
$3119       ---
$311a       ---
$311c       ---
$311f       [skip311F]
$3120       ---
$3123       ---
$3124       ---
$3127       ---
$312a       ---
$312d       ---
$312e       ---
$3130       ---
$3133       [skip3133]
$3136       ---
$3137       ---
$3138       ---
$3139       ---
$313a       ---
$313d       ---
$313e       ---
$313f       ---
$3140       [loop3140]
$3142       [skip3142]
$3144       ---
$3146       ---
$3147       ---
$3148       ---
$314a       [skip314A]
$314c       ---
$314e       ---
$314f       ---
$3150       ---
$3151       ---
$3152       ---
$3153       ---
$3154       ---
$3155       ---
$3156       ---
$3157       ---
$3158       ---
$3159       ---
$315a       ---
$315b       ---
$315c       ---
$315e       [skip315E]
$3161       ---
$3162       ---
$3165       ---
$3166       ---
$3167       ---
$3168       ---
$3169       ---
$316a       ---
$316b       ---
$316c       ---
$316d       ---
$316e       [inst_auto]
            %CODE
$3171       ---
$3172       ---
$3174       ---
$3177       ---
$3178       ---
$3179       ---
$317a       ---
$317d       ---
$317e       ---
$317f       ---
$3180       ---
$3182       ---
$3183       ---
$3184       ---
$3187       ---
$3188       ---
$3189       ---
$318a       ---
$318d       ---
$318e       ---
$3191       ---
$3195       [skip3195]
$3196       ---
$319a       ---
$319c       ---
$319f       [bcode_start]
$31a0       ---
$31a3       [inst_llist]
            %CODE
$31a5       ---
$31a8       [inst_list]
            %CODE
$31ab       ---
$31ae       ---

$31b1       [line_pair]
            Récupère deux arguments de type numéro de ligne et les sauve dans (temp) et (sonsav_hi).
            Le premier numéro de ligne (trouvé) est retourné dans DE.
$31b1       ---
$31b4       ---
$31b5       Lit le premier caractères du pointeur de ligne
$31b6       Et saute s'il n'y a rien (avec DE à $0000)
$31b8       Compare avec ','
$31ba       Si ce n'était pas une ',', alors va lire un numéro de ligne (récupéré dans DE)
$31bd       [no_pair_1]
            Sauvegarde du premier numéro de ligne dans 'temp'. $0000 s'il n'y avait pas de premier paramètre.
$31c1       ---
$31c2       Cherche le premier numéro de ligne valide à partir de DE.
$31c5       ---
$31c6       Pousse dans la pile le premier numéro de ligne valide après celui demandé.
$31c7       ---
$31c8       ---
$31c9       Saute s'il n'y a pas de second numéro de ligne.
$31cb       ---
$31cd       Si le caractère suivant n'était pas une ',', alors c'est une erreur de syntaxe.
$31d0       ---
$31d1       Sinon, récupération du deuxième argument comme un numéro de ligne.
$31d4       Si ce n'était pas un numéro de ligne valide, c'est une erreur de syntaxe.
$31d7       ---
$31d8       ---
$31d9       Si ce numéro n'était pas nul, on saute à la fin de la routine pour enregistrement.
$31db       [no_pair_2]
            Par défaut, le dernier numéro de ligne est $ffff
$31de       [save_pair_2]
            Sauvegarde du dernier numéro de ligne dans 'sonsav_hi'
$31e2       Le premier numéro de ligne (valide) est récupéré dans DE.
$31e3       ---

$31e4       [prt_list]
            Routine d'affichage d'un LISTING
$31e4       ---
$31e6       ---
$31e9       ---
$31ea       [jump31EA]
$31eb       ---
$31ec       ---
$31ed       ---
$31ee       ---
$31ef       ---
$31f0       ---
$31f1       ---
$31f4       ---
$31f6       ---
$31f8       ---
$31f9       [loop31F9]
$31fc       ---
$31fd       ---
$31ff       [loop31FF]
$3202       ---
$3205       ---
$3206       ---
$3208       ---
$3209       [skip3209]
$320a       ---
$320b       ---
$320c       ---
$320d       ---
$3210       ---
$3211       ---
$3212       ---
$3213       ---
$3214       ---
$3218       ---
$3219       ---
$321a       ---
$321b       ---
$321e       ---
$3220       ---
$3221       ---
$3224       ---
$3225       ---
$3228       ---
$322c       ---
$322d       [jump322D]
$322e       [loop322E]
$322f       ---
$3230       ---
$3232       ---
$3234       ---
$3236       ---
$3237       ---
$3238       ---
$3239       ---
$323a       ---
$323b       ---
$323c       ---
$323d       ---
$323e       ---
$323f       ---
$3240       ---
$3243       ---
$3244       ---
$3246       [skip3246]
$3247       ---
$3249       ---
$324c       ---
$324e       ---
$324f       ---
$3252       ---
$3254       ---
$3256       ---
$325a       [loop325A]
$325b       ---
$325c       ---
$325d       ---
$3260       ---
$3261       ---
$3263       [jump3263]
$3265       ---
$3266       ---
$3267       ---
$3268       ---
$3269       ---
$326c       ---
$326e       [skip326E]
$3272       ---
$3275       ---

$3278       [initscreen]
            $SECTION(co)
            Réinitialisation du curseur, d'attributs
            Redéfinition de deux caractères: $20 et $7F
            Efface l'écran, remise en colonne 1
$3278       Deux accès à $47FD pour set les bits 4 et 6
$327c       Test du bit zéro sur $47FE (majuscules\minuscules)
$3280       ---
$3284       ---
$3286       Changement de l'aspect du curseur si minuscules
$328a       [skip328A]
$328d       ---
$328f       ---
$3292       [initscreen2]
$3295       ---
$3297       [call3297]
            Initialisation des attributs utilisés pour l'effacement de l'écran
$329a       ---
$329d       [cur_home]
$32a0       Curseur mis en haut à droite de l'écran
$32a3       Force l'affichage à l'interruption suivante
$32a7       ---
$32ab       Et attend l'affichage
$32ac       ---
$32ad       ---

$32b7       [deckeyb]
            Fonction : décode le clavier
$32b7       ---
$32b8       ---
$32bb       ---
$32bd       ---
$32be       ---
$32c2       ---
$32c5       ---
$32c8       ---
$32ca       ---
$32cd       [jump32CD]
$32cf       [jump32CF]
$32d2       ---
$32d6       ---
$32d7       ---
$32da       [skip32DA]
$32de       [jump32DE]
$32e2       ---
$32e4       ---
$32e6       ---
$32ea       ---
$32ec       ---
$32f0       ---
$32f4       ---
$32f6       [skip32F6]
$32fa       ---
$32fe       [skip32FE]
$3302       ---
$3304       [skip3304]
$3308       ---
$330a       ---
$330c       ---
$330e       ---
$3310       ---
$3312       ---
$3314       ---
$3316       [jump3316]
$3317       [skip3317]
$3318       ---
$3319       ---
$331a       [sendchar_t2]
$331b       ---
$331c       ---
$331f       La pile contient, en haut, $33c5, puis AF (qui contient le caractère)
$3320       ---
$3322       ---
$3324       ---
$3326       ---
$3328       A est compris entre 128 et 160. La mise à 0 du bit 7 revient à soustraire 128
$332a       ---
$332c       [sdchar_bl80]
            A est inférieur ou égal à 128.
$332e       On vérifie s'il est supérieur à 32
$3330       ---
$3334       Saut si on est en train d'utiliser les caractères utilisateurs
$3336       ---
$333a       Saut si c'est un caractère graphique
$333c       [skip333C]
            Arrivé ici si le caractère était dans [128,160[ (ajusté en [0, 32[ ou un caractère redéfini de numéro inférieur strictement à 32.
$333e       ---
$333f       ---
$3340       ---
$3341       ---
$3342       E = A * 3 (A contient le caractère)
$3343       ---
$3346       ---
$3347       ---
$3348       Branchement sur la table de redirection qui commence en $3362

$3349       [sd_a_ff]
            Partial instruction trick en cascade.
            Les 6 labels suivants chargent A avec une certaine valeur.
            Puis exécutent une série de LD HL avec des valeurs inutiles
            Pour finalement arriver sur 'sdchar_pass'
            
            Cela agit comme un remapping des caractères qui étaient normalement non affichables.
$3349       ---
$334b       ---
$334c       [sd_a_0d]
$334e       ---
$334f       [sd_a_08]
$3351       ---
$3352       [sd_a_04]
$3354       ---
$3355       [sd_a_1f]
$3357       ---
$3358       [sd_a_03]
$335a       [sdchar_pass]
$335b       $33cd est mis sur la pile pour servir de branchement lors du prochain RET, à la fin de l'émission du caractère.
$335e       ---
$335f       ---
$3362       [sdchar_ind]
            %CODE
$3365       %CODE
$3368       %CODE
$336b       %CODE
$336e       %CODE
$3371       %CODE
$3374       %CODE
$3377       %CODE
$337a       %CODE
$337d       %CODE
$3380       %CODE
$3383       %CODE
$3386       %CODE
$3389       %CODE
$338c       %CODE
$338f       %CODE
$3392       %CODE
$3395       %CODE
$3398       %CODE
$339b       %CODE
$339e       %CODE
$33a1       %CODE
$33a4       %CODE
$33a7       %CODE
$33aa       %CODE
$33ad       %CODE
$33b0       %CODE
$33b3       %CODE
$33b6       %CODE
$33b9       %CODE
$33bc       %CODE
            Fin de la table d'indirection. Caractère 31.
$33bf       ---

$33cd       %CODE
            Cette adresse est forcée dans la pile pour que le RET de l'affichage de caractère passe par là.
            Le rafraichissement de l'écran est demandé et la pile et les registres remis en ordre.
$33cd       ---
$33d1       ---
$33d2       ---
$33d3       ---

$33d4       [carreturn]
            Fonction: traitement Carriage Return
            Traitement de l'affichage du caractère 13 (et 3)
$33d4       ---
$33d7       ---
$33d9       ---
$33da       Saut si 'x' est différent de 1
$33dc       ---
$33df       ---
$33e1       Saut si 'continuation permitted' est à 0
$33e3       Si le curseur est sur la colonne 1 et 'continuation permitted' est à 1, alors la colonne 0 est mise à $80 (attributs par défaut pour l'EF9345)
            Et c'est fini.
$33e6       ---
$33e7       ---
$33e8       ---
$33ea       ---
$33eb       [skip33EB]
$33ed       Le curseur est mis sur la colonne 1 et on enchaîne sur `line_down`

$33f0       [line_down]
            Fonction: amène le curseur une ligne plus bas
            Traitement de l'affichage du caractere 10
$33f0       ---
$33f3       ---
$33f4       ---
$33f6       ---
$33f8       ---
$33fb       ---
$33fd       Si le scrolling est désactivé, on saute
$33ff       ---
$3402       ---
$3404       ---
$3407       ---
$3409       [skip3409]
$340a       ---
$340d       [skip340D]

$340e       [line_up]
            Fonction: amène le curseur une ligne plus haut
            Traitement de l'affichage du caractere 9
$340e       ---
$3411       ---
$3412       ---
$3413       ---
$3415       ---
$3418       ---
$341a       Si le scrolling est désactivé, on saute
$341c       ---
$341f       ---
$3421       ---
$3424       ---
$3426       [skip3426]
$3427       ---
$342a       [skip342A]

$342b       [col_left]
            Fonction : La position du curseur est avancée de 1 vers la gauche
            Traitement de l'affichage du caractere 8
$342b       xcursor est suivi de ycursor. Ce qui fait que H contient 'y' et L contient 'x'
$342e       ---
$342f       ---
$3431       Saut si la colonne du curseur est inférieur strictement à 2
$3433       ---
$3434       [col_l_end]
$3437       ---
$3438       [line_above]
$3439       ---
$343a       On ne fait rien si la ligne du curseur est à zéro
$343b       ---
$343e       Curseur à la dernière colonne
$3440       ---

$3442       [col_right]
            Fonction : La position du curseur est avancée de 1 vers la droite
            Traitement de l'affichage du caractere 7
$3442       ---
$3445       ---
$3446       ---
$3448       Si le curseur est en position 39, on saute
$344a       ---
$344b       [col_r_end]
$344e       ---
$344f       [line_below]
$3450       ---
$3452       On ne fait rien si le curseur est en bas à droite de l'écran.
$3453       ---
$3456       ---
$3458       ---
$345a       [jump345A]
$345d       ---
$345f       ---
$3460       ---
$3463       ---
$3464       ---
$3467       ---
$3468       ---
$3469       ---
$346a       ---
$346b       ---
$346c       ---
$346e       ---
$346f       ---
$3470       ---
$3471       ---
$3473       [loop3473]
$3475       ---
$3476       ---
$3478       ---
$3479       ---
$347a       ---
$347c       ---
$347d       ---
$347e       [loop347E]
$347f       ---
$3480       ---
$3481       ---
$3482       ---
$3483       ---
$3484       ---
$3485       ---
$3486       ---
$3487       ---
$3488       ---
$3489       ---
$348a       ---
$348b       ---
$348c       ---
$348d       ---
$348e       ---
$3491       ---
$3493       [jump3493]
$3494       ---
$3495       ---
$3496       ---
$3497       ---
$349a       ---
$349b       ---
$349d       [jump349D]
$34a0       ---
$34a2       ---
$34a5       [skip34A5]
$34a7       ---
$34ab       ---
$34ad       ---
$34ae       [skip34AE]
$34af       ---
$34b2       ---
$34b3       [jump34B3]
$34b6       ---
$34b7       ---
$34b9       ---
$34ba       ---
$34bb       ---
$34be       ---
$34bf       ---
$34c2       ---
$34c4       ---
$34c6       ---
$34c8       ---
$34c9       [loop34C9]
$34ca       ---
$34cb       ---
$34cc       ---
$34cd       ---
$34cf       [loop34CF]
$34d0       ---
$34d2       ---
$34d3       ---
$34d4       ---
$34d7       ---
$34d8       ---
$34da       ---
$34db       ---
$34dc       ---
$34df       ---
$34e1       [skip34E1]
$34e2       [jump34E2]
$34e5       ---
$34e7       [jump34E7]
$34e8       ---
$34e9       ---
$34ec       ---
$34ed       ---
$34ee       ---
$34f1       ---
$34f2       ---
$34f3       ---
$34f4       ---
$34f5       ---
$34f6       ---
$34f7       ---
$34fb       ---
$34fd       ---
$34fe       ---
$3501       ---
$3503       [skip3503]
$3505       ---
$3508       [skip3508]
$350b       ---
$350c       ---
$350f       [jump350F]
$3510       ---
$3514       ---
$3516       ---
$3519       ---
$351c       ---
$351e       ---
$3521       ---
$3523       ---
$3524       ---
$3525       ---
$3528       [jump3528]
$352b       ---
$352c       ---
$352d       ---
$352e       ---
$3531       ---
$3532       ---
$3533       ---
$3534       ---
$3535       ---
$3538       ---
$353b       ---
$353c       ---
$353d       ---
$353e       ---
$353f       ---
$3540       ---
$3541       ---
$3543       ---
$3544       ---
$3545       ---
$3546       ---
$3547       ---
$3548       ---
$3549       ---
$354a       ---
$354b       ---
$354c       ---
$354f       [jump354F]
$3552       ---
$3553       ---
$3555       ---
$3558       ---
$3559       ---
$355a       ---
$355b       ---
$355c       ---
$355d       ---
$355f       ---
$3560       ---
$3562       ---
$3563       ---
$3564       ---
$3566       ---
$3568       [skip3568]
$356a       ---
$356e       ---
$3570       ---
$3571       [skip3571]
$3574       ---
$3577       ---

$3578       [peekchar]
            Fonction : récupère le caractère à l'écran aux coordonnées HL dans A
            HL est modifié. A contient le caractère. A est comparé à $84.
$3578       ---
$357b       ---
$357c       ---
$357e       ---
$357f       [jump357F]
$3582       ---
$3583       ---
$3584       ---
$3586       ---
$3588       ---
$358b       ---
$358e       ---
$358f       ---
$3591       ---
$3592       ---
$3593       ---
$3596       ---
$3598       [skip3598]
$359b       ---
$359e       ---
$359f       [clr_scr_btm]
            Fonction : Efface toutes les lignes à partir de la ligne courante jusqu'en bas de l'écran
            Traitement de l'affichage du caractère 31
$35a2       [loop35A2]
$35a3       ---
$35a6       ---
$35a7       ---
$35a8       ---
$35aa       ---
$35ac       ---

$35ad       [scroll_up]
            Fonction: monte le contenu de l'écran d'une ligne par recopie de la mémoire
            La nouvelle ligne a toujours l'ancien contenu
$35ad       ---
$35b0       ---
$35b3       ---
$35b6       ---
$35b8       ---

$35b9       [scroll_down]
            Fonction: descend le contenu de l'écran d'une ligne par recopie de la mémoire
            La nouvelle ligne a toujours l'ancien contenu
$35b9       ---
$35bc       ---
$35bf       ---
$35c2       ---
$35c4       ---

$35c5       [reset_term]
            La fonction réinitialise les bits 2 et 7 de $4871.
            Remet le scrolling (et ligne non entrée sous BASIC (?))
            
            Réinitialise quelques valeurs d'affichage
$35c5       ---
$35c8       ---
$35ca       ---
$35cd       $4804 à 0 : pas de redéfinition de caractères
$35d1       $4002 à 0 : couleur d'encre et fond graphique à zero, texte
$35d5       $47FB à 1 : force un affichage
$35d9       $47FC à 0 : équivalent de DISPLAY 10
$35dd       ---
$35e1       ---
$35e5       ---
$35e6       [honk]
$35e9       ---
$35ec       ---
$35ef       ---
$35f2       ---
$35f3       [jump_ret]
            Cette adresse est utilisée pour sauter à un RET depuis une table d'indirection.
$35f4       [char20]
$35fe       [char7f]
$3609       [bistrs]
            %CODE,SECTION(bistrs)
            This seems to be code, but where is it called from ???
            It's also the first part of the bistrs section.
$3636       [inst_str]
            %CODE
$3639       ---
$363c       ---
$363f       ---
$3642       ---
$3645       ---
$3646       [save_str]
            A <- longueur de la chaine
$3647       ---
$3648       ---
$3649       HL positionné sur l'adresse du contenu poussée dans la pile
$364a       Vérification qu'il y a assez de place dans la mémoire de chaines
$364d       Si oui, on lit l'adresse du contenu dans BC
$364e       ---
$364f       ---
$3650       ---
$3651       Création d'un descripteur temporaire
$3654       ---
$3655       ---
$3656       Copie L octets de BC (source) vers DE (destination)
$3659       Pointeur de descripteur de chaine dans DE
$365a       ---
$365b       [str_len_1]
            Construction après vérification d'une chaine de taille 1.
$365d       [ctr_ver_str]
            Construction d'une chaine après vérification de la mémoire disponible

$3660       [crt_str_dsc]
            Fonction: met la longueur de chaîne (A) puis rien (0, pour être sur 16 bits) puis DE (pointeur de chaîne) dans dsctmp
            Entrée: A contient un nombre de caractères (longueur de chaîne), DE le pointeur sur la chaine (sans séparateur de début)
            Sortie: HL pointe sur le buffer temporaire de chaîne, dsctmp
            
            MS_BASIC=CRTMST
$3660       ---
$3663       ---
$3664       ---
$3665       ---
$3666       [de_in_hl]
            Puts DE where HL points to
$3667       ---
$3668       ---
$3669       ---
$366a       ---
$366b       ---

$366c       [out_str_prc]
            Création d'une chaine de caractère depuis la source pointée par HL (dans le pool de string ???)
            
            MS_BASIC=CRTST (Create String?)
$366c       Positionne hl un caractère avant le début de la chaine (à cause du inc hl de la boucle qui suit)
$366d       [str_to_str]
            MS_BASIC=QTSTR
$366f       '"' est dans B puis D
$3670       [direct_str]
            Sauve la valeur courante de HL, la mémoire à parser entre guillemets. Un appel direct ici devra placer ses propres terminateurs dans B et D ; MS_BASIC=DTSTR
$3671       Compteur C de la taille de la chaine à -1
$3673       [loop_str]
$3674       Récupération du caractère dans a
$3675       Incrémentation du compteur de caractères parsés (longueur totale de la chaîne)
$3676       ---
$3677       Si le caractère est 0 (fin de chaîne)
$3679       ---
$367a       Si le caractère est $22 (=34, guillemets) (ou autre terminateur mis dans D)
$367c       Traitement du deuxième terminateur possible
$367d       Tant que l'on traite des caractères normaux
$367f       [create_str]
$3681       Si la lecture s'est terminée par des guillements, on les consomme ("BLA est une chaine valide si en fin de ligne)
$3684       Récupération du pointeur du début de la chaîne dans HL
$3685       ---
$3686       DE contient le début de la chaîne +1 (dont après les guillemets)
$3687       A <- longueur de la chaîne
$3688       Création du pointeur de chaine sur l'espace temporaire
$368b       [cpy_to_pool]
            DE <- espace temporaire
$368e       HL <- espace actuel de traitement de chaine
            Sauve l'adresse de la chaine dans FP
$3691       ---
$3694       ---
$3696       La valeur courante est une chaîne de caractères
$3699       Copie les 4 premiers octets de dsctmp vers HL, qui pointe vers (temppt). Autrement dit, copie la description de chaine temporaire dans le pool de chaine.
$369c       Comparaison avec DE, qui est dsctmp et agit donc comme gardien de fin de buffer (après tempst) (où est initialisé temppt à part au reset de stack ???)
$369d       Mise à jour du pointeur vers le buffer tempst
$36a0       Récupération du pointeur de parsing
$36a1       Lecture du prochain caractère
$36a2       Retour s'il reste de la place dans le buffer tempst
$36a3       ---
$36a6       Lancement de l'erreur "String formula too complex"

$36a9       [sharp_char]
            %CODE
            Afficher une chaîne sans le premier caractère
            
            MS_BASIC=PRNUMS
$36a9       ---

$36aa       [out_str]
            Fonction: Affichage d'une chaîne à l'écran
            Entrée: HL pointe sur la chaîne de caractère terminée par un 0
            
            MS_BASIC=PRS (Print String)
$36aa       ---
$36ad       [out_str1]
            MS_BASIC=PRS1
$36b0       ---
$36b3       ---
$36b4       [prsloop]
            MS_BASIC=PRSLP ; Compte les caractères
$36b5       ---
$36b6       ---
$36b7       ---
$36b8       ---
$36b9       ---

$36bb       [alloc_str_mem]
            Vérifie la place restante pour les chaines, alloue la chaine, lance le GC si nécessaire.
            La place demandée est dans A. À la fin de la routine, DE pointe sur un espace allouée de A
            caractères dans la mémoire dédiée, et (fretop) est ajusté en conséquence. Ainsi, ce n'est
            pas seulement un test mais un test et une allocation.
            Dans ces implémentations, Z est d'abord reset, mais plus tard Set avec un bouclage après GC.
            Si au deuxième passage il n'y a toujours pas assez de mémoire, alors l'erreur est lancée.
            
            MS_BASIC=TESTR
$36bb       Ajuste un flag pour signaler no-GC
$36bc       Annule $f1 qui est pop af
$36bd       [retry_alloc]
            %CODE
$36be       ---
$36bf       Charge le pointeur sur le haut de la stack (et donc juste sous la mémoire réservée pour les chaines)
$36c2       ... dans DE
$36c3       Charge le pointeur sur la plus haute mémoire libre disponible
$36c6       A contient la longueur cherchée.
$36c7       ---
$36c8       Met son inverse dans BC
$36ca       L'ajoute à la plus haute mémoire
$36cb       Ajustement pour le complèment à 2 de la soustraction
$36cc       Compare avec l'adresse DE (adresse minimale possible)
$36cd       Pas assez de mémoire, on lance l'erreur (ou le GC en première tentative)
$36cf       Remise en place de la plus haute mémoire après un GC.
$36d2       HL est positionné sur la première adresse après fretop (la première adresse des chaines avec une allocation de A caractères)
$36d3       ... dans DE (qui est utilisé par save_str par exemple)
$36d4       Restauration de AF
$36d5       ---
$36d6       [out_str_mem]
$36d7       ---
$36da       Sors avec l'erreur "Out of string space"
$36dd       ---
$36de       ---
$36df       ---
$36e2       ---
$36e3       [gc_start]
$36e6       [jump36E6]
$36e9       ---
$36ec       ---
$36ed       ---
$36f0       ---
$36f1       ---
$36f4       ---
$36f8       ---
$36f9       ---
$36fc       ---
$36ff       ---
$3702       [loop3702]
$3706       ---
$3707       ---
$3709       ---
$370a       ---
$370b       ---
$370c       ---
$370d       ---
$3710       ---
$3712       [jump3712]
$3713       [skip3713]
$3717       ---
$3718       ---
$371b       ---
$371e       ---
$371f       ---
$3720       ---
$3721       ---
$3722       ---
$3725       ---
$3728       ---
$3729       ---
$372a       ---
$372c       ---
$372d       ---
$372e       ---
$372f       ---
$3730       ---
$3733       ---
$3734       ---
$3735       ---
$3737       ---
$373a       [jump373A]
$373b       ---
$373d       [call373D]
$373e       ---
$373f       ---
$3740       ---
$3741       ---
$3742       ---
$3743       ---
$3744       ---
$3745       ---
$3746       ---
$3747       ---
$3748       ---
$3749       ---
$374c       ---
$374d       ---
$374e       ---
$374f       ---
$3750       ---
$3751       ---
$3752       ---
$3753       ---
$3754       ---
$3755       ---
$3756       ---
$3757       ---
$3758       ---
$3759       ---
$375a       ---
$375b       ---
$375c       ---
$375d       ---
$375e       ---
$375f       [jump375F]
$3760       ---
$3761       ---
$3762       ---
$3763       ---
$3764       ---
$3765       ---
$3766       ---
$3767       ---
$3768       ---
$3769       ---
$376a       ---
$376b       ---
$376c       ---
$376e       ---
$376f       ---
$3770       ---
$3771       ---
$3772       ---
$3773       ---
$3774       ---
$3777       ---
$377a       ---
$377b       ---
$377c       ---
$377d       ---
$377e       ---
$377f       ---
$3780       ---
$3781       ---
$3784       [str_concat]
$3785       ---
$3786       ---
$3789       ---
$378a       ---
$378d       ---
$378e       ---
$3791       ---
$3792       ---
$3793       ---
$3796       ---
$3797       ---
$3798       ---
$379b       Sors avec "String too long"
$379e       ---
$37a1       ---
$37a2       ---
$37a5       ---
$37a6       ---
$37a9       ---
$37aa       ---
$37ad       ---
$37ae       ---
$37b1       ---
$37b4       ---
$37b7       ---
$37b8       ---
$37b9       ---
$37bc       [call37BC]
$37bd       ---
$37be       ---
$37bf       ---
$37c0       ---
$37c1       ---
$37c2       ---
$37c3       ---
$37c4       ---

$37c5       [copy_str]
            Copie le contenu mémoire d'une taille de L de BC vers DE.
$37c5       ---
$37c6       [move_loop]
$37c7       ---
$37c8       ---
$37c9       ---
$37ca       ---
$37cb       ---
$37cc       ---

$37ce       [get_string]
            Vérifie le type courant comme étant un chaine, puis fallthrough dans la récupération de la chaine
            
            MS_BASIC=GETSTR
$37ce       ---

$37d1       [GSTRCU]
            MS_BASIC=GSTRCU (Current string to pool)
$37d1       ---
$37d4       [call37D4]
$37d5       [call37D5]
$37d8       ---
$37d9       ---
$37da       ---
$37db       ---
$37dc       DE <- BC, l'adresse de la chaine de caractères
$37dd       ---
$37de       C contient la taille de la chaine de caractères
$37df       ---
$37e2       ---
$37e3       ---
$37e5       ---
$37e6       ---
$37e7       ---
$37ea       [skip37EA]
$37eb       ---

$37ec       [bc_from_tmp]
            Récupère dans BC une adresse contenue dans l'adresse juste avant le pointeur (temppt)
            Si en remontant encore de deux adresse ou tombe sur DE, alors on met à jour (temppt) avec cette nouvelle addresse.
            Sinon, on retourne.
            Quoi qu'il arrive, avec BC
$37ec       ---
$37ef       ---
$37f0       ---
$37f1       ---
$37f2       ---
$37f3       ---
$37f4       ---
$37f5       ---
$37f6       ---
$37f7       ---
$37fa       ---

$37fb       [inst_len]
            %CODE
            Instruction BASIC len()
            
            MS_BASIC=LEN
$37fb       Adresse de retour qui renvoie l'entier qui est dans A
$37fe       ---
$37ff       [fetch_str]
$3802       A cet endroit, C contient la longueur de la chaine de caractères, mais on n'a pas l'air de s'en servir
$3803       ---
$3804       C'est une valeur numérique
$3807       HL pointe vers la longueur de chaine, qui est donc mise dans A pour valeur de retour
$3808       ---
$3809       ---

$380a       [inst_asc]
            %CODE
            Fonction BASIC ASC()
            Et sous routine pour pointer DE vers l'adresse de la chaine (indirection) avec le première caractère dans A.
            La fonction change la valeur de retour vers la routine qui met le résultat de A dans FAC. Ce qui fait un transtypage ASCII -> VALEUR ENTIERE
$380a       ---
$380d       ---
$380e       [str_to_de]
$3811       Saute si la longueur de la chaine est 0.
$3814       ---
$3815       ---
$3816       ---
$3817       ---
$3818       DE <- pointeur sur la chaine
$3819       A <- le premier caractère de la chaine, qui est aussi le résultat en numérique
$381a       ---
$381b       [inst_chr]
            %CODE
$381e       ---
$3821       ---
$3824       ---
$3825       ---
$3826       ---
$3829       [inst_left]
            %CODE
$382c       ---
$382d       [loop382D]
$382e       ---
$382f       ---
$3830       ---
$3831       ---
$3832       ---
$3834       ---
$3835       ---
$3836       [skip3836]
$3838       ---
$3839       ---
$383c       ---
$383d       ---
$383e       ---
$383f       ---
$3840       ---
$3841       ---
$3842       ---
$3843       ---
$3844       ---
$3845       ---
$3847       ---
$3848       ---
$3849       ---
$384a       ---
$384d       ---
$384e       ---
$3851       ---
$3852       ---
$3855       ---
$3858       [inst_right]
            %CODE
$385b       ---
$385c       ---
$385d       ---
$385e       ---
$385f       ---
$3861       [inst_mid]
            %CODE
$3862       ---
$3863       ---
$3866       ---
$3867       ---
$3868       ---
$386b       ---
$386c       ---
$386e       ---
$3870       ---
$3873       ---
$3874       ---
$3875       ---
$3878       [jump3878]
$3879       ---
$387a       ---
$387b       ---
$387c       ---
$387f       ---
$3880       ---
$3881       ---
$3882       ---
$3884       ---
$3885       ---
$3886       ---
$3887       ---
$3888       ---
$3889       ---
$388a       ---
$388b       ---
$388c       ---
$388d       [inst_val]
            %CODE
            Appel à LEN
$3890       Si la longueur est 0, alors le résultat est 0
            Saute si la longueur de la chaine est 0. Le résultat est alors 0.
$3893       Sauve la longueur de la chaine dans E
$3894       ---
$3895       ---
$3896       Se positionne sur le pointeur de chaine
$3897       ---
$3898       ---
$3899       Le pointeur est à présent dans HL
$389a       Qui est poussé sur la pile
$389b       Se place à la fin de la chaîne + 1 (D doit être égal à 0)
$389c       ---
$389d       Place 0 à la fin de la chaine pour terminaison (D est toujours égal à 0)
$389e       Met la fin de chaine sur la pile et récupère le début de la chaine.
$389f       Pousse sur la pile l'ancien contenu de la chaine + 1
$38a0       Positionne le pointeur un octet avant le début de la chaine pour pouvoir appeler chget.
$38a1       Récupère le premier octet de la chaine dans A
$38a2       Appelle la conversion de chaine vers FAC
$38a5       Récupère l'ancien octet d'après la chaine
$38a6       ... et son adresse
$38a7       Replace l'octet à sa place
$38a8       ---

$38a9       [lf_rt_arg]
            Récupère l'argument numérique de LEFT et RIGHT
$38a9       ---
$38aa       Vérifie que la suite est une parenthèse fermante, sinon, c'est une erreur de syntaxe.
$38ab       Caractère ')'
$38ac       [mid_arg]
            Récupère le deuxième argument pour MID
$38ad       Récupère l'argement depuis la pile en préservant l'adresse de retour.
$38ae       ---
$38af       Met l'argument (la longeur) dans B
$38b0       ---

$38b1       [inst_fre]
            %CODE
            Instruction : FRE()
            Entrée : (valtyp)
$38b1       ---
$38b4       DE contient l'adresse de (strend)
$38b5       ---
$38b8       HL contient l'adresse de la pile
$38b9       ---
$38bc       ---
$38bd       Saute si (valtyp) est à 0 (nombre)
$38c0       ---
$38c3       ---
$38c6       ---
$38ca       HL contient (fretop) et DE contient (stktop)
$38cd       ---

$38d0       [dim_cont]
            %CODE,SECTION(biptrg)
            L'appel est induit par le push en $38d8, lors de l'exécution de l'instruction DIM.
$38d0       ---
$38d1       Si la zone de parsing contient 0, alors retour de l'instruction
$38d2       ---
$38d3       Sinon, vérification que le caractère suivant est une virgule ($2C) qui induit une deuxième définition de tableau
$38d4       Valeur pour le chkchr précédent

$38d5       [inst_dim]
            %CODE
            Instruction : DIM
            Le format d'un tableau (stocké à partir de arytab) est le suivant:
            +0/+1 : identifiant du tableau
            +2/+3 : taille des données allouées pour le tableau (dimensions comprises)
            +4    : nombre de dimensions
            paires suivantes : taille de chaque dimension
            puis la zone d'allocation de données (4 octets par indice)
$38d5       ---
$38d8       ---
$38d9       ---

$38da       [getvar]
            Fonction qui parse le nom de la variable et initialise l'espace nécessaire après vartab, en poussant
            l'existant. Puis inscrit l'identifiant. Si la variable existe, se contente de la retourner.
            En entrée: HL pointe sur la zone de parsing.
            En sortie: DE pointe sur la zone de mémoire contenant la valeur et cas d'assigntion,
                       l'accumulateur flottant la valeur en cas d
                       HL sur la zone de parsing.
            L'identifant est sur deux caractères. Si le type est alphanum, alors le second caractère a son bit de poids fort à 1.
            Une variable a 4 octets de valeur.
            Si le type est une fonction, le premier caractère a son bit de poids fort à 1 (vérifier ???)
            Pour une chaine : taille, (rien), pointeur sur la chaine (en fin de mémoire)
$38da       Saut depuis LET pour définir une variable
$38db       0 dans dimflg sauf si l'on vient de DIM, auquel cas cela vaut $AF
$38de       Récupération du premier caractère de la variable dans C
$38df       [get_id]
$38e2       Si le nom de variable ne commence par par une lettre majuscule entre A et Z, c'est une erreur de syntaxe (rappel : tout ce qui est parsé hors chaîne de caractère est passé en majuscules)
$38e5       ---
$38e6       ---
$38e7       valtyp à 0 par défaut (valeur numérique)
$38ea       Lit le caractère suivant
$38eb       Saute si le caractère lu est un chiffre
$38ed       ---
$38f0       Saute si le caractère lu n'est pas entre A et Z (donc si ni chiffre ni A à Z l'identifiant est terminé)
$38f2       [idnum_trail]
            Sauve le premier caractère de la variable dans B
$38f3       [idtrail_skp]
$38f4       Avance la lecture de l'identifiant tant que l'on trouve des chiffres
$38f6       ---
$38f9       Avance la lecture de l'identifiant tant que l'on trouve des lettres
$38fb       [id_end]
            Le nom de l'identifiant a été lu. On vérifie son qualificatif en '$'
$38fd       Si '$' n'est pas présent, on saute. La valeur est bien numérique.
$38ff       Sinon, la variable est de type chaîne de caractères
$3900       Ce qui est indiqué dans valtyp
$3903       A <= $80 et Carry à 1
$3904       Ajoute $80 à B pour marque le type string de la variable
$3905       B <- B + A ($80)
$3906       Lecture du caractère suivant le '$'
$3907       [num_vrble]
            (subflg) == 1 pour une demande de tableau, >= 1 lorsque l'on vient d'un FOR ou d'une fonction ($80 lors d'une évaluation)
$390a       ---
$390b       Saut si subflg était égal à 1. L'appelant veut un tableau.
$390e       Saut si subflg était supérieur à 1 (traitement des fonctions et FOR Le subflg est à $80 pour une fonction lors d'une évaluation avec la variable paramètre)
$3911       ---
$3912       ---
$3914       Saut si le caractère suivant est une parenthèse ouvrante (pour le dimensionnement des tableaux)
$3917       [simplevar]
$3918       Reset de subflg
$391b       Push de la position actuelle du pointeur de parsing
$391c       ---
$391d       DE <- BC
$391e       ---
$3921       Compare DE (le nom de variable cherchée) et HL (le nom pointée par le paramètre)
$3922       ---
$3925       Si la valeur sont identique, saute (pour un RET) avec DE placé sur la valeur du paramètre.
$3928       ---
$392b       ---
$392c       HL est à (vartab) et DE est à (arytab). L'espace de stockage des variables est entre les deux (HL < ou égal à DE)
$392f       [next_var]
$3930       Saut si HL et DE sont égaux, c'est-à-dire (vartab) == (arytab) (donc pas de variable définie)
$3933       À cet endroit, HL < DE et l'espace entre les deux contient des variables. BC contient l'identifiant de la variable en train d'être parsée.
$3934       Comparaison du premier caractère de la variable avec le premier caractère de la variable pointée
$3935       Incrémente HL avant le saut potentiel
$3936       Saut si les caractères étaient différents (dont pas la bonne variable)
$3939       ---
$393a       Comparaison des seconds caractères
$393b       [var_diff]
            Incrémente pour la deuxième fois HL, qui pointe après l'identifiant.
$393c       Saute si le second caractère était identique à celui pointé. On a donc retrouvé la variable et on saute à la fin de la fonction
$393f       ---
$3940       ---
$3941       ---
$3942       La variable n'a pas été trouvée, on saute les 4 prochains octets pour aller vers la suivante (ou terminer en atteignant DE=(arytab))
$3943       ---
$3946       [no_var_yet]
$3947       Récupération dans HL dans la valeur de retour du CALL (2613 si appelé par LET)
$3948       Push de DE qui contient arytab
$3949       ---
$394c       Comparaison de l'adresse de retour avec $2927 (quelle instruction ???)
$394d       Pop de DE qui contient maintenant arytab
$394e       Saut si l'adresse de retour venait de str_to_var. Attention, l'adresse de retour est toujours dans HL et le pointeur de parsing sur la pile
$3951       Remise en place de l'adresse de retour et HL pointe sur le parsing.
$3952       Sauve le pointeur de parsing. On remet tout en place.
$3953       Sauve BC, qui contient le nom de la variable.
$3954       ---
$3957       ---
$395a       ---
$395b       Ajout de 6 à strend
$395c       Récupération de strend dans HL (pointeur de fin de mémoire utilisable)
$395d       Sauvegarde de strend + 6
$395e       Copie de DE,BC vers HL
$3961       ---
$3962       (strend) <- (strend) + 6
$3965       ---
$3966       HL <- BC
$3967       (arytab) <- HL
$396a       [clear_mem]
$396b       ---
$396d       ---
$396e       Mise à zéro de la partie entre l'ancien (arytab) (DE) et le nouveau (HL). C'est-à-dire l'espace libérée pour la nouvelle variable.
$3970       DE récupère le nom de la variable.
$3971       ---
$3972       ---
$3973       ---
$3974       (HL) <- DE et HL += 2, enregistrement du nom de la variable dans son emplacement.
$3975       [var_found]
            DE pointe sur la mémoire après le nom de la variable
$3976       HL pointe sur la zone de parsing
$3977       ---
$3978       [ret_null]
$397b       ---
$397e       ---
$3981       ---
$3982       ---

$3983       [subscript]
            HL pointe sur la zone de parsing
$3983       Sauvegarde du pointeur de parsing
$3984       ---
$3987       Récupération dans HL du pointeur de parsing et mise sur la pile de (dimflag)
$3988       Initialisation de D à 0 (A == 0 ici)
$3989       [loop_dim]
$398a       ---
$398b       ---
$398e       ---
$398f       ---
$3990       HL <- DE, la taille demandée du tableau
$3991       Mise sur la pile de la dimension.
$3992       Remise en place de la valeur qui était sur la pile (insertion de la dimension avant la valeur de la pile). Il s'agit de (dimflg)
$3993       DE contient le (dimflag), HL le pointeur de parsing
$3994       ---
$3995       D contient la dimension actuelle
$3996       Parsing
$3997       ---
$3999       Saut si la taille est suivie par une virgule
$399c       Vérification de parenthèse fermante
$399d       Code pour la parenthèses fermante
$399e       À ce moment, la pile contient (dimflg),(dimension tableau)+,...???, D contient le nombre de dimensions du tableau, HL le pointeur de parsing. La valeur du pointeur de parsing est sauvée dans (temp2)
$39a1       ---
$39a2       Remise en place de la valeur de (dimflg) venant de la pile (a-t-elle pu être modifiée ???)
$39a5       ---
$39a7       Nettoyage de E puis mise de DE (D contient le nombre de dimensions du tableau) sur la pile
$39a8       En arrivant par ici, les push hl et push af suivant saut ignorés.
$39a9       [aryvar]
            On arrive ici par un jump conditionnel si lors d'une recherche de variable, (subflg) == 1
$39aa       La pile contient (# de dimension),(tailles des dimensions)+
$39ab       ---
$39ae       En arrivant par ici, le add hl,de suivant est ignoré
$39af       [dim_search]
$39b0       ---
$39b4       ---
$39b5       ---
$39b7       Premier caractère du nom du tableau (BC contient le nom du tableau courant)
$39b8       ---
$39b9       ---
$39ba       Si le premier caractère est différent, on saute (c'est ok, pas de redimensionnement)
$39bc       ---
$39bd       Comparaison du second caractère du nom du tableau (le test aura lieu en $39c3)
$39be       [dim_neq]
$39bf       ---
$39c0       ---
$39c1       ---
$39c2       Récupération dans DE de la taille mémoire du contenu du tableau (pour chaînage)
$39c3       Si le nom de variable était différent, on boucle
$39c5       Arrivé ici, cela signifie qu'une entrée de tableau a été trouvée avec le même nom
$39c8       ---
$39c9       Si (dimflg) était différent de zéro, c'est que l'on cherche à redéfinir un tableau. Lancement de l'erreur
$39cc       Arrivé ici, le tableau a été trouvé (et c'est donc un accès).
$39cd       BC <- HL, qui pointe vers les attributs du tableau (debut+4)
$39ce       ---
$39cf       Saut dans quel cas ???
$39d2       Soustraction du type pour vérifier si c'est le même ???
$39d3       ---
$39d6       [out_range]
            Il n'y avait pas égalité, on lance une erreur.
$39d9       Sortie avec l'erreur "Subscript out of range"

$39dc       [ary_at_end]
            Arrive ici lorsque arytab == strend lors d'un dimensionnement de tableau.
            HL contient arytab
            BC contient le nom de la variable (du tableau)
            DE est initalisé à 4, qui est la taille d'un élément pour la première dimension
            
            MS_BASIC=CREARY
$39dc       ---
$39df       Récupération de la dimension (dans A, F == 0 normalement, sauf ???)
$39e0       Quelle est la nature du test précédente récupéré par AF ???
$39e3       Place le nom de la variable dans la zone pointée par HL (zone arytab)
$39e4       ---
$39e5       ---
$39e6       ---
$39e7       Place le nombre de dimensions dans C
$39e8       Vérifie la place restante pour stocker le nombre de dimensions * 2 (ce qui ne semble pas suffisant, cela ne compte pas le nombre de dimension ni la taille)
$39eb       ---
$39ec       ---
$39ed       Place le pointeur HL (4 octets après la variable) dans temp3
$39f0       Place le nombre de dimensions du tableau dans la structure du tableau
$39f1       HL pointe sur l'emplacement de la première dimension
$39f2       ---
$39f5       Pour setter Carry. A priori, si accès sans DIM, le Carry flag est OFF (donc bit de poids fors de A est à 0 ?)
$39f6       A contient le nombre de dimensions
$39f7       [multi_dim]
            Préparation de BC <- $000B pour le saut suivant. C'est la taille par défaut d'un tableau ; MS_BASIC=CRARLP
$39fa       ---
$39fc       BC contient la taille de la dimension traitée
$39fd       En BASIC, la taille d'un tableau est d'une unité plus grande que celle spécifiée (à cause de l'indice 0). Ce BASIC n'a pas l'option pour démarrer les indices à 1.
$39fe       [default_dim]
            MS_BASIC=DEFSIZ
$39ff       Sauvegarde de la dimension en cours sur la pile
$3a00       ---
$3a01       BC est placé dans les deux octets de la spécification de la dimension des données du tableau
$3a02       ---
$3a03       Sauvegarde sur la pile de la position suivante dans la structure du tableau
$3a04       ---
$3a07       DE <- taille nécessaire pour les données de cette dimension
$3a08       Récupération du pointeur sur les données du tableau
$3a09       Récupération de la dimension en cours
$3a0a       Dimension suivante (décroissante)
$3a0b       ---
$3a0d       Sauvegarde des flags (car A == 0 ici)
$3a0e       ---
$3a0f       BC <- DE (la taille du contenu du tableau à réserver)
$3a10       HL contient la taille à réserver, DE contient le pointeur de contenu du tableau
$3a11       Après l'addition, HL contient le pointeur de fin du contenu du tableau
$3a12       Si HL a débordé, alors il n'y avait plus de mémoire pour sûr (dépassement de la plus haute adresse adressable)
$3a15       Sinon, vérification par rapport à la mémoire installée
$3a18       Si tout est bon, comme un nouveau tableau est toujours en dernier (on ne redimensionne pas les tableaux), mise à jour de (strend)
$3a1b       [dim_nullify]
            MS_BASIC=ZERARY
$3a1c       Mise à zéro du contenu du tableau
$3a1e       ---
$3a1f       Mise à zéro du contenu du tableau en ramenant HL (pointeur sur la fin du contenu du tableau) vers DE (début du contenu du tableau)
$3a21       Incrément du la taille mémoire du tableau
$3a22       A priori, A == 0 donc mise à 0 de D
$3a23       ---
$3a26       Récupération dans E du nombre de dimensions du tableau
$3a27       ---
$3a28       ---
$3a29       HL <- 2 * (# de dimension) + BC(espace de tableau + 1)
$3a2a       DE <- HL == taille nécessaire pour les données, les tailles des dimensions et le nombre de dimension
$3a2b       ---
$3a2c       Positionnement de HL à identifiant + 2, pour stocker la taille de mémoire allouée au tableau (hors identifiant)
$3a2d       ---
$3a2e       ---
$3a2f       ---
$3a30       Placement de la taille calculée à cet endroit
$3a31       Récupération des anciens flags
$3a32       Si le Carry Flag était set, alors on a fini. Sinon, il s'agit d'un accès au tableau (allocation par défaut lors d'un accès à un tableau non défini)
$3a34       [dim_access]
            MS_BASIC=FINDEL
            En arrivant ici depuis $3a4e, a est égal à 0
$3a35       Donc BC <- $00
$3a36       HL est à identifiant+4. A <- nombre de dimensions du tableau
$3a37       HL pointe sur le début des taille de dimensions du tableau
$3a38       Le partial élimine le pop hl suivant
$3a39       [dimension_l]
            Récupération dans HL du pointeur vers la taille de la dimension courante (en première boucle, HL était initialisé par la partie précédente)
$3a3a       ---
$3a3b       ---
$3a3c       Ce qui donne DE <- taille du tableau dans la dimension actuelle
$3a3d       ---
$3a3e       Les index sont sur la pile. Récupération de l'index dans HL (en partant de la droite)
$3a3f       Sauvegarde du nombre de dimensions et flags
$3a40       ---
$3a41       Saut si l'index demandé est au delà de la taille du tableau
$3a44       Sauvegarde de l'index accédé sur la pile
$3a45       BC contient le numéro d'index accédé par la dimension précédente
$3a48       Récuépration dans DE de l'index accédé
$3a49       HL contient le début de la zone due à l'indice de la dimension précédente. On y ajoute l'index de la dimension courante.
$3a4a       Récupération de la valeur d'AF sauvegardée en $3a3f (contient la dimension en cours et les flags)
$3a4b       Décroit A, la dimension en court
$3a4c       ---
$3a4d       BC <- HL
$3a4e       ---
$3a50       ---
$3a51       HL <- Index * 4, car chaque entrée du tableau prend 4 octets.
$3a52       Récupération dans BC du pointeur des données du tableau mise sur la pile en $3a3e
$3a53       HL <- addresse de la donnée cherchée
$3a54       DE <- addresse de la donnée cherchée
$3a55       [end_dim]
            MS_BASIC=ENDDIM
            Récupération dans HL du pointeur de parsing
$3a58       En cas de lecture du tableau, DE contient le pointeur vers l'entrée cherchée.
$3a59       [jump3A59]
            $SECTION(caset)
$3a5b       ---
$3a5d       ---
$3a5e       [loop3A5E]
$3a5f       ---
$3a62       [loop3A62]
$3a63       ---
$3a64       ---
$3a65       ---
$3a66       ---
$3a68       ---
$3a6a       ---
$3a6b       ---
$3a6d       [call3A6D]
$3a6e       ---
$3a6f       ---
$3a72       [loop3A72]
$3a73       ---
$3a74       ---
$3a75       ---
$3a77       ---
$3a78       ---
$3a79       [call3A79]
$3a7a       ---
$3a7c       ---
$3a7e       ---
$3a7f       ---
$3a80       ---
$3a81       [k7sync]
$3a82       ---
$3a83       Valeur 2 sortie sur port 2 (???).
$3a85       ---
$3a87       Boucle d'attente le temps que HL boucle de $0000 à $0000
$3a8a       [sync_loop]
$3a8b       ---
$3a8c       ---
$3a8d       ---
$3a8f       ---
$3a90       [k7_end]
            Seems to end here at the end of K7 operations (???)
$3a93       Si (handler) est nul, on branche (mais pourquoi ne pas faire les deux add ?). Note: 0 va donne $0000 qui va donc être décrémentée jusqu'à 0 en partant de $FFFF.
$3a95       Si non nul, la valeur est multipliée par 4.
$3a96       ---
$3a97       [handler_0]
            La valeur est ensuite stockée dans B
$3a98       Et C est mis à $00 pour former BC comme un compteur qui commence à la valeur de handler * 1024
$3a9a       Désactivation des interruptions.
$3a9b       [k7_end_lp]
$3a9e       Attente de 8 cycles M (27 cycles T)
$3aa1       Décrémentation du compteur BC
$3aa2       ---
$3aa3       ---
$3aa4       Boucle dans que BC n'atteint pas 0.
$3aa6       Pour terminer, branche sur la vérification de BREAK, d'anti copie et de reset des touches.
$3aa9       [k7write]
$3aac       ---
$3aad       ---
$3aae       ---
$3ab0       ---
$3ab1       ---
$3ab4       ---
$3ab5       ---
$3ab7       [loop3AB7]
$3ab8       ---
$3abb       ---
$3abe       ---
$3ac0       ---
$3ac3       ---
$3ac6       ---
$3ac9       [call3AC9]
$3acc       ---
$3acf       [wait_8]
$3ad0       [call3AD0]
$3ad3       ---
$3ad4       ---
$3ad5       ---
$3ad6       ---
$3ad7       ---
$3ad8       ---
$3ad9       ---
$3adc       ---
$3add       [k7_send_1]
            Met la valeur du timing de cycle 1 (HIGH) dans HL
$3ae0       [k7_send_hl]
            Sauve AF
$3ae1       [k7_1_loop_l]
            Boucle sur L
$3ae2       Tant que L n'atteint pas 0
            Tant que H n'atteint pas 0
$3ae5       ---
$3ae7       Envoie 3 sur le port $AF (???)
$3ae9       [k7_1_loop_h]
            Boucle sur H
$3aea       ---
$3aed       ---
$3aef       ---
$3af1       Envoie 2 sur le port $AF (???)
$3af2       ---
$3af3       [k7test]
$3af5       ---
$3af7       ---
$3af8       [loop3AF8]
$3afb       [loop3AFB]
$3afc       ---
$3aff       ---
$3b00       ---
$3b01       ---
$3b03       ---
$3b05       ---
$3b07       ---
$3b09       ---
$3b0a       ---
$3b0c       ---
$3b0d       ---
$3b0e       [skip3B0E]
$3b10       ---
$3b12       ---
$3b13       ---
$3b14       ---
$3b15       ---
$3b17       ---
$3b1a       ---
$3b1b       ---
$3b1c       [jump3B1C]
$3b1f       ---
$3b20       ---
$3b21       ---
$3b22       ---
$3b25       ---
$3b28       ---
$3b29       ---
$3b2a       ---
$3b2b       ---
$3b2d       ---
$3b2e       ---
$3b2f       ---
$3b30       ---
$3b31       ---
$3b32       ---
$3b34       ---
$3b37       ---
$3b38       ---
$3b39       ---
$3b3b       [loop3B3B]
$3b3d       ---
$3b3e       ---
$3b40       ---
$3b41       ---
$3b43       ---
$3b46       ---
$3b47       ---
$3b48       [k7read]
$3b4b       ---
$3b4c       [loop3B4C]
$3b4f       ---
$3b50       ---
$3b52       ---
$3b53       ---
$3b55       [loop3B55]
$3b58       ---
$3b59       ---
$3b5b       ---
$3b5c       ---
$3b5e       ---
$3b60       ---
$3b63       [loop3B63]
$3b64       ---
$3b67       ---
$3b68       ---
$3b69       ---
$3b6a       ---
$3b6c       ---
$3b6d       ---
$3b6f       ---
$3b71       [jump3B71]
$3b74       ---
$3b76       ---
$3b77       ---
$3b78       ---
$3b7a       ---
$3b7b       ---
$3b7d       ---
$3b7e       ---
$3b7f       ---
$3b82       ---
$3b85       ---
$3b86       ---
$3b89       ---
$3b8c       ---
$3b8d       ---
$3b8e       [call3B8E]
$3b91       ---
$3b92       ---
$3b94       [loop3B94]
$3b96       ---
$3b97       ---
$3b9a       ---
$3b9b       ---
$3b9c       ---
$3b9d       ---
$3b9e       ---
$3ba0       ---
$3ba1       ---
$3ba2       [jump3BA2]
$3ba3       ---
$3ba4       ---
$3ba5       ---
$3ba6       ---
$3ba8       ---
$3ba9       ---
$3baa       [call3BAA]
$3bad       ---
$3bae       [call3BAE]
$3bb0       [jump3BB0]
$3bb1       ---
$3bb3       ---
$3bb5       ---
$3bb6       ---
$3bb9       ---
$3bba       ---
$3bbb       ---
$3bbc       ---
$3bbd       [skip3BBD]
$3bbe       ---
$3bbf       [call3BBF]
$3bc2       ---
$3bc3       ---
$3bc5       ---
$3bc6       ---
$3bc8       ---
$3bca       ---
$3bcd       ---

$3bd0       [outdo_impl]
            $SECTION(bio)
            Fonction : envoie d'un caractère sur le périphérique sélectionné
            Entrée : le caractère est contenu dans A
$3bd0       ---
$3bd3       ---
$3bd4       ---
$3bd7       ---
$3bd8       ---
$3bda       ---
$3bdb       ---
$3bdd       ---
$3bde       ---
$3be1       [sendchar_pt]
$3be4       ---
$3be6       ---
$3be8       ---
$3be9       ---
$3bea       ---
$3bec       ---
$3bee       [loop3BEE]
$3bf0       ---
$3bf1       ---
$3bf4       ---
$3bf6       ---
$3bf8       ---
$3bf9       ---
$3bfa       [skip3BFA]
$3bfc       ---
$3bfe       ---
$3c00       ---
$3c02       ---
$3c04       ---
$3c07       ---
$3c09       ---
$3c0c       ---
$3c0d       [skip3C0D]
$3c10       [skip3C10]
$3c11       ---

$3c14       [resetprt]
            Fonction: Mise à zéro de l'état de l'imprimante
$3c14       ---
$3c16       Sélectionne l'imprimante pour l'affichage
$3c19       ---
$3c1c       ---
$3c1e       ---
$3c20       Récupération et mise à zéro du Bit 7 du status de l'imprimante
$3c23       ---
$3c25       Si le bit était à 0, récupération du numéro de ligne de l'imprimante dans a
$3c28       Permet de mettre à jour les flags de F
$3c29       [skip3C29]
            Appel si le bit 7 du status était 1, ou bien si la ligne de l'imprimante n'est pas 0
$3c2c       ---
$3c2f       ---
$3c31       Clear du picflg sauf le bit 6 (signal de curseur en fin de page)
$3c34       ---
$3c35       Sélection du terminal comme sortie des caractères
$3c38       Mise à zéro de l'état de l'imprimante.
$3c3b       ---
$3c3c       [sendchar_te]
            Récupération de AF qui contient prtflg
$3c3d       ---

$3c40       [cursor_x0]
            Remet le terminal en état. Puis, si le curseur n'était pas en
            première colonne, fait un saut à la ligne sur le terminal. Sinon, ressort.
            
            MS_BASIC=STTLIN
$3c40       ---
$3c43       ---
$3c46       ---
$3c47       ---
$3c48       ---

$3c4a       [putnulatend]
            Fonction: met un caractère NUL à la fin de la chaîne précédent le pointeur HL actuel, en ignorant les espaces.
            À la fin de la fonction, HL contient $4897, c'est-a-dire juste avant le buffer de crunch de la ligne.
$3c4a       ---
$3c4b       ---
$3c4c       ---
$3c4e       Recale le pointeur HL sur le derniere caractère non espace ($20) avant le CR ($0D)
$3c50       HL pointe donc à présent juste après le dernier caractère de la ligne à traiter

$3c51       [hl_oncrunch]
            Met un zéro à l'emplacement pointé par HL puis fait pointer HL en début de buffer de crunch.
$3c51       ---
$3c52       Place un $0 à la fin de la chaîne
$3c53       ---
$3c56       Ayant été appelé par jp, ce RET va sortir de la boucle de traitement de basicloop (et se retrouver en $22b1)

$3c57       [crdo]
            Fonction : Envoi d'un retour chariot sur la sortie de caractère actuel
$3c57       ---
$3c5a       ---
$3c5d       ---
$3c5e       Saut si la sortie de caractère se faire sur le terminal
$3c60       ---
$3c61       Saut si la sortie de caractère n'est pas l'imprimante (donc la k7)

$3c63       [crdo_prt]
            Fonction : Retour chariot à la ligne suivante sur l'imprimante
$3c63       ---
$3c65       ---
$3c66       ---
$3c68       ---
$3c69       ---
$3c6a       Mise à zéro de la colonne de l'imprimante (aucun test de la véracité...)
$3c6d       ---
$3c6e       [crdo_k7]
$3c70       ---
$3c71       ---
$3c72       [crdo_term]
$3c74       ---
$3c75       ---
$3c76       ---

$3c77       [chk_break]
            Vérifie la séquence de BREAK puis continue sur l'instruction STOP.
            L'instruction STOP commence par 'ret nz', qui fera donc un RET s'il
            n'y a pas eu de BREAK, et qui fera un STOP dans le cas contraire.
$3c77       ---
$3c7a       ---

$3c7d       [break_delay]
            Function : vérifie la séquence BREAK, avec un délai préalable
$3c7d       ---
$3c7e       ---
$3c7f       [break_impl]
            Est-ce que la touche RUN-STOP est appuyée ?
$3c81       ---
$3c83       Si non, retour immédiat
$3c84       Est-ce que la touche SHIFT est appuyée ?
$3c86       ---
$3c88       Si non, retour immédiat
$3c89       Vérification de l'exécution BASIC (flag = 0).
$3c8c       ---
$3c8d       Sinon, retour immédiat.
$3c8e       Met $f2 dans la dernière touche scannée
$3c92       Réinitialisation du drapeau de répétition des touches
$3c96       Réinitialisation du compteur de répétition des touches
$3c9a       Set Carry, pour provoquer la boucle immédiate du BASIC
$3c9b       ---

$3c9c       [print_prt]
            Affiche le prompt "? " de INPUT.
            Puis fallthrough sur l'acquisition d'une ligne de texte.
            
            MS_BASIC=PROMPT
$3c9c       ---
$3c9e       ---
$3c9f       ---
$3ca1       ---

$3ca2       [get_line]
            Fonction: Récupération d'une ligne d'instruction entrée au BASIC
            Entre à chaque nouvelle invite. Sort lorsque la touche CR est appuyée.
            
            MS_BASIC=GETLIN
$3ca2       Appel au HOOK de GetLine
$3ca5       ---
$3ca8       [get_line2]
$3cab       ---
$3cac       Saute si le périphérique d'entrée actuel est le clavier.
$3cae       Traitement si inputsel ne désigne pas un clavier (!= 0). A priori, on arrive ici lorsque l'on décode du BASICODE à travers LOAD. À vérifier.
$3cb1       ---
$3cb3       ---

$3cb5       [keyloop]
            Fonction : Traitement du moniteur pour une entrée par le clavier
$3cb5       ---
$3cb8       ---
$3cb9       Saute si une touche a été appuyée et nécessite un traitement. La plupart des touches renvoient 0 dans A. Quelles touchent sortent avec A != 0 ? STOP par exemple.
$3cbb       ---
$3cbe       Retour à la boucle de traitement si la touche STOP n'a pas été appuyée
$3cc0       La touche STOP a été appuyée. Carry est à 1.

$3cc1       [decodebasic]
            Fonction : décode la ligne en BASIC ?
$3cc1       ---
$3cc3       Saute si la touche était la touche entrée.
$3cc5       ---
$3cc7       Remise du caractère dans le buffer en s'assurant qu'il soit sur 7 bits
$3cc8       ---
$3ccb       Comparaison de HL avec $4918, qui est juste avant la fin du buffer de crunch. Mais comment est-ce que HL pourrait déborder ? Pas en entrée direct on dirait... Il est possible qu'on n'arrive là que via la lecture k7 ?
$3ccc       ---
$3ccf       [hl_incbuf]
            HL pointe sur la position suivante dans le buffer de crunch
$3cd0       ---
$3cd2       [jump3CD2]
            $SECTION(biprtr)
$3cd3       ---
$3cd4       ---
$3cd5       ---
$3cd6       ---
$3cd9       ---
$3cdb       ---
$3cde       ---
$3ce1       ---
$3ce3       ---
$3ce5       ---
$3ce8       [skip3CE8]
$3ceb       ---
$3ced       ---
$3cee       ---
$3cef       ---
$3cf2       ---
$3cf3       ---
$3cf6       ---
$3cf7       [skip3CF7]
$3cf8       ---
$3cf9       ---
$3cfa       ---
$3cfb       ---
$3cfc       [call3CFC]
$3cfe       ---
$3d01       ---
$3d02       ---
$3d05       [loop3D05]
$3d06       ---
$3d07       ---
$3d0a       ---
$3d0b       ---
$3d0d       ---
$3d0e       ---
$3d0f       [call3D0F]
$3d10       ---
$3d11       ---
$3d12       ---
$3d14       ---
$3d17       [loop3D17]
$3d1a       [loop3D1A]
$3d1c       ---
$3d1e       ---
$3d1f       ---
$3d20       ---
$3d21       [loop3D21]
$3d22       ---
$3d23       ---
$3d25       ---
$3d26       ---
$3d27       ---
$3d29       ---
$3d2a       ---
$3d2d       ---
$3d2f       [loop3D2F]
$3d31       ---
$3d32       ---
$3d34       ---
$3d37       ---
$3d39       ---
$3d3c       ---
$3d3d       ---
$3d3f       ---
$3d42       ---
$3d45       ---
$3d46       ---
$3d48       ---
$3d4b       [skip3D4B]
$3d4e       [skip3D4E]
$3d50       ---
$3d53       [loop3D53]
$3d56       ---
$3d57       ---
$3d59       ---
$3d5b       ---
$3d5d       [call3D5D]
$3d60       ---
$3d62       ---
$3d64       ---
$3d67       ---
$3d69       ---
$3d6a       ---
$3d6b       ---
$3d6c       ---
$3d6d       [call3D6D]
$3d6e       ---
$3d71       ---
$3d72       ---
$3d74       ---
$3d77       ---
$3d78       ---
$3d79       ---
$3d7b       ---
$3d7c       ---
$3d7d       ---
$3d7e       ---
$3d80       ---
$3d81       ---
$3d82       ---
$3d83       ---
$3d84       [skip3D84]
$3d85       ---
$3d86       [call3D86]
$3d88       ---
$3d8a       ---
$3d8c       ---
$3d8e       ---
$3d90       ---
$3d91       [reset_mem_3]
            0 dans (autoflg)
$3d94       0 dans les deux premiers octets de (txttab). Cela coupe le premier lien du listing BASIC.
$3d95       ---
$3d96       ---
$3d97       ---

$3d9a       [auto]
            Traitement appelé lorsque le mode AUTO est activé
            DE contient l'ancien numéro de ligne (ou le premier en début de AUTO)
            HL contient le nouveau numéro de ligne.
$3d9a       ---
$3d9b       ---
$3d9e       Récupération du numéro de ligne
$3d9f       Recherche de la ligne (pointeur dans HL si résultat)
$3da2       Continue par l'affiche d'un espace si la ligne n'a pas été trouvée
$3da5       ---
$3da7       Sinon, affiche le caractère $a0 pour indiquer qu'il y a déjà du contenu.
$3daa       [after_auto]
            Traitement d'un overflow sur AUTO. Si HL est devenu trop grand, on arrête.
$3dac       ---
$3dad       Préparation de la comparaison avec $fff9 (65529, plus haut numéro de ligne valide)
$3db0       ---
$3db1       ---
$3db2       si HL (le numéro de ligne courant) est égal ou supérieur à $fff9, on arrête AUTO
$3db4       Sinon, la nouvelle ligne auto est validée
$3db7       ---
$3db9       [stopauto]
            Stop le traitement de AUTO
$3dba       ---
$3dbd       [after_auto2]
$3dc0       [initscreen1]
$3dc3       ---
$3dc6       ---
$3dc8       ---
$3dcb       ---

$3dce       [inst_new]
            %CODE
            Instruction : NEW
            Efface le listing courant.
            S'il n'y a pas de paramètre, on branche directement vers le reset de la mémoire.
            S'il y a un paramètre`et que c'est un numéro de ligne, on efface à partir de ce numéro de ligne (a vérifier ???)
            
            MS_BASIC=NEW
$3dce       ---
$3dd1       ---
$3dd4       ---
$3dd5       ---
$3dd8       ---
$3dd9       ---
$3ddc       ---
$3ddd       ---
$3dde       ---
$3de1       [decodenext]
            Si HL était avant la fin du buffer de crunch, on incrémente HL et on continue.
$3de3       Si HL n'est pas égal non plus, c'est qu'il est supérieur à la fin du buffer de crunch, on loop directement sur le moniteur sans toucher à HL.
            Sinon, HL est sur la dernière position du buffer, on émet le caractere $0E (signification ?) puis on passe à l'incrémentation de HL. $0E semble donc être un marqueur de fin de buffer.
$3de6       ---
$3de8       ---
$3de9       [ind_inchl]
            Saut intermédiaire pour aller incrémenter HL
$3dec       [prompt]
            MS_BASIC=PROMPT (ou pas tout à fait, car chez MS, c'est l'affichage du PROMPT et le branchement sur l'acquisition)
$3def       ---
$3df1       Met le flag INPUT à 1
$3df4       Paramètres du curseur
$3df8       ---

$3dfb       [acquirekeyn4]
            Suite (3) du traitement de l'entrée
$3dfb       ---
$3dfd       ---
$3dff       Si le caractère d'entrée était ACK
$3e02       Test du flag INPUT actif
$3e04       ---
$3e07       [acquirekeyn6]
$3e0a       [acquirekeyn5]
            Test de Unit Separator
$3e0c       Si différent, branche
$3e0e       ---
$3e11       [jump3E11]
$3e14       ---
$3e16       ---
$3e19       ---
$3e1b       ---
$3e1c       ---
$3e1f       [jump3E1F]
$3e22       ---
$3e25       ---
$3e27       ---
$3e2a       ---

$3e2d       [acquirekeyn2]
            Suite (1) du traitement de l'entrée
$3e2d       Saut si la touche appuyée était ENTREE
$3e30       ---
$3e31       ---
$3e34       ---
$3e35       Si on est en basexec == 1
$3e37       ---
$3e38       ---
$3e3b       [skip3E3B]
$3e3c       ---
$3e3f       ---
$4000       [screen]
$4000       [screen]
$47d0       [inthk]
$47d3       [calhk]
$47d6       [sonhk]
$47d9       [plyhk]
$47dc       [rsthk]
$47df       [prthk]
$47e2       [outhk]
$47e5       [crdhk]
$47e8       [inlhk]
$47eb       [inphk]
$47ee       [nmihk]
$47f1       [inst_lpen]
            %CODE
$47f4       [inst_disk]
            %CODE
$47f7       [inst_modem]
            %CODE
$47fa       [intdiv]
            Début de la zone de données graphiques pour la communication avec le EF9345
$47fb       [intact]
$47fc       [intrat]
$47fd       [cursor]
$47fe       [fklock]
$47ff       [crchar]
            valeur scannée du clavier la plus récente
$4800       [reptim]
$4801       [repena]
$4802       [attcar]
$4803       [attbak]
$4804       [extenf]
$4805       [xcursor]
$4806       [ycursor]
$4807       [prelin]
$4809       [homeln]
$480b       [retadr]
            Coordonnées de la prochaine ligne à interpréter
$480d       [entstt]
            programme ($82) ou direct ($80)
$480e       [sonsav_hi]
$480f       [sonsav_lo]
$4810       [ft]
            Table de fichier
$4826       [low]
$4828       [high]
$482a       [handler]
$482e       [lowlim]
$482f       [winwid]
$4830       [ramlow]
$4833       [inst_usr]
            %CODE
$4836       [fdivc]
$4837       [fdivc_1]
$483b       [fdivc_2]
$483f       [fdivc_3]
$4842       [fdivc_4]
$4844       [rnd_seed_0]
$4845       [rnd_seed_1]
$4846       [rnd_seed_2]
$4867       [rnd_gen]
$486e       [lptpos]
$486f       [prtflg]
            Selectionne la sortie des caractères (0=Terminal, 1=printer, ff=k7)
$4870       [getflg]
            Entrée des caractères sur clavier (0) ou cassette (255)
$4871       [picflg]
$4872       [cascom]
$4873       [rawprt]
$4874       [prtstt]
            État de l'imprimante
$4875       [prtcom]
$4876       [prtint]
$4878       [prtxlt]
$487a       [contbl]
$4884       [autoflg]
            Etat courant de la commande AUTO
$4885       [autoline]
            Ligne courante de la commande AUTO
$4887       [autostep]
            Incrément du mode AUTO
$4889       [allflg]
            Execution de la boucle BASIC (0 to execute BASIC control loop)
$488a       [linlen]
$488b       [clmlst]
$488c       [curlin]
            Ligne courante du BASIC
$488e       [txttab]
$4890       [frgglg]
            Messages en anglais (1) ou francais (0)
$4891       [kbdtbl]
            Table de transcription du clavier
$4893       [tmpsav]
$4894       [octsav]
$4895       [stktop]
            Addresse de départ (maximale) pour la pile. Initialisée tout en haut de la RAM.
$4897       [bufmin]
            Zone précédent la zone de tokenisation. Mis dans HL après avoir mis NUL en fin de chaîne à traiter.
$4898       [basbuf]
            Buffer d'entrée pour le BASIC
$4918       [basbufpre]
            Juste avant la fin du buffer
$4919       [basbufend]
            Fin du buffer
$491a       [dimflg]
$491b       [valtyp]
            (0 = numeric, 1=string)
$491c       [dores]
            Drapeau de suppression de la tokenisation
$491d       [contxt]
$491f       [memsiz]
            Plus haute mémoire disponible (pour le BASIC ?)
$4921       [temppt]
$4923       [tempst]
$499b       [dsctmp]
$49c3       [fretop]
$49c5       [temp3]
$49c7       [temp8]
$49c9       [endfor]
$49cb       [datlin]
$49cd       [subflg]
$49ce       [flginp]
$49cf       [temp]
$49d1       [ptrfrg]
$49d2       [temp2]
$49d4       [oldlin]
$49d6       [oldtxt]
$49d8       [vartab]
$49da       [arytab]
$49dc       [strend]
$49de       [datptr]
$49e0       [prmnam]
$49e2       [prmval]
$49e4       [prmval_2]
$49e6       [fac_lsb]
$49e8       [fac_msb]
$49e9       [fac_exp]
$49ea       [fac_sgn]
$49eb       [fbuffr]
$49f8       [fmltt1]
$49f8       Valeur temporaire pour la multiplication (`fp_bcde_mul`)
$49f9       [fmltt2]
$49f9       Valeur temporaire pour la multiplication (`fp_bcde_mul`)
$49fb       [end_vars]
            Adresse juste après la dernière des variables système.
$e1c1       [jumpE1C1]
